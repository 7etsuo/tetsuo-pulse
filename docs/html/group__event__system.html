<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="High-performance, exception-driven socket toolkit for POSIX systems">
<meta name="keywords" content="socket, networking, C, POSIX, TCP, UDP, TLS, async, high-performance, library">
<meta name="author" content="Tetsuo Corporation">
<meta name="theme-color" content="#3b82f6">
<title>Event System Modules</title>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' stop-color='%233b82f6'/><stop offset='100%25' stop-color='%238b5cf6'/></linearGradient></defs><rect width='100' height='100' rx='20' fill='url(%23g)'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='bold'>S</text></svg>">
</head>
<body>
<div id="top">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">1.0.0</span></div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
  <td style="text-align: right; padding: 20px; vertical-align: middle;">
    <div style="display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; align-items: center;">
      <a href="index.html" class="quick-link">Home</a>
      <a href="annotated.html" class="quick-link">Structures</a>
      <a href="files.html" class="quick-link">Files</a>
      <a href="globals.html" class="quick-link">API</a>
    </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__event__system.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Event System Modules</div></div>
</div><!--header-->
<div class="contents">

<p>High-performance I/O multiplexing with cross-platform backends.Key components: <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> (cross-platform I/O multiplexing), <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> (timer management). Enables scalable event-driven network applications with automatic platform adaptation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketTimer-private_8h" id="r_SocketTimer-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketTimer-private_8h.html">SocketTimer-private.h</a></td></tr>
<tr class="memdesc:SocketTimer-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timer implementation details and heap management. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketTimer_8h" id="r_SocketTimer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketTimer_8h.html">SocketTimer.h</a></td></tr>
<tr class="memdesc:SocketTimer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance timer subsystem integrated with the event loop. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketPoll-private_8h" id="r_SocketPoll-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPoll-private_8h.html">SocketPoll-private.h</a></td></tr>
<tr class="memdesc:SocketPoll-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation details for SocketPoll module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketPoll_8h" id="r_SocketPoll_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPoll_8h.html">SocketPoll.h</a></td></tr>
<tr class="memdesc:SocketPoll_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform high-level interface for monitoring multiple sockets for I/O events. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketPoll__backend_8h" id="r_SocketPoll__backend_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPoll__backend_8h.html">SocketPoll_backend.h</a></td></tr>
<tr class="memdesc:SocketPoll__backend_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for platform-specific polling implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketData" id="r_structSocketData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketData">SocketData</a></td></tr>
<tr class="memdesc:structSocketData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table entry for socket-to-userdata mapping.  <a href="group__event__system.html#structSocketData">More...</a><br /></td></tr>
<tr class="separator:structSocketData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structFdSocketEntry" id="r_structFdSocketEntry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structFdSocketEntry">FdSocketEntry</a></td></tr>
<tr class="memdesc:structFdSocketEntry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table entry for file descriptor to socket reverse mapping.  <a href="group__event__system.html#structFdSocketEntry">More...</a><br /></td></tr>
<tr class="separator:structFdSocketEntry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketPoll__T" id="r_structSocketPoll__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a></td></tr>
<tr class="memdesc:structSocketPoll__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete internal state for SocketPoll instance.  <a href="group__event__system.html#structSocketPoll__T">More...</a><br /></td></tr>
<tr class="separator:structSocketPoll__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketEvent__T" id="r_structSocketEvent__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a></td></tr>
<tr class="memdesc:structSocketEvent__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event notification structure returned by polling operations.  <a href="group__event__system.html#structSocketEvent__T">More...</a><br /></td></tr>
<tr class="separator:structSocketEvent__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab6d7f45fcb5eae5fe42694e8e123cab4" id="r_gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab6d7f45fcb5eae5fe42694e8e123cab4">SOCKET_MAX_POLL_EVENTS</a>&#160;&#160;&#160;10000</td></tr>
<tr class="memdesc:gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum events per poll iteration.  <br /></td></tr>
<tr class="separator:gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673275383493d8cff8bc582fef311e42" id="r_ga673275383493d8cff8bc582fef311e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga673275383493d8cff8bc582fef311e42">POLL_INITIAL_FDS</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga673275383493d8cff8bc582fef311e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial file descriptor capacity for poll backend.  <br /></td></tr>
<tr class="separator:ga673275383493d8cff8bc582fef311e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211a6387523fa6487af971831aabf461" id="r_ga211a6387523fa6487af971831aabf461"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga211a6387523fa6487af971831aabf461">POLL_INITIAL_FD_MAP_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga211a6387523fa6487af971831aabf461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial file descriptor map size.  <br /></td></tr>
<tr class="separator:ga211a6387523fa6487af971831aabf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834e79d67b92d737d55e4ba2b0684025" id="r_ga834e79d67b92d737d55e4ba2b0684025"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga834e79d67b92d737d55e4ba2b0684025">POLL_FD_MAP_EXPAND_INCREMENT</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga834e79d67b92d737d55e4ba2b0684025"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor map expansion increment.  <br /></td></tr>
<tr class="separator:ga834e79d67b92d737d55e4ba2b0684025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad738dd2be8abca1d0353d31f888ba3eb" id="r_gad738dd2be8abca1d0353d31f888ba3eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gad738dd2be8abca1d0353d31f888ba3eb">SOCKET_MAX_TIMER_TIMEOUT_MS</a>&#160;&#160;&#160;300000</td></tr>
<tr class="memdesc:gad738dd2be8abca1d0353d31f888ba3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum timer timeout to prevent indefinite blocking.  <br /></td></tr>
<tr class="separator:gad738dd2be8abca1d0353d31f888ba3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5492f9166c78ee14f4b69362ccaf51" id="r_ga7f5492f9166c78ee14f4b69362ccaf51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga7f5492f9166c78ee14f4b69362ccaf51">SOCKET_MAX_TIMER_DELAY_MS</a>&#160;&#160;&#160;(INT64_C (31536000000)) /* 365 days */</td></tr>
<tr class="memdesc:ga7f5492f9166c78ee14f4b69362ccaf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed delay or interval for individual timers.  <br /></td></tr>
<tr class="separator:ga7f5492f9166c78ee14f4b69362ccaf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56cfec8835c59bfb69bb1c1cb128c93" id="r_gab56cfec8835c59bfb69bb1c1cb128c93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab56cfec8835c59bfb69bb1c1cb128c93">SOCKET_TIMER_ERROR_BUFSIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gab56cfec8835c59bfb69bb1c1cb128c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer error buffer size for detailed error messages.  <br /></td></tr>
<tr class="separator:gab56cfec8835c59bfb69bb1c1cb128c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115b76003aaf131241e5b091a63b3285" id="r_ga115b76003aaf131241e5b091a63b3285"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga115b76003aaf131241e5b091a63b3285">SOCKET_TIMER_HEAP_INITIAL_CAPACITY</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga115b76003aaf131241e5b091a63b3285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial capacity for timer heap array.  <br /></td></tr>
<tr class="separator:ga115b76003aaf131241e5b091a63b3285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5f033531acb4f68ba5823ce2b769d7" id="r_gaca5f033531acb4f68ba5823ce2b769d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaca5f033531acb4f68ba5823ce2b769d7">SOCKET_TIMER_HEAP_GROWTH_FACTOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaca5f033531acb4f68ba5823ce2b769d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth factor when resizing timer heap.  <br /></td></tr>
<tr class="separator:gaca5f033531acb4f68ba5823ce2b769d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53de6720fd3fc8accf99751c1e4e0d50" id="r_ga53de6720fd3fc8accf99751c1e4e0d50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga53de6720fd3fc8accf99751c1e4e0d50">SOCKET_MAX_TIMERS_PER_HEAP</a>&#160;&#160;&#160;100000</td></tr>
<tr class="memdesc:ga53de6720fd3fc8accf99751c1e4e0d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of timers per heap.  <br /></td></tr>
<tr class="separator:ga53de6720fd3fc8accf99751c1e4e0d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ced17c77c552330176b69557fb83fc" id="r_gab0ced17c77c552330176b69557fb83fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab0ced17c77c552330176b69557fb83fc">SOCKET_TIMER_MIN_DELAY_MS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gab0ced17c77c552330176b69557fb83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum delay for one-shot timers.  <br /></td></tr>
<tr class="separator:gab0ced17c77c552330176b69557fb83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59221d1781370448def350dafb2d7e24" id="r_ga59221d1781370448def350dafb2d7e24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga59221d1781370448def350dafb2d7e24">SOCKET_TIMER_MIN_INTERVAL_MS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga59221d1781370448def350dafb2d7e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum interval for repeating timers.  <br /></td></tr>
<tr class="separator:ga59221d1781370448def350dafb2d7e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3100d409a6fd3f6d160700ba6c64c6" id="r_gacd3100d409a6fd3f6d160700ba6c64c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gacd3100d409a6fd3f6d160700ba6c64c6">SOCKET_TIMER_INITIAL_ID</a>&#160;&#160;&#160;1ULL</td></tr>
<tr class="memdesc:gacd3100d409a6fd3f6d160700ba6c64c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial timer ID value.  <br /></td></tr>
<tr class="separator:gacd3100d409a6fd3f6d160700ba6c64c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac815951cb4cbc800c781eb143b8cb" id="r_ga76ac815951cb4cbc800c781eb143b8cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga76ac815951cb4cbc800c781eb143b8cb">SOCKET_EVENT_MAX_HANDLERS</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga76ac815951cb4cbc800c781eb143b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of event handlers that can be registered.  <br /></td></tr>
<tr class="separator:ga76ac815951cb4cbc800c781eb143b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cb10d1eefc15616a20bcd7ae21e875" id="r_ga71cb10d1eefc15616a20bcd7ae21e875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga71cb10d1eefc15616a20bcd7ae21e875">SOCKET_DEFAULT_POLL_TIMEOUT</a>&#160;&#160;&#160;1000 /* 1 second */</td></tr>
<tr class="memdesc:ga71cb10d1eefc15616a20bcd7ae21e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default poll timeout.  <br /></td></tr>
<tr class="separator:ga71cb10d1eefc15616a20bcd7ae21e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2829aac1405cdf86f8ef8b6eb3ecf365" id="r_ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2829aac1405cdf86f8ef8b6eb3ecf365">SOCKET_TIMER_INVALID_HEAP_INDEX</a>&#160;&#160;&#160;((size_t) - 1)</td></tr>
<tr class="memdesc:ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value indicating that a timer is not currently in the heap.  <br /></td></tr>
<tr class="separator:ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointer to a timer instance.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type macro for internal <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> structure definition.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0e59971e52bc0a110b2a7066ea2732" id="r_ga7c0e59971e52bc0a110b2a7066ea2732"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga7c0e59971e52bc0a110b2a7066ea2732">SOCKET_DATA_HASH_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td></tr>
<tr class="memdesc:ga7c0e59971e52bc0a110b2a7066ea2732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configured hash table size for internal socket data and FD-to-socket mappings.  <br /></td></tr>
<tr class="separator:ga7c0e59971e52bc0a110b2a7066ea2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f5cf0f097a98b03e1511d1b6bd91b2" id="r_ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a>(e)&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (SocketPoll, e)</td></tr>
<tr class="memdesc:ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe exception raising with detailed error messages.  <br /></td></tr>
<tr class="separator:ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance socket polling abstraction with cross-platform backends.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc8aa94a3e9bb10cb26d85c6474d04e" id="r_ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special timeout value to use the poll's default timeout.  <br /></td></tr>
<tr class="separator:ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c973c74b3941d078d573439e92c65b" id="r_gad5c973c74b3941d078d573439e92c65b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gad5c973c74b3941d078d573439e92c65b">VALIDATE_MAXEVENTS</a>(maxevents,  event_type)</td></tr>
<tr class="memdesc:gad5c973c74b3941d078d573439e92c65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate maxevents parameter with overflow protection.  <br /></td></tr>
<tr class="separator:gad5c973c74b3941d078d573439e92c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ef813749c8c54d8f8ccf64ba724a0a" id="r_ga72ef813749c8c54d8f8ccf64ba724a0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga72ef813749c8c54d8f8ccf64ba724a0a">VALIDATE_FD</a>(fd)</td></tr>
<tr class="memdesc:ga72ef813749c8c54d8f8ccf64ba724a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate file descriptor parameter for backend operations.  <br /></td></tr>
<tr class="separator:ga72ef813749c8c54d8f8ccf64ba724a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafb51f69cdbf1b882a7a4226959c4fca7" id="r_gafb51f69cdbf1b882a7a4226959c4fca7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>) (void *userdata)</td></tr>
<tr class="memdesc:gafb51f69cdbf1b882a7a4226959c4fca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for timer expiration callback functions.  <br /></td></tr>
<tr class="separator:gafb51f69cdbf1b882a7a4226959c4fca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd97c2d63f6b491ef855bd928211e71b" id="r_gadd97c2d63f6b491ef855bd928211e71b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a></td></tr>
<tr class="memdesc:gadd97c2d63f6b491ef855bd928211e71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for platform-specific polling backend instances.  <br /></td></tr>
<tr class="separator:gadd97c2d63f6b491ef855bd928211e71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9e8943c9cb47aba63dda4ad9083142b6" id="r_ga9e8943c9cb47aba63dda4ad9083142b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">SocketPoll_Events</a> { <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9">POLL_ERROR</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c">POLL_HANGUP</a> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:ga9e8943c9cb47aba63dda4ad9083142b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event types for socket I/O monitoring.  <a href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">More...</a><br /></td></tr>
<tr class="separator:ga9e8943c9cb47aba63dda4ad9083142b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18f3d33b3f70cc8620fef042ca65e66a" id="r_ga18f3d33b3f70cc8620fef042ca65e66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena)</td></tr>
<tr class="memdesc:ga18f3d33b3f70cc8620fef042ca65e66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new timer heap.  <br /></td></tr>
<tr class="separator:ga18f3d33b3f70cc8620fef042ca65e66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3257343cc10ae56314c03abd8311d873" id="r_ga3257343cc10ae56314c03abd8311d873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> **heap)</td></tr>
<tr class="memdesc:ga3257343cc10ae56314c03abd8311d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free timer heap structure and destroy mutex.  <br /></td></tr>
<tr class="separator:ga3257343cc10ae56314c03abd8311d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04afe41789d51a71d4a03883a89ad61c" id="r_ga04afe41789d51a71d4a03883a89ad61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c">SocketTimer_heap_push</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga04afe41789d51a71d4a03883a89ad61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add timer to heap.  <br /></td></tr>
<tr class="separator:ga04afe41789d51a71d4a03883a89ad61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e40363cf44bb1025f2269ddc2cef0d2" id="r_ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2">SocketTimer_heap_pop</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return earliest timer.  <br /></td></tr>
<tr class="separator:ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0961e214a845a52c242176ed425095a3" id="r_ga0961e214a845a52c242176ed425095a3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0961e214a845a52c242176ed425095a3">SocketTimer_heap_peek</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga0961e214a845a52c242176ed425095a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get earliest timer without removing.  <br /></td></tr>
<tr class="separator:ga0961e214a845a52c242176ed425095a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7deeb47aba9580052152bbf036c419" id="r_ga0f7deeb47aba9580052152bbf036c419"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419">SocketTimer_heap_peek_delay</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga0f7deeb47aba9580052152bbf036c419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get milliseconds until next timer expiry.  <br /></td></tr>
<tr class="separator:ga0f7deeb47aba9580052152bbf036c419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888ed4acbf5d1ca29bdafc07f346566e" id="r_ga888ed4acbf5d1ca29bdafc07f346566e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e">SocketTimer_process_expired</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga888ed4acbf5d1ca29bdafc07f346566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fire all expired timers and return count.  <br /></td></tr>
<tr class="separator:ga888ed4acbf5d1ca29bdafc07f346566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af1dd7cd2864bea6226054f1ff9b22b" id="r_ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga8af1dd7cd2864bea6226054f1ff9b22b">SocketTimer_heap_cancel</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark timer as cancelled (lazy deletion).  <br /></td></tr>
<tr class="separator:ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69365f1c685576d76414fbb43fe2248b" id="r_ga69365f1c685576d76414fbb43fe2248b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga69365f1c685576d76414fbb43fe2248b">SocketTimer_heap_remaining</a> (<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, const struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga69365f1c685576d76414fbb43fe2248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get milliseconds until timer expiry.  <br /></td></tr>
<tr class="separator:ga69365f1c685576d76414fbb43fe2248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2537cebf106e583079ec472086a26d65" id="r_ga2537cebf106e583079ec472086a26d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, int64_t delay_ms, <a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a> callback, void *userdata)</td></tr>
<tr class="memdesc:ga2537cebf106e583079ec472086a26d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a one-shot timer.  <br /></td></tr>
<tr class="separator:ga2537cebf106e583079ec472086a26d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6961bde0e491d732450b66577294d097" id="r_ga6961bde0e491d732450b66577294d097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097">SocketTimer_add_repeating</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, int64_t interval_ms, <a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a> callback, void *userdata)</td></tr>
<tr class="memdesc:ga6961bde0e491d732450b66577294d097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating timer.  <br /></td></tr>
<tr class="separator:ga6961bde0e491d732450b66577294d097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7ca05c6cfc7c69ddc3d676a681bc62" id="r_ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> timer)</td></tr>
<tr class="memdesc:ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending timer.  <br /></td></tr>
<tr class="separator:ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5519b89e0bba69f26d03b6893ba779" id="r_ga4c5519b89e0bba69f26d03b6893ba779"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779">SocketTimer_remaining</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> timer)</td></tr>
<tr class="memdesc:ga4c5519b89e0bba69f26d03b6893ba779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get milliseconds until timer expiry.  <br /></td></tr>
<tr class="separator:ga4c5519b89e0bba69f26d03b6893ba779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf791d7d3363309127dbdd94e4181b8c3" id="r_gaf791d7d3363309127dbdd94e4181b8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaf791d7d3363309127dbdd94e4181b8c3">socketpoll_get_timer_heap</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:gaf791d7d3363309127dbdd94e4181b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access timer heap for internal SocketTimer integration.  <br /></td></tr>
<tr class="separator:gaf791d7d3363309127dbdd94e4181b8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1fbd1a09d564f7988b0e427e5707ca7" id="r_gac1fbd1a09d564f7988b0e427e5707ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a> (int maxevents)</td></tr>
<tr class="memdesc:gac1fbd1a09d564f7988b0e427e5707ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new event poll instance.  <br /></td></tr>
<tr class="separator:gac1fbd1a09d564f7988b0e427e5707ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca744c50badbdb869c52088b9f32f8d2" id="r_gaca744c50badbdb869c52088b9f32f8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> *poll)</td></tr>
<tr class="memdesc:gaca744c50badbdb869c52088b9f32f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of an event poll instance and release resources.  <br /></td></tr>
<tr class="separator:gaca744c50badbdb869c52088b9f32f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" id="r_ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, Socket_T socket, unsigned events, void *data)</td></tr>
<tr class="memdesc:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a socket for event monitoring in the poll set.  <br /></td></tr>
<tr class="separator:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3755cc4d5ed8838ce2261f0efd1d5d85" id="r_ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85">SocketPoll_mod</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, Socket_T socket, unsigned events, void *data)</td></tr>
<tr class="memdesc:ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update event monitoring and/or user data for a registered socket.  <br /></td></tr>
<tr class="separator:ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3074c5a225a7c49880951ecfb984498f" id="r_ga3074c5a225a7c49880951ecfb984498f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, Socket_T socket)</td></tr>
<tr class="memdesc:ga3074c5a225a7c49880951ecfb984498f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister a socket from event monitoring.  <br /></td></tr>
<tr class="separator:ga3074c5a225a7c49880951ecfb984498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb5e288308c3de5a479b27366bba257" id="r_ga1bb5e288308c3de5a479b27366bba257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257">SocketPoll_getdefaulttimeout</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:ga1bb5e288308c3de5a479b27366bba257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default wait timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga1bb5e288308c3de5a479b27366bba257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945845cc57758a91e47a75ef17064d2a" id="r_ga945845cc57758a91e47a75ef17064d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a">SocketPoll_setdefaulttimeout</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, int timeout)</td></tr>
<tr class="memdesc:ga945845cc57758a91e47a75ef17064d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default wait timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga945845cc57758a91e47a75ef17064d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d47365dd18329d50ee636284839738" id="r_gaa3d47365dd18329d50ee636284839738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, <a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> **events, int timeout)</td></tr>
<tr class="memdesc:gaa3d47365dd18329d50ee636284839738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for I/O events on registered sockets.  <br /></td></tr>
<tr class="separator:gaa3d47365dd18329d50ee636284839738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665b3363d16ab859ec60e69a792d1ff0" id="r_ga665b3363d16ab859ec60e69a792d1ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__async__io.html#structSocketAsync__T">SocketAsync_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0">SocketPoll_get_async</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:ga665b3363d16ab859ec60e69a792d1ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get async I/O context associated with poll instance.  <br /></td></tr>
<tr class="separator:ga665b3363d16ab859ec60e69a792d1ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16688a9e444183863bab8051f57fe688" id="r_ga16688a9e444183863bab8051f57fe688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688">SocketPoll_getmaxregistered</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:ga16688a9e444183863bab8051f57fe688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum registered sockets limit.  <br /></td></tr>
<tr class="separator:ga16688a9e444183863bab8051f57fe688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d4052d444bcab4cae26f41cf5729eb" id="r_ga35d4052d444bcab4cae26f41cf5729eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb">SocketPoll_setmaxregistered</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll, int max)</td></tr>
<tr class="memdesc:ga35d4052d444bcab4cae26f41cf5729eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum registered sockets limit.  <br /></td></tr>
<tr class="separator:ga35d4052d444bcab4cae26f41cf5729eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79e719de24f09f84eb3816b3ab60c65" id="r_gac79e719de24f09f84eb3816b3ab60c65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65">SocketPoll_getregisteredcount</a> (<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:gac79e719de24f09f84eb3816b3ab60c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current registered socket count.  <br /></td></tr>
<tr class="separator:gac79e719de24f09f84eb3816b3ab60c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa198b207e04b5bb6bec2746c7d86b735" id="r_gaa198b207e04b5bb6bec2746c7d86b735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735">backend_new</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, int maxevents)</td></tr>
<tr class="memdesc:gaa198b207e04b5bb6bec2746c7d86b735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend Interface - Abstract Polling Operations.  <br /></td></tr>
<tr class="separator:gaa198b207e04b5bb6bec2746c7d86b735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a767499b3aa80b77e4fb63368be228" id="r_ga30a767499b3aa80b77e4fb63368be228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga30a767499b3aa80b77e4fb63368be228">backend_free</a> (<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend)</td></tr>
<tr class="memdesc:ga30a767499b3aa80b77e4fb63368be228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close backend resources.  <br /></td></tr>
<tr class="separator:ga30a767499b3aa80b77e4fb63368be228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51ec4e5f966a860cdd9359c36e977c6" id="r_gaa51ec4e5f966a860cdd9359c36e977c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6">backend_add</a> (<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int fd, unsigned events)</td></tr>
<tr class="memdesc:gaa51ec4e5f966a860cdd9359c36e977c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add socket to poll set.  <br /></td></tr>
<tr class="separator:gaa51ec4e5f966a860cdd9359c36e977c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b929e888a5088e59cd045c41759363e" id="r_ga4b929e888a5088e59cd045c41759363e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga4b929e888a5088e59cd045c41759363e">backend_mod</a> (<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int fd, unsigned events)</td></tr>
<tr class="memdesc:ga4b929e888a5088e59cd045c41759363e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify monitored events.  <br /></td></tr>
<tr class="separator:ga4b929e888a5088e59cd045c41759363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ec719e250346605c00e5b3efb2e7d8" id="r_gae9ec719e250346605c00e5b3efb2e7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8">backend_del</a> (<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int fd)</td></tr>
<tr class="memdesc:gae9ec719e250346605c00e5b3efb2e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove socket from poll set.  <br /></td></tr>
<tr class="separator:gae9ec719e250346605c00e5b3efb2e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2c06638f0c76ea3c6c2f38503d266b" id="r_ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b">backend_wait</a> (<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int timeout_ms)</td></tr>
<tr class="memdesc:ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for events.  <br /></td></tr>
<tr class="separator:ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad998de1df9f46711f5c3b4dc0257f548" id="r_gad998de1df9f46711f5c3b4dc0257f548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548">backend_get_event</a> (const <a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int index, int *fd_out, unsigned *events_out)</td></tr>
<tr class="memdesc:gad998de1df9f46711f5c3b4dc0257f548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get event details for index.  <br /></td></tr>
<tr class="separator:gad998de1df9f46711f5c3b4dc0257f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edb00f128ad773d62c8f11c516153d9" id="r_ga2edb00f128ad773d62c8f11c516153d9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2edb00f128ad773d62c8f11c516153d9">backend_name</a> (void)</td></tr>
<tr class="memdesc:ga2edb00f128ad773d62c8f11c516153d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable backend name for debugging and logging.  <br /></td></tr>
<tr class="separator:ga2edb00f128ad773d62c8f11c516153d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2f0acf311c238671c6d9d14d4cc7c158" id="r_ga2f0acf311c238671c6d9d14d4cc7c158"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a></td></tr>
<tr class="memdesc:ga2f0acf311c238671c6d9d14d4cc7c158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer subsystem operation failure.  <br /></td></tr>
<tr class="separator:ga2f0acf311c238671c6d9d14d4cc7c158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4754362476e3ffc3e000b1cbcc2a6f0" id="r_gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a></td></tr>
<tr class="memdesc:gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketPoll operation failure exception.  <br /></td></tr>
<tr class="separator:gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>High-performance I/O multiplexing with cross-platform backends.</p>
<p>Key components: <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> (cross-platform I/O multiplexing), <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> (timer management). Enables scalable event-driven network applications with automatic platform adaptation. </p>
<p>Architecture Overview:</p><ul>
<li># <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a>: Core polling interface with backend abstraction for epoll/kqueue/poll.</li>
<li># <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a>: Heap-based timer scheduling integrated with poll wait cycles.</li>
<li>Integration with async_io::SocketAsync_T via <a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0" title="Get async I/O context associated with poll instance.">SocketPoll_get_async()</a> for zero-copy, high-throughput async operations.</li>
</ul>
<p>Backend Selection:</p><ul>
<li>Linux: epoll(7) for O(1) edge-triggered notifications.</li>
<li>BSD/macOS: kqueue(2) for efficient event filtering and file descriptor monitoring.</li>
<li>Fallback: poll(2) for broad POSIX compatibility (level-triggered).</li>
</ul>
<p>Design Principles:</p><ul>
<li>Thread-safe: Internal mutexes protect shared state across operations.</li>
<li>Arena-allocated: Efficient memory management tied to poll lifecycle.</li>
<li>Non-blocking: Automatically configures sockets for async operation.</li>
</ul>
<p>Usage Patterns:</p><ul>
<li>Servers: Combine with connection_mgmt::SocketPool_T for connection handling.</li>
<li>Clients: Use with utilities::SocketReconnect_T for resilient connections.</li>
<li>Timeouts: Integrate <a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> for idle connection management.</li>
</ul>
<p>Error Handling: Uses <a class="el" href="group__foundation.html">Core Foundation Modules</a> exceptions with detailed errno mapping. Performance: Minimizes syscalls; supports up to system limits (e.g., /proc/sys/fs/epoll/max_user_watches).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html">Core Foundation Modules</a> for base infrastructure (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>, <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a>). </dd>
<dd>
<a class="el" href="group__core__io.html">Core I/O Modules</a> for Socket_T primitives compatible with event registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for advanced connection lifecycle management. </dd>
<dd>
<a class="el" href="group__async__io.html">Async I/O Modules</a> for <a class="el" href="group__async__io.html#structSocketAsync__T" title="Opaque structure representing the asynchronous I/O context.">SocketAsync_T</a> usage in high-performance scenarios. </dd>
<dd>
<a class="el" href="group__utilities.html">Utility Modules</a> for rate limiting and retry logic integration. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for polling API details. </dd>
<dd>
<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer API (re-exported here). </dd>
<dd>
async_io::SocketAsync_T for async extensions (integrated via <a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0" title="Get async I/O context associated with poll instance.">SocketPoll_get_async()</a>). </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for event-driven programming examples and best practices. </dd>
<dd>
docs/ERROR_HANDLING.md for exception patterns in event loops. </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketData" id="structSocketData"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketData">&#9670;&#160;</a></span>SocketData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketData</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Hash table entry for socket-to-userdata mapping. </p>
<p>Used in internal hash table for O(1) average-case socket-to-userdata lookup during event processing. Hash table uses golden ratio multiplication hash function for optimal distribution and collision resistance.</p>
<p>Thread Safety: Access protected by poll instance mutex for all operations. Memory Management: Allocated from poll's arena for efficient cleanup.</p>
<dl class="section see"><dt>See also</dt><dd>socket_data_add_unlocked() for hash table insertion (internal). </dd>
<dd>
socket_data_lookup_unlocked() for hash table lookup (returns user <a class="el" href="group__event__system.html#a942b54345de6283838d63e9de0378440">data</a>). </dd>
<dd>
socket_data_remove_unlocked() for hash table deletion (internal). </dd>
<dd>
<a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for updating user <a class="el" href="group__event__system.html#a942b54345de6283838d63e9de0378440">data</a> and monitored events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for public interface that uses this mapping. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for hash function implementation details. </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd()</a> for hash function implementation. </dd>
<dd>
poll_fd_hash() for seeded FD hashing used internally. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00110">110</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketData:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketData__coll__graph.svg" width="176" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a942b54345de6283838d63e9de0378440" name="a942b54345de6283838d63e9de0378440"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>User-associated data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a60a4b17af0ea783aea433d16a8f1767b" name="a60a4b17af0ea783aea433d16a8f1767b"></a>struct <a class="el" href="group__event__system.html#structSocketData">SocketData</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>Next entry in hash bucket </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a235a818367962ab1444d564fc9ecb733" name="a235a818367962ab1444d564fc9ecb733"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Socket reference </p>
</td></tr>
</table>

</div>
</div>
<a name="structFdSocketEntry" id="structFdSocketEntry"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structFdSocketEntry">&#9670;&#160;</a></span>FdSocketEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct FdSocketEntry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Hash table entry for file descriptor to socket reverse mapping. </p>
<p>Enables O(1) reverse lookup from file descriptor to Socket_T during event translation. Required because polling backends return raw file descriptors, but SocketPoll API returns Socket_T objects with associated user data.</p>
<p>Used in event translation pipeline:</p><ol type="1">
<li>Backend returns (fd, events) pairs from <a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a></li>
<li><a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> provides fd-&gt;events mapping</li>
<li>Reverse lookup finds Socket_T for each fd</li>
<li>Forward lookup retrieves user data for each socket</li>
<li><a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> populated with (socket, data, events)</li>
</ol>
<p>Thread Safety: Access protected by poll instance mutex for all operations. Memory Management: Allocated from poll's arena for efficient cleanup.</p>
<dl class="section see"><dt>See also</dt><dd>translate_backend_events_to_socket_events() for general event translation implementation. </dd>
<dd>
<a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> for backend event retrieval interface. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for final translated event structure. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for complete event processing pipeline. </dd>
<dd>
translate_from_epoll() for epoll-specific event translation example. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00141">141</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for FdSocketEntry:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structFdSocketEntry__coll__graph.svg" width="186" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6e281de117ccb3201b590ba4184adb62" name="a6e281de117ccb3201b590ba4184adb62"></a>int</td>
<td class="fieldname">
fd</td>
<td class="fielddoc">
<p>File descriptor </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aec49f71e7b318291b9270ff95811c7b9" name="aec49f71e7b318291b9270ff95811c7b9"></a>struct <a class="el" href="group__event__system.html#structFdSocketEntry">FdSocketEntry</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>Next entry in hash bucket </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adf65761f33705691e1fdae79ae0e8f24" name="adf65761f33705691e1fdae79ae0e8f24"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Associated socket </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketPoll__T" id="structSocketPoll__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketPoll__T">&#9670;&#160;</a></span>SocketPoll_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketPoll_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Complete internal state for SocketPoll instance. </p>
<p>Contains all state for a socket polling instance including backend, event arrays, hash tables, synchronization primitives, and optional extensions. Thread-safe through mutex protection for all operations. All memory allocated from arena for efficient cleanup on destruction.</p>
<p>Core Components:</p><ul>
<li>backend: Platform-specific polling implementation (epoll/kqueue/poll)</li>
<li>maxevents: Configurable limit on events per wait() call</li>
<li>default_timeout_ms: Configurable default timeout for wait operations</li>
<li>registered_count/max_registered: Resource usage tracking and limits</li>
<li>socketevents: Pre-allocated array for translated <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> structures</li>
</ul>
<p>Hash Tables (O(1) lookups):</p><ul>
<li>socket_data_map: Socket_T -&gt; user data mapping for event delivery</li>
<li>fd_to_socket_map: File descriptor -&gt; Socket_T reverse mapping for translation</li>
<li>hash_seed: Random seed for collision resistance in hash functions</li>
</ul>
<p>Extensions:</p><ul>
<li>mutex: Pthread mutex for thread-safe operations</li>
<li>async: Optional SocketAsync context for high-throughput I/O</li>
<li>timer_heap: SocketTimer heap for integrated timer management</li>
</ul>
<p>Memory Layout: All components allocated from arena for single cleanup operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b" title="Opaque type for platform-specific polling backend instances.">PollBackend_T</a> for <a class="el" href="group__event__system.html#a88a87bcdd916ff495a756adc1e9f06d7">backend</a> abstraction layer. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketData" title="Hash table entry for socket-to-userdata mapping.">SocketData</a> for socket-to-userdata hash table entries. </dd>
<dd>
<a class="el" href="group__event__system.html#structFdSocketEntry" title="Hash table entry for file descriptor to socket reverse mapping.">FdSocketEntry</a> for file descriptor reverse mapping entries. </dd>
<dd>
<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T" title="Typedef for the internal timer heap structure.">SocketTimer_heap_T</a> for integrated timer heap. </dd>
<dd>
<a class="el" href="group__async__io.html#structSocketAsync__T" title="Opaque structure representing the asynchronous I/O context.">SocketAsync_T</a> for optional <a class="el" href="group__event__system.html#a33dcc6465ff521360c191ee1b699fc47">async</a> I/O context. </dd>
<dd>
<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> for memory management. </dd>
<dd>
<a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for instance creation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00184">184</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketPoll_T:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structSocketPoll__T__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a31237bda8b145cd7a4c4b1b2591ee3dc" name="a31237bda8b145cd7a4c4b1b2591ee3dc"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Memory arena </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a33dcc6465ff521360c191ee1b699fc47" name="a33dcc6465ff521360c191ee1b699fc47"></a><a class="el" href="group__async__io.html#structSocketAsync__T">SocketAsync_T</a></td>
<td class="fieldname">
async</td>
<td class="fielddoc">
<p>Optional async I/O context </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a88a87bcdd916ff495a756adc1e9f06d7" name="a88a87bcdd916ff495a756adc1e9f06d7"></a><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a></td>
<td class="fieldname">
backend</td>
<td class="fielddoc">
<p>Platform-specific backend </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5aeb90d7138a60d98bcf5948da12e9f5" name="a5aeb90d7138a60d98bcf5948da12e9f5"></a>int</td>
<td class="fieldname">
default_timeout_ms</td>
<td class="fielddoc">
<p>Default timeout for wait </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5a9bf570afcf7c0d4ac9a9311f3a27b0" name="a5a9bf570afcf7c0d4ac9a9311f3a27b0"></a><a class="el" href="group__event__system.html#structFdSocketEntry">FdSocketEntry</a> *</td>
<td class="fieldname">
fd_to_socket_map[1021]</td>
<td class="fielddoc">
<p>FD-&gt;socket hash table </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af8c9fe4c2e7f12115a135c69c9e7fbdb" name="af8c9fe4c2e7f12115a135c69c9e7fbdb"></a>unsigned</td>
<td class="fieldname">
hash_seed</td>
<td class="fielddoc">
<p>Random seed for FD hashing to mitigate collisions </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afd944e224b0b04685b0e0b94716965be" name="afd944e224b0b04685b0e0b94716965be"></a>int</td>
<td class="fieldname">
max_registered</td>
<td class="fielddoc">
<p>Max registered (0=unlimited) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a658db3993da32f677a948cd36d276a83" name="a658db3993da32f677a948cd36d276a83"></a>int</td>
<td class="fieldname">
maxevents</td>
<td class="fielddoc">
<p>Maximum events per wait </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a56fa157efc7ff3aa02cdb75e57ee2f89" name="a56fa157efc7ff3aa02cdb75e57ee2f89"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
<p>Thread-safety mutex </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2fa65b0698266106795cd06f53b277a2" name="a2fa65b0698266106795cd06f53b277a2"></a>int</td>
<td class="fieldname">
registered_count</td>
<td class="fielddoc">
<p>Current registered socket count </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a80bda4f02a183fc02340510cc79b5112" name="a80bda4f02a183fc02340510cc79b5112"></a><a class="el" href="group__event__system.html#structSocketData">SocketData</a> *</td>
<td class="fieldname">
socket_data_map[1021]</td>
<td class="fielddoc">
<p>Socket-&gt;data hash table </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aef3fbc97c09600c5f16b65d2bdbda6f0" name="aef3fbc97c09600c5f16b65d2bdbda6f0"></a><a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> *</td>
<td class="fieldname">
socketevents</td>
<td class="fielddoc">
<p>Translated event array </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a377ea71b38ec41e5e223d479077024e2" name="a377ea71b38ec41e5e223d479077024e2"></a><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *</td>
<td class="fieldname">
timer_heap</td>
<td class="fielddoc">
<p>Timer heap for integrated timers </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketEvent__T" id="structSocketEvent__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketEvent__T">&#9670;&#160;</a></span>SocketEvent_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketEvent_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Event notification structure returned by polling operations. </p>
<p>Contains information about I/O events that occurred on monitored sockets. Returned as an array from <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> calls. The array is managed internally by the poll instance and should not be freed by the caller.</p>
<p>Memory Management:</p><ul>
<li>Array lifetime tied to poll instance</li>
<li>Valid until next <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> call or poll destruction</li>
<li>Do not free or modify the returned array</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for event retrieval. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for possible event types. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for associating user <a class="el" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">data</a> with sockets. </dd>
<dd>
Socket_T for <a class="el" href="group__event__system.html#a98544b5a507331adac069acd7f42d593">socket</a> type definition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00187">187</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>
</div><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketEvent_T:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketEvent__T__coll__graph.svg" width="154" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="acb5b92ec2f2954ee3baa024a74ce4655" name="acb5b92ec2f2954ee3baa024a74ce4655"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>User data associated with socket at registration </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac526bc7e51851919ae7b0f3cec5934bc" name="ac526bc7e51851919ae7b0f3cec5934bc"></a>unsigned</td>
<td class="fieldname">
events</td>
<td class="fielddoc">
<p>Bitmask of events that occurred (SocketPoll_Events) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a98544b5a507331adac069acd7f42d593" name="a98544b5a507331adac069acd7f42d593"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Socket that triggered the event </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga834e79d67b92d737d55e4ba2b0684025" name="ga834e79d67b92d737d55e4ba2b0684025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834e79d67b92d737d55e4ba2b0684025">&#9670;&#160;</a></span>POLL_FD_MAP_EXPAND_INCREMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_FD_MAP_EXPAND_INCREMENT&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File descriptor map expansion increment. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00498">498</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga211a6387523fa6487af971831aabf461" name="ga211a6387523fa6487af971831aabf461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211a6387523fa6487af971831aabf461">&#9670;&#160;</a></span>POLL_INITIAL_FD_MAP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_INITIAL_FD_MAP_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial file descriptor map size. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00488">488</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga673275383493d8cff8bc582fef311e42" name="ga673275383493d8cff8bc582fef311e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673275383493d8cff8bc582fef311e42">&#9670;&#160;</a></span>POLL_INITIAL_FDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_INITIAL_FDS&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial file descriptor capacity for poll backend. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00478">478</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga55f5cf0f097a98b03e1511d1b6bd91b2" name="ga55f5cf0f097a98b03e1511d1b6bd91b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f5cf0f097a98b03e1511d1b6bd91b2">&#9670;&#160;</a></span>RAISE_POLL_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_POLL_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (SocketPoll, e)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread-safe exception raising with detailed error messages. </p>
<p>Uses centralized SOCKET_RAISE_MODULE_ERROR macro from <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> which handles thread-local exception copying to prevent race conditions when multiple threads raise the same exception type simultaneously.</p>
<p>Thread Safety Mechanism:</p><ul>
<li>Creates thread-local copy of SocketPoll_DetailedException</li>
<li>Populates copy with current error message from socket_error_buf</li>
<li>Raises the copy, leaving global exception unchanged for other threads</li>
</ul>
<p>Usage Pattern: </p><div class="fragment"><div class="line"><a class="code hl_define" href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8">SOCKET_ERROR_FMT</a>(<span class="stringliteral">&quot;Operation failed on fd=%d&quot;</span>, fd);</div>
<div class="line"><a class="code hl_define" href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a>(<a class="code hl_variable" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a>);</div>
<div class="ttc" id="aSocketUtil_8h_html_adf114e63024eabf6e40f1ed7f89c79b8"><div class="ttname"><a href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8">SOCKET_ERROR_FMT</a></div><div class="ttdeci">#define SOCKET_ERROR_FMT(fmt,...)</div><div class="ttdoc">SOCKET_ERROR_FMT - Format error message with errno information.</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l01066">SocketUtil.h:1066</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga55f5cf0f097a98b03e1511d1b6bd91b2"><div class="ttname"><a href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a></div><div class="ttdeci">#define RAISE_POLL_ERROR(e)</div><div class="ttdoc">Thread-safe exception raising with detailed error messages.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll-private_8h_source.html#l00239">SocketPoll-private.h:239</a></div></div>
<div class="ttc" id="agroup__event__system_html_gab4754362476e3ffc3e000b1cbcc2a6f0"><div class="ttname"><a href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a></div><div class="ttdeci">const Except_T SocketPoll_Failed</div><div class="ttdoc">SocketPoll operation failure exception.</div></div>
</div><!-- fragment --><p>Error Message Population:</p><ul>
<li>Use <a class="el" href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8" title="SOCKET_ERROR_FMT - Format error message with errno information.">SOCKET_ERROR_FMT()</a> for formatted messages with errno</li>
<li>Use <a class="el" href="SocketUtil_8h.html#a1feea47474a6b6e939c442cdd7c42fdb" title="SOCKET_ERROR_MSG - Format error message without errno.">SOCKET_ERROR_MSG()</a> for simple messages without errno</li>
<li>Messages stored in thread-local socket_error_buf</li>
</ul>
<dl class="section user"><dt>Thread Safety\n Yes - Uses thread-local exception copies.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-local SocketPoll_DetailedException declared in SocketPoll.c. </dd>
<dd>
Error message must be populated before calling this macro. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b" title="SOCKET_RAISE_MODULE_ERROR - Raise module-specific exception.">SOCKET_RAISE_MODULE_ERROR</a> for implementation details. </dd>
<dd>
<a class="el" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0" title="SocketPoll operation failure exception.">SocketPoll_Failed</a> for the exception type definition. </dd>
<dd>
error_handling for complete exception handling patterns. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8" title="SOCKET_ERROR_FMT - Format error message with errno information.">SOCKET_ERROR_FMT</a> for error message formatting macros. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#a1feea47474a6b6e939c442cdd7c42fdb" title="SOCKET_ERROR_MSG - Format error message without errno.">SOCKET_ERROR_MSG</a> for simple error messages. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for centralized exception handling <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utility Modules</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00239">239</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
<a id="ga7c0e59971e52bc0a110b2a7066ea2732" name="ga7c0e59971e52bc0a110b2a7066ea2732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c0e59971e52bc0a110b2a7066ea2732">&#9670;&#160;</a></span>SOCKET_DATA_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DATA_HASH_SIZE&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configured hash table size for internal socket data and FD-to-socket mappings. </p>
<p>Aliases the global SOCKET_HASH_TABLE_SIZE (default: 1021) for consistent hash table sizing across modules. Enables O(1) average-case lookups during event processing and socket management. The size is chosen as a prime number for optimal hash distribution with the golden ratio hash function.</p>
<dl class="section note"><dt>Note</dt><dd>Value can be overridden at compile-time via -DSOCKET_HASH_TABLE_SIZE=N in CMake. </dd>
<dd>
Larger sizes reduce collisions but increase memory usage for hash tables. </dd>
<dd>
Used for both socket_data_map and fd_to_socket_map arrays.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketConfig_8h.html" title="Compile-time configuration and platform detection for the socket library.">SocketConfig.h</a> for <a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84" title="Hash table size for socket data mapping.">SOCKET_HASH_TABLE_SIZE</a> definition and configuration. </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd()</a> and <a class="el" href="group__foundation.html#ga81d733432a2030afb97cd12be61e7054" title="Hash unsigned integer using golden ratio.">socket_util_hash_uint()</a> for hash functions. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketData" title="Hash table entry for socket-to-userdata mapping.">SocketData</a> for socket-to-data mapping entries. </dd>
<dd>
<a class="el" href="group__event__system.html#structFdSocketEntry" title="Hash table entry for file descriptor to socket reverse mapping.">FdSocketEntry</a> for FD-to-socket reverse mapping entries. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for hash table design patterns in <a class="el" href="group__foundation.html" title="Base infrastructure for memory management, exception handling, and core utilities....">Core Foundation Modules</a> modules. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00086">86</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
<a id="ga71cb10d1eefc15616a20bcd7ae21e875" name="ga71cb10d1eefc15616a20bcd7ae21e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71cb10d1eefc15616a20bcd7ae21e875">&#9670;&#160;</a></span>SOCKET_DEFAULT_POLL_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_POLL_TIMEOUT&#160;&#160;&#160;1000 /* 1 second */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default poll timeout. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01271">1271</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga76ac815951cb4cbc800c781eb143b8cb" name="ga76ac815951cb4cbc800c781eb143b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ac815951cb4cbc800c781eb143b8cb">&#9670;&#160;</a></span>SOCKET_EVENT_MAX_HANDLERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_EVENT_MAX_HANDLERS&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of event handlers that can be registered. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__async__io.html#structSocketAsync__T" title="Opaque structure representing the asynchronous I/O context.">SocketAsync_T</a> for async I/O events. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00632">632</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gab6d7f45fcb5eae5fe42694e8e123cab4" name="gab6d7f45fcb5eae5fe42694e8e123cab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d7f45fcb5eae5fe42694e8e123cab4">&#9670;&#160;</a></span>SOCKET_MAX_POLL_EVENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_POLL_EVENTS&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum events per poll iteration. </p>
<p>Can be overridden at compile time with -DSOCKET_MAX_POLL_EVENTS=value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00235">235</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7f5492f9166c78ee14f4b69362ccaf51" name="ga7f5492f9166c78ee14f4b69362ccaf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5492f9166c78ee14f4b69362ccaf51">&#9670;&#160;</a></span>SOCKET_MAX_TIMER_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMER_DELAY_MS&#160;&#160;&#160;(INT64_C (31536000000)) /* 365 days */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum allowed delay or interval for individual timers. </p>
<p>Prevents resource exhaustion and int64_t overflow (~1 year in ms). Can be overridden at compile time with -DSOCKET_MAX_TIMER_DELAY_MS=value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00542">542</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad738dd2be8abca1d0353d31f888ba3eb" name="gad738dd2be8abca1d0353d31f888ba3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad738dd2be8abca1d0353d31f888ba3eb">&#9670;&#160;</a></span>SOCKET_MAX_TIMER_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMER_TIMEOUT_MS&#160;&#160;&#160;300000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum timer timeout to prevent indefinite blocking. </p>
<p>5 minutes maximum to prevent resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00529">529</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga53de6720fd3fc8accf99751c1e4e0d50" name="ga53de6720fd3fc8accf99751c1e4e0d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53de6720fd3fc8accf99751c1e4e0d50">&#9670;&#160;</a></span>SOCKET_MAX_TIMERS_PER_HEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMERS_PER_HEAP&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of timers per heap. </p>
<p>Prevents resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00585">585</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0fc8aa94a3e9bb10cb26d85c6474d04e" name="ga0fc8aa94a3e9bb10cb26d85c6474d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fc8aa94a3e9bb10cb26d85c6474d04e">&#9670;&#160;</a></span>SOCKET_POLL_TIMEOUT_USE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POLL_TIMEOUT_USE_DEFAULT&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special timeout value to use the poll's default timeout. </p>
<p>When passed to <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a>, this value instructs the function to use the default timeout configured via <a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a>. Useful for consistent timeout behavior across multiple wait calls.</p>
<dl class="section note"><dt>Note</dt><dd>This constant ensures timeout consistency across multiple wait operations. </dd>
<dd>
Equivalent to calling <a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for each wait.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for timeout parameter usage. </dd>
<dd>
<a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for setting the default timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for retrieving the current default. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00209">209</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<a id="gab56cfec8835c59bfb69bb1c1cb128c93" name="gab56cfec8835c59bfb69bb1c1cb128c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56cfec8835c59bfb69bb1c1cb128c93">&#9670;&#160;</a></span>SOCKET_TIMER_ERROR_BUFSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_ERROR_BUFSIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer error buffer size for detailed error messages. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00551">551</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaca5f033531acb4f68ba5823ce2b769d7" name="gaca5f033531acb4f68ba5823ce2b769d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5f033531acb4f68ba5823ce2b769d7">&#9670;&#160;</a></span>SOCKET_TIMER_HEAP_GROWTH_FACTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_HEAP_GROWTH_FACTOR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Growth factor when resizing timer heap. </p>
<p>Must be greater than 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer heap implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00573">573</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga115b76003aaf131241e5b091a63b3285" name="ga115b76003aaf131241e5b091a63b3285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115b76003aaf131241e5b091a63b3285">&#9670;&#160;</a></span>SOCKET_TIMER_HEAP_INITIAL_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_HEAP_INITIAL_CAPACITY&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial capacity for timer heap array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer heap implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00561">561</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacd3100d409a6fd3f6d160700ba6c64c6" name="gacd3100d409a6fd3f6d160700ba6c64c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3100d409a6fd3f6d160700ba6c64c6">&#9670;&#160;</a></span>SOCKET_TIMER_INITIAL_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_INITIAL_ID&#160;&#160;&#160;1ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial timer ID value. </p>
<p>Wraps at UINT64_MAX.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00617">617</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2829aac1405cdf86f8ef8b6eb3ecf365" name="ga2829aac1405cdf86f8ef8b6eb3ecf365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2829aac1405cdf86f8ef8b6eb3ecf365">&#9670;&#160;</a></span>SOCKET_TIMER_INVALID_HEAP_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_INVALID_HEAP_INDEX&#160;&#160;&#160;((size_t) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sentinel value indicating that a timer is not currently in the heap. </p>
<p>Used in <a class="el" href="SocketTimer-private_8h.html#a6773d27e4dd53f972df13651ed8bf518">SocketTimer_T::heap_index</a> to mark timers that are cancelled or not inserted. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#a6773d27e4dd53f972df13651ed8bf518">SocketTimer_T::heap_index</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer-private_8h_source.html#l00109">109</a> of file <a class="el" href="SocketTimer-private_8h_source.html">SocketTimer-private.h</a>.</p>

</div>
</div>
<a id="gab0ced17c77c552330176b69557fb83fc" name="gab0ced17c77c552330176b69557fb83fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ced17c77c552330176b69557fb83fc">&#9670;&#160;</a></span>SOCKET_TIMER_MIN_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_MIN_DELAY_MS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum delay for one-shot timers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00595">595</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga59221d1781370448def350dafb2d7e24" name="ga59221d1781370448def350dafb2d7e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59221d1781370448def350dafb2d7e24">&#9670;&#160;</a></span>SOCKET_TIMER_MIN_INTERVAL_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_MIN_INTERVAL_MS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum interval for repeating timers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00605">605</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque pointer to a timer instance. </p>
<p>High-performance socket polling abstraction with cross-platform backends.</p>
<p>Opaque type macro for internal <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> structure definition.</p>
<p>Represents a timer created by <a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> or <a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating timer.">SocketTimer_add_repeating()</a>. Used to cancel the timer or query remaining time. Becomes invalid after the timer fires or is cancelled. </p><dl class="section note"><dt>Note</dt><dd>Not a pointer to the internal <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> structure; heap manages actual storage. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a></dd></dl>
<p>Standard opaque pointer pattern used for private implementation hiding. Allows compile-time definition of struct T while keeping internal fields inaccessible from public headers.</p>
<dl class="section note"><dt>Note</dt><dd>Used only in private implementation files (.c and -private.h). </dd>
<dd>
Matches public typedef in <a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">SocketPoll.h</a> for ABI compatibility.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> in <a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">SocketPoll.h</a> for public opaque type. </dd>
<dd>
struct <a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5" title="High-performance socket polling abstraction with cross-platform backends.">T</a> below for complete internal structure.</dd></dl>
<p>Provides scalable event notification for network applications with O(1) event delivery regardless of the number of monitored sockets. Automatically selects the best available backend for the platform: epoll (Linux), kqueue (BSD/macOS), or poll (POSIX fallback).</p>
<p>Key Features:</p><ul>
<li>O(1) event delivery with edge-triggered mode for efficiency</li>
<li>Automatic backend selection based on platform capabilities</li>
<li>Thread-safe operations with internal mutex protection</li>
<li>Integrated timer management via SocketTimer</li>
<li>Optional asynchronous I/O support via SocketAsync</li>
<li>Configurable limits for resource protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for event waiting. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer_8h_source.html#l00055">55</a> of file <a class="el" href="SocketTimer_8h_source.html">SocketTimer.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type macro for internal <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> structure definition. </p>
<p>High-performance socket polling abstraction with cross-platform backends.</p>
<p>Standard opaque pointer pattern used for private implementation hiding. Allows compile-time definition of struct T while keeping internal fields inaccessible from public headers.</p>
<dl class="section note"><dt>Note</dt><dd>Used only in private implementation files (.c and -private.h). </dd>
<dd>
Matches public typedef in <a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">SocketPoll.h</a> for ABI compatibility.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> in <a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">SocketPoll.h</a> for public opaque type. </dd>
<dd>
struct <a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5" title="High-performance socket polling abstraction with cross-platform backends.">T</a> below for complete internal structure.</dd></dl>
<p>Provides scalable event notification for network applications with O(1) event delivery regardless of the number of monitored sockets. Automatically selects the best available backend for the platform: epoll (Linux), kqueue (BSD/macOS), or poll (POSIX fallback).</p>
<p>Key Features:</p><ul>
<li>O(1) event delivery with edge-triggered mode for efficiency</li>
<li>Automatic backend selection based on platform capabilities</li>
<li>Thread-safe operations with internal mutex protection</li>
<li>Integrated timer management via SocketTimer</li>
<li>Optional asynchronous I/O support via SocketAsync</li>
<li>Configurable limits for resource protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for event waiting. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00066">66</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-performance socket polling abstraction with cross-platform backends. </p>
<p>Provides scalable event notification for network applications with O(1) event delivery regardless of the number of monitored sockets. Automatically selects the best available backend for the platform: epoll (Linux), kqueue (BSD/macOS), or poll (POSIX fallback).</p>
<p>Key Features:</p><ul>
<li>O(1) event delivery with edge-triggered mode for efficiency</li>
<li>Automatic backend selection based on platform capabilities</li>
<li>Thread-safe operations with internal mutex protection</li>
<li>Integrated timer management via SocketTimer</li>
<li>Optional asynchronous I/O support via SocketAsync</li>
<li>Configurable limits for resource protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for event waiting. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00125">125</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<a id="ga72ef813749c8c54d8f8ccf64ba724a0a" name="ga72ef813749c8c54d8f8ccf64ba724a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72ef813749c8c54d8f8ccf64ba724a0a">&#9670;&#160;</a></span>VALIDATE_FD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VALIDATE_FD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fd</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      if ((fd) &lt; 0)                                                           \</div>
<div class="line">        {                                                                     \</div>
<div class="line">          errno = EBADF;                                                      \</div>
<div class="line">          <span class="keywordflow">return</span> -1;                                                          \</div>
<div class="line">        }                                                                     \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Validate file descriptor parameter for backend operations. </p>
<p>Common validation macro used by all backend implementations to ensure file descriptors are valid before performing backend operations. Provides defense-in-depth validation to catch invalid descriptors early and prevent undefined behavior in system calls.</p>
<p>Validation Logic: File descriptor must be &gt;= 0 (negative values invalid).</p>
<p>Error Handling: Sets errno to EBADF and returns -1 from calling function on validation failure, ensuring consistent error reporting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor to validate (must be &gt;= 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns -1 from calling function on validation failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sets errno to EBADF for negative file descriptors. </dd>
<dd>
Used by <a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a>, <a class="el" href="group__event__system.html#ga4b929e888a5088e59cd045c41759363e" title="Modify monitored events.">backend_mod()</a>, <a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8" title="Remove socket from poll set.">backend_del()</a> implementations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for usage in socket registration operations. </dd>
<dd>
<a class="el" href="group__event__system.html#ga4b929e888a5088e59cd045c41759363e" title="Modify monitored events.">backend_mod()</a> for usage in event modification operations. </dd>
<dd>
<a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8" title="Remove socket from poll set.">backend_del()</a> for usage in socket removal operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877" title="Get underlying file descriptor.">Socket_fd()</a> for obtaining valid file descriptors from Socket_T. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for public interface that validates sockets. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll__backend_8h_source.html#l00140">140</a> of file <a class="el" href="SocketPoll__backend_8h_source.html">SocketPoll_backend.h</a>.</p>

</div>
</div>
<a id="gad5c973c74b3941d078d573439e92c65b" name="gad5c973c74b3941d078d573439e92c65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c973c74b3941d078d573439e92c65b">&#9670;&#160;</a></span>VALIDATE_MAXEVENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VALIDATE_MAXEVENTS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxevents, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      if ((<span class="keywordtype">size_t</span>)(maxevents) &lt;= 0)                                           \</div>
<div class="line">        {                                                                     \</div>
<div class="line">          errno = EINVAL;                                                     \</div>
<div class="line">          <span class="keywordflow">return</span> NULL;                                                        \</div>
<div class="line">        }                                                                     \</div>
<div class="line">      if ((<span class="keywordtype">size_t</span>)(maxevents) &gt; SIZE_MAX / <span class="keyword">sizeof</span> (event_type))               \</div>
<div class="line">        {                                                                     \</div>
<div class="line">          errno = EOVERFLOW;                                                  \</div>
<div class="line">          <span class="keywordflow">return</span> NULL;                                                        \</div>
<div class="line">        }                                                                     \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Validate maxevents parameter with overflow protection. </p>
<p>Common validation macro used by all backend implementations to prevent integer overflow attacks and ensure safe memory allocation. Validates that maxevents is positive and won't cause overflow when calculating event array sizes.</p>
<p>Validation Logic:</p><ul>
<li>maxevents must be &gt; 0 (EINVAL if not)</li>
<li>maxevents * sizeof(event_type) must not exceed SIZE_MAX (EOVERFLOW if not)</li>
</ul>
<p>Error Handling: Sets errno and returns NULL from calling function on validation failure, allowing consistent error propagation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxevents</td><td>Maximum events to validate (must be &gt; 0). </td></tr>
    <tr><td class="paramname">event_type</td><td>Event structure type for sizeof calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL from calling function on validation failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sets errno to EINVAL for non-positive maxevents. </dd>
<dd>
Sets errno to EOVERFLOW for potential integer overflow. </dd>
<dd>
Used by all <a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> implementations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> for usage in backend creation functions. </dd>
<dd>
SIZE_MAX for overflow protection limits. </dd>
<dd>
<a class="el" href="group__foundation.html#gad93b1dd7d771cbed846dcc3c5c836917" title="Allocate memory from arena.">Arena_alloc()</a> for safe allocation that respects these limits. </dd>
<dd>
<a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for public interface that validates parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll__backend_8h_source.html#l00097">97</a> of file <a class="el" href="SocketPoll__backend_8h_source.html">SocketPoll_backend.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gadd97c2d63f6b491ef855bd928211e71b" name="gadd97c2d63f6b491ef855bd928211e71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd97c2d63f6b491ef855bd928211e71b">&#9670;&#160;</a></span>PollBackend_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>* <a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for platform-specific polling backend instances. </p>
<p>Represents a backend-specific polling implementation that abstracts platform differences between epoll, kqueue, and poll. Each backend provides the same interface while using the most efficient system calls available on the target platform.</p>
<p>Memory Management: Backend instances are allocated from Arena_T for efficient cleanup when the poll instance is destroyed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> for backend creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga30a767499b3aa80b77e4fb63368be228" title="Close backend resources.">backend_free()</a> for backend cleanup. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll__backend_8h_source.html#l00067">67</a> of file <a class="el" href="SocketPoll__backend_8h_source.html">SocketPoll_backend.h</a>.</p>

</div>
</div>
<a id="gafb51f69cdbf1b882a7a4226959c4fca7" name="gafb51f69cdbf1b882a7a4226959c4fca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb51f69cdbf1b882a7a4226959c4fca7">&#9670;&#160;</a></span>SocketTimerCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketTimerCallback) (void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for timer expiration callback functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>Opaque user data provided at timer creation.</td></tr>
  </table>
  </dd>
</dl>
<p>Invoked when timer expires during <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a>. Executes in the thread calling <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a>. </p><dl class="section note"><dt>Note</dt><dd>Must not call <a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> on itself or block indefinitely. </dd>
<dd>
Safe to allocate/free resources, but avoid recursive timer operations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer_8h_source.html#l00082">82</a> of file <a class="el" href="SocketTimer_8h_source.html">SocketTimer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9e8943c9cb47aba63dda4ad9083142b6" name="ga9e8943c9cb47aba63dda4ad9083142b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8943c9cb47aba63dda4ad9083142b6">&#9670;&#160;</a></span>SocketPoll_Events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">SocketPoll_Events</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event types for socket I/O monitoring. </p>
<p>Bitmask values specifying which I/O events to monitor on sockets. Multiple events can be combined using bitwise OR operations. Used in <a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> and <a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for event registration.</p>
<dl class="section note"><dt>Note</dt><dd>POLL_ERROR and POLL_HANGUP are always monitored automatically. </dd>
<dd>
Edge-triggered mode delivers events only when state changes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for registering sockets with specific events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for modifying monitored events. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event delivery structure. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for event retrieval. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8" name="gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8"></a>POLL_READ&#160;</td><td class="fielddoc"><p>Data available for reading </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195" name="gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195"></a>POLL_WRITE&#160;</td><td class="fielddoc"><p>Socket ready for writing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9" name="gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9"></a>POLL_ERROR&#160;</td><td class="fielddoc"><p>Error condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c" name="gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c"></a>POLL_HANGUP&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> hang up / disconnection </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00161">161</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa51ec4e5f966a860cdd9359c36e977c6" name="gaa51ec4e5f966a860cdd9359c36e977c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa51ec4e5f966a860cdd9359c36e977c6">&#9670;&#160;</a></span>backend_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add socket to poll set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance. </td></tr>
    <tr><td class="paramname">fd</td><td>File descriptor to monitor. </td></tr>
    <tr><td class="paramname">events</td><td>Events to monitor (bitmask of POLL_READ | POLL_WRITE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Validates fd parameter before backend operations. </dd>
<dd>
Socket automatically set to non-blocking mode by SocketPoll. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga72ef813749c8c54d8f8ccf64ba724a0a" title="Validate file descriptor parameter for backend operations.">VALIDATE_FD</a> for file descriptor validation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event type definitions. </dd>
<dd>
<a class="el" href="group__event__system.html#ga4b929e888a5088e59cd045c41759363e" title="Modify monitored events.">backend_mod()</a> for modifying events. </dd>
<dd>
<a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8" title="Remove socket from poll set.">backend_del()</a> for removal. </dd>
<dd>
<a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting. </dd></dl>

</div>
</div>
<a id="gae9ec719e250346605c00e5b3efb2e7d8" name="gae9ec719e250346605c00e5b3efb2e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ec719e250346605c00e5b3efb2e7d8">&#9670;&#160;</a></span>backend_del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove socket from poll set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance. </td></tr>
    <tr><td class="paramname">fd</td><td>File descriptor to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Should succeed silently if fd not in set (idempotent operation). </dd>
<dd>
Validates fd parameter before backend operations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga72ef813749c8c54d8f8ccf64ba724a0a" title="Validate file descriptor parameter for backend operations.">VALIDATE_FD</a> for file descriptor validation. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga4b929e888a5088e59cd045c41759363e" title="Modify monitored events.">backend_mod()</a> for modification. </dd></dl>

</div>
</div>
<a id="ga30a767499b3aa80b77e4fb63368be228" name="ga30a767499b3aa80b77e4fb63368be228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30a767499b3aa80b77e4fb63368be228">&#9670;&#160;</a></span>backend_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void backend_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close backend resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance (fd closed, memory freed by arena dispose). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only closes the backend file descriptor; memory allocations owned by arena. </dd>
<dd>
Safe to call multiple times (idempotent). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations.">Arena_dispose()</a> for complete cleanup including backend memory. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> for creation. </dd></dl>

</div>
</div>
<a id="gad998de1df9f46711f5c3b4dc0257f548" name="gad998de1df9f46711f5c3b4dc0257f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad998de1df9f46711f5c3b4dc0257f548">&#9670;&#160;</a></span>backend_get_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_get_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>events_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get event details for index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance (const - read-only access to events array). </td></tr>
    <tr><td class="paramname">index</td><td>Event index (0 to count-1 from backend_wait return value). </td></tr>
    <tr><td class="paramname">fd_out</td><td>Output parameter - file descriptor that triggered event. </td></tr>
    <tr><td class="paramname">events_out</td><td>Output parameter - events that occurred (POLL_READ | POLL_WRITE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on invalid index. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - Read-only access to backend's internal event array.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called repeatedly by SocketPoll to translate backend events to <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a>. </dd>
<dd>
Used in event translation pipeline: fd -&gt; events -&gt; <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting that populates the array. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event type definitions. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for translated event structure. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for complete event processing pipeline. </dd></dl>

</div>
</div>
<a id="ga4b929e888a5088e59cd045c41759363e" name="ga4b929e888a5088e59cd045c41759363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b929e888a5088e59cd045c41759363e">&#9670;&#160;</a></span>backend_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify monitored events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance. </td></tr>
    <tr><td class="paramname">fd</td><td>File descriptor to modify. </td></tr>
    <tr><td class="paramname">events</td><td>New events to monitor (bitmask of POLL_READ | POLL_WRITE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Validates fd parameter before backend operations. </dd>
<dd>
More efficient than remove/add sequence for backends that support it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga72ef813749c8c54d8f8ccf64ba724a0a" title="Validate file descriptor parameter for backend operations.">VALIDATE_FD</a> for file descriptor validation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event type definitions. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for initial registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8" title="Remove socket from poll set.">backend_del()</a> for removal. </dd></dl>

</div>
</div>
<a id="ga2edb00f128ad773d62c8f11c516153d9" name="ga2edb00f128ad773d62c8f11c516153d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2edb00f128ad773d62c8f11c516153d9">&#9670;&#160;</a></span>backend_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * backend_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get human-readable backend name for debugging and logging. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string identifying the backend ("epoll", "kqueue", or "poll"). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned string is compile-time constant and safe for repeated calls. </dd>
<dd>
Useful for logging backend-specific behavior and performance characteristics. </dd>
<dd>
Helps identify active backend for platform-specific issue diagnosis. </dd>
<dd>
Never NULL - always returns valid string for current backend. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> for compile-time backend selection logic. </dd>
<dd>
<a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for backend initialization during poll creation. </dd></dl>

</div>
</div>
<a id="gaa198b207e04b5bb6bec2746c7d86b735" name="gaa198b207e04b5bb6bec2746c7d86b735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa198b207e04b5bb6bec2746c7d86b735">&#9670;&#160;</a></span>backend_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxevents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend Interface - Abstract Polling Operations. </p>
<p>Defines the complete interface that all polling backend implementations must provide for consistent SocketPoll operations. Each backend abstracts a platform-specific polling mechanism while providing identical behavior.</p>
<p>Backend Selection and Priority:</p><ul>
<li>Linux kernel 2.6.8+: epoll (optimal performance, edge-triggered)</li>
<li>BSD/macOS systems: kqueue (optimal performance, edge-triggered)</li>
<li>POSIX-compliant systems: poll (portable fallback, level-triggered)</li>
<li>Selection occurs at compile-time via Makefile platform detection</li>
</ul>
<p>Interface Contract and Guarantees:</p><ul>
<li>Return Value: -1 on error (errno set) or 0 on success</li>
<li>Memory Management: All allocations use provided Arena_T</li>
<li>Thread Safety: Handled at SocketPoll layer (backends need not be thread-safe)</li>
<li>Event Format: All backends translate to SocketPoll_Events bitmask</li>
<li>Error Handling: POSIX errno values for consistent error reporting</li>
<li>Resource Cleanup: <a class="el" href="group__event__system.html#ga30a767499b3aa80b77e4fb63368be228" title="Close backend resources.">backend_free()</a> handles complete cleanup</li>
</ul>
<p>Implementation Requirements:</p><ul>
<li>Validate parameters using VALIDATE_FD and VALIDATE_MAXEVENTS macros</li>
<li>Handle EINTR gracefully (automatic restart not required)</li>
<li>Support all SocketPoll_Events (READ, WRITE, ERROR, HANGUP)</li>
<li>Provide <a class="el" href="group__event__system.html#ga2edb00f128ad773d62c8f11c516153d9" title="Get human-readable backend name for debugging and logging.">backend_name()</a> for debugging and logging</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Backend Interface - Abstract Polling Operations.">backend_new()</a> for backend instance creation. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for socket registration interface. </dd>
<dd>
<a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting and retrieval. </dd>
<dd>
<a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> for event details access. </dd>
<dd>
<a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b" title="Opaque type for platform-specific polling backend instances.">PollBackend_T</a> for backend instance type. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for standardized event type definitions. </dd>
<dd>
<a class="el" href="group__event__system.html#ga72ef813749c8c54d8f8ccf64ba724a0a" title="Validate file descriptor parameter for backend operations.">VALIDATE_FD</a> for parameter validation requirements. </dd>
<dd>
<a class="el" href="group__event__system.html#gad5c973c74b3941d078d573439e92c65b" title="Validate maxevents parameter with overflow protection.">VALIDATE_MAXEVENTS</a> for overflow protection requirements.</dd></dl>
<p>Create new backend instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arena</td><td>Arena for memory allocation (backend and events allocated here). </td></tr>
    <tr><td class="paramname">maxevents</td><td>Maximum events to return per wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Backend instance or NULL on failure (errno set). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>On failure, arena allocations are leaked but freed by caller arena dispose. </dd>
<dd>
Validates maxevents parameter for overflow protection. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gad5c973c74b3941d078d573439e92c65b" title="Validate maxevents parameter with overflow protection.">VALIDATE_MAXEVENTS</a> for parameter validation. </dd>
<dd>
<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> for memory management. </dd>
<dd>
<a class="el" href="group__event__system.html#ga30a767499b3aa80b77e4fb63368be228" title="Close backend resources.">backend_free()</a> for cleanup. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting. </dd></dl>

</div>
</div>
<a id="ga5b2c06638f0c76ea3c6c2f38503d266b" name="ga5b2c06638f0c76ea3c6c2f38503d266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b2c06638f0c76ea3c6c2f38503d266b">&#9670;&#160;</a></span>backend_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance (modifies internal events array for output). </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (-1 for infinite, 0 for immediate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events ready (&gt;= 0), or -1 on error (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns 0 on timeout, EINTR (signal interrupt), or immediate return. </dd>
<dd>
Internal event array updated for <a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> retrieval. </dd>
<dd>
Thread-safe: Assumes single-threaded access via SocketPoll mutex. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> for retrieving event details. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Add socket to poll set.">backend_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for public interface that calls this. </dd></dl>

</div>
</div>
<a id="ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" name="ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">&#9670;&#160;</a></span>SocketPoll_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a socket for event monitoring in the poll set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance to register with. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket_T to monitor for I/O events. </td></tr>
    <tr><td class="paramname">events</td><td>Bitmask of events (POLL_READ | POLL_WRITE | etc.). </td></tr>
    <tr><td class="paramname">data</td><td>Opaque user data pointer associated with this socket (retrieved in events). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic registration with mutex protection.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically configures socket to non-blocking mode if not already set. </dd>
<dd>
POLL_ERROR and POLL_HANGUP are always implicitly monitored. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if socket already registered, invalid fd, or backend registration fails (e.g., EMFILE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Respects <a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb" title="Set maximum registered sockets limit.">SocketPoll_setmaxregistered()</a> limit; raises if exceeded.</dd></dl>
<p>User data is stored internally and returned unchanged in <a class="el" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">SocketEvent_T.data</a> during notifications.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> to update events or data for existing registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from event monitoring.">SocketPoll_del()</a> to deregister a socket. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> to receive events for registered sockets. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event bitmask definitions. </dd>
<dd>
<a class="el" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4" title="Enable non-blocking mode.">Socket_setnonblocking()</a> for manual non-blocking configuration. </dd>
<dd>
core_io::Socket_T for socket lifecycle management. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga3074c5a225a7c49880951ecfb984498f" name="ga3074c5a225a7c49880951ecfb984498f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3074c5a225a7c49880951ecfb984498f">&#9670;&#160;</a></span>SocketPoll_del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregister a socket from event monitoring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket to deregister (no-op if not registered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - mutex-protected removal from internal mappings.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Idempotent: safe to call multiple times or on unregistered sockets. </dd>
<dd>
On transient backend errors, cleans local state for consistency. </dd>
<dd>
Logs warnings for inconsistent state (e.g., backend already removed). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>on persistent backend errors (rare, e.g., EBADF).</td></tr>
  </table>
  </dd>
</dl>
<p>Call during connection cleanup or error recovery to free poll resources. Does not close the socket fd; user must manage socket lifecycle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> and <a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for registration/modification. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> to track active registrations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Free a socket and close the connection.">Socket_free()</a> for full socket disposal after deregistration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for pool-based connection cleanup patterns. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="gaca744c50badbdb869c52088b9f32f8d2" name="gaca744c50badbdb869c52088b9f32f8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca744c50badbdb869c52088b9f32f8d2">&#9670;&#160;</a></span>SocketPoll_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> *&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispose of an event poll instance and release resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Pointer to poll instance (set to NULL on success). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - safe from any thread.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Closes underlying backend file descriptor (epoll fd, kqueue, or poll structures). </dd>
<dd>
Automatically deregisters and closes all tracked sockets if configured. </dd>
<dd>
Releases internal mappings, timers, and arena-allocated memory. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure no concurrent <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> or registrations are active.</dd></dl>
<p>Always pair with <a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> and call before program exit to avoid leaks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for instance creation. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> to verify cleanup (should be 0 post-free). </dd>
<dd>
foundation::Arena_dispose() for managing the arena used by poll. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md for arena lifecycle best practices. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga665b3363d16ab859ec60e69a792d1ff0" name="ga665b3363d16ab859ec60e69a792d1ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665b3363d16ab859ec60e69a792d1ff0">&#9670;&#160;</a></span>SocketPoll_get_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__async__io.html#structSocketAsync__T">SocketAsync_T</a> SocketPoll_get_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get async I/O context associated with poll instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Async context or NULL if unavailable. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns NULL if async I/O is not available on this platform. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__async__io.html#structSocketAsync__T" title="Opaque structure representing the asynchronous I/O context.">SocketAsync_T</a> for async I/O operations. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for automatic async completion processing. </dd></dl>

</div>
</div>
<a id="gaf791d7d3363309127dbdd94e4181b8c3" name="gaf791d7d3363309127dbdd94e4181b8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf791d7d3363309127dbdd94e4181b8c3">&#9670;&#160;</a></span>socketpoll_get_timer_heap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> * socketpoll_get_timer_heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access timer heap for internal SocketTimer integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer heap pointer or NULL if not available. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - Internal use only, assumes caller holds poll mutex.</dt><dd></dd></dl>
<p>Provides access to the internal timer heap used for SocketTimer integration. The timer heap manages all active timers with efficient O(log n) operations for insertion, deletion, and timeout processing.</p>
<dl class="section note"><dt>Note</dt><dd>Used by SocketTimer module for timer heap integration. </dd>
<dd>
Returns NULL if timer heap not initialized (timer integration disabled). </dd>
<dd>
Caller must hold poll instance mutex before calling. </dd>
<dd>
Timer heap is automatically processed during <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> calls.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T" title="Typedef for the internal timer heap structure.">SocketTimer_heap_T</a> for timer heap structure definition. </dd>
<dd>
<a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> for public timer creation interface. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for automatic timer processing during event waits. </dd>
<dd>
<a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T" title="Typedef for the internal timer heap structure.">SocketTimer_heap_T</a> for complete timer heap documentation. </dd>
<dd>
<a class="el" href="SocketTimer-private_8h.html" title="Internal timer implementation details and heap management.">SocketTimer-private.h</a> for timer heap internal details. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for timer heap memory management patterns. </dd></dl>

</div>
</div>
<a id="ga1bb5e288308c3de5a479b27366bba257" name="ga1bb5e288308c3de5a479b27366bba257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bb5e288308c3de5a479b27366bba257">&#9670;&#160;</a></span>SocketPoll_getdefaulttimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getdefaulttimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default wait timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Default timeout in milliseconds. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for setting the timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for how the default timeout is used. </dd></dl>

</div>
</div>
<a id="ga16688a9e444183863bab8051f57fe688" name="ga16688a9e444183863bab8051f57fe688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16688a9e444183863bab8051f57fe688">&#9670;&#160;</a></span>SocketPoll_getmaxregistered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getmaxregistered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum registered sockets limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum limit (0 = unlimited). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defense-in-depth: Returns the configured limit on socket registrations. </dd>
<dd>
Compile-time default is SOCKET_POLL_MAX_REGISTERED (0 = disabled). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb" title="Set maximum registered sockets limit.">SocketPoll_setmaxregistered()</a> for setting the limit. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> for current count. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for socket registration that respects limits. </dd></dl>

</div>
</div>
<a id="gac79e719de24f09f84eb3816b3ab60c65" name="gac79e719de24f09f84eb3816b3ab60c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79e719de24f09f84eb3816b3ab60c65">&#9670;&#160;</a></span>SocketPoll_getregisteredcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getregisteredcount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current registered socket count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of currently registered sockets. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688" title="Get maximum registered sockets limit.">SocketPoll_getmaxregistered()</a> for the maximum allowed. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for registering sockets. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from event monitoring.">SocketPoll_del()</a> for removing sockets. </dd></dl>

</div>
</div>
<a id="ga3755cc4d5ed8838ce2261f0efd1d5d85" name="ga3755cc4d5ed8838ce2261f0efd1d5d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3755cc4d5ed8838ce2261f0efd1d5d85">&#9670;&#160;</a></span>SocketPoll_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_mod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update event monitoring and/or user data for a registered socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Registered socket to modify. </td></tr>
    <tr><td class="paramname">events</td><td>Updated event bitmask to monitor (can change from previous). </td></tr>
    <tr><td class="paramname">data</td><td>Updated user data pointer (replaces previous association). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic update protecting against concurrent access.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if socket not registered or backend modification fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to del + add internally on some backends (e.g., kqueue). </dd>
<dd>
Does not change socket's non-blocking state.</dd></dl>
<p>Use to dynamically adjust monitoring (e.g., enable write after connect success).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for initial socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from event monitoring.">SocketPoll_del()</a> for complete deregistration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event bitmask options. </dd>
<dd>
<a class="el" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">SocketEvent_T::data</a> for how user data is delivered in events. </dd></dl>

</div>
</div>
<a id="gac1fbd1a09d564f7988b0e427e5707ca7" name="gac1fbd1a09d564f7988b0e427e5707ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1fbd1a09d564f7988b0e427e5707ca7">&#9670;&#160;</a></span>SocketPoll_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a> SocketPoll_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxevents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new event poll instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxevents</td><td>Maximum number of events to process per wait call (suggest 1024+ for servers). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if backend initialization fails (e.g., resource limits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - each instance is independent.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically selects and initializes platform-optimal backend (epoll/kqueue/poll) with edge-triggered mode where supported. </dd>
<dd>
Allocates an internal arena for efficient memory management tied to poll lifecycle. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2" title="Dispose of an event poll instance and release resources.">SocketPoll_free()</a> for resource cleanup. </dd>
<dd>
<a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb" title="Set maximum registered sockets limit.">SocketPoll_setmaxregistered()</a> for configuring registration limits. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for primary event loop integration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for adding sockets to monitor. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System</a> for complete module overview. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga945845cc57758a91e47a75ef17064d2a" name="ga945845cc57758a91e47a75ef17064d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945845cc57758a91e47a75ef17064d2a">&#9670;&#160;</a></span>SocketPoll_setdefaulttimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_setdefaulttimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set default wait timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds (0 = immediate, -1 = infinite). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for retrieving the current timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> for how the default timeout is used. </dd></dl>

</div>
</div>
<a id="ga35d4052d444bcab4cae26f41cf5729eb" name="ga35d4052d444bcab4cae26f41cf5729eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35d4052d444bcab4cae26f41cf5729eb">&#9670;&#160;</a></span>SocketPoll_setmaxregistered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_setmaxregistered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum registered sockets limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">max</td><td>Maximum limit (0 = unlimited). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if max &lt; registered_count and max &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defense-in-depth: Limits the number of sockets that can be registered to prevent resource exhaustion attacks. </dd>
<dd>
Set to 0 to disable limit. </dd>
<dd>
Cannot set limit below current registered_count. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688" title="Get maximum registered sockets limit.">SocketPoll_getmaxregistered()</a> for retrieving the current limit. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> for current count. </dd></dl>

</div>
</div>
<a id="gaa3d47365dd18329d50ee636284839738" name="gaa3d47365dd18329d50ee636284839738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d47365dd18329d50ee636284839738">&#9670;&#160;</a></span>SocketPoll_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> **&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for I/O events on registered sockets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">events</td><td>Output - array of events that occurred. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds (-1 for infinite, 0 for immediate, SOCKET_POLL_TIMEOUT_USE_DEFAULT for poll's default timeout). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events (0 on timeout). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - event array is thread-local to poll instance.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The events array points to internal memory - do not free. </dd>
<dd>
Also processes async I/O completions automatically. </dd>
<dd>
Use SOCKET_POLL_TIMEOUT_USE_DEFAULT for consistent timeout behavior. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for event monitoring in the poll set.">SocketPoll_add()</a> for registering sockets to monitor. </dd>
<dd>
<a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for default timeout configuration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for setting default timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e" title="Special timeout value to use the poll&#39;s default timeout.">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a> for special timeout constant. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure details. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__async__io.html#structSocketAsync__T" title="Opaque structure representing the asynchronous I/O context.">SocketAsync_T</a> for async I/O integration. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga2537cebf106e583079ec472086a26d65" name="ga2537cebf106e583079ec472086a26d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2537cebf106e583079ec472086a26d65">&#9670;&#160;</a></span>SocketTimer_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> SocketTimer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a one-shot timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Event poll instance to associate timer with. </td></tr>
    <tr><td class="paramname">delay_ms</td><td>Delay in milliseconds (must be &gt;= 0). </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when timer expires. </td></tr>
    <tr><td class="paramname">userdata</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer handle for cancellation and management. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>on invalid parameters (e.g., delay_ms &lt; 0, null callback or poll), memory allocation failure, or internal heap error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timer fires once after delay_ms milliseconds. Callbacks execute during <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Wait for I/O events on registered sockets.">SocketPoll_wait()</a> in the calling thread. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating timer.">SocketTimer_add_repeating()</a> for repeating timers. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> for cancellation. </dd></dl>

</div>
</div>
<a id="ga6961bde0e491d732450b66577294d097" name="ga6961bde0e491d732450b66577294d097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6961bde0e491d732450b66577294d097">&#9670;&#160;</a></span>SocketTimer_add_repeating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> SocketTimer_add_repeating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a repeating timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Event poll instance to associate timer with. </td></tr>
    <tr><td class="paramname">interval_ms</td><td>Interval in milliseconds between firings (must be &gt;= 1). </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call when timer expires. </td></tr>
    <tr><td class="paramname">userdata</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer handle for cancellation and management. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>on invalid parameters (e.g., interval_ms &lt; 1, null callback or poll), memory allocation failure, or internal heap error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timer fires repeatedly every interval_ms milliseconds. First firing occurs after interval_ms milliseconds. </dd>
<dd>
Use <a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> to stop. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> for one-shot timers. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> for cancellation. </dd></dl>

</div>
</div>
<a id="ga6f7ca05c6cfc7c69ddc3d676a681bc62" name="ga6f7ca05c6cfc7c69ddc3d676a681bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7ca05c6cfc7c69ddc3d676a681bc62">&#9670;&#160;</a></span>SocketTimer_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Event poll instance timer is associated with. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer handle to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (pending timer was cancelled), -1 if timer invalid, already fired/cancelled, poll heap unavailable, or poll/timer mismatch. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not raise exceptions; all failure modes return -1 (non-blocking). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Safe to call on already-fired or cancelled timers. </dd>
<dd>
Do not call from within a timer callback function. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> for creating timers. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating timer.">SocketTimer_add_repeating()</a> for repeating timers. </dd></dl>

</div>
</div>
<a id="ga8af1dd7cd2864bea6226054f1ff9b22b" name="ga8af1dd7cd2864bea6226054f1ff9b22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af1dd7cd2864bea6226054f1ff9b22b">&#9670;&#160;</a></span>SocketTimer_heap_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_heap_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark timer as cancelled (lazy deletion). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if timer not found. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(1) time complexity using maintained heap_index field. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga3257343cc10ae56314c03abd8311d873" name="ga3257343cc10ae56314c03abd8311d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3257343cc10ae56314c03abd8311d873">&#9670;&#160;</a></span>SocketTimer_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketTimer_heap_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> **&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free timer heap structure and destroy mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Heap to free (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No (caller must ensure no concurrent access).</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Frees the heap control structure and destroys the mutex. Timers and timers array must be freed via Arena_dispose(arena). Arena lifetime managed by caller. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a" title="Create a new timer heap.">SocketTimer_heap_new()</a> for creation. </dd></dl>

</div>
</div>
<a id="ga18f3d33b3f70cc8620fef042ca65e66a" name="ga18f3d33b3f70cc8620fef042ca65e66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f3d33b3f70cc8620fef042ca65e66a">&#9670;&#160;</a></span>SocketTimer_heap_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> * SocketTimer_heap_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new timer heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arena</td><td>Arena to allocate from (NULL for malloc fallback). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New heap instance or NULL on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>if memory allocation fails or mutex initialization fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - heap mutex not yet usable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873" title="Free timer heap structure and destroy mutex.">SocketTimer_heap_free()</a> for cleanup. </dd>
<dd>
<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> for arena usage details. </dd></dl>

</div>
</div>
<a id="ga0961e214a845a52c242176ed425095a3" name="ga0961e214a845a52c242176ed425095a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0961e214a845a52c242176ed425095a3">&#9670;&#160;</a></span>SocketTimer_heap_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> * SocketTimer_heap_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get earliest timer without removing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Earliest timer or NULL if heap empty. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> for removal. </dd></dl>

</div>
</div>
<a id="ga0f7deeb47aba9580052152bbf036c419" name="ga0f7deeb47aba9580052152bbf036c419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7deeb47aba9580052152bbf036c419">&#9670;&#160;</a></span>SocketTimer_heap_peek_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_heap_peek_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get milliseconds until next timer expiry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until next timer (&gt;= 0), or -1 if no timers. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> to fire expired timers. </dd></dl>

</div>
</div>
<a id="ga9e40363cf44bb1025f2269ddc2cef0d2" name="ga9e40363cf44bb1025f2269ddc2cef0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e40363cf44bb1025f2269ddc2cef0d2">&#9670;&#160;</a></span>SocketTimer_heap_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> * SocketTimer_heap_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return earliest timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Earliest timer or NULL if heap empty. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga04afe41789d51a71d4a03883a89ad61c" name="ga04afe41789d51a71d4a03883a89ad61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04afe41789d51a71d4a03883a89ad61c">&#9670;&#160;</a></span>SocketTimer_heap_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketTimer_heap_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add timer to heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to add (takes ownership). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> for removal. </dd></dl>

</div>
</div>
<a id="ga69365f1c685576d76414fbb43fe2248b" name="ga69365f1c685576d76414fbb43fe2248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69365f1c685576d76414fbb43fe2248b">&#9670;&#160;</a></span>SocketTimer_heap_remaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_heap_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get milliseconds until timer expiry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until expiry (&gt;= 0), or -1 if timer not found/cancelled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(1) time complexity using maintained heap_index field. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga888ed4acbf5d1ca29bdafc07f346566e" name="ga888ed4acbf5d1ca29bdafc07f346566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga888ed4acbf5d1ca29bdafc07f346566e">&#9670;&#160;</a></span>SocketTimer_process_expired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_process_expired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fire all expired timers and return count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of timers that fired. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callbacks are invoked outside the mutex to prevent deadlocks. Repeating timers are rescheduled after firing. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419" title="Get milliseconds until next timer expiry.">SocketTimer_heap_peek_delay()</a> to check for expired timers. </dd></dl>

</div>
</div>
<a id="ga4c5519b89e0bba69f26d03b6893ba779" name="ga4c5519b89e0bba69f26d03b6893ba779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5519b89e0bba69f26d03b6893ba779">&#9670;&#160;</a></span>SocketTimer_remaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketTimer-private_8h.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get milliseconds until timer expiry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Event poll instance timer is associated with. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer handle to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds remaining until expiry (&gt;= 0 even if overdue), -1 if timer invalid, fired/cancelled, poll heap unavailable, or poll/timer mismatch. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not raise exceptions; all failure modes return -1 (non-blocking). Returns approximate value based on monotonic clock. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns 0 if timer has already expired but not yet fired. </dd>
<dd>
Useful for debugging and implementing timeout logic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a> for creating timers. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> for checking timer state. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab4754362476e3ffc3e000b1cbcc2a6f0" name="gab4754362476e3ffc3e000b1cbcc2a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4754362476e3ffc3e000b1cbcc2a6f0">&#9670;&#160;</a></span>SocketPoll_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketPoll_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketPoll operation failure exception. </p>
<p>Raised for various poll operation failures including backend creation, invalid socket operations, and resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#ga4b19847d604cdc5896376e694ee2a9c1" title="SocketError_categorize_errno - Classify errno into SocketErrorCategory.">SocketError_categorize_errno()</a> for error categorization. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163" title="SocketError_is_retryable_errno - Check if errno indicates retryable error.">SocketError_is_retryable_errno()</a> for retryability checking. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga2f0acf311c238671c6d9d14d4cc7c158" name="ga2f0acf311c238671c6d9d14d4cc7c158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0acf311c238671c6d9d14d4cc7c158">&#9670;&#160;</a></span>SocketTimer_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketTimer_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer subsystem operation failure. </p>
<p>Generic exception for all timer-related errors, including allocation failures, invalid timer handles, heap operations, parameter validation, and internal state inconsistencies.</p>
<p>Specific error details available via <a class="el" href="group__foundation.html#ga46f8d730d28e8c5cbd55e3cbe4c83945" title="Socket_geterrorcode - Convert last errno to normalized SocketErrorCode.">Socket_geterrorcode()</a> or errno after catch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer.">SocketTimer_add()</a>, <a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating timer.">SocketTimer_add_repeating()</a> - creation failures (e.g., invalid delay, memory) </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer.">SocketTimer_cancel()</a> - invalid handle or race conditions </dd>
<dd>
<a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779" title="Get milliseconds until timer expiry.">SocketTimer_remaining()</a> - invalid timer or computation errors </dd>
<dd>
<a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> for structured exception handling </dd>
<dd>
<a class="el" href="group__foundation.html#ga4b19847d604cdc5896376e694ee2a9c1" title="SocketError_categorize_errno - Classify errno into SocketErrorCategory.">SocketError_categorize_errno()</a> for classifying underlying system errors </dd>
<dd>
docs/ERROR_HANDLING.md for best practices on handling library exceptions </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/>
<footer class="footer">
  <div style="max-width: 960px; margin: 0 auto; padding: 40px 24px;">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 40px;">
      <!-- Brand -->
      <div style="flex: 1; min-width: 200px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); border-radius: 6px;"></div>
          <span style="font-size: 1rem; font-weight: 600; color: #f7f9fa;">Socket Library</span>
        </div>
        <p style="color: #8b98a5; font-size: 0.8125rem; line-height: 1.6; margin: 0;">
          High-performance socket toolkit for POSIX systems with exception-based error handling and TLS 1.3 support.
        </p>
      </div>
      <!-- Links -->
      <div style="display: flex; gap: 48px; flex-wrap: wrap;">
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Documentation</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="index.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Getting Started</a></li>
            <li style="margin: 6px 0;"><a href="annotated.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Data Structures</a></li>
            <li style="margin: 6px 0;"><a href="globals.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">API Reference</a></li>
          </ul>
        </div>
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Resources</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="files.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Header Files</a></li>
            <li style="margin: 6px 0;"><a href="https://x.com/tetsuocorp" target="_blank" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Twitter/X</a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Bottom -->
    <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 0.75rem; font-weight: 500; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 4px 8px; border-radius: 4px;">C11</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 4px 8px; border-radius: 4px;">POSIX</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #8b5cf6; background: rgba(139, 92, 246, 0.1); padding: 4px 8px; border-radius: 4px;">TLS 1.3</span>
      </div>
      <div style="color: #6e7681; font-size: 0.75rem; display: flex; align-items: center; gap: 8px;">
        <span> 2025 Tetsuo Corporation</span>
        <span style="color: #30363d;"></span>
        <a href="https://opensource.org/licenses/MIT" target="_blank" style="color: #8b98a5; text-decoration: none;">MIT License</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
