<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="High-performance, exception-driven socket toolkit for POSIX systems">
<meta name="keywords" content="socket, networking, C, POSIX, TCP, UDP, TLS, async, high-performance, library">
<meta name="author" content="Tetsuo Corporation">
<meta name="theme-color" content="#3b82f6">
<title>Event System Modules</title>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' stop-color='%233b82f6'/><stop offset='100%25' stop-color='%238b5cf6'/></linearGradient></defs><rect width='100' height='100' rx='20' fill='url(%23g)'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='bold'>S</text></svg>">
</head>
<body>
<div id="top">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">1.0.0</span></div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
  <td style="text-align: right; padding: 20px; vertical-align: middle;">
    <div style="display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; align-items: center;">
      <a href="index.html" class="quick-link">Home</a>
      <a href="annotated.html" class="quick-link">Structures</a>
      <a href="files.html" class="quick-link">Files</a>
      <a href="globals.html" class="quick-link">API</a>
    </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__event__system.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Event System Modules</div></div>
</div><!--header-->
<div class="contents">

<p>High-performance I/O multiplexing with cross-platform backends.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Event System Modules:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__event__system.svg" width="476" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__poll__private" id="r_group__poll__private"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__poll__private.html">SocketPoll Private Implementation Details</a></td></tr>
<tr class="memdesc:group__poll__private"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structures and utilities for cross-platform event polling. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__event__system__backend" id="r_group__event__system__backend"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system__backend.html">Polling Backend Interface</a></td></tr>
<tr class="memdesc:group__event__system__backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal platform abstraction for efficient I/O event multiplexing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketTimer-private_8h" id="r_SocketTimer-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketTimer-private_8h.html">SocketTimer-private.h</a></td></tr>
<tr class="memdesc:SocketTimer-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation details for the high-performance SocketTimer module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketTimer_8h" id="r_SocketTimer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketTimer_8h.html">SocketTimer.h</a></td></tr>
<tr class="memdesc:SocketTimer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance timer subsystem integrated with the event loop. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketPoll_8h" id="r_SocketPoll_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPoll_8h.html">SocketPoll.h</a></td></tr>
<tr class="memdesc:SocketPoll_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform high-level interface for monitoring multiple sockets for I/O events. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketTimer__T" id="r_structSocketTimer__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a></td></tr>
<tr class="memdesc:structSocketTimer__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal representation of a single scheduled timer event.  <a href="group__event__system.html#structSocketTimer__T">More...</a><br /></td></tr>
<tr class="separator:structSocketTimer__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketTimer__heap__T" id="r_structSocketTimer__heap__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a></td></tr>
<tr class="memdesc:structSocketTimer__heap__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary min-heap container for managing multiple <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> instances.  <a href="group__event__system.html#structSocketTimer__heap__T">More...</a><br /></td></tr>
<tr class="separator:structSocketTimer__heap__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketEvent__T" id="r_structSocketEvent__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a></td></tr>
<tr class="memdesc:structSocketEvent__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event notification structure returned by polling operations.  <a href="group__event__system.html#structSocketEvent__T">More...</a><br /></td></tr>
<tr class="separator:structSocketEvent__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab6d7f45fcb5eae5fe42694e8e123cab4" id="r_gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab6d7f45fcb5eae5fe42694e8e123cab4">SOCKET_MAX_POLL_EVENTS</a>&#160;&#160;&#160;10000</td></tr>
<tr class="memdesc:gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum events per poll iteration.  <br /></td></tr>
<tr class="separator:gab6d7f45fcb5eae5fe42694e8e123cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673275383493d8cff8bc582fef311e42" id="r_ga673275383493d8cff8bc582fef311e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga673275383493d8cff8bc582fef311e42">POLL_INITIAL_FDS</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga673275383493d8cff8bc582fef311e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial file descriptor capacity for poll backend.  <br /></td></tr>
<tr class="separator:ga673275383493d8cff8bc582fef311e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211a6387523fa6487af971831aabf461" id="r_ga211a6387523fa6487af971831aabf461"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga211a6387523fa6487af971831aabf461">POLL_INITIAL_FD_MAP_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga211a6387523fa6487af971831aabf461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial file descriptor map size.  <br /></td></tr>
<tr class="separator:ga211a6387523fa6487af971831aabf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834e79d67b92d737d55e4ba2b0684025" id="r_ga834e79d67b92d737d55e4ba2b0684025"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga834e79d67b92d737d55e4ba2b0684025">POLL_FD_MAP_EXPAND_INCREMENT</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga834e79d67b92d737d55e4ba2b0684025"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor map expansion increment.  <br /></td></tr>
<tr class="separator:ga834e79d67b92d737d55e4ba2b0684025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad738dd2be8abca1d0353d31f888ba3eb" id="r_gad738dd2be8abca1d0353d31f888ba3eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gad738dd2be8abca1d0353d31f888ba3eb">SOCKET_MAX_TIMER_TIMEOUT_MS</a>&#160;&#160;&#160;300000</td></tr>
<tr class="memdesc:gad738dd2be8abca1d0353d31f888ba3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum timer timeout to prevent indefinite blocking.  <br /></td></tr>
<tr class="separator:gad738dd2be8abca1d0353d31f888ba3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5492f9166c78ee14f4b69362ccaf51" id="r_ga7f5492f9166c78ee14f4b69362ccaf51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga7f5492f9166c78ee14f4b69362ccaf51">SOCKET_MAX_TIMER_DELAY_MS</a>&#160;&#160;&#160;(INT64_C (31536000000)) /* 365 days */</td></tr>
<tr class="memdesc:ga7f5492f9166c78ee14f4b69362ccaf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed delay or interval for individual timers.  <br /></td></tr>
<tr class="separator:ga7f5492f9166c78ee14f4b69362ccaf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56cfec8835c59bfb69bb1c1cb128c93" id="r_gab56cfec8835c59bfb69bb1c1cb128c93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab56cfec8835c59bfb69bb1c1cb128c93">SOCKET_TIMER_ERROR_BUFSIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gab56cfec8835c59bfb69bb1c1cb128c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer error buffer size for detailed error messages.  <br /></td></tr>
<tr class="separator:gab56cfec8835c59bfb69bb1c1cb128c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115b76003aaf131241e5b091a63b3285" id="r_ga115b76003aaf131241e5b091a63b3285"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga115b76003aaf131241e5b091a63b3285">SOCKET_TIMER_HEAP_INITIAL_CAPACITY</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga115b76003aaf131241e5b091a63b3285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial capacity for timer heap array.  <br /></td></tr>
<tr class="separator:ga115b76003aaf131241e5b091a63b3285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5f033531acb4f68ba5823ce2b769d7" id="r_gaca5f033531acb4f68ba5823ce2b769d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaca5f033531acb4f68ba5823ce2b769d7">SOCKET_TIMER_HEAP_GROWTH_FACTOR</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaca5f033531acb4f68ba5823ce2b769d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth factor when resizing timer heap.  <br /></td></tr>
<tr class="separator:gaca5f033531acb4f68ba5823ce2b769d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53de6720fd3fc8accf99751c1e4e0d50" id="r_ga53de6720fd3fc8accf99751c1e4e0d50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga53de6720fd3fc8accf99751c1e4e0d50">SOCKET_MAX_TIMERS_PER_HEAP</a>&#160;&#160;&#160;100000</td></tr>
<tr class="memdesc:ga53de6720fd3fc8accf99751c1e4e0d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of timers per heap.  <br /></td></tr>
<tr class="separator:ga53de6720fd3fc8accf99751c1e4e0d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ced17c77c552330176b69557fb83fc" id="r_gab0ced17c77c552330176b69557fb83fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab0ced17c77c552330176b69557fb83fc">SOCKET_TIMER_MIN_DELAY_MS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gab0ced17c77c552330176b69557fb83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum delay for one-shot timers.  <br /></td></tr>
<tr class="separator:gab0ced17c77c552330176b69557fb83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59221d1781370448def350dafb2d7e24" id="r_ga59221d1781370448def350dafb2d7e24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga59221d1781370448def350dafb2d7e24">SOCKET_TIMER_MIN_INTERVAL_MS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga59221d1781370448def350dafb2d7e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum interval for repeating timers.  <br /></td></tr>
<tr class="separator:ga59221d1781370448def350dafb2d7e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3100d409a6fd3f6d160700ba6c64c6" id="r_gacd3100d409a6fd3f6d160700ba6c64c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gacd3100d409a6fd3f6d160700ba6c64c6">SOCKET_TIMER_INITIAL_ID</a>&#160;&#160;&#160;1ULL</td></tr>
<tr class="memdesc:gacd3100d409a6fd3f6d160700ba6c64c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial timer ID value.  <br /></td></tr>
<tr class="separator:gacd3100d409a6fd3f6d160700ba6c64c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ac815951cb4cbc800c781eb143b8cb" id="r_ga76ac815951cb4cbc800c781eb143b8cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga76ac815951cb4cbc800c781eb143b8cb">SOCKET_EVENT_MAX_HANDLERS</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga76ac815951cb4cbc800c781eb143b8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of event handlers that can be registered.  <br /></td></tr>
<tr class="separator:ga76ac815951cb4cbc800c781eb143b8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cb10d1eefc15616a20bcd7ae21e875" id="r_ga71cb10d1eefc15616a20bcd7ae21e875"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga71cb10d1eefc15616a20bcd7ae21e875">SOCKET_DEFAULT_POLL_TIMEOUT</a>&#160;&#160;&#160;1000 /* 1 second */</td></tr>
<tr class="memdesc:ga71cb10d1eefc15616a20bcd7ae21e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default poll timeout.  <br /></td></tr>
<tr class="separator:ga71cb10d1eefc15616a20bcd7ae21e875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2829aac1405cdf86f8ef8b6eb3ecf365" id="r_ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2829aac1405cdf86f8ef8b6eb3ecf365">SOCKET_TIMER_INVALID_HEAP_INDEX</a>&#160;&#160;&#160;((size_t) - 1)</td></tr>
<tr class="memdesc:ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value indicating that a timer is not currently in the heap.  <br /></td></tr>
<tr class="separator:ga2829aac1405cdf86f8ef8b6eb3ecf365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque pointer to a timer instance.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0e59971e52bc0a110b2a7066ea2732" id="r_ga7c0e59971e52bc0a110b2a7066ea2732"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga7c0e59971e52bc0a110b2a7066ea2732">SOCKET_DATA_HASH_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td></tr>
<tr class="memdesc:ga7c0e59971e52bc0a110b2a7066ea2732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constant for hash table capacity in socket mappings.  <br /></td></tr>
<tr class="separator:ga7c0e59971e52bc0a110b2a7066ea2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f5cf0f097a98b03e1511d1b6bd91b2" id="r_ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a>(e)&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (SocketPoll, e)</td></tr>
<tr class="memdesc:ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module-specific exception raising macro for SocketPoll errors.  <br /></td></tr>
<tr class="separator:ga55f5cf0f097a98b03e1511d1b6bd91b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;SocketPoll_T</td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance socket polling abstraction with cross-platform backends.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc8aa94a3e9bb10cb26d85c6474d04e" id="r_ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special timeout value to use the poll's default timeout.  <br /></td></tr>
<tr class="separator:ga0fc8aa94a3e9bb10cb26d85c6474d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafb51f69cdbf1b882a7a4226959c4fca7" id="r_gafb51f69cdbf1b882a7a4226959c4fca7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>) (void *userdata)</td></tr>
<tr class="memdesc:gafb51f69cdbf1b882a7a4226959c4fca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for timer expiration callback functions.  <br /></td></tr>
<tr class="separator:gafb51f69cdbf1b882a7a4226959c4fca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9e8943c9cb47aba63dda4ad9083142b6" id="r_ga9e8943c9cb47aba63dda4ad9083142b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">SocketPoll_Events</a> { <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a> = 1 &lt;&lt; 0
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a> = 1 &lt;&lt; 1
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9">POLL_ERROR</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c">POLL_HANGUP</a> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:ga9e8943c9cb47aba63dda4ad9083142b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event types for socket I/O monitoring.  <a href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">More...</a><br /></td></tr>
<tr class="separator:ga9e8943c9cb47aba63dda4ad9083142b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18f3d33b3f70cc8620fef042ca65e66a" id="r_ga18f3d33b3f70cc8620fef042ca65e66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena)</td></tr>
<tr class="memdesc:ga18f3d33b3f70cc8620fef042ca65e66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new timer heap instance.  <br /></td></tr>
<tr class="separator:ga18f3d33b3f70cc8620fef042ca65e66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3257343cc10ae56314c03abd8311d873" id="r_ga3257343cc10ae56314c03abd8311d873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> **heap)</td></tr>
<tr class="memdesc:ga3257343cc10ae56314c03abd8311d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize and nullify timer heap handle: destroy mutex only.  <br /></td></tr>
<tr class="separator:ga3257343cc10ae56314c03abd8311d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04afe41789d51a71d4a03883a89ad61c" id="r_ga04afe41789d51a71d4a03883a89ad61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c">SocketTimer_heap_push</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga04afe41789d51a71d4a03883a89ad61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add timer to heap.  <br /></td></tr>
<tr class="separator:ga04afe41789d51a71d4a03883a89ad61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e40363cf44bb1025f2269ddc2cef0d2" id="r_ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2">SocketTimer_heap_pop</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return earliest timer.  <br /></td></tr>
<tr class="separator:ga9e40363cf44bb1025f2269ddc2cef0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0961e214a845a52c242176ed425095a3" id="r_ga0961e214a845a52c242176ed425095a3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0961e214a845a52c242176ed425095a3">SocketTimer_heap_peek</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga0961e214a845a52c242176ed425095a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get earliest timer without removing.  <br /></td></tr>
<tr class="separator:ga0961e214a845a52c242176ed425095a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7deeb47aba9580052152bbf036c419" id="r_ga0f7deeb47aba9580052152bbf036c419"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419">SocketTimer_heap_peek_delay</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga0f7deeb47aba9580052152bbf036c419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get milliseconds until next timer expiry.  <br /></td></tr>
<tr class="separator:ga0f7deeb47aba9580052152bbf036c419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga888ed4acbf5d1ca29bdafc07f346566e" id="r_ga888ed4acbf5d1ca29bdafc07f346566e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e">SocketTimer_process_expired</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap)</td></tr>
<tr class="memdesc:ga888ed4acbf5d1ca29bdafc07f346566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fire all expired timers and return count.  <br /></td></tr>
<tr class="separator:ga888ed4acbf5d1ca29bdafc07f346566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af1dd7cd2864bea6226054f1ff9b22b" id="r_ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga8af1dd7cd2864bea6226054f1ff9b22b">SocketTimer_heap_cancel</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark timer as cancelled (lazy deletion).  <br /></td></tr>
<tr class="separator:ga8af1dd7cd2864bea6226054f1ff9b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69365f1c685576d76414fbb43fe2248b" id="r_ga69365f1c685576d76414fbb43fe2248b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga69365f1c685576d76414fbb43fe2248b">SocketTimer_heap_remaining</a> (<a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap, const struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *timer)</td></tr>
<tr class="memdesc:ga69365f1c685576d76414fbb43fe2248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get milliseconds until timer expiry.  <br /></td></tr>
<tr class="separator:ga69365f1c685576d76414fbb43fe2248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2537cebf106e583079ec472086a26d65" id="r_ga2537cebf106e583079ec472086a26d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a> (SocketPoll_T poll, int64_t delay_ms, <a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a> callback, void *userdata)</td></tr>
<tr class="memdesc:ga2537cebf106e583079ec472086a26d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a one-shot timer to the event poll.  <br /></td></tr>
<tr class="separator:ga2537cebf106e583079ec472086a26d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6961bde0e491d732450b66577294d097" id="r_ga6961bde0e491d732450b66577294d097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097">SocketTimer_add_repeating</a> (SocketPoll_T poll, int64_t interval_ms, <a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a> callback, void *userdata)</td></tr>
<tr class="memdesc:ga6961bde0e491d732450b66577294d097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating (periodic) timer to the event poll.  <br /></td></tr>
<tr class="separator:ga6961bde0e491d732450b66577294d097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7ca05c6cfc7c69ddc3d676a681bc62" id="r_ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a> (SocketPoll_T poll, <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> timer)</td></tr>
<tr class="memdesc:ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending timer (lazy deletion).  <br /></td></tr>
<tr class="separator:ga6f7ca05c6cfc7c69ddc3d676a681bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5519b89e0bba69f26d03b6893ba779" id="r_ga4c5519b89e0bba69f26d03b6893ba779"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779">SocketTimer_remaining</a> (SocketPoll_T poll, <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> timer)</td></tr>
<tr class="memdesc:ga4c5519b89e0bba69f26d03b6893ba779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query milliseconds remaining until timer expiry.  <br /></td></tr>
<tr class="separator:ga4c5519b89e0bba69f26d03b6893ba779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1fbd1a09d564f7988b0e427e5707ca7" id="r_gac1fbd1a09d564f7988b0e427e5707ca7"><td class="memItemLeft" align="right" valign="top">SocketPoll_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a> (int maxevents)</td></tr>
<tr class="memdesc:gac1fbd1a09d564f7988b0e427e5707ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new event poll instance.  <br /></td></tr>
<tr class="separator:gac1fbd1a09d564f7988b0e427e5707ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca744c50badbdb869c52088b9f32f8d2" id="r_gaca744c50badbdb869c52088b9f32f8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a> (SocketPoll_T *poll)</td></tr>
<tr class="memdesc:gaca744c50badbdb869c52088b9f32f8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of a SocketPoll instance and release all associated resources.  <br /></td></tr>
<tr class="separator:gaca744c50badbdb869c52088b9f32f8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" id="r_ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a> (SocketPoll_T poll, Socket_T socket, unsigned events, void *data)</td></tr>
<tr class="memdesc:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a socket for I/O event monitoring within the poll instance.  <br /></td></tr>
<tr class="separator:ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3755cc4d5ed8838ce2261f0efd1d5d85" id="r_ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85">SocketPoll_mod</a> (SocketPoll_T poll, Socket_T socket, unsigned events, void *data)</td></tr>
<tr class="memdesc:ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update event monitoring and/or user data for a registered socket.  <br /></td></tr>
<tr class="separator:ga3755cc4d5ed8838ce2261f0efd1d5d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3074c5a225a7c49880951ecfb984498f" id="r_ga3074c5a225a7c49880951ecfb984498f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a> (SocketPoll_T poll, Socket_T socket)</td></tr>
<tr class="memdesc:ga3074c5a225a7c49880951ecfb984498f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister a socket from the poll's event monitoring set.  <br /></td></tr>
<tr class="separator:ga3074c5a225a7c49880951ecfb984498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb5e288308c3de5a479b27366bba257" id="r_ga1bb5e288308c3de5a479b27366bba257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257">SocketPoll_getdefaulttimeout</a> (SocketPoll_T poll)</td></tr>
<tr class="memdesc:ga1bb5e288308c3de5a479b27366bba257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default wait timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga1bb5e288308c3de5a479b27366bba257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga945845cc57758a91e47a75ef17064d2a" id="r_ga945845cc57758a91e47a75ef17064d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a">SocketPoll_setdefaulttimeout</a> (SocketPoll_T poll, int timeout)</td></tr>
<tr class="memdesc:ga945845cc57758a91e47a75ef17064d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default wait timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga945845cc57758a91e47a75ef17064d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d47365dd18329d50ee636284839738" id="r_gaa3d47365dd18329d50ee636284839738"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a> (SocketPoll_T poll, <a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> **events, int timeout)</td></tr>
<tr class="memdesc:gaa3d47365dd18329d50ee636284839738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block and wait for I/O events or timeout on registered sockets.  <br /></td></tr>
<tr class="separator:gaa3d47365dd18329d50ee636284839738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665b3363d16ab859ec60e69a792d1ff0" id="r_ga665b3363d16ab859ec60e69a792d1ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__async__io.html#structSocketAsync__T">SocketAsync_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0">SocketPoll_get_async</a> (SocketPoll_T poll)</td></tr>
<tr class="memdesc:ga665b3363d16ab859ec60e69a792d1ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get async I/O context associated with poll instance.  <br /></td></tr>
<tr class="separator:ga665b3363d16ab859ec60e69a792d1ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16688a9e444183863bab8051f57fe688" id="r_ga16688a9e444183863bab8051f57fe688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688">SocketPoll_getmaxregistered</a> (SocketPoll_T poll)</td></tr>
<tr class="memdesc:ga16688a9e444183863bab8051f57fe688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum registered sockets limit.  <br /></td></tr>
<tr class="separator:ga16688a9e444183863bab8051f57fe688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d4052d444bcab4cae26f41cf5729eb" id="r_ga35d4052d444bcab4cae26f41cf5729eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb">SocketPoll_setmaxregistered</a> (SocketPoll_T poll, int max)</td></tr>
<tr class="memdesc:ga35d4052d444bcab4cae26f41cf5729eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum registered sockets limit.  <br /></td></tr>
<tr class="separator:ga35d4052d444bcab4cae26f41cf5729eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79e719de24f09f84eb3816b3ab60c65" id="r_gac79e719de24f09f84eb3816b3ab60c65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65">SocketPoll_getregisteredcount</a> (SocketPoll_T poll)</td></tr>
<tr class="memdesc:gac79e719de24f09f84eb3816b3ab60c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current registered socket count.  <br /></td></tr>
<tr class="separator:gac79e719de24f09f84eb3816b3ab60c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ec719e250346605c00e5b3efb2e7d8" id="r_gae9ec719e250346605c00e5b3efb2e7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gae9ec719e250346605c00e5b3efb2e7d8">backend_del</a> (<a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int fd)</td></tr>
<tr class="memdesc:gae9ec719e250346605c00e5b3efb2e7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove socket from poll set.  <br /></td></tr>
<tr class="separator:gae9ec719e250346605c00e5b3efb2e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b2c06638f0c76ea3c6c2f38503d266b" id="r_ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b">backend_wait</a> (<a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int timeout_ms)</td></tr>
<tr class="memdesc:ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for events.  <br /></td></tr>
<tr class="separator:ga5b2c06638f0c76ea3c6c2f38503d266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad998de1df9f46711f5c3b4dc0257f548" id="r_gad998de1df9f46711f5c3b4dc0257f548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548">backend_get_event</a> (const <a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a> backend, int index, int *fd_out, unsigned *events_out)</td></tr>
<tr class="memdesc:gad998de1df9f46711f5c3b4dc0257f548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get event details for index.  <br /></td></tr>
<tr class="separator:gad998de1df9f46711f5c3b4dc0257f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edb00f128ad773d62c8f11c516153d9" id="r_ga2edb00f128ad773d62c8f11c516153d9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2edb00f128ad773d62c8f11c516153d9">backend_name</a> (void)</td></tr>
<tr class="memdesc:ga2edb00f128ad773d62c8f11c516153d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable backend name for debugging and logging.  <br /></td></tr>
<tr class="separator:ga2edb00f128ad773d62c8f11c516153d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2f0acf311c238671c6d9d14d4cc7c158" id="r_ga2f0acf311c238671c6d9d14d4cc7c158"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a></td></tr>
<tr class="memdesc:ga2f0acf311c238671c6d9d14d4cc7c158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer subsystem operation failure.  <br /></td></tr>
<tr class="separator:ga2f0acf311c238671c6d9d14d4cc7c158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76e53ad178174f0f70747acfc5f83a2" id="r_gac76e53ad178174f0f70747acfc5f83a2"><td class="memItemLeft" align="right" valign="top">*Ensures ABI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gac76e53ad178174f0f70747acfc5f83a2">stability</a></td></tr>
<tr class="memdesc:gac76e53ad178174f0f70747acfc5f83a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type alias macro enabling private struct definition.  <br /></td></tr>
<tr class="separator:gac76e53ad178174f0f70747acfc5f83a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4754362476e3ffc3e000b1cbcc2a6f0" id="r_gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a></td></tr>
<tr class="memdesc:gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketPoll operation failure exception.  <br /></td></tr>
<tr class="separator:gab4754362476e3ffc3e000b1cbcc2a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>High-performance I/O multiplexing with cross-platform backends. </p>
<p>High-performance I/O multiplexing with cross-platform backends.</p>
<p>Key components: SocketPoll_T (cross-platform I/O multiplexing), <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> (timer management). Enables scalable event-driven network applications with automatic platform adaptation.</p>
<p>Comprehensive event-driven I/O subsystem providing multiplexing, timers, and async operations for scalable network servers and clients. Supports epoll (Linux), kqueue (BSD/macOS), and poll (fallback) backends with automatic selection. Timers integrate seamlessly with poll loops for timeout handling.</p>
<h2><a class="anchor" id="autotoc_md216"></a>
Architecture Overview</h2>
<div class="fragment"><div class="line"></div>
<div class="line">                Application Layer                          </div>
<div class="line">  SocketPool, SocketReconnect, <a class="code hl_struct" href="group__http.html#structSocketHTTPClient">SocketHTTPClient</a>, Servers   </div>
<div class="line"></div>
<div class="line">              Uses / Integrates</div>
<div class="line"></div>
<div class="line">              Event System Layer                           </div>
<div class="line">  SocketPoll (I/O multiplexing)                            </div>
<div class="line">  SocketTimer (min-heap timers, O(log n))                  </div>
<div class="line">  SocketAsync (non-blocking connect/accept)                </div>
<div class="line"></div>
<div class="line">              Depends on</div>
<div class="line"></div>
<div class="line">             Foundation Layer                              </div>
<div class="line">  Arena, Except, SocketUtil, SocketConfig, Monotonic Time  </div>
<div class="line"></div>
<div class="ttc" id="agroup__http_html_structSocketHTTPClient"><div class="ttname"><a href="group__http.html#structSocketHTTPClient">SocketHTTPClient</a></div><div class="ttdoc">Main HTTP client instance managing configuration, pool, auth, and state.</div><div class="ttdef"><b>Definition</b> <a href="SocketHTTPClient-private_8h_source.html#l00193">SocketHTTPClient-private.h:194</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md217"></a>
Module Relationships</h2>
<ul>
<li><b>Depends on</b>: Foundation (<a class="el" href="group__foundation.html">Core Foundation Modules</a>) for memory allocation (Arena), error handling (Except), utilities (SocketUtil), and global config.</li>
<li><b>Used by</b>: <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> management (<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a>) for idle timeouts and drain scheduling; HTTP (<a class="el" href="group__http.html">HTTP Modules</a>) for request timeouts; Security (<a class="el" href="group__security.html">Security Modules</a>) for protection sweeps.</li>
<li><b>Integration Points</b>: Timers fire during <code><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a></code>; async ops use poll for completion notification.</li>
<li><b>Thread Safety</b>: All operations thread-safe; callbacks execute in poll thread context.</li>
<li><b>Performance</b>: O(log n) timer operations; zero-copy event delivery.</li>
</ul>
<h2><a class="anchor" id="autotoc_md218"></a>
Key Features</h2>
<ul>
<li>Cross-platform poll backends with unified API</li>
<li>Min-heap timers with lazy cancellation for efficiency</li>
<li>Monotonic timestamps immune to clock adjustments</li>
<li>Automatic SIGPIPE/EINTR handling</li>
<li>Arena-managed memory for lifecycle control</li>
</ul>
<h2><a class="anchor" id="autotoc_md219"></a>
Platform Requirements</h2>
<ul>
<li>POSIX-compliant system (Unix/Linux/BSD/macOS)</li>
<li>pthreads for thread safety (mutex protection)</li>
<li>CLOCK_MONOTONIC support for accurate timing</li>
<li>File descriptor limits sufficient for registered sockets/timers</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html">Core Foundation Modules</a> Base infrastructure dependencies </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> pooling with timer integration </dd>
<dd>
<a class="el" href="group__http.html">HTTP Modules</a> HTTP client/server timeout handling </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> Detailed async patterns </dd>
<dd>
docs/cross-platform-backends.md Backend selection and tuning</dd></dl>
<p>Architecture Overview:</p><ul>
<li># SocketPoll_T: Core polling interface with backend abstraction for epoll/kqueue/poll.</li>
<li># <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a>: Heap-based timer scheduling integrated with poll wait cycles.</li>
<li>Integration with async_io::SocketAsync_T via <a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0" title="Get async I/O context associated with poll instance.">SocketPoll_get_async()</a> for zero-copy, high-throughput async operations.</li>
</ul>
<p>Backend Selection:</p><ul>
<li>Linux: epoll(7) for O(1) edge-triggered notifications.</li>
<li>BSD/macOS: kqueue(2) for efficient event filtering and file descriptor monitoring.</li>
<li>Fallback: poll(2) for broad POSIX compatibility (level-triggered).</li>
</ul>
<p>Design Principles:</p><ul>
<li>Thread-safe: Internal mutexes protect shared state across operations.</li>
<li>Arena-allocated: Efficient memory management tied to poll lifecycle.</li>
<li>Non-blocking: Automatically configures sockets for async operation.</li>
</ul>
<p>Usage Patterns:</p><ul>
<li>Servers: Combine with connection_mgmt::SocketPool_T for connection handling.</li>
<li>Clients: Use with utilities::SocketReconnect_T for resilient connections.</li>
<li>Timeouts: Integrate <a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for idle connection management.</li>
</ul>
<p>Error Handling: Uses <a class="el" href="group__foundation.html">Core Foundation Modules</a> exceptions with detailed errno mapping. Performance: Minimizes syscalls; supports up to system limits (e.g., /proc/sys/fs/epoll/max_user_watches).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html">Core Foundation Modules</a> for base infrastructure (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>, <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a>). </dd>
<dd>
<a class="el" href="group__core__io.html">Core I/O Modules</a> for Socket_T primitives compatible with event registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for advanced connection lifecycle management. </dd>
<dd>
<a class="el" href="group__async__io.html">Async I/O Modules</a> for <a class="el" href="group__async__io.html#structSocketAsync__T" title="Core structure for asynchronous I/O context management.">SocketAsync_T</a> usage in high-performance scenarios. </dd>
<dd>
<a class="el" href="group__utilities.html">Utilities</a> for rate limiting and retry logic integration. </dd>
<dd>
SocketPoll_T for polling API details. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer API (re-exported here). </dd>
<dd>
async_io::SocketAsync_T for async extensions (integrated via <a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0" title="Get async I/O context associated with poll instance.">SocketPoll_get_async()</a>). </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for event-driven programming examples and best practices. </dd>
<dd>
docs/ERROR_HANDLING.md for exception patterns in event loops. </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketTimer__T" id="structSocketTimer__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketTimer__T">&#9670;&#160;</a></span>SocketTimer_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketTimer_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Internal representation of a single scheduled timer event. </p>
<p>Stores all necessary state for a timer managed by the binary min-heap: timing parameters, user callback and data, cancellation status, unique identifier, and positioning data for efficient heap operations.</p>
<p>Instances are allocated from the heap's Arena_T and lifecycle-managed automatically: created on add, potentially rescheduled on repeat fire, marked for lazy deletion on cancel, and freed on pop or arena dispose.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
Field Access</h2>
<p>Fields are private and accessed only under heap mutex protection. Direct manipulation by external code is prohibited and may cause corruption or crashes.</p>
<h2><a class="anchor" id="autotoc_md210"></a>
Timing Model</h2>
<ul>
<li>expiry_ms: Absolute future time (ms since monotonic epoch)</li>
<li>interval_ms: Period for repeats; reschedule sets new expiry = current + interval</li>
<li>Delays computed as now_ms + delay_ms for absolute expiry</li>
</ul>
<h2><a class="anchor" id="autotoc_md211"></a>
Callback Execution</h2>
<p>When expired, <a class="el" href="group__event__system.html#aff80a635f3f8e99d2a20e1d0a46674a3">callback(userdata)</a> invoked outside mutex (to prevent deadlock). Callback must be fast; no heap operations or long blocks.</p>
<dl class="section user"><dt>Thread Safety\n Partial - modifications and reads protected by heap mutex.</dt><dd>Callback executes with userdata (user-managed safety).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use monotonic clock (CLOCK_MONOTONIC) for reliable expiry calculations. </dd>
<dd>
cancelled=1 marks for skip during process_expired(), removed on pop. </dd>
<dd>
id generated sequentially; used for logging and duplicate prevention. </dd>
<dd>
heap_index enables O(1) cancel by direct array access + heapify.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Never free timers manually or access fields directly. </dd>
<dd>
Callback must not call heap functions (deadlock risk).</dd></dl>
<dl class="section user"><dt>Complexity\n Fields support O(log n) heap ops via index maintenance.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__heap__T" title="Binary min-heap container for managing multiple SocketTimer_T instances.">SocketTimer_heap_T</a> The heap managing collections of these timers. </dd>
<dd>
<a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> Public creation (sets expiry, interval=0, <a class="el" href="group__event__system.html#aff80a635f3f8e99d2a20e1d0a46674a3">callback</a>, <a class="el" href="group__event__system.html#ab3ccb2b76d027a31b3ec829323639c08">userdata</a>). </dd>
<dd>
<a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a> Sets interval &gt;0. </dd>
<dd>
<a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7" title="Type for timer expiration callback functions.">SocketTimerCallback</a> Callback type constraints. </dd>
<dd>
docs/TIMEOUTS.md For advanced timing patterns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer-private_8h_source.html#l00125">125</a> of file <a class="el" href="SocketTimer-private_8h_source.html">SocketTimer-private.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aff80a635f3f8e99d2a20e1d0a46674a3" name="aff80a635f3f8e99d2a20e1d0a46674a3"></a><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a></td>
<td class="fieldname">
callback</td>
<td class="fielddoc">
<p>Function invoked on expiry: <a class="el" href="group__event__system.html#aff80a635f3f8e99d2a20e1d0a46674a3">callback(userdata)</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a038e1cecaf5f6a57d82521cd40f9c24f" name="a038e1cecaf5f6a57d82521cd40f9c24f"></a>int</td>
<td class="fieldname">
cancelled</td>
<td class="fielddoc">
<p>Lazy cancel flag: 1=skip firing/remove on pop, 0=active. Atomic set under mutex. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af4c657d2a6dced76ca87a3214878a8de" name="af4c657d2a6dced76ca87a3214878a8de"></a>int64_t</td>
<td class="fieldname">
expiry_ms</td>
<td class="fielddoc">
<p>Absolute expiry time (ms, CLOCK_MONOTONIC). Updated for repeats. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6773d27e4dd53f972df13651ed8bf518" name="a6773d27e4dd53f972df13651ed8bf518"></a>size_t</td>
<td class="fieldname">
heap_index</td>
<td class="fielddoc">
<p>Position in heap-&gt;timers array. Enables O(1) access for cancel/update. SOCKET_TIMER_INVALID_HEAP_INDEX if not active/in heap. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae3f246704f321c316d308121213b1b66" name="ae3f246704f321c316d308121213b1b66"></a>uint64_t</td>
<td class="fieldname">
id</td>
<td class="fielddoc">
<p>Unique monotonic ID for debugging/uniqueness. 64-bit prevents wrap in practice. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a420d42e1d3c0288bf9bb505fc8fcf1b1" name="a420d42e1d3c0288bf9bb505fc8fcf1b1"></a>int64_t</td>
<td class="fieldname">
interval_ms</td>
<td class="fielddoc">
<p>Repeat interval (ms); 0=one-shot, &gt;0=periodic. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab3ccb2b76d027a31b3ec829323639c08" name="ab3ccb2b76d027a31b3ec829323639c08"></a>void *</td>
<td class="fieldname">
userdata</td>
<td class="fielddoc">
<p>Opaque data passed unchanged to callback. User owns lifetime. </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketTimer__heap__T" id="structSocketTimer__heap__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketTimer__heap__T">&#9670;&#160;</a></span>SocketTimer_heap_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketTimer_heap_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Binary min-heap container for managing multiple <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> instances. </p>
<p>Typedef for the internal timer heap structure.</p>
<p>Implements a dynamic array-based binary min-heap (priority queue) ordered by timer expiry time (earliest first). Supports efficient scheduling, expiry checking, and processing in high-performance event loops.</p>
<p>Core Operations Complexity: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Complexity   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">push   </td><td class="markdownTableBodyNone">O(log n)   </td><td class="markdownTableBodyNone">Insert timer, heapify-up from leaf    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pop   </td><td class="markdownTableBodyNone">O(log n)   </td><td class="markdownTableBodyNone">Extract min, heapify-down from root    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">peek   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Access root (next expiry) without remove    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cancel   </td><td class="markdownTableBodyNone">O(log n)   </td><td class="markdownTableBodyNone">Mark + remove/reheap if active    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">resize   </td><td class="markdownTableBodyNone">Amortized O(1)   </td><td class="markdownTableBodyNone">Double capacity when full   </td></tr>
</table>
<p>Memory &amp; Growth:</p><ul>
<li>Starts with small capacity, doubles on overflow (efficient amortized growth)</li>
<li>All data (heap array, timers) from single Arena_T for batch free</li>
<li>Supports millions of timers practically (memory-limited)</li>
</ul>
<p>Thread Safety &amp; Concurrency:</p><ul>
<li>Full protection via pthread_mutex_t for all state modifications/queries</li>
<li>process_expired() temporarily releases lock during user callbacks</li>
<li>Suitable for multi-threaded environments (e.g., worker threads adding timers)</li>
</ul>
<p>Error Handling:</p><ul>
<li>Functions return error codes or NULL; some raise SocketTimer_Failed via validation</li>
<li>Mutex init failure or arena exhaustion handled gracefully (no leaks)</li>
</ul>
<dl class="section user"><dt>Thread Safety\n Yes - mutex serializes all access; callbacks executed unlocked.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Heap is 1-indexed (timers[0] unused as sentinel). </dd>
<dd>
Lazy cancellation: timers marked invalid but stay until popped (optimizes cancel). </dd>
<dd>
next_id increments atomically; overflow irrelevant (64-bit huge). </dd>
<dd>
arena lifetime &gt; heap lifetime; clear only after heap_free().</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid long-running callbacks in process_expired() (starves other ops). </dd>
<dd>
Direct field access corrupts heap invariants; always use API. </dd>
<dd>
Capacity growth consumes memory; monitor via count/capacity if needed.</dd></dl>
<dl class="section user"><dt>Complexity\n See table above for ops; overall scalable to high loads.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md212"></a>
Usage Pattern (Internal)</h2>
<div class="fragment"><div class="line"><span class="comment">// Typical initialization in SocketPoll or similar</span></div>
<div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> <a class="code hl_variable" href="group__event__system.html#a9ed59a6ac8ae4bc38e66ce5138286f1d">arena</a> = ...;</div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap = <a class="code hl_function" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a>(<a class="code hl_variable" href="group__event__system.html#a9ed59a6ac8ae4bc38e66ce5138286f1d">arena</a>);</div>
<div class="line"><span class="keywordflow">if</span> (heap) {</div>
<div class="line">  <span class="comment">// Add timers: heap_push(heap, new_timer);</span></div>
<div class="line">  <span class="comment">// In loop: process_expired(heap); or use peek_delay for poll timeout</span></div>
<div class="line">  <a class="code hl_function" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a>(&amp;heap);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;<a class="code hl_variable" href="group__event__system.html#a9ed59a6ac8ae4bc38e66ce5138286f1d">arena</a>);</div>
<div class="ttc" id="agroup__event__system_html_a9ed59a6ac8ae4bc38e66ce5138286f1d"><div class="ttname"><a href="group__event__system.html#a9ed59a6ac8ae4bc38e66ce5138286f1d">SocketTimer_heap_T::arena</a></div><div class="ttdeci">Arena_T arena</div><div class="ttdef"><b>Definition</b> <a href="SocketTimer-private_8h_source.html#l00214">SocketTimer-private.h:214</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga18f3d33b3f70cc8620fef042ca65e66a"><div class="ttname"><a href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a></div><div class="ttdeci">SocketTimer_heap_T * SocketTimer_heap_new(Arena_T arena)</div><div class="ttdoc">Allocate and initialize a new timer heap instance.</div></div>
<div class="ttc" id="agroup__event__system_html_ga3257343cc10ae56314c03abd8311d873"><div class="ttname"><a href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a></div><div class="ttdeci">void SocketTimer_heap_free(SocketTimer_heap_T **heap)</div><div class="ttdoc">Finalize and nullify timer heap handle: destroy mutex only.</div></div>
<div class="ttc" id="agroup__event__system_html_structSocketTimer__heap__T"><div class="ttname"><a href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a></div><div class="ttdoc">Binary min-heap container for managing multiple SocketTimer_T instances.</div><div class="ttdef"><b>Definition</b> <a href="SocketTimer-private_8h_source.html#l00204">SocketTimer-private.h:205</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga6842e66018614df08139e67826cf3e0d"><div class="ttname"><a href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a></div><div class="ttdeci">void Arena_dispose(Arena_T *ap)</div><div class="ttdoc">Dispose of an arena and all its allocations, freeing underlying memory chunks.</div></div>
<div class="ttc" id="agroup__foundation_html_gac1ed22b9df4eff7a3398cac608c090cc"><div class="ttname"><a href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></div><div class="ttdeci">struct Arena_T * Arena_T</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00078">Arena.h:78</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> Timers stored and managed by this heap. </dd>
<dd>
<a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a" title="Allocate and initialize a new timer heap instance.">SocketTimer_heap_new()</a> Creation and initialization. </dd>
<dd>
<a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> Adding <a class="el" href="group__event__system.html#a546b1db23427498d6d17f913a203c683">timers</a>. </dd>
<dd>
<a class="el" href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e" title="Fire all expired timers and return count.">SocketTimer_process_expired()</a> Firing expired <a class="el" href="group__event__system.html#a546b1db23427498d6d17f913a203c683">timers</a>. </dd>
<dd>
<a class="el" href="SocketTimer_8h.html" title="High-performance timer subsystem integrated with the event loop.">SocketTimer.h</a> Public functions wrapping heap ops. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> Event loop timer integration. </dd>
<dd>
docs/ERROR_HANDLING.md Exception details for validation failures.</dd></dl>
<p>Provides opaque access to the heap implementation. </p><dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="group__event__system.html#structSocketTimer__heap__T" title="Binary min-heap container for managing multiple SocketTimer_T instances.">SocketTimer_heap_T</a> for detailed fields. </dd>
<dd>
<a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a" title="Allocate and initialize a new timer heap instance.">SocketTimer_heap_new()</a> for creation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer-private_8h_source.html#l00204">204</a> of file <a class="el" href="SocketTimer-private_8h_source.html">SocketTimer-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketTimer_heap_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketTimer__heap__T__coll__graph.svg" width="158" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9ed59a6ac8ae4bc38e66ce5138286f1d" name="a9ed59a6ac8ae4bc38e66ce5138286f1d"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Allocation source for timers[], internal buffers, and <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> instances. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a719a334242bd551e439fadcdf85cc7d5" name="a719a334242bd551e439fadcdf85cc7d5"></a>size_t</td>
<td class="fieldname">
capacity</td>
<td class="fielddoc">
<p>Allocated array size. Doubled when count == capacity. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5f7e444e7943597fa7d510072da85559" name="a5f7e444e7943597fa7d510072da85559"></a>size_t</td>
<td class="fieldname">
count</td>
<td class="fielddoc">
<p>Active timers in heap. Updated on push/pop/cancel. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a698e2aa8ebea1e347733059e4de77665" name="a698e2aa8ebea1e347733059e4de77665"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
<p>Synchronization primitive. Locks all operations except during callbacks. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aef1a8571b21ab39180d69365a8bbb0a2" name="aef1a8571b21ab39180d69365a8bbb0a2"></a>uint64_t</td>
<td class="fieldname">
next_id</td>
<td class="fielddoc">
<p>Next timer ID generator. Incremented on each new timer. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a546b1db23427498d6d17f913a203c683" name="a546b1db23427498d6d17f913a203c683"></a>struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> **</td>
<td class="fieldname">
timers</td>
<td class="fielddoc">
<p>Dynamic array of timer pointers (heap structure). 1-indexed; reallocated on growth. </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketEvent__T" id="structSocketEvent__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketEvent__T">&#9670;&#160;</a></span>SocketEvent_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketEvent_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Event notification structure returned by polling operations. </p>
<p>Contains information about I/O events that occurred on monitored sockets. Returned as an array from <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> calls. The array is managed internally by the poll instance and should not be freed by the caller.</p>
<p>Memory Management:</p><ul>
<li>Array lifetime tied to poll instance</li>
<li>Valid until next <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> call or poll destruction</li>
<li>Do not free or modify the returned array</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for event retrieval. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for possible event types. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for associating user <a class="el" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">data</a> with sockets. </dd>
<dd>
Socket_T for <a class="el" href="group__event__system.html#a98544b5a507331adac069acd7f42d593">socket</a> type definition. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00187">187</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketEvent_T:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketEvent__T__coll__graph.svg" width="328" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="acb5b92ec2f2954ee3baa024a74ce4655" name="acb5b92ec2f2954ee3baa024a74ce4655"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>User data associated with socket at registration </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac526bc7e51851919ae7b0f3cec5934bc" name="ac526bc7e51851919ae7b0f3cec5934bc"></a>unsigned</td>
<td class="fieldname">
events</td>
<td class="fielddoc">
<p>Bitmask of events that occurred (SocketPoll_Events) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a98544b5a507331adac069acd7f42d593" name="a98544b5a507331adac069acd7f42d593"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Socket that triggered the event </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga834e79d67b92d737d55e4ba2b0684025" name="ga834e79d67b92d737d55e4ba2b0684025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834e79d67b92d737d55e4ba2b0684025">&#9670;&#160;</a></span>POLL_FD_MAP_EXPAND_INCREMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_FD_MAP_EXPAND_INCREMENT&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File descriptor map expansion increment. </p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll_T for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00621">621</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga211a6387523fa6487af971831aabf461" name="ga211a6387523fa6487af971831aabf461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211a6387523fa6487af971831aabf461">&#9670;&#160;</a></span>POLL_INITIAL_FD_MAP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_INITIAL_FD_MAP_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial file descriptor map size. </p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll_T for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00611">611</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga673275383493d8cff8bc582fef311e42" name="ga673275383493d8cff8bc582fef311e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673275383493d8cff8bc582fef311e42">&#9670;&#160;</a></span>POLL_INITIAL_FDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POLL_INITIAL_FDS&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial file descriptor capacity for poll backend. </p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll_T for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00601">601</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga55f5cf0f097a98b03e1511d1b6bd91b2" name="ga55f5cf0f097a98b03e1511d1b6bd91b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f5cf0f097a98b03e1511d1b6bd91b2">&#9670;&#160;</a></span>RAISE_POLL_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_POLL_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (SocketPoll, e)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module-specific exception raising macro for SocketPoll errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Exception type (e.g., SocketPoll_Failed)</td></tr>
  </table>
  </dd>
</dl>
<p>Convenience wrapper over SOCKET_RAISE_MODULE_ERROR for SocketPoll module exceptions. Ensures thread-safe raising by copying to thread-local exception state, avoiding races in multi-threaded environments where multiple errors occur concurrently.</p>
<p>Integrates with foundation <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> system and SocketUtil error formatting. Automatically populates detailed message from thread-local error buffer.</p>
<ul>
<li>Thread-local exception copy prevents global state corruption</li>
<li>Compatible with TRY/EXCEPT/FINALLY/END_TRY blocks</li>
<li>Safe in signal handlers? No - not async-signal-safe due to TLS</li>
</ul>
<h2><a class="anchor" id="autotoc_md374"></a>
Usage Patterns</h2>
<h3><a class="anchor" id="autotoc_md375"></a>
Basic Error with errno</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (some_syscall() == -1) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8">SOCKET_ERROR_FMT</a>(<span class="stringliteral">&quot;bind failed: %s&quot;</span>, strerror(errno));</div>
<div class="line">    <a class="code hl_define" href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a>(<a class="code hl_variable" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aSocketUtil_8h_html_adf114e63024eabf6e40f1ed7f89c79b8"><div class="ttname"><a href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8">SOCKET_ERROR_FMT</a></div><div class="ttdeci">#define SOCKET_ERROR_FMT(fmt,...)</div><div class="ttdoc">SOCKET_ERROR_FMT - Format error message with errno information.</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l01222">SocketUtil.h:1222</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga55f5cf0f097a98b03e1511d1b6bd91b2"><div class="ttname"><a href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a></div><div class="ttdeci">#define RAISE_POLL_ERROR(e)</div><div class="ttdoc">Module-specific exception raising macro for SocketPoll errors.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll-private_8h_source.html#l00474">SocketPoll-private.h:474</a></div></div>
<div class="ttc" id="agroup__event__system_html_gab4754362476e3ffc3e000b1cbcc2a6f0"><div class="ttname"><a href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a></div><div class="ttdeci">const Except_T SocketPoll_Failed</div><div class="ttdoc">SocketPoll operation failure exception.</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md376"></a>
Custom Message</h3>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (condition_invalid) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a1feea47474a6b6e939c442cdd7c42fdb">SOCKET_ERROR_MSG</a>(<span class="stringliteral">&quot;Invalid maxevents=%d (&lt;0)&quot;</span>, maxevents);</div>
<div class="line">    <a class="code hl_define" href="group__event__system.html#ga55f5cf0f097a98b03e1511d1b6bd91b2">RAISE_POLL_ERROR</a>(SocketPoll_InvalidParam);</div>
<div class="line">}</div>
<div class="ttc" id="aSocketUtil_8h_html_a1feea47474a6b6e939c442cdd7c42fdb"><div class="ttname"><a href="SocketUtil_8h.html#a1feea47474a6b6e939c442cdd7c42fdb">SOCKET_ERROR_MSG</a></div><div class="ttdeci">#define SOCKET_ERROR_MSG(fmt,...)</div><div class="ttdoc">SOCKET_ERROR_MSG - Format error message without errno.</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l01244">SocketUtil.h:1244</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md377"></a>
In TRY Block</h3>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <span class="comment">// Operations that may fail</span></div>
<div class="line">    backend_init(...);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a>) {</div>
<div class="line">    <span class="comment">// Local handling</span></div>
<div class="line">    LOG_ERROR(<span class="stringliteral">&quot;Backend init failed: %s&quot;</span>, Except_message(<a class="code hl_variable" href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a>));</div>
<div class="line">    <a class="code hl_define" href="group__foundation.html#ga947ef43f0f0def3fcc050a8df849fd16">RERAISE</a>;  <span class="comment">// Or return error code</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga3d38c6361ecf1c4873bbcb2de8a50874"><div class="ttname"><a href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a></div><div class="ttdeci">Except_Frame * Except_stack</div><div class="ttdoc">Thread-local exception stack for TRY/EXCEPT/FINALLY blocks.</div></div>
<div class="ttc" id="agroup__foundation_html_ga947ef43f0f0def3fcc050a8df849fd16"><div class="ttname"><a href="group__foundation.html#ga947ef43f0f0def3fcc050a8df849fd16">RERAISE</a></div><div class="ttdeci">#define RERAISE</div><div class="ttdoc">Re-raise the currently caught exception.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00677">Except.h:677</a></div></div>
<div class="ttc" id="agroup__foundation_html_gab5e72fc2bd41014c75e0ace4feabfe8e"><div class="ttname"><a href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a></div><div class="ttdeci">#define EXCEPT(e)</div><div class="ttdoc">Catch a specific exception type within a TRY block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01035">Except.h:1035</a></div></div>
<div class="ttc" id="agroup__foundation_html_gad2746371528bdf15c3910b7bf217dac0"><div class="ttname"><a href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a></div><div class="ttdeci">#define TRY</div><div class="ttdoc">Start a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00927">Except.h:927</a></div></div>
<div class="ttc" id="agroup__foundation_html_gae6628ac788ad213363b89dba9868420b"><div class="ttname"><a href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a></div><div class="ttdeci">#define END_TRY</div><div class="ttdoc">Complete a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01358">Except.h:1358</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md378"></a>
Supported Exception Types</h2>
<p>Defined in <a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">SocketPoll.h</a> (public) or private exceptions:</p><ul>
<li>SocketPoll_Failed: General failure (system calls, allocations)</li>
<li>SocketPoll_InvalidParam: Caller error (null pointers, invalid limits)</li>
<li>SocketPoll_Closed: Socket closed unexpectedly</li>
<li>Others module-specific</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Precede with SOCKET_ERROR_*() macro to set message </dd>
<dd>
Declares local SocketPoll_DetailedException in SocketPoll.c </dd>
<dd>
Message buffer size: SOCKET_ERROR_BUF_SIZE (256 bytes) </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - TLS copy and raise</dt><dd></dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - per-thread exception stack and buffers</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not async-signal-safe; avoid in signal handlers </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Integrates with RAISE_POLL_ERROR in private code only</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> <a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b" title="SOCKET_RAISE_MODULE_ERROR - Raise module-specific exception.">SOCKET_RAISE_MODULE_ERROR</a> base macro </dd>
<dd>
<a class="el" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0" title="SocketPoll operation failure exception.">SocketPoll_Failed</a> primary exception </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> system </dd>
<dd>
error_handling patterns and best practices </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#adf114e63024eabf6e40f1ed7f89c79b8" title="SOCKET_ERROR_FMT - Format error message with errno information.">SOCKET_ERROR_FMT()</a> with errno formatting </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#a1feea47474a6b6e939c442cdd7c42fdb" title="SOCKET_ERROR_MSG - Format error message without errno.">SOCKET_ERROR_MSG()</a> custom messages </dd>
<dd>
<a class="el" href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874" title="Thread-local exception stack for TRY/EXCEPT/FINALLY blocks.">Except_stack</a> thread-local stack </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00474">474</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
<a id="ga7c0e59971e52bc0a110b2a7066ea2732" name="ga7c0e59971e52bc0a110b2a7066ea2732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c0e59971e52bc0a110b2a7066ea2732">&#9670;&#160;</a></span>SOCKET_DATA_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DATA_HASH_SIZE&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile-time constant for hash table capacity in socket mappings. </p>
<p>Defines the number of buckets in internal hash tables (socket_data_map and fd_to_socket_map). Aliases SOCKET_HASH_TABLE_SIZE from <a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> (default prime: 1021) for module consistency. Prime size + golden ratio hash minimizes collisions for even distribution.</p>
<p>Memory: sizeof(SocketData* [size]) + sizeof(FdSocketEntry* [size]) ~ 16KB default (64-bit). Performance: Larger reduces chain lengths, improving worst-case to near O(1).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Scenario   </th><th class="markdownTableHeadNone">Pros   </th><th class="markdownTableHeadNone">Cons    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1021 (default)   </td><td class="markdownTableBodyNone">General apps (1K-10K conns)   </td><td class="markdownTableBodyNone">Balanced   </td><td class="markdownTableBodyNone">Minor collisions possible    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4093-16381   </td><td class="markdownTableBodyNone">High-load servers (&gt;10K conns)   </td><td class="markdownTableBodyNone">Low collisions   </td><td class="markdownTableBodyNone">Increased memory (~64KB+)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">251-509   </td><td class="markdownTableBodyNone">Embedded/low-mem   </td><td class="markdownTableBodyNone">Low footprint   </td><td class="markdownTableBodyNone">Higher collision risk   </td></tr>
</table>
<p>Override via CMake: cmake -DSOCKET_HASH_TABLE_SIZE=4093 ..</p>
<dl class="section note"><dt>Note</dt><dd>Must be compile-time constant; affects struct T layout </dd>
<dd>
Prime recommended for hash quality; powers-of-2 suboptimal </dd>
<dd>
Shared across modules for consistency; change impacts all </dd></dl>
<dl class="section user"><dt>Complexity\n Influences avg chain length: collisions ~ 1/size</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Non-prime sizes degrade performance; test under load </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used in struct T array declarations; sizeof impacts cache</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> <a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84" title="Hash table size for socket data mapping.">SOCKET_HASH_TABLE_SIZE</a> source </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd()</a> FD hashing </dd>
<dd>
<a class="el" href="group__foundation.html#ga81d733432a2030afb97cd12be61e7054" title="Hash unsigned integer using golden ratio.">socket_util_hash_uint()</a> general uint hashing </dd>
<dd>
poll_fd_hash() module-specific seeded hash </dd>
<dd>
SocketData table entries </dd>
<dd>
FdSocketEntry reverse entries </dd>
<dd>
struct <a class="el" href="group__poll__private.html#ga0acb682b8260ab1c60b918599864e2e5">T</a> poll-&gt;*_map arrays using this </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> hashing best practices </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00157">157</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
<a id="ga71cb10d1eefc15616a20bcd7ae21e875" name="ga71cb10d1eefc15616a20bcd7ae21e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71cb10d1eefc15616a20bcd7ae21e875">&#9670;&#160;</a></span>SOCKET_DEFAULT_POLL_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_POLL_TIMEOUT&#160;&#160;&#160;1000 /* 1 second */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default poll timeout. </p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll_T for event polling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01394">1394</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga76ac815951cb4cbc800c781eb143b8cb" name="ga76ac815951cb4cbc800c781eb143b8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ac815951cb4cbc800c781eb143b8cb">&#9670;&#160;</a></span>SOCKET_EVENT_MAX_HANDLERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_EVENT_MAX_HANDLERS&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of event handlers that can be registered. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__async__io.html#structSocketAsync__T" title="Core structure for asynchronous I/O context management.">SocketAsync_T</a> for async I/O events. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00755">755</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gab6d7f45fcb5eae5fe42694e8e123cab4" name="gab6d7f45fcb5eae5fe42694e8e123cab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d7f45fcb5eae5fe42694e8e123cab4">&#9670;&#160;</a></span>SOCKET_MAX_POLL_EVENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_POLL_EVENTS&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum events per poll iteration. </p>
<p>Can be overridden at compile time with -DSOCKET_MAX_POLL_EVENTS=value.</p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll_T for event polling implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00358">358</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7f5492f9166c78ee14f4b69362ccaf51" name="ga7f5492f9166c78ee14f4b69362ccaf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f5492f9166c78ee14f4b69362ccaf51">&#9670;&#160;</a></span>SOCKET_MAX_TIMER_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMER_DELAY_MS&#160;&#160;&#160;(INT64_C (31536000000)) /* 365 days */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum allowed delay or interval for individual timers. </p>
<p>Prevents resource exhaustion and int64_t overflow (~1 year in ms). Can be overridden at compile time with -DSOCKET_MAX_TIMER_DELAY_MS=value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00665">665</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad738dd2be8abca1d0353d31f888ba3eb" name="gad738dd2be8abca1d0353d31f888ba3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad738dd2be8abca1d0353d31f888ba3eb">&#9670;&#160;</a></span>SOCKET_MAX_TIMER_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMER_TIMEOUT_MS&#160;&#160;&#160;300000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum timer timeout to prevent indefinite blocking. </p>
<p>5 minutes maximum to prevent resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00652">652</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga53de6720fd3fc8accf99751c1e4e0d50" name="ga53de6720fd3fc8accf99751c1e4e0d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53de6720fd3fc8accf99751c1e4e0d50">&#9670;&#160;</a></span>SOCKET_MAX_TIMERS_PER_HEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TIMERS_PER_HEAP&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of timers per heap. </p>
<p>Prevents resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00708">708</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0fc8aa94a3e9bb10cb26d85c6474d04e" name="ga0fc8aa94a3e9bb10cb26d85c6474d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fc8aa94a3e9bb10cb26d85c6474d04e">&#9670;&#160;</a></span>SOCKET_POLL_TIMEOUT_USE_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POLL_TIMEOUT_USE_DEFAULT&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special timeout value to use the poll's default timeout. </p>
<p>When passed to <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a>, this value instructs the function to use the default timeout configured via <a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a>. Useful for consistent timeout behavior across multiple wait calls.</p>
<dl class="section note"><dt>Note</dt><dd>This constant ensures timeout consistency across multiple wait operations. </dd>
<dd>
Equivalent to calling <a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for each wait.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for timeout parameter usage. </dd>
<dd>
<a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for setting the default timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for retrieving the current default. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00209">209</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<a id="gab56cfec8835c59bfb69bb1c1cb128c93" name="gab56cfec8835c59bfb69bb1c1cb128c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56cfec8835c59bfb69bb1c1cb128c93">&#9670;&#160;</a></span>SOCKET_TIMER_ERROR_BUFSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_ERROR_BUFSIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer error buffer size for detailed error messages. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00674">674</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaca5f033531acb4f68ba5823ce2b769d7" name="gaca5f033531acb4f68ba5823ce2b769d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5f033531acb4f68ba5823ce2b769d7">&#9670;&#160;</a></span>SOCKET_TIMER_HEAP_GROWTH_FACTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_HEAP_GROWTH_FACTOR&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Growth factor when resizing timer heap. </p>
<p>Must be greater than 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer heap implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00696">696</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga115b76003aaf131241e5b091a63b3285" name="ga115b76003aaf131241e5b091a63b3285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115b76003aaf131241e5b091a63b3285">&#9670;&#160;</a></span>SOCKET_TIMER_HEAP_INITIAL_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_HEAP_INITIAL_CAPACITY&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial capacity for timer heap array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer heap implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00684">684</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacd3100d409a6fd3f6d160700ba6c64c6" name="gacd3100d409a6fd3f6d160700ba6c64c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd3100d409a6fd3f6d160700ba6c64c6">&#9670;&#160;</a></span>SOCKET_TIMER_INITIAL_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_INITIAL_ID&#160;&#160;&#160;1ULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial timer ID value. </p>
<p>Wraps at UINT64_MAX.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00740">740</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2829aac1405cdf86f8ef8b6eb3ecf365" name="ga2829aac1405cdf86f8ef8b6eb3ecf365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2829aac1405cdf86f8ef8b6eb3ecf365">&#9670;&#160;</a></span>SOCKET_TIMER_INVALID_HEAP_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_INVALID_HEAP_INDEX&#160;&#160;&#160;((size_t) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sentinel value indicating that a timer is not currently in the heap. </p>
<p>Used in <a class="el" href="group__event__system.html#a6773d27e4dd53f972df13651ed8bf518">SocketTimer_T::heap_index</a> to mark timers that are cancelled or not inserted. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#a6773d27e4dd53f972df13651ed8bf518">SocketTimer_T::heap_index</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer-private_8h_source.html#l00236">236</a> of file <a class="el" href="SocketTimer-private_8h_source.html">SocketTimer-private.h</a>.</p>

</div>
</div>
<a id="gab0ced17c77c552330176b69557fb83fc" name="gab0ced17c77c552330176b69557fb83fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ced17c77c552330176b69557fb83fc">&#9670;&#160;</a></span>SOCKET_TIMER_MIN_DELAY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_MIN_DELAY_MS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum delay for one-shot timers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00718">718</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga59221d1781370448def350dafb2d7e24" name="ga59221d1781370448def350dafb2d7e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59221d1781370448def350dafb2d7e24">&#9670;&#160;</a></span>SOCKET_TIMER_MIN_INTERVAL_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TIMER_MIN_INTERVAL_MS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum interval for repeating timers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00728">728</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__utilities.html#ga24514489b0962fafe8414bfae95aa268">T</a>&#160;&#160;&#160;<a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque pointer to a timer instance. </p>
<p>High-performance socket polling abstraction with cross-platform backends.</p>
<p>Represents a timer created by <a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> or <a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a>. Used to cancel the timer or query remaining time via public API functions. Becomes invalid after the timer fires or is cancelled; subsequent use leads to undefined behavior.</p>
<dl class="section note"><dt>Note</dt><dd>Internal storage managed by per-poll heap (min-heap structure); not direct pointer to struct <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a>. </dd>
<dd>
Do not free or access directly; use <a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> to invalidate. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Using invalid (fired/cancelled) timer handle in cancel/remaining may return -1 or cause assertion failures in debug builds. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Handle valid only through thread-safe public functions; concurrent access safe but serialized by mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for creation </dd>
<dd>
<a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a> for periodic timers </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> for invalidation </dd>
<dd>
<a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779" title="Query milliseconds remaining until timer expiry.">SocketTimer_remaining()</a> for time queries</dd></dl>
<p>Provides scalable event notification for network applications with O(1) event delivery regardless of the number of monitored sockets. Automatically selects the best available backend for the platform: epoll (Linux), kqueue (BSD/macOS), or poll (POSIX fallback).</p>
<p>Key Features:</p><ul>
<li>O(1) event delivery with edge-triggered mode for efficiency</li>
<li>Automatic backend selection based on platform capabilities</li>
<li>Thread-safe operations with internal mutex protection</li>
<li>Integrated timer management via SocketTimer</li>
<li>Optional asynchronous I/O support via SocketAsync</li>
<li>Configurable limits for resource protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for event waiting. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer_8h_source.html#l00175">175</a> of file <a class="el" href="SocketTimer_8h_source.html">SocketTimer.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__utilities.html#ga24514489b0962fafe8414bfae95aa268">T</a>&#160;&#160;&#160;SocketPoll_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-performance socket polling abstraction with cross-platform backends. </p>
<p>Provides scalable event notification for network applications with O(1) event delivery regardless of the number of monitored sockets. Automatically selects the best available backend for the platform: epoll (Linux), kqueue (BSD/macOS), or poll (POSIX fallback).</p>
<p>Key Features:</p><ul>
<li>O(1) event delivery with edge-triggered mode for efficiency</li>
<li>Automatic backend selection based on platform capabilities</li>
<li>Thread-safe operations with internal mutex protection</li>
<li>Integrated timer management via SocketTimer</li>
<li>Optional asynchronous I/O support via SocketAsync</li>
<li>Configurable limits for resource protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for event waiting. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for available event types. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00125">125</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gafb51f69cdbf1b882a7a4226959c4fca7" name="gafb51f69cdbf1b882a7a4226959c4fca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb51f69cdbf1b882a7a4226959c4fca7">&#9670;&#160;</a></span>SocketTimerCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketTimerCallback) (void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for timer expiration callback functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>Opaque user data provided at timer creation time.</td></tr>
  </table>
  </dd>
</dl>
<p>Invoked automatically when timer expires, during <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> call. Executes in the thread/context of the <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> caller.</p>
<dl class="section note"><dt>Note</dt><dd>Callback must complete promptly; long-running ops may block event loop. </dd>
<dd>
Must not call <a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> on any timer in same heap (mutex deadlock risk). </dd>
<dd>
Safe for resource allocation/freeing within arena scope, but avoid deep recursion. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid adding/cancelling timers recursively on the same heap to prevent stack overflow or deadlocks. </dd>
<dd>
Do not block indefinitely (e.g., no synchronous I/O); use non-blocking or defer work. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - executes under heap mutex briefly; user code should be reentrant if needed.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md224"></a>
Best Practices</h2>
<ul>
<li>Keep lightweight: Log, schedule work, update state - defer heavy computation.</li>
<li>Use userdata for context: Pass structures with needed data.</li>
<li>Handle errors gracefully: No exceptions from callbacks; use logging.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> timeout_callback(<span class="keywordtype">void</span> *ud) {</div>
<div class="line">    MyContext_T *ctx = ud;</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Timeout for ctx=%p&quot;</span>, ctx);</div>
<div class="line">    <span class="comment">// Schedule deferred work or update state</span></div>
<div class="line">    <span class="comment">// Do NOT: SocketTimer_add(poll, ... ) // potential recursion</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> t = <a class="code hl_function" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a>(poll, 30000, timeout_callback, ctx);</div>
<div class="ttc" id="aSocketUtil_8h_html_a9fe70c7ab8b971af2971f3a102b82819"><div class="ttname"><a href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_INFO_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00494">SocketUtil.h:494</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga2537cebf106e583079ec472086a26d65"><div class="ttname"><a href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a></div><div class="ttdeci">SocketTimer_T SocketTimer_add(SocketPoll_T poll, int64_t delay_ms, SocketTimerCallback callback, void *userdata)</div><div class="ttdoc">Add a one-shot timer to the event poll.</div></div>
<div class="ttc" id="agroup__event__system_html_structSocketTimer__T"><div class="ttname"><a href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a></div><div class="ttdoc">Internal representation of a single scheduled timer event.</div><div class="ttdef"><b>Definition</b> <a href="SocketTimer-private_8h_source.html#l00125">SocketTimer-private.h:126</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for associating callback with timer </dd>
<dd>
<a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a> for periodic callbacks </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketTimer_8h_source.html#l00227">227</a> of file <a class="el" href="SocketTimer_8h_source.html">SocketTimer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9e8943c9cb47aba63dda4ad9083142b6" name="ga9e8943c9cb47aba63dda4ad9083142b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8943c9cb47aba63dda4ad9083142b6">&#9670;&#160;</a></span>SocketPoll_Events</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6">SocketPoll_Events</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event types for socket I/O monitoring. </p>
<p>Bitmask values specifying which I/O events to monitor on sockets. Multiple events can be combined using bitwise OR operations. Used in <a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> and <a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for event registration.</p>
<dl class="section note"><dt>Note</dt><dd>POLL_ERROR and POLL_HANGUP are always monitored automatically. </dd>
<dd>
Edge-triggered mode delivers events only when state changes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registering sockets with specific events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for modifying monitored events. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for event delivery structure. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for event retrieval. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8" name="gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8"></a>POLL_READ&#160;</td><td class="fielddoc"><p>Data available for reading </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195" name="gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195"></a>POLL_WRITE&#160;</td><td class="fielddoc"><p>Socket ready for writing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9" name="gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9"></a>POLL_ERROR&#160;</td><td class="fielddoc"><p>Error condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c" name="gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c"></a>POLL_HANGUP&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> hang up / disconnection </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketPoll_8h_source.html#l00161">161</a> of file <a class="el" href="SocketPoll_8h_source.html">SocketPoll.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae9ec719e250346605c00e5b3efb2e7d8" name="gae9ec719e250346605c00e5b3efb2e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ec719e250346605c00e5b3efb2e7d8">&#9670;&#160;</a></span>backend_del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_del </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove socket from poll set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance. </td></tr>
    <tr><td class="paramname">fd</td><td>File descriptor to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Should succeed silently if fd not in set (idempotent operation). </dd>
<dd>
Validates fd parameter before backend operations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system__backend.html#ga72ef813749c8c54d8f8ccf64ba724a0a" title="Essential macro to validate file descriptors before backend system calls.">VALIDATE_FD</a> for file descriptor validation. </dd>
<dd>
<a class="el" href="group__backend__functions.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Register file descriptor for I/O event notifications.">backend_add()</a> for registration. </dd>
<dd>
<a class="el" href="group__backend__functions.html#ga4b929e888a5088e59cd045c41759363e" title="Update event monitoring configuration for existing file descriptor.">backend_mod()</a> for modification. </dd></dl>

</div>
</div>
<a id="gad998de1df9f46711f5c3b4dc0257f548" name="gad998de1df9f46711f5c3b4dc0257f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad998de1df9f46711f5c3b4dc0257f548">&#9670;&#160;</a></span>backend_get_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_get_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>events_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get event details for index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance (const - read-only access to events array). </td></tr>
    <tr><td class="paramname">index</td><td>Event index (0 to count-1 from backend_wait return value). </td></tr>
    <tr><td class="paramname">fd_out</td><td>Output parameter - file descriptor that triggered event. </td></tr>
    <tr><td class="paramname">events_out</td><td>Output parameter - events that occurred (POLL_READ | POLL_WRITE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on invalid index. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - Read-only access to backend's internal event array.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called repeatedly by SocketPoll to translate backend events to <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a>. </dd>
<dd>
Used in event translation pipeline: fd -&gt; events -&gt; <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga5b2c06638f0c76ea3c6c2f38503d266b" title="Wait for events.">backend_wait()</a> for event waiting that populates the array. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event type definitions. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for translated event structure. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for complete event processing pipeline. </dd></dl>

</div>
</div>
<a id="ga2edb00f128ad773d62c8f11c516153d9" name="ga2edb00f128ad773d62c8f11c516153d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2edb00f128ad773d62c8f11c516153d9">&#9670;&#160;</a></span>backend_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * backend_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get human-readable backend name for debugging and logging. </p>
<dl class="section return"><dt>Returns</dt><dd>Static string identifying the backend ("epoll", "kqueue", or "poll"). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned string is compile-time constant and safe for repeated calls. </dd>
<dd>
Useful for logging backend-specific behavior and performance characteristics. </dd>
<dd>
Helps identify active backend for platform-specific issue diagnosis. </dd>
<dd>
Never NULL - always returns valid string for current backend. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__backend__functions.html#gaa198b207e04b5bb6bec2746c7d86b735" title="Allocate and initialize a platform-optimized polling backend.">backend_new()</a> for compile-time backend selection logic. </dd>
<dd>
<a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for backend initialization during poll creation. </dd></dl>

</div>
</div>
<a id="ga5b2c06638f0c76ea3c6c2f38503d266b" name="ga5b2c06638f0c76ea3c6c2f38503d266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b2c06638f0c76ea3c6c2f38503d266b">&#9670;&#160;</a></span>backend_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int backend_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system__backend.html#gadd97c2d63f6b491ef855bd928211e71b">PollBackend_T</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>Backend instance (modifies internal events array for output). </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (-1 for infinite, 0 for immediate). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events ready (&gt;= 0), or -1 on error (sets errno). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns 0 on timeout, EINTR (signal interrupt), or immediate return. </dd>
<dd>
Internal event array updated for <a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> retrieval. </dd>
<dd>
Thread-safe: Assumes single-threaded access via SocketPoll mutex. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gad998de1df9f46711f5c3b4dc0257f548" title="Get event details for index.">backend_get_event()</a> for retrieving event details. </dd>
<dd>
<a class="el" href="group__backend__functions.html#gaa51ec4e5f966a860cdd9359c36e977c6" title="Register file descriptor for I/O event notifications.">backend_add()</a> for socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for public interface that calls this. </dd></dl>

</div>
</div>
<a id="ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" name="ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">&#9670;&#160;</a></span>SocketPoll_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_add </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a socket for I/O event monitoring within the poll instance. </p>
<p>Adds the specified socket to the poll's internal monitoring set, enabling event notifications for the requested I/O conditions. Internally performs:</p><ul>
<li>Socket validity check and duplicate registration detection.</li>
<li>Idempotent configuration of socket to non-blocking mode.</li>
<li>O(1) hash table insertion for socket-to-userdata mapping.</li>
<li>Platform-specific backend registration (epoll_ctl add, kevent add, poll array update).</li>
<li>registered_count increment with max_registered limit enforcement.</li>
</ul>
<p>Event monitoring includes explicit flags (read/write) plus implicit error and hangup detection. User data is preserved and delivered verbatim in event notifications.</p>
<p>Error conditions trigger SocketPoll_Failed with detailed messages via <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a>. Common failures: duplicate socket, bad fd, resource limits (EMFILE), permissions (EPERM).</p>
<h2><a class="anchor" id="autotoc_md385"></a>
Event Flags Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Backend Equivalent    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">POLL_READ   </td><td class="markdownTableBodyNone">Data ready to read   </td><td class="markdownTableBodyNone">EPOLLIN / EVFILT_READ    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">POLL_WRITE   </td><td class="markdownTableBodyNone">Ready to write   </td><td class="markdownTableBodyNone">EPOLLOUT / EVFILT_WRITE    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">POLL_ERROR   </td><td class="markdownTableBodyNone">Error condition   </td><td class="markdownTableBodyNone">EPOLLERR / NOTE_ERROR    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">POLL_HANGUP   </td><td class="markdownTableBodyNone">Peer disconnect   </td><td class="markdownTableBodyNone">EPOLLHUP / EVFILT_READ eof   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Poll instance (non-NULL, valid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to add for monitoring (valid open fd required). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Bitmask of events to monitor (0 invalid; use SocketPoll_Events). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Opaque userdata (may be NULL; stored and returned in events).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>For:<ul>
<li>Duplicate registration (socket already in poll).</li>
<li>Invalid socket (NULL, closed, bad fd).</li>
<li>Backend failure (EMFILE, ENOMEM, EPERM, ENOSYS).</li>
<li>Exceeds configured max_registered limit.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - Fully atomic with mutex; concurrent safe.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average case - Hash insert + O(1) backend syscall.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md386"></a>
Basic Server Listener Registration</h2>
<div class="fragment"><div class="line">Socket_T listener;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    listener = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(listener, <span class="stringliteral">&quot;0.0.0.0&quot;</span>, 8080);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a>(listener, SOMAXCONN);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a>(listener, 1);  <span class="comment">// Recommended</span></div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, listener, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>, listener);  <span class="comment">// Self-reference common</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// Handle bind/listen failure</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_ga225f4a8fd657fd52a05146c6fc4f58b0"><div class="ttname"><a href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a></div><div class="ttdeci">const Except_T Socket_Failed</div><div class="ttdoc">General socket operation failure exception.</div></div>
<div class="ttc" id="agroup__core__io_html_ga35309677a1760480783d5f0c294d0db4"><div class="ttname"><a href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a></div><div class="ttdeci">void Socket_setnonblocking(Socket_T socket)</div><div class="ttdoc">Enable non-blocking mode.</div></div>
<div class="ttc" id="agroup__core__io_html_ga6212fb2b6eefa567592a59f55c25a6f1"><div class="ttname"><a href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a></div><div class="ttdeci">Socket_T Socket_new(int domain, int type, int protocol)</div><div class="ttdoc">Create a new socket with specified domain, type, and protocol.</div></div>
<div class="ttc" id="agroup__core__io_html_gab24b026bc4c69e6f766211f44675e189"><div class="ttname"><a href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a></div><div class="ttdeci">void Socket_listen(Socket_T socket, int backlog)</div><div class="ttdoc">Listen for incoming connections.</div></div>
<div class="ttc" id="agroup__core__io_html_gacb65d693d8c93e2a1fe6411dd0d0af98"><div class="ttname"><a href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a></div><div class="ttdeci">void Socket_bind(Socket_T socket, const char *host, int port)</div><div class="ttdoc">Bind a socket to a local IP address and port.</div></div>
<div class="ttc" id="agroup__event__system_html_ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><div class="ttname"><a href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a></div><div class="ttdeci">void SocketPoll_add(SocketPoll_T poll, Socket_T socket, unsigned events, void *data)</div><div class="ttdoc">Register a socket for I/O event monitoring within the poll instance.</div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a></div><div class="ttdeci">@ POLL_READ</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00163">SocketPoll.h:163</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md387"></a>
Client Connection Handling</h2>
<div class="fragment"><div class="line"><span class="comment">// After accept(2)</span></div>
<div class="line">Socket_T client = <a class="code hl_function" href="group__core__io.html#gae7c6b82ec5bf6be8131532de9ade5caf">Socket_new_from_fd</a>(accepted_fd);</div>
<div class="line"><span class="keywordflow">if</span> (client) {</div>
<div class="line">    <a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">        <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, client, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a> | <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a>, client_ctx);</div>
<div class="line">    } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__event__system.html#gab4754362476e3ffc3e000b1cbcc2a6f0">SocketPoll_Failed</a>) {</div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;client);</div>
<div class="line">        <span class="comment">// Log registration failure</span></div>
<div class="line">    } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga74ad7a9bb8deaf499c59d90d6e411f37"><div class="ttname"><a href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a></div><div class="ttdeci">void Socket_free(Socket_T *socket)</div><div class="ttdoc">Dispose of a socket instance and close the underlying file descriptor.</div></div>
<div class="ttc" id="agroup__core__io_html_gae7c6b82ec5bf6be8131532de9ade5caf"><div class="ttname"><a href="group__core__io.html#gae7c6b82ec5bf6be8131532de9ade5caf">Socket_new_from_fd</a></div><div class="ttdeci">Socket_T Socket_new_from_fd(int fd)</div><div class="ttdoc">Create Socket_T from existing file descriptor.</div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a></div><div class="ttdeci">@ POLL_WRITE</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00164">SocketPoll.h:164</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md388"></a>
With Custom User Data</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ConnCtx { <span class="keywordtype">void</span> *app_data; time_t last_active; };</div>
<div class="line"><span class="keyword">struct </span>ConnCtx *ctx = <a class="code hl_define" href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934">CALLOC</a>(poll_arena, 1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ConnCtx));</div>
<div class="line">ctx-&gt;app_data = user_object;</div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, sock, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>, ctx);  <span class="comment">// Retrieved in SocketEvent_T.data</span></div>
<div class="ttc" id="agroup__foundation_html_gaf5249a1778cd6cf5db0e2e410b292934"><div class="ttname"><a href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934">CALLOC</a></div><div class="ttdeci">#define CALLOC(arena, count, nbytes)</div><div class="ttdoc">Convenience macro for zero-initialized multi-element allocation with source tracking.</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00506">Arena.h:506</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>User data lifetime must exceed poll lifetime or until <a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from the poll&#39;s event monitoring set.">SocketPoll_del()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not register the same socket in multiple polls; use one primary poll per socket. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for event/data updates without re-registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from the poll&#39;s event monitoring set.">SocketPoll_del()</a> for explicit removal. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> to process resulting events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> enum for flag values. </dd>
<dd>
<a class="el" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4" title="Enable non-blocking mode.">Socket_setnonblocking()</a> <a class="el" href="group__reconnect__private.html#ga0450dbfcd56214ed2989e6ff4d97b25d" title="Generate uniform random double in [0.0, 1.0) for jitter in backoff calculations.">if</a> manual control needed. </dd>
<dd>
connection_mgmt::SocketPool_add() for pool-integrated registration patterns. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for full event-driven examples. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga3074c5a225a7c49880951ecfb984498f" name="ga3074c5a225a7c49880951ecfb984498f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3074c5a225a7c49880951ecfb984498f">&#9670;&#160;</a></span>SocketPoll_del()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_del </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deregister a socket from the poll's event monitoring set. </p>
<p>Removes the specified socket from internal monitoring, stopping future event notifications for it. Internally executes:</p><ul>
<li>Hash table removal for socket-data and fd-socket mappings (O(1) average).</li>
<li>Backend deregistration (epoll_ctl del, kevent delete, poll array removal).</li>
<li>registered_count decrement.</li>
<li>Cleanup of any associated state (e.g., event filters).</li>
</ul>
<p>Idempotent operation: No-op if socket not registered or already removed. On backend transient errors (e.g., ENOENT), local state cleaned for consistency. Persistent errors (EBADF, EPERM) raise exception. Logs warnings for detected inconsistencies via SOCKET_LOG_WARN.</p>
<p>Call this during connection closure, error handling, or resource reclamation to prevent stale events and free backend slots. Does NOT close or free the socket; manage separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Valid poll instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to remove (ignored if NULL or unregistered).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>Rarely, on backend del failure (e.g., EBADF invalid fd, EPERM permissions).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - Atomic with mutex; concurrent safe.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average - Hash removal + single backend del syscall.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md389"></a>
Usage in Event Handling</h2>
<div class="fragment"><div class="line"><span class="comment">// In event loop, on error or hangup</span></div>
<div class="line"><span class="keywordflow">if</span> (ev-&gt;events &amp; (<a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9">POLL_ERROR</a> | <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c">POLL_HANGUP</a>)) {</div>
<div class="line">    <a class="code hl_enumvalue" href="group__foundation.html#ggadf209a9f107e88a5df277fcc3e2641d1a0c366302769a94f7e8f4d535f4cc5716">SOCKET_LOG_INFO</a>(<span class="stringliteral">&quot;Disconnecting socket %d&quot;</span>, <a class="code hl_function" href="group__core__io.html#ga4d727948c677509eec04746585819877">Socket_fd</a>(ev-&gt;socket));</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a>(poll, ev-&gt;socket);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;ev-&gt;socket);  <span class="comment">// Or Socket_close() if reusing fd</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga4d727948c677509eec04746585819877"><div class="ttname"><a href="group__core__io.html#ga4d727948c677509eec04746585819877">Socket_fd</a></div><div class="ttdeci">int Socket_fd(const Socket_T socket)</div><div class="ttdoc">Get underlying file descriptor.</div></div>
<div class="ttc" id="agroup__event__system_html_ga3074c5a225a7c49880951ecfb984498f"><div class="ttname"><a href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a></div><div class="ttdeci">void SocketPoll_del(SocketPoll_T poll, Socket_T socket)</div><div class="ttdoc">Deregister a socket from the poll's event monitoring set.</div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9">POLL_ERROR</a></div><div class="ttdeci">@ POLL_ERROR</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00165">SocketPoll.h:165</a></div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c">POLL_HANGUP</a></div><div class="ttdeci">@ POLL_HANGUP</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00167">SocketPoll.h:166</a></div></div>
<div class="ttc" id="agroup__foundation_html_ggadf209a9f107e88a5df277fcc3e2641d1a0c366302769a94f7e8f4d535f4cc5716"><div class="ttname"><a href="group__foundation.html#ggadf209a9f107e88a5df277fcc3e2641d1a0c366302769a94f7e8f4d535f4cc5716">SOCKET_LOG_INFO</a></div><div class="ttdeci">@ SOCKET_LOG_INFO</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00053">SocketUtil.h:53</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md390"></a>
Bulk Cleanup with Pool</h2>
<div class="fragment"><div class="line"><span class="comment">// Graceful shutdown</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gab6ffb3b44d5214daeed16af0c4cae08c">SocketPool_foreach</a>(pool, cleanup_cb, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> cleanup_cb(Connection_T conn, <span class="keywordtype">void</span> *arg) {</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a>(conn);</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a>(poll, sock);  <span class="comment">// Deregister before pool remove</span></div>
<div class="line">    <span class="comment">// Pool handles further cleanup</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_gaaeff7efb1109a312f56e35689b67c652"><div class="ttname"><a href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a></div><div class="ttdeci">Socket_T Connection_socket(const Connection_T conn)</div><div class="ttdoc">Get connection's socket.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gab6ffb3b44d5214daeed16af0c4cae08c"><div class="ttname"><a href="group__connection__mgmt.html#gab6ffb3b44d5214daeed16af0c4cae08c">SocketPool_foreach</a></div><div class="ttdeci">void SocketPool_foreach(SocketPool_T pool, void(*func)(Connection_T, void *), void *arg)</div><div class="ttdoc">Iterate over active connections.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>After del, socket can be re-registered with <a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> or used elsewhere. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Failing to del before <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> may leak backend state (rare; auto-clean on close). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registration counterpart. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for updates without full removal. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> to verify removal (decrements count). </dd>
<dd>
<a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> for socket disposal post-del. </dd>
<dd>
connection_mgmt::SocketPool_remove() for pool integration. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for cleanup patterns in event-driven apps. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="gaca744c50badbdb869c52088b9f32f8d2" name="gaca744c50badbdb869c52088b9f32f8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca744c50badbdb869c52088b9f32f8d2">&#9670;&#160;</a></span>SocketPoll_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_free </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T *&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispose of a SocketPoll instance and release all associated resources. </p>
<p>Completes the lifecycle of a poll instance by:</p><ul>
<li>Closing the platform-specific backend file descriptor (e.g., epoll fd).</li>
<li>Implicitly deregistering all monitored file descriptors by destroying backend state.</li>
<li>Canceling all integrated timers via heap cleanup.</li>
<li>Destroying synchronization primitives (mutex).</li>
<li>Disposing the internal arena, which frees all hash table entries, event buffers, and mappings.</li>
<li>Freeing the main poll structure.</li>
</ul>
<p>Sockets registered with the poll are NOT closed or freed; the user remains responsible for calling <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> or Socket_close() on them separately. The internal mappings (socket-to-data and fd-to-socket) are cleared, preventing further event delivery for those sockets.</p>
<p>Post-cleanup, the poll pointer is set to NULL to prevent accidental reuse. If called on NULL or invalid, it's a no-op.</p>
<p>Edge cases:</p><ul>
<li>Concurrent wait/add/del operations: May result in incomplete cleanup; internal locks mitigate but prefer sequential access.</li>
<li>Backend close failures: Logged via SOCKET_LOG_ERROR but do not halt cleanup.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">poll</td><td>Pointer to the poll instance (set to NULL on completion).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - Uses internal mutex to protect shared state during cleanup.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(n + m) where n=registered sockets (hash table traversal implicit via arena dispose), m=timers.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md383"></a>
Usage Example</h2>
<div class="fragment"><div class="line">SocketPoll_T poll = <a class="code hl_function" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a>(1024);</div>
<div class="line"><span class="comment">// ... register sockets, run event loop ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cleanup</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a>(&amp;poll);  <span class="comment">// poll now NULL, all internal resources released</span></div>
<div class="ttc" id="agroup__event__system_html_gac1fbd1a09d564f7988b0e427e5707ca7"><div class="ttname"><a href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a></div><div class="ttdeci">SocketPoll_T SocketPoll_new(int maxevents)</div><div class="ttdoc">Create a new event poll instance.</div></div>
<div class="ttc" id="agroup__event__system_html_gaca744c50badbdb869c52088b9f32f8d2"><div class="ttname"><a href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a></div><div class="ttdeci">void SocketPoll_free(SocketPoll_T *poll)</div><div class="ttdoc">Dispose of a SocketPoll instance and release all associated resources.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md384"></a>
In Exception-Safe Context</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    SocketPoll_T poll = <a class="code hl_function" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a>(1024);</div>
<div class="line">    <span class="comment">// Operations that may throw</span></div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, sock, events, data);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a>(&amp;poll);  <span class="comment">// Ensures cleanup even if exceptions occur</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga0e2a75478cd44f1666a6aca626c5c50b"><div class="ttname"><a href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a></div><div class="ttdeci">#define FINALLY</div><div class="ttdoc">Define cleanup code that executes regardless of exceptions.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01251">Except.h:1251</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Sockets must be explicitly closed by user code post-deregistration. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid calling during active <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a>; use signals or timeouts for graceful shutdown. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7" title="Create a new event poll instance.">SocketPoll_new()</a> for creation counterpart. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from the poll&#39;s event monitoring set.">SocketPoll_del()</a> for deregistering individual sockets before full cleanup. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> to monitor and verify count drops to 0. </dd>
<dd>
<a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> indirectly called via internal arena. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873" title="Finalize and nullify timer heap handle: destroy mutex only.">SocketTimer_heap_free()</a> for timer cleanup details. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md for comprehensive resource disposal guidelines. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga665b3363d16ab859ec60e69a792d1ff0" name="ga665b3363d16ab859ec60e69a792d1ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665b3363d16ab859ec60e69a792d1ff0">&#9670;&#160;</a></span>SocketPoll_get_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__async__io.html#structSocketAsync__T">SocketAsync_T</a> SocketPoll_get_async </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get async I/O context associated with poll instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Async context or NULL if unavailable. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns NULL if async I/O is not available on this platform. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__async__io.html#structSocketAsync__T" title="Core structure for asynchronous I/O context management.">SocketAsync_T</a> for async I/O operations. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for automatic async completion processing. </dd></dl>

</div>
</div>
<a id="ga1bb5e288308c3de5a479b27366bba257" name="ga1bb5e288308c3de5a479b27366bba257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bb5e288308c3de5a479b27366bba257">&#9670;&#160;</a></span>SocketPoll_getdefaulttimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getdefaulttimeout </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default wait timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Default timeout in milliseconds. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for setting the timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for how the default timeout is used. </dd></dl>

</div>
</div>
<a id="ga16688a9e444183863bab8051f57fe688" name="ga16688a9e444183863bab8051f57fe688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16688a9e444183863bab8051f57fe688">&#9670;&#160;</a></span>SocketPoll_getmaxregistered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getmaxregistered </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum registered sockets limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum limit (0 = unlimited). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defense-in-depth: Returns the configured limit on socket registrations. </dd>
<dd>
Compile-time default is SOCKET_POLL_MAX_REGISTERED (0 = disabled). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb" title="Set maximum registered sockets limit.">SocketPoll_setmaxregistered()</a> for setting the limit. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> for current count. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for socket registration that respects limits. </dd></dl>

</div>
</div>
<a id="gac79e719de24f09f84eb3816b3ab60c65" name="gac79e719de24f09f84eb3816b3ab60c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79e719de24f09f84eb3816b3ab60c65">&#9670;&#160;</a></span>SocketPoll_getregisteredcount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_getregisteredcount </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current registered socket count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of currently registered sockets. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688" title="Get maximum registered sockets limit.">SocketPoll_getmaxregistered()</a> for the maximum allowed. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registering sockets. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from the poll&#39;s event monitoring set.">SocketPoll_del()</a> for removing sockets. </dd></dl>

</div>
</div>
<a id="ga3755cc4d5ed8838ce2261f0efd1d5d85" name="ga3755cc4d5ed8838ce2261f0efd1d5d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3755cc4d5ed8838ce2261f0efd1d5d85">&#9670;&#160;</a></span>SocketPoll_mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_mod </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update event monitoring and/or user data for a registered socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Registered socket to modify. </td></tr>
    <tr><td class="paramname">events</td><td>Updated event bitmask to monitor (can change from previous). </td></tr>
    <tr><td class="paramname">data</td><td>Updated user data pointer (replaces previous association). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic update protecting against concurrent access.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if socket not registered or backend modification fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to del + add internally on some backends (e.g., kqueue). </dd>
<dd>
Does not change socket's non-blocking state.</dd></dl>
<p>Use to dynamically adjust monitoring (e.g., enable write after connect success).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for initial socket registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f" title="Deregister a socket from the poll&#39;s event monitoring set.">SocketPoll_del()</a> for complete deregistration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event bitmask options. </dd>
<dd>
<a class="el" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">SocketEvent_T::data</a> for how user data is delivered in events. </dd></dl>

</div>
</div>
<a id="gac1fbd1a09d564f7988b0e427e5707ca7" name="gac1fbd1a09d564f7988b0e427e5707ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1fbd1a09d564f7988b0e427e5707ca7">&#9670;&#160;</a></span>SocketPoll_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketPoll_T SocketPoll_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxevents</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new event poll instance. </p>
<p>Initializes a cross-platform event polling context capable of monitoring multiple sockets for I/O readiness. Automatically detects and configures the optimal backend based on platform capabilities, ensuring high-performance event delivery suitable for servers handling thousands of concurrent connections.</p>
<p>The maxevents parameter determines the capacity of the internal event queue, which affects how many events can be retrieved in a single <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> call. Recommended values:</p><ul>
<li>Small clients: 64-256</li>
<li>Medium servers: 1024-4096</li>
<li>High-throughput: 8192+ (monitor memory usage)</li>
</ul>
<p>Edge cases and error conditions:</p><ul>
<li>If maxevents &lt;= 0, defaults to system-specific value (e.g., 64 for epoll).</li>
<li>Backend initialization failures due to resource limits (ulimit -n, /proc/sys/fs/epoll/max_user_watches).</li>
<li>Unsupported platforms fall back to poll(2) with level-triggered semantics.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxevents</td><td>Maximum number of events to process per wait call (0 for system default; suggest 1024+ for servers).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New SocketPoll_T instance, fully initialized and ready for use.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>On backend creation failure, such as:<ul>
<li>EMFILE/ENFILE: Process/system file descriptor limit reached.</li>
<li>ENOMEM: Memory allocation failure for internal structures.</li>
<li>ENOSYS: Backend not supported on platform.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - Creation is atomic and instances operate independently across threads.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - Involves a single system call for backend setup and initial allocations.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md381"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Basic TCP echo server setup</span></div>
<div class="line">SocketPoll_T poll = <a class="code hl_function" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a>(1024);  <span class="comment">// Tune based on expected load</span></div>
<div class="line"><span class="keywordflow">if</span> (poll == NULL) {</div>
<div class="line">    <span class="comment">// Handle initialization failure</span></div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Socket_T listener = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(listener, <span class="stringliteral">&quot;127.0.0.1&quot;</span>, 8080);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a>(listener, SOMAXCONN);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a>(listener, 1);</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, listener, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>, (<span class="keywordtype">void</span>*)listener);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// Log error</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Event loop would follow...</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2">SocketPoll_free</a>(&amp;poll);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md382"></a>
Advanced Usage with Configuration</h2>
<div class="fragment"><div class="line">SocketPoll_T poll = <a class="code hl_function" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a>(2048);</div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a">SocketPoll_setdefaulttimeout</a>(poll, 100);  <span class="comment">// 100ms default wait</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb">SocketPoll_setmaxregistered</a>(poll, 10000); <span class="comment">// Limit connections</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Integrate with timers for heartbeats</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> heartbeat = <a class="code hl_function" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a>(poll, 30000, heartbeat_cb, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... main loop ...</span></div>
<div class="ttc" id="agroup__event__system_html_ga35d4052d444bcab4cae26f41cf5729eb"><div class="ttname"><a href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb">SocketPoll_setmaxregistered</a></div><div class="ttdeci">void SocketPoll_setmaxregistered(SocketPoll_T poll, int max)</div><div class="ttdoc">Set maximum registered sockets limit.</div></div>
<div class="ttc" id="agroup__event__system_html_ga945845cc57758a91e47a75ef17064d2a"><div class="ttname"><a href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a">SocketPoll_setdefaulttimeout</a></div><div class="ttdeci">void SocketPoll_setdefaulttimeout(SocketPoll_T poll, int timeout)</div><div class="ttdoc">Set default wait timeout in milliseconds.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Each poll instance manages its own internal arena; no external Arena_T required. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>High maxevents values increase per-wait memory footprint; profile under load. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaca744c50badbdb869c52088b9f32f8d2" title="Dispose of a SocketPoll instance and release all associated resources.">SocketPoll_free()</a> for proper disposal and resource release. </dd>
<dd>
<a class="el" href="group__event__system.html#ga35d4052d444bcab4cae26f41cf5729eb" title="Set maximum registered sockets limit.">SocketPoll_setmaxregistered()</a> for post-creation registration limits. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for the core event waiting mechanism. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registering sockets to monitor. </dd>
<dd>
<a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for scheduling timers integrated with the poll cycle. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System Modules</a> for full event system architecture. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for event-driven server examples and best practices. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga945845cc57758a91e47a75ef17064d2a" name="ga945845cc57758a91e47a75ef17064d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga945845cc57758a91e47a75ef17064d2a">&#9670;&#160;</a></span>SocketPoll_setdefaulttimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_setdefaulttimeout </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set default wait timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout in milliseconds (0 = immediate, -1 = infinite). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga1bb5e288308c3de5a479b27366bba257" title="Get default wait timeout in milliseconds.">SocketPoll_getdefaulttimeout()</a> for retrieving the current timeout. </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> for how the default timeout is used. </dd></dl>

</div>
</div>
<a id="ga35d4052d444bcab4cae26f41cf5729eb" name="ga35d4052d444bcab4cae26f41cf5729eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35d4052d444bcab4cae26f41cf5729eb">&#9670;&#160;</a></span>SocketPoll_setmaxregistered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPoll_setmaxregistered </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum registered sockets limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll</td><td>Poll instance. </td></tr>
    <tr><td class="paramname">max</td><td>Maximum limit (0 = unlimited). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>if max &lt; registered_count and max &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defense-in-depth: Limits the number of sockets that can be registered to prevent resource exhaustion attacks. </dd>
<dd>
Set to 0 to disable limit. </dd>
<dd>
Cannot set limit below current registered_count. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga16688a9e444183863bab8051f57fe688" title="Get maximum registered sockets limit.">SocketPoll_getmaxregistered()</a> for retrieving the current limit. </dd>
<dd>
<a class="el" href="group__event__system.html#gac79e719de24f09f84eb3816b3ab60c65" title="Get current registered socket count.">SocketPoll_getregisteredcount()</a> for current count. </dd></dl>

</div>
</div>
<a id="gaa3d47365dd18329d50ee636284839738" name="gaa3d47365dd18329d50ee636284839738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d47365dd18329d50ee636284839738">&#9670;&#160;</a></span>SocketPoll_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPoll_wait </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> **&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block and wait for I/O events or timeout on registered sockets. </p>
<p>Core event loop primitive: suspends execution until I/O events occur on monitored sockets, timers expire, or timeout elapses. Internally orchestrates:</p><ul>
<li>Timer heap check for due timers (integrated SocketTimer support).</li>
<li>Backend wait syscall (epoll_wait, kevent, poll) for raw fd events.</li>
<li>Event translation from backend fd/events to <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> with userdata.</li>
<li>Optional async I/O completion processing (SocketAsync).</li>
<li>Automatic cleanup of expired/closed registrations.</li>
</ul>
<p>Returns array of <a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> populated with occurred events. Array is valid until next wait call. 0 return indicates timeout (no events); negative or exception on errors.</p>
<p>Timeout semantics:</p><ul>
<li>-1: Infinite wait (block until event).</li>
<li>0: Non-blocking poll (immediate return).</li>
<li>&gt;0: Wait up to N ms.</li>
<li>SOCKET_POLL_TIMEOUT_USE_DEFAULT: Use poll-&gt;default_timeout_ms.</li>
</ul>
<p>Errors: Backend syscalls fail (EINTR handled), invalid state, or resource issues. Also processes and delivers timer callbacks if timers due.</p>
<h2><a class="anchor" id="autotoc_md391"></a>
Timeout Values Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Behavior   </th><th class="markdownTableHeadNone">Use Case    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-1   </td><td class="markdownTableBodyNone">Infinite block   </td><td class="markdownTableBodyNone">Primary server loop    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Non-blocking   </td><td class="markdownTableBodyNone">Edge-triggered checks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&gt;0   </td><td class="markdownTableBodyNone">Bounded wait   </td><td class="markdownTableBodyNone">With external timeouts    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">USE_DEFAULT   </td><td class="markdownTableBodyNone">Configured default   </td><td class="markdownTableBodyNone">Consistent loops   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Valid poll instance with registered sockets. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Pointer to array of events (internal; do not free/modify). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Wait timeout (-1 infinite, 0 immediate, USE_DEFAULT for default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 Number of occurred events (0=timeout, no events). Exceptions or negative on fatal errors (rare; check throws).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPoll_Failed</td><td>On backend wait failure (e.g., EINVAL, EBADF, ENOMEM).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - Returns thread-local event array; mutex protects internal state.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(k) where k=number of ready events (backend delivers in batch).</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md392"></a>
Simple Event Loop</h2>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="http__server_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    <a class="code hl_struct" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> *events;</div>
<div class="line">    <span class="keywordtype">int</span> nev = <a class="code hl_function" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a>(poll, &amp;events, 100);  <span class="comment">// 100ms timeout</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nev; ++i) {</div>
<div class="line">        <a class="code hl_struct" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> *ev = &amp;events[i];</div>
<div class="line">        <span class="keywordflow">if</span> (ev-&gt;<a class="code hl_variable" href="group__event__system.html#ac526bc7e51851919ae7b0f3cec5934bc">events</a> &amp; <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>) {</div>
<div class="line">            <span class="comment">// Handle read: recv, accept, etc.</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (ev-&gt;<a class="code hl_variable" href="group__event__system.html#ac526bc7e51851919ae7b0f3cec5934bc">events</a> &amp; <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a>) {</div>
<div class="line">            <span class="comment">// Handle write: send, connect completion</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (ev-&gt;<a class="code hl_variable" href="group__event__system.html#ac526bc7e51851919ae7b0f3cec5934bc">events</a> &amp; (<a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a29422ea3bfa0fde21ed413e6f9d7b0d9">POLL_ERROR</a> | <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6aaa263b6ed4ed526b0d9c55f0c2702f4c">POLL_HANGUP</a>)) {</div>
<div class="line">            <span class="comment">// Handle error/disconnect: close, log</span></div>
<div class="line">            <a class="code hl_function" href="group__event__system.html#ga3074c5a225a7c49880951ecfb984498f">SocketPoll_del</a>(poll, ev-&gt;<a class="code hl_variable" href="group__event__system.html#a98544b5a507331adac069acd7f42d593">socket</a>);</div>
<div class="line">            <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;ev-&gt;<a class="code hl_variable" href="group__event__system.html#a98544b5a507331adac069acd7f42d593">socket</a>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">void</span> *data = ev-&gt;<a class="code hl_variable" href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">data</a>;  <span class="comment">// User data from add/mod</span></div>
<div class="line">        <span class="comment">// Use data for context-specific handling</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__event__system_html_a98544b5a507331adac069acd7f42d593"><div class="ttname"><a href="group__event__system.html#a98544b5a507331adac069acd7f42d593">SocketEvent_T::socket</a></div><div class="ttdeci">Socket_T socket</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00189">SocketPoll.h:189</a></div></div>
<div class="ttc" id="agroup__event__system_html_ac526bc7e51851919ae7b0f3cec5934bc"><div class="ttname"><a href="group__event__system.html#ac526bc7e51851919ae7b0f3cec5934bc">SocketEvent_T::events</a></div><div class="ttdeci">unsigned events</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00191">SocketPoll.h:191</a></div></div>
<div class="ttc" id="agroup__event__system_html_acb5b92ec2f2954ee3baa024a74ce4655"><div class="ttname"><a href="group__event__system.html#acb5b92ec2f2954ee3baa024a74ce4655">SocketEvent_T::data</a></div><div class="ttdeci">void * data</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00190">SocketPoll.h:190</a></div></div>
<div class="ttc" id="agroup__event__system_html_gaa3d47365dd18329d50ee636284839738"><div class="ttname"><a href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a></div><div class="ttdeci">int SocketPoll_wait(SocketPoll_T poll, SocketEvent_T **events, int timeout)</div><div class="ttdoc">Block and wait for I/O events or timeout on registered sockets.</div></div>
<div class="ttc" id="agroup__event__system_html_structSocketEvent__T"><div class="ttname"><a href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a></div><div class="ttdoc">Event notification structure returned by polling operations.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00187">SocketPoll.h:188</a></div></div>
<div class="ttc" id="ahttp__server_8c_html_af1f449cc09f8d36befcce07bc38c29c0"><div class="ttname"><a href="http__server_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a></div><div class="ttdeci">static volatile int running</div><div class="ttdef"><b>Definition</b> <a href="http__server_8c_source.html#l00032">http_server.c:32</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md393"></a>
With Timers and Default Timeout</h2>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a">SocketPoll_setdefaulttimeout</a>(poll, -1);  <span class="comment">// Infinite default</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> timer = <a class="code hl_function" href="group__event__system.html#ga6961bde0e491d732450b66577294d097">SocketTimer_add_repeating</a>(poll, 5000, periodic_cb, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="http__server_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    <a class="code hl_struct" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> *events;</div>
<div class="line">    <span class="keywordtype">int</span> nev = <a class="code hl_function" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a>(poll, &amp;events, <a class="code hl_define" href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a>);</div>
<div class="line">    <span class="comment">// Process events + timers (periodic_cb called if due)</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__event__system_html_ga0fc8aa94a3e9bb10cb26d85c6474d04e"><div class="ttname"><a href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a></div><div class="ttdeci">#define SOCKET_POLL_TIMEOUT_USE_DEFAULT</div><div class="ttdoc">Special timeout value to use the poll's default timeout.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00209">SocketPoll.h:209</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga6961bde0e491d732450b66577294d097"><div class="ttname"><a href="group__event__system.html#ga6961bde0e491d732450b66577294d097">SocketTimer_add_repeating</a></div><div class="ttdeci">SocketTimer_T SocketTimer_add_repeating(SocketPoll_T poll, int64_t interval_ms, SocketTimerCallback callback, void *userdata)</div><div class="ttdoc">Add a repeating (periodic) timer to the event poll.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Events array overwritten on next wait; process immediately. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Infinite timeout (-1) without signals/timers risks deadlock; prefer bounded. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> to populate monitoring set before wait. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> structure for event details. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for event flags in returned events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga0fc8aa94a3e9bb10cb26d85c6474d04e" title="Special timeout value to use the poll&#39;s default timeout.">SOCKET_POLL_TIMEOUT_USE_DEFAULT</a> constant. </dd>
<dd>
<a class="el" href="group__event__system.html#ga945845cc57758a91e47a75ef17064d2a" title="Set default wait timeout in milliseconds.">SocketPoll_setdefaulttimeout()</a> for configuring default. </dd>
<dd>
<a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for timer integration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga665b3363d16ab859ec60e69a792d1ff0" title="Get async I/O context associated with poll instance.">SocketPoll_get_async()</a> for async extensions processed here. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for complete event loop examples. </dd>
<dd>
docs/ERROR_HANDLING.md for exception safety in loops. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga2537cebf106e583079ec472086a26d65" name="ga2537cebf106e583079ec472086a26d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2537cebf106e583079ec472086a26d65">&#9670;&#160;</a></span>SocketTimer_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> SocketTimer_add </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a one-shot timer to the event poll. </p>
<p>Schedules a single timer expiration after specified delay. The timer integrates with the provided SocketPoll instance, firing the callback automatically during <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> when expired. Uses monotonic clock for reliable timing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Event poll instance; timers fired during its wait() calls </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_ms</td><td>Delay from now in milliseconds (&gt;=0; clamped if excessive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Non-NULL function invoked on expiry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>Opaque data passed to callback (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid timer handle on success; NULL if exception raised</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>Invalid args (delay_ms &lt;0 or &gt;max, NULL poll/callback), alloc fail, heap full (&gt;max timers), mutex error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - internal mutex protects heap; safe from any thread</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(log n) - min-heap insertion; O(1) amortized for capacity growth</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md227"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Cleanup timer after 5 seconds of inactivity</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> cleanup_callback(<span class="keywordtype">void</span> *ud) {</div>
<div class="line">    Connection_T *conn = ud;</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;Cleaning idle connection %p&quot;</span>, conn);</div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d">SocketPool_remove</a>(pool, <a class="code hl_function" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a>(conn));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In server init or connection handler</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> idle_timer = <a class="code hl_function" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a>(poll, 5000, cleanup_callback, conn);</div>
<div class="line"><span class="keywordflow">if</span> (idle_timer) {</div>
<div class="line">    <span class="comment">// Timer will auto-fire during poll loop</span></div>
<div class="line">} <span class="comment">// else handle exception</span></div>
<div class="ttc" id="aSocketUtil_8h_html_a7853a630bcaead9d41536ccbfd598f6d"><div class="ttname"><a href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_DEBUG_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00490">SocketUtil.h:490</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gacdffcf1802367df60db15c649fc7072d"><div class="ttname"><a href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d">SocketPool_remove</a></div><div class="ttdeci">void SocketPool_remove(SocketPool_T pool, Socket_T socket)</div><div class="ttdoc">Remove socket from pool.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md228"></a>
Error Handling</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> t = <a class="code hl_function" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a>(poll, delay, cb, data);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a>) {</div>
<div class="line">    <span class="comment">// Log and fallback: e.g., use longer delay or skip timeout</span></div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;Failed to add timer: %s&quot;</span>, <a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>());</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketUtil_8h_html_ae560ccd4aef66d44e8ecbd256844059c"><div class="ttname"><a href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_WARN_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00498">SocketUtil.h:498</a></div></div>
<div class="ttc" id="agroup__event__system_html_ga2f0acf311c238671c6d9d14d4cc7c158"><div class="ttname"><a href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a></div><div class="ttdeci">const Except_T SocketTimer_Failed</div><div class="ttdoc">Timer subsystem operation failure.</div></div>
<div class="ttc" id="agroup__foundation_html_gac71a25566cdc9e11eaecb16c966081db"><div class="ttname"><a href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a></div><div class="ttdeci">const char * Socket_GetLastError(void)</div><div class="ttdoc">Socket_GetLastError - Retrieve the most recent formatted error message.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Delay of 0 ms schedules for next poll cycle (near-immediate). </dd>
<dd>
Extreme delays (&gt;365 days) clamped with warning log. </dd>
<dd>
Timer memory arena-allocated; free via arena dispose or cancel. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callback executes in poll thread; keep short to avoid blocking I/O.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a> for periodic scheduling </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> to abort before firing </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> where firing occurs </dd>
<dd>
<a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7" title="Type for timer expiration callback functions.">SocketTimerCallback</a> for callback guidelines </dd></dl>

</div>
</div>
<a id="ga6961bde0e491d732450b66577294d097" name="ga6961bde0e491d732450b66577294d097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6961bde0e491d732450b66577294d097">&#9670;&#160;</a></span>SocketTimer_add_repeating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> SocketTimer_add_repeating </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7">SocketTimerCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a repeating (periodic) timer to the event poll. </p>
<p>Schedules periodic timer firings every interval_ms milliseconds, starting after the first interval. Integrates with SocketPoll for automatic callback invocation during wait(). Uses monotonic clock; reschedules after each firing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Event poll instance; manages firing during wait() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_ms</td><td>Repeat interval in ms (&gt;=1; clamped if excessive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Non-NULL function invoked periodically </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>Opaque data for callback (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid timer handle; NULL on exception</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>Invalid interval/delay (&gt;=1 ms min), NULL args, alloc/heap full/mutex errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - mutex-protected; concurrent safe</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(log n) - heap insert; repeated for rescheduling on fire</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md229"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Periodic heartbeat or metrics collection every 10 seconds</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> heartbeat_callback(<span class="keywordtype">void</span> *ud) {</div>
<div class="line">    ServerStats_T *stats = ud;</div>
<div class="line">    stats-&gt;heartbeat_count++;</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Heartbeat %lu&quot;</span>, stats-&gt;heartbeat_count);</div>
<div class="line">    <span class="comment">// Send metrics or check health</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Setup in server init</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> heart_timer = <a class="code hl_function" href="group__event__system.html#ga6961bde0e491d732450b66577294d097">SocketTimer_add_repeating</a>(poll, 10000, heartbeat_callback, &amp;server_stats);</div>
<div class="line"><span class="comment">// Continues until cancelled or poll freed</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md230"></a>
Stopping Periodic Timer</h2>
<div class="fragment"><div class="line"><span class="comment">// Graceful stop on shutdown signal</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a>(poll, periodic_timer) == 0) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Periodic timer cancelled&quot;</span>);</div>
<div class="line">} <span class="comment">// -1 if already invalid/fired</span></div>
<div class="ttc" id="agroup__event__system_html_ga6f7ca05c6cfc7c69ddc3d676a681bc62"><div class="ttname"><a href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a></div><div class="ttdeci">int SocketTimer_cancel(SocketPoll_T poll, SocketTimer_T timer)</div><div class="ttdoc">Cancel a pending timer (lazy deletion).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>First fire after interval_ms; subsequent every interval_ms from expiry (not wall-clock aligned). </dd>
<dd>
Interval clamped &gt;365 days with warning; min 1ms to avoid loops. </dd>
<dd>
Rescheduling happens after callback; drift accumulates if callback slow. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For precise intervals, use shorter intervals or adjust in callback. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Memory managed by poll's arena; persists until cancel or arena dispose.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> for single-fire timers </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> to stop repetition </dd>
<dd>
<a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7" title="Type for timer expiration callback functions.">SocketTimerCallback</a> Guidelines for periodic callbacks </dd>
<dd>
<a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> Automatic firing mechanism </dd></dl>

</div>
</div>
<a id="ga6f7ca05c6cfc7c69ddc3d676a681bc62" name="ga6f7ca05c6cfc7c69ddc3d676a681bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7ca05c6cfc7c69ddc3d676a681bc62">&#9670;&#160;</a></span>SocketTimer_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_cancel </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending timer (lazy deletion). </p>
<p>Marks the specified timer as cancelled, preventing future firing. Uses lazy deletion: flag set immediately, but timer removed from heap only when it reaches root during processing (efficient, no immediate heap restructure).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Event poll associated with the timer heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Handle of timer to cancel (must match poll's heap)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if timer was pending and marked cancelled; -1 if invalid handle, mismatch, already invalid/fired, or heap unavailable</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-blocking, no exceptions raised - check return for success </dd>
<dd>
Idempotent: Repeated calls or on invalid timers return -1 harmlessly </dd>
<dd>
Lazy: Memory freed later; callback never called post-cancel</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - quick mutex lock for flag set</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct heap_index access to set flag; no sift operations</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md231"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Cancel idle timeout if activity resumes</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a>(poll, idle_timer) == 0) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;Idle timer cancelled due to activity&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Already fired or invalid - no action needed</span></div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;Timer already invalid&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md232"></a>
In Shutdown</h2>
<div class="fragment"><div class="line"><span class="comment">// Cancel all timers before poll free</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a>(poll, timer1);</div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a>(poll, timer2);</div>
<div class="line"><span class="comment">// Ignore returns; ensures no pending fires</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Do NOT call from timer callback (deadlock on heap mutex) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For repeating timers, stops future firings immediately </dd>
<dd>
After cancel, timer handle invalid for further ops (remaining returns -1) </dd>
<dd>
To free memory sooner, consider arena clear/dispose after batch cancels</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> One-shot timer creation </dd>
<dd>
<a class="el" href="group__event__system.html#ga6961bde0e491d732450b66577294d097" title="Add a repeating (periodic) timer to the event poll.">SocketTimer_add_repeating()</a> Periodic timers </dd>
<dd>
<a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779" title="Query milliseconds remaining until timer expiry.">SocketTimer_remaining()</a> Check status post-cancel </dd></dl>

</div>
</div>
<a id="ga8af1dd7cd2864bea6226054f1ff9b22b" name="ga8af1dd7cd2864bea6226054f1ff9b22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8af1dd7cd2864bea6226054f1ff9b22b">&#9670;&#160;</a></span>SocketTimer_heap_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_heap_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark timer as cancelled (lazy deletion). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if timer not found. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(1) time complexity using maintained heap_index field. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga3257343cc10ae56314c03abd8311d873" name="ga3257343cc10ae56314c03abd8311d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3257343cc10ae56314c03abd8311d873">&#9670;&#160;</a></span>SocketTimer_heap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketTimer_heap_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> **&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize and nullify timer heap handle: destroy mutex only. </p>
<p>Destroys the internal pthread mutex (releasing any system resources) and sets *heap = NULL to invalidate the handle and prevent dangling use.</p>
<p><b>Important</b>: Does NOT free the heap structure, timers array, or any <a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> instances - these remain allocated in the original Arena_T. To reclaim memory, caller must subsequently call Arena_dispose(arena) or equivalent after ensuring all timers processed/cancelled.</p>
<p>Safe for NULL or already-NULL *heap (no-op).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>Pointer to heap handle; set to NULL after mutex destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Call after draining/processing all timers to avoid leaks of pending callbacks. </dd>
<dd>
Mutex must be unlocked at call time (caller enforce via no concurrent ops). </dd>
<dd>
No return value; failures in mutex_destroy() (rare, e.g., invalid mutex) ignored silently. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - requires exclusive access; call after stopping threads using heap.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md215"></a>
Proper Cleanup Sequence</h2>
<div class="fragment"><div class="line"><span class="comment">// Before free: optionally drain</span></div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419">SocketTimer_heap_peek_delay</a>(heap) &lt;= 0) {</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e">SocketTimer_process_expired</a>(heap);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Cancel any remaining if needed</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a>(&amp;heap);  <span class="comment">// Mutex destroy + nullify</span></div>
<div class="line"><span class="comment">// Now safe to free memory</span></div>
<div class="line"><a class="code hl_function" href="group__foundation.html#ga0af0c54c1c64ff88ad43aadd48ce3ebe">Arena_clear</a>(arena);  <span class="comment">// Or dispose if end-of-life</span></div>
<div class="ttc" id="agroup__event__system_html_ga0f7deeb47aba9580052152bbf036c419"><div class="ttname"><a href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419">SocketTimer_heap_peek_delay</a></div><div class="ttdeci">int64_t SocketTimer_heap_peek_delay(SocketTimer_heap_T *heap)</div><div class="ttdoc">Get milliseconds until next timer expiry.</div></div>
<div class="ttc" id="agroup__event__system_html_ga888ed4acbf5d1ca29bdafc07f346566e"><div class="ttname"><a href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e">SocketTimer_process_expired</a></div><div class="ttdeci">int SocketTimer_process_expired(SocketTimer_heap_T *heap)</div><div class="ttdoc">Fire all expired timers and return count.</div></div>
<div class="ttc" id="agroup__foundation_html_ga0af0c54c1c64ff88ad43aadd48ce3ebe"><div class="ttname"><a href="group__foundation.html#ga0af0c54c1c64ff88ad43aadd48ce3ebe">Arena_clear</a></div><div class="ttdeci">void Arena_clear(Arena_T arena)</div><div class="ttdoc">Reset the arena by invalidating all current allocations while preserving the arena for reuse.</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Calling with locked mutex leads to undefined behavior (pthread UB). </dd>
<dd>
Memory leak if arena not cleared/disposed after this call. </dd>
<dd>
Does not wait for or cancel in-flight callbacks (caller responsibility).</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single mutex destroy operation.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a" title="Allocate and initialize a new timer heap instance.">SocketTimer_heap_new()</a> Creation and arena association. </dd>
<dd>
<a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> / <a class="el" href="group__foundation.html#ga0af0c54c1c64ff88ad43aadd48ce3ebe" title="Reset the arena by invalidating all current allocations while preserving the arena for reuse.">Arena_clear()</a> For memory reclamation post-free. </dd>
<dd>
pthread_mutex_destroy(3) Low-level mutex cleanup and <a class="el" href="SocketHappyEyeballs-private_8h.html#a11614f44ef4d939bdd984953346a7572">error</a> conditions. </dd>
<dd>
<a class="el" href="group__event__system.html#ga888ed4acbf5d1ca29bdafc07f346566e" title="Fire all expired timers and return count.">SocketTimer_process_expired()</a> To handle remaining timers before free. </dd>
<dd>
<a class="el" href="group__event__system.html#ga8af1dd7cd2864bea6226054f1ff9b22b" title="Mark timer as cancelled (lazy deletion).">SocketTimer_heap_cancel()</a> To invalidate pending timers. </dd></dl>

</div>
</div>
<a id="ga18f3d33b3f70cc8620fef042ca65e66a" name="ga18f3d33b3f70cc8620fef042ca65e66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f3d33b3f70cc8620fef042ca65e66a">&#9670;&#160;</a></span>SocketTimer_heap_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> * SocketTimer_heap_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new timer heap instance. </p>
<p>Dynamically allocates the heap control structure, initial timers array, and initializes state variables and mutex. All memory from provided arena. Initial heap capacity is small and grows dynamically as needed.</p>
<p>Failure modes (return NULL):</p><ul>
<li>Invalid/NULL arena parameter</li>
<li>Arena allocation failure for heap struct or initial timers array</li>
<li>pthread_mutex_init() failure (system resource limits, e.g., too many locks)</li>
</ul>
<p>No exceptions are raised by this function; check return value for success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Required non-NULL Arena_T for heap allocations. No malloc fallback; NULL input returns NULL immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated and initialized <a class="el" href="group__event__system.html#structSocketTimer__heap__T" title="Binary min-heap container for managing multiple SocketTimer_T instances.">SocketTimer_heap_T</a> * or NULL on any failure.</dd></dl>
<dl class="section user"><dt>Thread Safety\n No - initialization is single-threaded; use thread-safe after success.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md213"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a>();  <span class="comment">// Or existing arena</span></div>
<div class="line"><a class="code hl_struct" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap = <a class="code hl_function" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a>(arena);</div>
<div class="line"><span class="keywordflow">if</span> (heap == NULL) {</div>
<div class="line">    <span class="comment">// Error: log, retry allocation, or fail gracefully</span></div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Failed to create timer heap&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;arena);</div>
<div class="line">    <span class="keywordflow">return</span> NULL;  <span class="comment">// Or handle error</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Heap ready: push timers, integrate with poll loop</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873">SocketTimer_heap_free</a>(&amp;heap);  <span class="comment">// Cleanup structure/mutex</span></div>
<div class="line"><a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;arena);         <span class="comment">// Free all memory (timers, array)</span></div>
<div class="ttc" id="aSocketUtil_8h_html_a16642c35dec627aeb4976538671b1552"><div class="ttname"><a href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_ERROR_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00502">SocketUtil.h:502</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga6a6d6890eb6ed1248ae1a5f0c677c7a4"><div class="ttname"><a href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a></div><div class="ttdeci">Arena_T Arena_new(void)</div><div class="ttdoc">Create a new memory arena with initial capacity and thread-safe protection.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md214"></a>
Error Handling Pattern</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a>();</div>
<div class="line">    <a class="code hl_struct" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *heap = <a class="code hl_function" href="group__event__system.html#ga18f3d33b3f70cc8620fef042ca65e66a">SocketTimer_heap_new</a>(arena);</div>
<div class="line">    <span class="comment">// Use heap...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a>) {  <span class="comment">// Note: this func doesn&#39;t throw, but later ops may</span></div>
<div class="line">    <span class="comment">// Handle via validation helpers</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Mutex initialized with default attributes (fast mutex, not recursive). </dd>
<dd>
Initial capacity typically 8-16 timers; doubles on resize (amortized efficient). </dd>
<dd>
After success, all subsequent heap ops are thread-safe.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Arena lifetime must exceed heap's: dispose only after heap_free(). </dd>
<dd>
On failure, no resources leaked (partial allocs cleaned internally). </dd>
<dd>
In low-memory, may fail arena allocs; consider larger initial arena.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - constant time fixed allocations and init.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga3257343cc10ae56314c03abd8311d873" title="Finalize and nullify timer heap handle: destroy mutex only.">SocketTimer_heap_free()</a> Required paired cleanup (mutex destroy). </dd>
<dd>
<a class="el" href="group__foundation.html#gad93b1dd7d771cbed846dcc3c5c836917" title="Allocate raw memory block from the specified arena.">Arena_alloc()</a> Underlying allocation mechanism. </dd>
<dd>
pthread_mutex_init(3) Mutex creation details and errno codes. </dd>
<dd>
<a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> First operation after creation. </dd></dl>

</div>
</div>
<a id="ga0961e214a845a52c242176ed425095a3" name="ga0961e214a845a52c242176ed425095a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0961e214a845a52c242176ed425095a3">&#9670;&#160;</a></span>SocketTimer_heap_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> * SocketTimer_heap_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get earliest timer without removing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Earliest timer or NULL if heap empty. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> for removal. </dd></dl>

</div>
</div>
<a id="ga0f7deeb47aba9580052152bbf036c419" name="ga0f7deeb47aba9580052152bbf036c419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7deeb47aba9580052152bbf036c419">&#9670;&#160;</a></span>SocketTimer_heap_peek_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_heap_peek_delay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get milliseconds until next timer expiry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until next timer (&gt;= 0), or -1 if no timers. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> to fire expired timers. </dd></dl>

</div>
</div>
<a id="ga9e40363cf44bb1025f2269ddc2cef0d2" name="ga9e40363cf44bb1025f2269ddc2cef0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e40363cf44bb1025f2269ddc2cef0d2">&#9670;&#160;</a></span>SocketTimer_heap_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> * SocketTimer_heap_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return earliest timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Earliest timer or NULL if heap empty. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga04afe41789d51a71d4a03883a89ad61c" name="ga04afe41789d51a71d4a03883a89ad61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04afe41789d51a71d4a03883a89ad61c">&#9670;&#160;</a></span>SocketTimer_heap_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketTimer_heap_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add timer to heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to add (takes ownership). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketTimer_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga9e40363cf44bb1025f2269ddc2cef0d2" title="Remove and return earliest timer.">SocketTimer_heap_pop()</a> for removal. </dd></dl>

</div>
</div>
<a id="ga69365f1c685576d76414fbb43fe2248b" name="ga69365f1c685576d76414fbb43fe2248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69365f1c685576d76414fbb43fe2248b">&#9670;&#160;</a></span>SocketTimer_heap_remaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_heap_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> *&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get milliseconds until timer expiry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
    <tr><td class="paramname">timer</td><td>Timer to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until expiry (&gt;= 0), or -1 if timer not found/cancelled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(1) time complexity using maintained heap_index field. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga04afe41789d51a71d4a03883a89ad61c" title="Add timer to heap.">SocketTimer_heap_push()</a> for adding timers. </dd></dl>

</div>
</div>
<a id="ga888ed4acbf5d1ca29bdafc07f346566e" name="ga888ed4acbf5d1ca29bdafc07f346566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga888ed4acbf5d1ca29bdafc07f346566e">&#9670;&#160;</a></span>SocketTimer_process_expired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketTimer_process_expired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__heap__T">SocketTimer_heap_T</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fire all expired timers and return count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Timer heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of timers that fired. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses heap mutex.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callbacks are invoked outside the mutex to prevent deadlocks. Repeating timers are rescheduled after firing. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga0f7deeb47aba9580052152bbf036c419" title="Get milliseconds until next timer expiry.">SocketTimer_heap_peek_delay()</a> to check for expired timers. </dd></dl>

</div>
</div>
<a id="ga4c5519b89e0bba69f26d03b6893ba779" name="ga4c5519b89e0bba69f26d03b6893ba779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5519b89e0bba69f26d03b6893ba779">&#9670;&#160;</a></span>SocketTimer_remaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketTimer_remaining </td>
          <td>(</td>
          <td class="paramtype">SocketPoll_T&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a>&#160;</td>
          <td class="paramname"><em>timer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query milliseconds remaining until timer expiry. </p>
<p>Computes time left until the timer's scheduled expiry using current monotonic clock. Useful for monitoring, logging, or dynamic timeout adjustments. Returns approximate value; actual firing may vary slightly due to scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td>Poll instance owning the timer heap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle to query (must match poll)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 ms remaining (0 if due or overdue); -1 if invalid, mismatch, fired/cancelled, or heap unavailable</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-raising, non-blocking - always safe to call </dd>
<dd>
Value decreases over time; snapshot only, race possible in multi-thread </dd>
<dd>
For cancelled timers, returns -1 (not overdue)</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - brief mutex for validation and expiry read</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct index lookup + monotonic clock query</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md233"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Log remaining time for monitoring</span></div>
<div class="line">int64_t remaining = <a class="code hl_function" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779">SocketTimer_remaining</a>(poll, timer);</div>
<div class="line"><span class="keywordflow">if</span> (remaining &gt; 0) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;Timer %p has %&quot;</span> PRId64 <span class="stringliteral">&quot; ms left&quot;</span>, timer, remaining);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (remaining == 0) {</div>
<div class="line">    <span class="comment">// Due now - expect imminent firing</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Invalid - perhaps already fired</span></div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;Timer %p invalid&quot;</span>, timer);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__event__system_html_ga4c5519b89e0bba69f26d03b6893ba779"><div class="ttname"><a href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779">SocketTimer_remaining</a></div><div class="ttdeci">int64_t SocketTimer_remaining(SocketPoll_T poll, SocketTimer_T timer)</div><div class="ttdoc">Query milliseconds remaining until timer expiry.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md234"></a>
Dynamic Adjustment</h2>
<div class="fragment"><div class="line"><span class="comment">// Check if enough time left before critical op</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779">SocketTimer_remaining</a>(poll, deadline_timer) &lt; 1000) {</div>
<div class="line">    <span class="comment">// Less than 1s - extend or cancel</span></div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62">SocketTimer_cancel</a>(poll, deadline_timer);</div>
<div class="line">    <span class="comment">// Reschedule with longer delay</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Approximate: CLOCK_MONOTONIC query + expiry diff; may be negative internally but clamped &gt;=0 </dd>
<dd>
Overdue timers (negative remaining) return 0; firing pending in next poll_wait </dd>
<dd>
Useful for health checks, logging, or before/after callback timing </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not real-time precise; for critical timing use shorter intervals </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Invalidates assumption if called post-fire (use-after-invalid)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> Timer creation </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> Invalidates timer </dd>
<dd>
<a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7" title="Type for timer expiration callback functions.">SocketTimerCallback</a> Where expiry confirmed </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab4754362476e3ffc3e000b1cbcc2a6f0" name="gab4754362476e3ffc3e000b1cbcc2a6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4754362476e3ffc3e000b1cbcc2a6f0">&#9670;&#160;</a></span>SocketPoll_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketPoll_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketPoll operation failure exception. </p>
<p>Raised for various poll operation failures including backend creation, invalid socket operations, and resource exhaustion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#ga4b19847d604cdc5896376e694ee2a9c1" title="SocketError_categorize_errno - Classify errno into SocketErrorCategory.">SocketError_categorize_errno()</a> for <a class="el" href="SocketHappyEyeballs-private_8h.html#a11614f44ef4d939bdd984953346a7572">error</a> categorization. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163" title="SocketError_is_retryable_errno - Check if errno indicates retryable error.">SocketError_is_retryable_errno()</a> for retryability checking. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00235">main()</a>.</p>

</div>
</div>
<a id="ga2f0acf311c238671c6d9d14d4cc7c158" name="ga2f0acf311c238671c6d9d14d4cc7c158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0acf311c238671c6d9d14d4cc7c158">&#9670;&#160;</a></span>SocketTimer_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketTimer_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer subsystem operation failure. </p>
<p>Generic exception raised for all errors in timer operations, covering allocation failures, invalid parameters, heap inconsistencies, mutex errors, and capacity limits.</p>
<p>Provides consistent error handling via <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> mechanism. Catch with TRY/EXCEPT(SocketTimer_Failed). Detailed diagnostics via <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a>, <a class="el" href="group__foundation.html#ga46f8d730d28e8c5cbd55e3cbe4c83945" title="Socket_geterrorcode - Convert last errno to normalized SocketErrorCode.">Socket_geterrorcode()</a>, or errno.</p>
<h2><a class="anchor" id="autotoc_md225"></a>
Common Triggers</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Common Causes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SocketTimer_add / add_repeating   </td><td class="markdownTableBodyNone">Invalid delay/interval (&lt;0, &lt;min, &gt;max days), NULL poll/callback/userdata, memory allocation failure (arena), heap full (&gt;100k timers), mutex lock/init fail    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Internal heap ops   </td><td class="markdownTableBodyNone">Capacity overflow (rare, after many resizes), sift up/down violations (consistency error), ID wrap-around (unlikely)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Parameter validation   </td><td class="markdownTableBodyNone">Negative delays/intervals, excessive values clamped but logged; validation fails on bounds    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Threading   </td><td class="markdownTableBodyNone">pthread_mutex_lock/unlock failures (system resource exhaustion), race conditions in extreme concurrency    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">System   </td><td class="markdownTableBodyNone">CLOCK_MONOTONIC query fail (rare kernel issue), arithmetic overflow in expiry calc   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Extreme delays/intervals clamped to max (365 days) with warning log; does not raise but may affect precision. </dd>
<dd>
Non-blocking functions (cancel, remaining) return -1 instead of raising. </dd>
<dd>
Recoverable: Often retryable after freeing resources (e.g., cancel old timers).</dd></dl>
<h2><a class="anchor" id="autotoc_md226"></a>
Error Handling Example</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a> t = <a class="code hl_function" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65">SocketTimer_add</a>(poll, delay_ms, cb, ud);</div>
<div class="line">    <span class="comment">// Use timer...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__event__system.html#ga2f0acf311c238671c6d9d14d4cc7c158">SocketTimer_Failed</a>) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Timer add failed: %s (errno=%d)&quot;</span>, <a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>(), errno);</div>
<div class="line">    <span class="comment">// Handle: reduce delay, check params, free resources, retry or fallback</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163">SocketError_is_retryable_errno</a>(errno)) {</div>
<div class="line">        <span class="comment">// Exponential backoff retry logic</span></div>
<div class="line">    }</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketUtil_8h_html_a78065a32bc90c30a5d062b0b9ac88163"><div class="ttname"><a href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163">SocketError_is_retryable_errno</a></div><div class="ttdeci">int SocketError_is_retryable_errno(int err)</div><div class="ttdoc">SocketError_is_retryable_errno - Check if errno indicates retryable error.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga2537cebf106e583079ec472086a26d65" title="Add a one-shot timer to the event poll.">SocketTimer_add()</a> Creation entry points </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> Non-raising cancellation </dd>
<dd>
<a class="el" href="group__event__system.html#ga4c5519b89e0bba69f26d03b6893ba779" title="Query milliseconds remaining until timer expiry.">SocketTimer_remaining()</a> Non-raising query </dd>
<dd>
<a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> Structured exceptions </dd>
<dd>
<a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a> Detailed messages </dd>
<dd>
<a class="el" href="group__foundation.html#ga4b19847d604cdc5896376e694ee2a9c1" title="SocketError_categorize_errno - Classify errno into SocketErrorCategory.">SocketError_categorize_errno()</a> Classify system errors </dd>
<dd>
docs/ERROR_HANDLING.md Best practices for library errors </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> Compile-time limits tuning (e.g., <a class="el" href="group__event__system.html#ga53de6720fd3fc8accf99751c1e4e0d50" title="Maximum number of timers per heap.">SOCKET_MAX_TIMERS_PER_HEAP</a>) </dd></dl>

</div>
</div>
<a id="gac76e53ad178174f0f70747acfc5f83a2" name="gac76e53ad178174f0f70747acfc5f83a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac76e53ad178174f0f70747acfc5f83a2">&#9670;&#160;</a></span>stability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* Ensures ABI stability</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type alias macro enabling private struct definition. </p>
<p>Defines T as SocketPoll_T for use in private headers and .c files. Enables forward declaration and full struct definition in implementation while maintaining opaque type in public API (include/socket/SocketPoll.h).</p>
<p>Pattern: #define T Module_T; typedef struct T <em>T; /</em> private </p>

<p class="definition">Definition at line <a class="el" href="SocketPoll-private_8h_source.html#l00095">95</a> of file <a class="el" href="SocketPoll-private_8h_source.html">SocketPoll-private.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/>
<footer class="footer">
  <div style="max-width: 960px; margin: 0 auto; padding: 40px 24px;">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 40px;">
      <!-- Brand -->
      <div style="flex: 1; min-width: 200px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); border-radius: 6px;"></div>
          <span style="font-size: 1rem; font-weight: 600; color: #f7f9fa;">Socket Library</span>
        </div>
        <p style="color: #8b98a5; font-size: 0.8125rem; line-height: 1.6; margin: 0;">
          High-performance socket toolkit for POSIX systems with exception-based error handling and TLS 1.3 support.
        </p>
      </div>
      <!-- Links -->
      <div style="display: flex; gap: 48px; flex-wrap: wrap;">
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Documentation</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="index.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Getting Started</a></li>
            <li style="margin: 6px 0;"><a href="annotated.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Data Structures</a></li>
            <li style="margin: 6px 0;"><a href="globals.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">API Reference</a></li>
          </ul>
        </div>
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Resources</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="files.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Header Files</a></li>
            <li style="margin: 6px 0;"><a href="https://x.com/tetsuocorp" target="_blank" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Twitter/X</a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Bottom -->
    <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 0.75rem; font-weight: 500; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 4px 8px; border-radius: 4px;">C11</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 4px 8px; border-radius: 4px;">POSIX</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #8b5cf6; background: rgba(139, 92, 246, 0.1); padding: 4px 8px; border-radius: 4px;">TLS 1.3</span>
      </div>
      <div style="color: #6e7681; font-size: 0.75rem; display: flex; align-items: center; gap: 8px;">
        <span> 2025 Tetsuo Corporation</span>
        <span style="color: #30363d;"></span>
        <a href="https://opensource.org/licenses/MIT" target="_blank" style="color: #8b98a5; text-decoration: none;">MIT License</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
