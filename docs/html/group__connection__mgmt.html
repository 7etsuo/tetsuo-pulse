<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tetsuo Pulse: Connection Management Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="socket-brand.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Tetsuo Pulse<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance networking from Tetsuo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__connection__mgmt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Connection Management Modules</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> lifecycle management with pooling, reconnection, and resilience patterns.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Connection Management Modules:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__connection__mgmt.svg" width="555" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__reconnect__private" id="r_group__reconnect__private"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reconnect__private.html">SocketReconnect Private Implementation Details</a></td></tr>
<tr class="memdesc:group__reconnect__private"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structures and utilities for reconnection logic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketPool-private_8h" id="r_SocketPool-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPool-private_8h.html">SocketPool-private.h</a></td></tr>
<tr class="memdesc:SocketPool-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details and internal structures for SocketPool module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketPool_8h" id="r_SocketPool_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketPool_8h.html">SocketPool.h</a></td></tr>
<tr class="memdesc:SocketPool_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> pooling with automatic lifecycle management. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketReconnect-private_8h" id="r_SocketReconnect-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketReconnect-private_8h.html">SocketReconnect-private.h</a></td></tr>
<tr class="memdesc:SocketReconnect-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private header for SocketReconnect module internals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketReconnect_8h" id="r_SocketReconnect_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketReconnect_8h.html">SocketReconnect.h</a></td></tr>
<tr class="memdesc:SocketReconnect_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic reconnection framework for resilient TCP connections with backoff and circuit breaker patterns. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structConnection" id="r_structConnection"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#structConnection">Connection_T</a></td></tr>
<tr class="memdesc:structConnection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structure representing a pooled connection slot.  <a href="group__connection__mgmt.html#structConnection">More...</a><br /></td></tr>
<tr class="separator:structConnection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structAsyncConnectContext" id="r_structAsyncConnectContext"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#structAsyncConnectContext">AsyncConnectContext_T</a></td></tr>
<tr class="memdesc:structAsyncConnectContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal context structure for tracking asynchronous connect operations.  <a href="group__connection__mgmt.html#structAsyncConnectContext">More...</a><br /></td></tr>
<tr class="separator:structAsyncConnectContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketPool__Stats" id="r_structSocketPool__Stats"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#structSocketPool__Stats">SocketPool_Stats</a></td></tr>
<tr class="memdesc:structSocketPool__Stats"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool statistics snapshot structure.  <a href="group__connection__mgmt.html#structSocketPool__Stats">More...</a><br /></td></tr>
<tr class="separator:structSocketPool__Stats"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketReconnect__T" id="r_structSocketReconnect__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a></td></tr>
<tr class="memdesc:structSocketReconnect__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque internal context for reconnecting socket management.  <a href="group__reconnect__private.html#structSocketReconnect__T">More...</a><br /></td></tr>
<tr class="separator:structSocketReconnect__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketReconnect__Policy__T" id="r_structSocketReconnect__Policy__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a></td></tr>
<tr class="memdesc:structSocketReconnect__Policy__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure defining backoff policy, circuit breaker thresholds, and health check parameters for <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a>.  <a href="group__connection__mgmt.html#structSocketReconnect__Policy__T">More...</a><br /></td></tr>
<tr class="separator:structSocketReconnect__Policy__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa656899af348069271d2878e221b95e3" id="r_gaa656899af348069271d2878e221b95e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa656899af348069271d2878e221b95e3">SOCKET_DEFAULT_IDLE_TIMEOUT</a>&#160;&#160;&#160;300 /* 5 minutes */</td></tr>
<tr class="memdesc:gaa656899af348069271d2878e221b95e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default idle timeout.  <br /></td></tr>
<tr class="separator:gaa656899af348069271d2878e221b95e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab0335d59ba489638143cfcdbeb131c" id="r_ga2ab0335d59ba489638143cfcdbeb131c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2ab0335d59ba489638143cfcdbeb131c">SOCKET_DEFAULT_POOL_SIZE</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:ga2ab0335d59ba489638143cfcdbeb131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default connection pool size.  <br /></td></tr>
<tr class="separator:ga2ab0335d59ba489638143cfcdbeb131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae566ef3ebb6568218b7f7dbf8feea2c6" id="r_gae566ef3ebb6568218b7f7dbf8feea2c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae566ef3ebb6568218b7f7dbf8feea2c6">SOCKET_DEFAULT_POOL_BUFSIZE</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:gae566ef3ebb6568218b7f7dbf8feea2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default pool buffer size.  <br /></td></tr>
<tr class="separator:gae566ef3ebb6568218b7f7dbf8feea2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e9cd9dc6e5eabbe91e5fa71ec00b81" id="r_ga46e9cd9dc6e5eabbe91e5fa71ec00b81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga46e9cd9dc6e5eabbe91e5fa71ec00b81">SOCKET_POOL_DEFAULT_PREWARM_PCT</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:ga46e9cd9dc6e5eabbe91e5fa71ec00b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default pool prewarm percentage.  <br /></td></tr>
<tr class="separator:ga46e9cd9dc6e5eabbe91e5fa71ec00b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331e1002cf6dfb30695f5af41625cf46" id="r_ga331e1002cf6dfb30695f5af41625cf46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga331e1002cf6dfb30695f5af41625cf46">SOCKET_POOL_MAX_BATCH_ACCEPTS</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:ga331e1002cf6dfb30695f5af41625cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum batch accepts per iteration.  <br /></td></tr>
<tr class="separator:ga331e1002cf6dfb30695f5af41625cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34901523f9a628eab93a9f50bf70366" id="r_gae34901523f9a628eab93a9f50bf70366"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae34901523f9a628eab93a9f50bf70366">SOCKET_POOL_MAX_ASYNC_PENDING</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:gae34901523f9a628eab93a9f50bf70366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum pending async connect operations per pool.  <br /></td></tr>
<tr class="separator:gae34901523f9a628eab93a9f50bf70366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775d9db592e6205d00a2b6ad81bf3492" id="r_ga775d9db592e6205d00a2b6ad81bf3492"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga775d9db592e6205d00a2b6ad81bf3492">SOCKET_PERCENTAGE_DIVISOR</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga775d9db592e6205d00a2b6ad81bf3492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Percentage divisor for calculations.  <br /></td></tr>
<tr class="separator:ga775d9db592e6205d00a2b6ad81bf3492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d9e9b8f4116f114766da91e8dd0744" id="r_gaa6d9e9b8f4116f114766da91e8dd0744"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa6d9e9b8f4116f114766da91e8dd0744">SOCKET_POOL_STATS_WINDOW_SEC</a>&#160;&#160;&#160;60</td></tr>
<tr class="memdesc:gaa6d9e9b8f4116f114766da91e8dd0744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time window for pool statistics calculation.  <br /></td></tr>
<tr class="separator:gaa6d9e9b8f4116f114766da91e8dd0744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa74a3828cb86356140cb80cd1d0e688e" id="r_gaa74a3828cb86356140cb80cd1d0e688e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa74a3828cb86356140cb80cd1d0e688e">SOCKET_POOL_MAX_RATE_PER_SEC</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="memdesc:gaa74a3828cb86356140cb80cd1d0e688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum rate limit value (connections per second).  <br /></td></tr>
<tr class="separator:gaa74a3828cb86356140cb80cd1d0e688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea8374cf5055b8fe5b30a0f57b4405e" id="r_ga7ea8374cf5055b8fe5b30a0f57b4405e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga7ea8374cf5055b8fe5b30a0f57b4405e">SOCKET_POOL_MAX_BURST_MULTIPLIER</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga7ea8374cf5055b8fe5b30a0f57b4405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum burst multiplier relative to rate.  <br /></td></tr>
<tr class="separator:ga7ea8374cf5055b8fe5b30a0f57b4405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91891177acf4458552ad96ff6e2ae29e" id="r_ga91891177acf4458552ad96ff6e2ae29e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga91891177acf4458552ad96ff6e2ae29e">SOCKET_POOL_MAX_CONNECTIONS_PER_IP</a>&#160;&#160;&#160;10000</td></tr>
<tr class="memdesc:ga91891177acf4458552ad96ff6e2ae29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum connections allowed per IP address.  <br /></td></tr>
<tr class="separator:ga91891177acf4458552ad96ff6e2ae29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73d5adbdff8bd8738401ab2b2a7a9a3" id="r_gaa73d5adbdff8bd8738401ab2b2a7a9a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa73d5adbdff8bd8738401ab2b2a7a9a3">SOCKET_POOL_TOKENS_PER_ACCEPT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaa73d5adbdff8bd8738401ab2b2a7a9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokens consumed per connection accept.  <br /></td></tr>
<tr class="separator:gaa73d5adbdff8bd8738401ab2b2a7a9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae461bf5ddae6eda683926a6303af87f6" id="r_gae461bf5ddae6eda683926a6303af87f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae461bf5ddae6eda683926a6303af87f6">SOCKET_LOG_COMPONENT</a>&#160;&#160;&#160;&quot;SocketPool&quot;</td></tr>
<tr class="memdesc:gae461bf5ddae6eda683926a6303af87f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default log component for all SocketPool implementation files.  <br /></td></tr>
<tr class="separator:gae461bf5ddae6eda683926a6303af87f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019e030e52afae45ed11af4470267f3d" id="r_ga019e030e52afae45ed11af4470267f3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga019e030e52afae45ed11af4470267f3d">POOL_LOCK</a>(p)</td></tr>
<tr class="memdesc:ga019e030e52afae45ed11af4470267f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire pool mutex.  <br /></td></tr>
<tr class="separator:ga019e030e52afae45ed11af4470267f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab23175b8e98780e2f7f52a917e7d0862" id="r_gab23175b8e98780e2f7f52a917e7d0862"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab23175b8e98780e2f7f52a917e7d0862">POOL_UNLOCK</a>(p)</td></tr>
<tr class="memdesc:gab23175b8e98780e2f7f52a917e7d0862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release pool mutex.  <br /></td></tr>
<tr class="separator:gab23175b8e98780e2f7f52a917e7d0862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a354a257cb7d9a1f7cd2befa6d72d0f" id="r_ga4a354a257cb7d9a1f7cd2befa6d72d0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4a354a257cb7d9a1f7cd2befa6d72d0f">SOCKET_HASH_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td></tr>
<tr class="memdesc:ga4a354a257cb7d9a1f7cd2befa6d72d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the library's central hash table size configuration.  <br /></td></tr>
<tr class="separator:ga4a354a257cb7d9a1f7cd2befa6d72d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1430b907c84491b37ab7b18f7fd75a4" id="r_gaf1430b907c84491b37ab7b18f7fd75a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaf1430b907c84491b37ab7b18f7fd75a4">RAISE_POOL_ERROR</a>(exception)</td></tr>
<tr class="memdesc:gaf1430b907c84491b37ab7b18f7fd75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise exception with detailed error message.  <br /></td></tr>
<tr class="separator:gaf1430b907c84491b37ab7b18f7fd75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e22f6917e11a16763e27d6ec2a5ccb" id="r_gac9e22f6917e11a16763e27d6ec2a5ccb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gac9e22f6917e11a16763e27d6ec2a5ccb">RAISE_POOL_MSG</a>(exception,  fmt, ...)</td></tr>
<tr class="memdesc:gac9e22f6917e11a16763e27d6ec2a5ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format error message (without errno) and raise.  <br /></td></tr>
<tr class="separator:gac9e22f6917e11a16763e27d6ec2a5ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5125f82ee57c3f482b9371081caa3b0d" id="r_ga5125f82ee57c3f482b9371081caa3b0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga5125f82ee57c3f482b9371081caa3b0d">RAISE_POOL_FMT</a>(exception,  fmt, ...)</td></tr>
<tr class="memdesc:ga5125f82ee57c3f482b9371081caa3b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format error message (with errno) and raise.  <br /></td></tr>
<tr class="separator:ga5125f82ee57c3f482b9371081caa3b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core internal structure defining the complete SocketPool state.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level connection pool with lifecycle management.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb408f000a8df7938e79ddf2a1e26ae7" id="r_gacb408f000a8df7938e79ddf2a1e26ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gacb408f000a8df7938e79ddf2a1e26ae7">SOCKET_RECONNECT_ERROR_BUFSIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gacb408f000a8df7938e79ddf2a1e26ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum buffer capacity for internal error message strings.  <br /></td></tr>
<tr class="separator:gacb408f000a8df7938e79ddf2a1e26ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b81d768340db7dd2d315d1037f85c5e" id="r_ga2b81d768340db7dd2d315d1037f85c5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2b81d768340db7dd2d315d1037f85c5e">SOCKET_RECONNECT_MAX_HOST_LEN</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:ga2b81d768340db7dd2d315d1037f85c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length for target hostname/IP strings (excluding null terminator).  <br /></td></tr>
<tr class="separator:ga2b81d768340db7dd2d315d1037f85c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9a848b27d2034b028ceb2febdc6471b5" id="r_ga9a848b27d2034b028ceb2febdc6471b5"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9a848b27d2034b028ceb2febdc6471b5">SocketPool_ValidationCallback</a>) (Connection_T conn, void *data)</td></tr>
<tr class="memdesc:ga9a848b27d2034b028ceb2febdc6471b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to validate connection before reuse.  <br /></td></tr>
<tr class="separator:ga9a848b27d2034b028ceb2febdc6471b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec7b7f0dae3b1366f32f93294dc8b4a" id="r_ga6ec7b7f0dae3b1366f32f93294dc8b4a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga6ec7b7f0dae3b1366f32f93294dc8b4a">SocketPool_ResizeCallback</a>) (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, size_t old_size, size_t new_size, void *data)</td></tr>
<tr class="memdesc:ga6ec7b7f0dae3b1366f32f93294dc8b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked after pool resize.  <br /></td></tr>
<tr class="separator:ga6ec7b7f0dae3b1366f32f93294dc8b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f3ff7614b9968e5cc27f2017a0f058" id="r_ga18f3ff7614b9968e5cc27f2017a0f058"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga18f3ff7614b9968e5cc27f2017a0f058">SocketPool_IdleCallback</a>) (Connection_T conn, void *data)</td></tr>
<tr class="memdesc:ga18f3ff7614b9968e5cc27f2017a0f058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked when a connection becomes idle.  <br /></td></tr>
<tr class="separator:ga18f3ff7614b9968e5cc27f2017a0f058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1277558455541e0ec64e20bf8d21b71c" id="r_ga1277558455541e0ec64e20bf8d21b71c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c">SocketPool_Predicate</a>) (Connection_T conn, void *data)</td></tr>
<tr class="memdesc:ga1277558455541e0ec64e20bf8d21b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate callback for filtering connections.  <br /></td></tr>
<tr class="separator:ga1277558455541e0ec64e20bf8d21b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5441c8cf779cd74fbb9f39bd322c33bd" id="r_ga5441c8cf779cd74fbb9f39bd322c33bd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd">SocketPool_ConnectCallback</a>) (Connection_T conn, int error, void *data)</td></tr>
<tr class="memdesc:ga5441c8cf779cd74fbb9f39bd322c33bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for async connections.  <br /></td></tr>
<tr class="separator:ga5441c8cf779cd74fbb9f39bd322c33bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7679db7b1be62e465d9896944f3ad20" id="r_gad7679db7b1be62e465d9896944f3ad20"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gad7679db7b1be62e465d9896944f3ad20">SocketPool_DrainCallback</a>) (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int timed_out, void *data)</td></tr>
<tr class="memdesc:gad7679db7b1be62e465d9896944f3ad20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification callback when drain completes.  <br /></td></tr>
<tr class="separator:gad7679db7b1be62e465d9896944f3ad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4cc030dc9989344d20a170b6410220" id="r_ga0d4cc030dc9989344d20a170b6410220"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220">SocketReconnect_Callback</a>) (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, <a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> old_state, <a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> new_state, void *userdata)</td></tr>
<tr class="memdesc:ga0d4cc030dc9989344d20a170b6410220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback invoked on reconnection state transitions for monitoring and custom logic.  <br /></td></tr>
<tr class="separator:ga0d4cc030dc9989344d20a170b6410220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24b576ed367f734f434ef30ad8386c3" id="r_gae24b576ed367f734f434ef30ad8386c3"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3">SocketReconnect_HealthCheck</a>) (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, Socket_T socket, int timeout_ms, void *userdata)</td></tr>
<tr class="memdesc:gae24b576ed367f734f434ef30ad8386c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom health check callback to verify connection liveness beyond basic connectivity.  <br /></td></tr>
<tr class="separator:gae24b576ed367f734f434ef30ad8386c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae5f905ecace343c3b462dfadd5fa8056" id="r_gae5f905ecace343c3b462dfadd5fa8056"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056">SocketPool_State</a> { <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggae5f905ecace343c3b462dfadd5fa8056a6c2b7ace544a9999526d4314075694f5">POOL_STATE_RUNNING</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggae5f905ecace343c3b462dfadd5fa8056a24af61ac7dffa2f526a693507b11075b">POOL_STATE_DRAINING</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggae5f905ecace343c3b462dfadd5fa8056a937e01590410f41013603cedffd2d2d9">POOL_STATE_STOPPED</a>
<br />
 }</td></tr>
<tr class="memdesc:gae5f905ecace343c3b462dfadd5fa8056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool lifecycle states for graceful shutdown.  <a href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056">More...</a><br /></td></tr>
<tr class="separator:gae5f905ecace343c3b462dfadd5fa8056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c30d41df98c69bb394f0a91c3759ae" id="r_ga97c30d41df98c69bb394f0a91c3759ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae">SocketPool_Health</a> { <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga97c30d41df98c69bb394f0a91c3759aea42517e08f6d9119b5f96fe68b5623e2d">POOL_HEALTH_HEALTHY</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga97c30d41df98c69bb394f0a91c3759aea972a5e12c8d2b2b17477779aece54c74">POOL_HEALTH_DRAINING</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga97c30d41df98c69bb394f0a91c3759aea083eb1503d53d80d116c0ee25022b819">POOL_HEALTH_STOPPED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga97c30d41df98c69bb394f0a91c3759ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Health status for load balancer integration.  <a href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae">More...</a><br /></td></tr>
<tr class="separator:ga97c30d41df98c69bb394f0a91c3759ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92931382e16ec0f93619d6fe95c68fdf" id="r_ga92931382e16ec0f93619d6fe95c68fdf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf">SocketPool_ConnHealth</a> { <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga92931382e16ec0f93619d6fe95c68fdfa92d5c5da87579cc06fcbe3ff7f3c312e">POOL_CONN_HEALTHY</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga92931382e16ec0f93619d6fe95c68fdfae8b36f49ecaf54a76a78bed5a38da457">POOL_CONN_DISCONNECTED</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga92931382e16ec0f93619d6fe95c68fdfa6d7a0c62f6bf32b8e47f29eed6533f69">POOL_CONN_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#gga92931382e16ec0f93619d6fe95c68fdfa38972b76d931672d61056eea4fec704a">POOL_CONN_STALE</a>
<br />
 }</td></tr>
<tr class="memdesc:ga92931382e16ec0f93619d6fe95c68fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> health status enumeration.  <a href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf">More...</a><br /></td></tr>
<tr class="separator:ga92931382e16ec0f93619d6fe95c68fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94358cbf0bb7d00f70705a6c5245433" id="r_gad94358cbf0bb7d00f70705a6c5245433"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gad94358cbf0bb7d00f70705a6c5245433">SocketReconnect_CircuitState</a> { <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggad94358cbf0bb7d00f70705a6c5245433a12c918198345e8aefaaabab17a21f9bf">CIRCUIT_CLOSED</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e">CIRCUIT_OPEN</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggad94358cbf0bb7d00f70705a6c5245433a41651f787427ec87c589c4c5c912a6f9">CIRCUIT_HALF_OPEN</a>
<br />
 }</td></tr>
<tr class="memdesc:gad94358cbf0bb7d00f70705a6c5245433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal circuit breaker states for reconnection resilience.  <a href="group__connection__mgmt.html#gad94358cbf0bb7d00f70705a6c5245433">More...</a><br /></td></tr>
<tr class="separator:gad94358cbf0bb7d00f70705a6c5245433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f7f9254ebc5d681f058d6b2c26f548" id="r_gab0f7f9254ebc5d681f058d6b2c26f548"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> { <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548aad8113419cbfb25276d1139df9831611">RECONNECT_DISCONNECTED</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548aa8ce7a5b74cbcbbaf91d733e39ec0c07">RECONNECT_CONNECTING</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1">RECONNECT_CONNECTED</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548a32ae482a193f2b27c73f934837a458a6">RECONNECT_BACKOFF</a>
, <br />
&#160;&#160;<a class="el" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db">RECONNECT_CIRCUIT_OPEN</a>
<br />
 }</td></tr>
<tr class="memdesc:gab0f7f9254ebc5d681f058d6b2c26f548"><td class="mdescLeft">&#160;</td><td class="mdescRight">States of the reconnection state machine for tracking connection lifecycle and backoff status.  <a href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">More...</a><br /></td></tr>
<tr class="separator:gab0f7f9254ebc5d681f058d6b2c26f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga88ab86be313053fde04989b904bb957a" id="r_ga88ab86be313053fde04989b904bb957a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga88ab86be313053fde04989b904bb957a">SocketPool_connections_initialize_slot</a> (struct <a class="el" href="group__connection__mgmt.html#structConnection">Connection</a> *conn)</td></tr>
<tr class="memdesc:ga88ab86be313053fde04989b904bb957a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and zero-initialize array of connection structures.  <br /></td></tr>
<tr class="separator:ga88ab86be313053fde04989b904bb957a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0baf2c21ed54520dcaab3460a9a987f7" id="r_ga0baf2c21ed54520dcaab3460a9a987f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0baf2c21ed54520dcaab3460a9a987f7">SocketPool_connections_alloc_buffers</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, size_t bufsize, Connection_T conn)</td></tr>
<tr class="memdesc:ga0baf2c21ed54520dcaab3460a9a987f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate input/output buffers for connection.  <br /></td></tr>
<tr class="separator:ga0baf2c21ed54520dcaab3460a9a987f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344c2ab8a3e0b099bd74e65cc97cb66f" id="r_ga344c2ab8a3e0b099bd74e65cc97cb66f"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga344c2ab8a3e0b099bd74e65cc97cb66f">find_slot</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const Socket_T socket)</td></tr>
<tr class="memdesc:ga344c2ab8a3e0b099bd74e65cc97cb66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find connection slot by socket (internal).  <br /></td></tr>
<tr class="separator:ga344c2ab8a3e0b099bd74e65cc97cb66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga122ba4bb8b8c2ed5400b544deefe8903" id="r_ga122ba4bb8b8c2ed5400b544deefe8903"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga122ba4bb8b8c2ed5400b544deefe8903">find_free_slot</a> (const <a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga122ba4bb8b8c2ed5400b544deefe8903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first available free connection slot.  <br /></td></tr>
<tr class="separator:ga122ba4bb8b8c2ed5400b544deefe8903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4e8594fc75b148281c6b7874c279d3" id="r_gaae4e8594fc75b148281c6b7874c279d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaae4e8594fc75b148281c6b7874c279d3">check_pool_full</a> (const <a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gaae4e8594fc75b148281c6b7874c279d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if pool has reached maximum capacity.  <br /></td></tr>
<tr class="separator:gaae4e8594fc75b148281c6b7874c279d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3db0f18f008462c96cd8dc85be8c40" id="r_ga8d3db0f18f008462c96cd8dc85be8c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8d3db0f18f008462c96cd8dc85be8c40">remove_from_free_list</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn)</td></tr>
<tr class="memdesc:ga8d3db0f18f008462c96cd8dc85be8c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove connection from free list.  <br /></td></tr>
<tr class="separator:ga8d3db0f18f008462c96cd8dc85be8c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7024a2a77a04587e061d67a1172cdbfc" id="r_ga7024a2a77a04587e061d67a1172cdbfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga7024a2a77a04587e061d67a1172cdbfc">return_to_free_list</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn)</td></tr>
<tr class="memdesc:ga7024a2a77a04587e061d67a1172cdbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return connection to free list.  <br /></td></tr>
<tr class="separator:ga7024a2a77a04587e061d67a1172cdbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7821321479544a6e24fb4c2946e22c60" id="r_ga7821321479544a6e24fb4c2946e22c60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga7821321479544a6e24fb4c2946e22c60">prepare_free_slot</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn)</td></tr>
<tr class="memdesc:ga7821321479544a6e24fb4c2946e22c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare free slot for new connection.  <br /></td></tr>
<tr class="separator:ga7821321479544a6e24fb4c2946e22c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1541da7f1233af52ca75bb932074851" id="r_gae1541da7f1233af52ca75bb932074851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae1541da7f1233af52ca75bb932074851">update_existing_slot</a> (Connection_T conn, time_t now)</td></tr>
<tr class="memdesc:gae1541da7f1233af52ca75bb932074851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update existing connection slot activity.  <br /></td></tr>
<tr class="separator:gae1541da7f1233af52ca75bb932074851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac073c8a892a77bae682cec8398d10518" id="r_gac073c8a892a77bae682cec8398d10518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518">insert_into_hash_table</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn, Socket_T socket)</td></tr>
<tr class="memdesc:gac073c8a892a77bae682cec8398d10518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert connection into hash table.  <br /></td></tr>
<tr class="separator:gac073c8a892a77bae682cec8398d10518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5426648c6c6a14ebaff48ee2160856c3" id="r_ga5426648c6c6a14ebaff48ee2160856c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga5426648c6c6a14ebaff48ee2160856c3">increment_pool_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga5426648c6c6a14ebaff48ee2160856c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment active connection count.  <br /></td></tr>
<tr class="separator:ga5426648c6c6a14ebaff48ee2160856c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c55ecf49e5103925192159127088241" id="r_ga6c55ecf49e5103925192159127088241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga6c55ecf49e5103925192159127088241">initialize_connection</a> (Connection_T conn, Socket_T socket, time_t now)</td></tr>
<tr class="memdesc:ga6c55ecf49e5103925192159127088241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize connection with socket and timestamp.  <br /></td></tr>
<tr class="separator:ga6c55ecf49e5103925192159127088241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5693c260bb02fb1c779d497b35eb6db" id="r_gae5693c260bb02fb1c779d497b35eb6db"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae5693c260bb02fb1c779d497b35eb6db">find_or_create_slot</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T socket, time_t now)</td></tr>
<tr class="memdesc:gae5693c260bb02fb1c779d497b35eb6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find existing connection or create new slot.  <br /></td></tr>
<tr class="separator:gae5693c260bb02fb1c779d497b35eb6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9710c881ae321ed9da843ca815ca0733" id="r_ga9710c881ae321ed9da843ca815ca0733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9710c881ae321ed9da843ca815ca0733">remove_from_hash_table</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn, Socket_T socket)</td></tr>
<tr class="memdesc:ga9710c881ae321ed9da843ca815ca0733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove connection from hash table.  <br /></td></tr>
<tr class="separator:ga9710c881ae321ed9da843ca815ca0733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf51388d2a06f1d1b1caa4d55fe29159" id="r_gacf51388d2a06f1d1b1caa4d55fe29159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gacf51388d2a06f1d1b1caa4d55fe29159">SocketPool_connections_reset_slot</a> (Connection_T conn)</td></tr>
<tr class="memdesc:gacf51388d2a06f1d1b1caa4d55fe29159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Securely clear (zero) connection's input/output buffers.  <br /></td></tr>
<tr class="separator:gacf51388d2a06f1d1b1caa4d55fe29159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5374f9969a32eb12ea7794b1f1a20d77" id="r_ga5374f9969a32eb12ea7794b1f1a20d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga5374f9969a32eb12ea7794b1f1a20d77">decrement_pool_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga5374f9969a32eb12ea7794b1f1a20d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement active connection count.  <br /></td></tr>
<tr class="separator:ga5374f9969a32eb12ea7794b1f1a20d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e4d3464b3def2864e59849788aaf11" id="r_ga93e4d3464b3def2864e59849788aaf11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga93e4d3464b3def2864e59849788aaf11">validate_saved_session</a> (Connection_T conn, time_t now)</td></tr>
<tr class="memdesc:ga93e4d3464b3def2864e59849788aaf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate TLS session for reuse.  <br /></td></tr>
<tr class="separator:ga93e4d3464b3def2864e59849788aaf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eec83919427223173cdaae6f1b36b8a" id="r_ga3eec83919427223173cdaae6f1b36b8a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a">socketpool_hash</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga3eec83919427223173cdaae6f1b36b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate temporary buffer for bulk cleanup operations from arena.  <br /></td></tr>
<tr class="separator:ga3eec83919427223173cdaae6f1b36b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8dfea746f7edd426d43574e437ffc7" id="r_gaab8dfea746f7edd426d43574e437ffc7"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaab8dfea746f7edd426d43574e437ffc7">safe_time</a> (void)</td></tr>
<tr class="memdesc:gaab8dfea746f7edd426d43574e437ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current time with error handling.  <br /></td></tr>
<tr class="separator:gaab8dfea746f7edd426d43574e437ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c16fe70b77643b386b314b1c5e23575" id="r_ga0c16fe70b77643b386b314b1c5e23575"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0c16fe70b77643b386b314b1c5e23575">socketpool_enforce_range</a> (size_t val, size_t minv, size_t maxv)</td></tr>
<tr class="memdesc:ga0c16fe70b77643b386b314b1c5e23575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp value to min/max bounds.  <br /></td></tr>
<tr class="separator:ga0c16fe70b77643b386b314b1c5e23575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63eed07eef58937549d0d7139d869189" id="r_ga63eed07eef58937549d0d7139d869189"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga63eed07eef58937549d0d7139d869189">socketpool_enforce_max_connections</a> (size_t maxconns)</td></tr>
<tr class="memdesc:ga63eed07eef58937549d0d7139d869189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce maximum connection limit.  <br /></td></tr>
<tr class="separator:ga63eed07eef58937549d0d7139d869189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f4277a3a98a8ce25680796876e17a9" id="r_gaf2f4277a3a98a8ce25680796876e17a9"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaf2f4277a3a98a8ce25680796876e17a9">socketpool_enforce_buffer_size</a> (size_t bufsize)</td></tr>
<tr class="memdesc:gaf2f4277a3a98a8ce25680796876e17a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce buffer size limits.  <br /></td></tr>
<tr class="separator:gaf2f4277a3a98a8ce25680796876e17a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2774ba952af4a9a218e33b492aed1a18" id="r_ga2774ba952af4a9a218e33b492aed1a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18">SocketPool_new</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, size_t maxconns, size_t bufsize)</td></tr>
<tr class="memdesc:ga2774ba952af4a9a218e33b492aed1a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new connection pool.  <br /></td></tr>
<tr class="separator:ga2774ba952af4a9a218e33b492aed1a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef36179b23774c639bb9fd68a99001c7" id="r_gaef36179b23774c639bb9fd68a99001c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaef36179b23774c639bb9fd68a99001c7">SocketPool_prepare_connection</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *host, int port, Socket_T *out_socket, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> *out_req)</td></tr>
<tr class="memdesc:gaef36179b23774c639bb9fd68a99001c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare async connection using DNS resolution.  <br /></td></tr>
<tr class="separator:gaef36179b23774c639bb9fd68a99001c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb57544a14c977302953fd36634bd004" id="r_gafb57544a14c977302953fd36634bd004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004">SocketPool_free</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> *pool)</td></tr>
<tr class="memdesc:gafb57544a14c977302953fd36634bd004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a connection pool and release all resources.  <br /></td></tr>
<tr class="separator:gafb57544a14c977302953fd36634bd004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaca1689f64e0266f4b3366e99bcb766" id="r_gabaca1689f64e0266f4b3366e99bcb766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766">SocketPool_connect_async</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const char *host, int port, <a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd">SocketPool_ConnectCallback</a> callback, void *data)</td></tr>
<tr class="memdesc:gabaca1689f64e0266f4b3366e99bcb766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create async connection to remote host.  <br /></td></tr>
<tr class="separator:gabaca1689f64e0266f4b3366e99bcb766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b17f01e3036b53fed194c6b3c0b95f" id="r_ga21b17f01e3036b53fed194c6b3c0b95f"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f">SocketPool_get</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T socket)</td></tr>
<tr class="memdesc:ga21b17f01e3036b53fed194c6b3c0b95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve Connection_T wrapper for a socket in the pool.  <br /></td></tr>
<tr class="separator:ga21b17f01e3036b53fed194c6b3c0b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7720c7b7d679624fa95bdefe9a38494" id="r_gac7720c7b7d679624fa95bdefe9a38494"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494">SocketPool_add</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T socket)</td></tr>
<tr class="memdesc:gac7720c7b7d679624fa95bdefe9a38494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a connected socket to the pool, creating a Connection_T wrapper.  <br /></td></tr>
<tr class="separator:gac7720c7b7d679624fa95bdefe9a38494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283d343a8192530c349dc9a02b987c26" id="r_ga283d343a8192530c349dc9a02b987c26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga283d343a8192530c349dc9a02b987c26">SocketPool_accept_batch</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T server, int max_accepts, size_t accepted_capacity, Socket_T *accepted)</td></tr>
<tr class="memdesc:ga283d343a8192530c349dc9a02b987c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept multiple connections from server socket.  <br /></td></tr>
<tr class="separator:ga283d343a8192530c349dc9a02b987c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdffcf1802367df60db15c649fc7072d" id="r_gacdffcf1802367df60db15c649fc7072d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d">SocketPool_remove</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T socket)</td></tr>
<tr class="memdesc:gacdffcf1802367df60db15c649fc7072d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove socket from pool.  <br /></td></tr>
<tr class="separator:gacdffcf1802367df60db15c649fc7072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a7df0479b8f9ac899672afdb488b94" id="r_gab2a7df0479b8f9ac899672afdb488b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94">SocketPool_cleanup</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, time_t idle_timeout)</td></tr>
<tr class="memdesc:gab2a7df0479b8f9ac899672afdb488b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove idle connections.  <br /></td></tr>
<tr class="separator:gab2a7df0479b8f9ac899672afdb488b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618413d296dac8730047cf248273461e" id="r_ga618413d296dac8730047cf248273461e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga618413d296dac8730047cf248273461e">SocketPool_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga618413d296dac8730047cf248273461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get active connection count.  <br /></td></tr>
<tr class="separator:ga618413d296dac8730047cf248273461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d2acf643422a026241225f245f8d26" id="r_gae7d2acf643422a026241225f245f8d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26">SocketPool_resize</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, size_t new_maxconns)</td></tr>
<tr class="memdesc:gae7d2acf643422a026241225f245f8d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize pool capacity at runtime.  <br /></td></tr>
<tr class="separator:gae7d2acf643422a026241225f245f8d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8363470d36d9cac714f087b8dcb1a048" id="r_ga8363470d36d9cac714f087b8dcb1a048"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8363470d36d9cac714f087b8dcb1a048">SocketPool_prewarm</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int percentage)</td></tr>
<tr class="memdesc:ga8363470d36d9cac714f087b8dcb1a048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-allocate buffers for percentage of free slots.  <br /></td></tr>
<tr class="separator:ga8363470d36d9cac714f087b8dcb1a048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ad1fb6ad736f4169297af3fd255410" id="r_ga83ad1fb6ad736f4169297af3fd255410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga83ad1fb6ad736f4169297af3fd255410">SocketPool_set_bufsize</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, size_t new_bufsize)</td></tr>
<tr class="memdesc:ga83ad1fb6ad736f4169297af3fd255410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer size for future connections.  <br /></td></tr>
<tr class="separator:ga83ad1fb6ad736f4169297af3fd255410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ffb3b44d5214daeed16af0c4cae08c" id="r_gab6ffb3b44d5214daeed16af0c4cae08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab6ffb3b44d5214daeed16af0c4cae08c">SocketPool_foreach</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, void(*func)(Connection_T, void *), void *arg)</td></tr>
<tr class="memdesc:gab6ffb3b44d5214daeed16af0c4cae08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over active connections.  <br /></td></tr>
<tr class="separator:gab6ffb3b44d5214daeed16af0c4cae08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3180e20634cf447edc962d5cdbf7253f" id="r_ga3180e20634cf447edc962d5cdbf7253f"><td class="memItemLeft" align="right" valign="top">Connection_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f">SocketPool_find</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c">SocketPool_Predicate</a> predicate, void *userdata)</td></tr>
<tr class="memdesc:ga3180e20634cf447edc962d5cdbf7253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first connection matching a predicate.  <br /></td></tr>
<tr class="separator:ga3180e20634cf447edc962d5cdbf7253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90825b0b38b8aa9afef5fc1d63458dac" id="r_ga90825b0b38b8aa9afef5fc1d63458dac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac">SocketPool_filter</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c">SocketPool_Predicate</a> predicate, void *userdata, Connection_T *results, size_t max_results)</td></tr>
<tr class="memdesc:ga90825b0b38b8aa9afef5fc1d63458dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all connections matching a predicate.  <br /></td></tr>
<tr class="separator:ga90825b0b38b8aa9afef5fc1d63458dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeff7efb1109a312f56e35689b67c652" id="r_gaaeff7efb1109a312f56e35689b67c652"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:gaaeff7efb1109a312f56e35689b67c652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection's socket.  <br /></td></tr>
<tr class="separator:gaaeff7efb1109a312f56e35689b67c652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24170577512ce3a19fe195ab9c3576bf" id="r_ga24170577512ce3a19fe195ab9c3576bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf">Connection_inbuf</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga24170577512ce3a19fe195ab9c3576bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection's input buffer.  <br /></td></tr>
<tr class="separator:ga24170577512ce3a19fe195ab9c3576bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7573f71d8853943029cfd55fa3fb3a" id="r_ga6d7573f71d8853943029cfd55fa3fb3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga6d7573f71d8853943029cfd55fa3fb3a">Connection_outbuf</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga6d7573f71d8853943029cfd55fa3fb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection's output buffer.  <br /></td></tr>
<tr class="separator:ga6d7573f71d8853943029cfd55fa3fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1faf8c706d1ed9418446fc155fa289dd" id="r_ga1faf8c706d1ed9418446fc155fa289dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga1faf8c706d1ed9418446fc155fa289dd">Connection_data</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga1faf8c706d1ed9418446fc155fa289dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection's user data.  <br /></td></tr>
<tr class="separator:ga1faf8c706d1ed9418446fc155fa289dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48a53bc1b36954d521104fedf9012c1" id="r_gab48a53bc1b36954d521104fedf9012c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1">Connection_setdata</a> (Connection_T conn, void *data)</td></tr>
<tr class="memdesc:gab48a53bc1b36954d521104fedf9012c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connection's user data.  <br /></td></tr>
<tr class="separator:gab48a53bc1b36954d521104fedf9012c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68397aca39e8902ee26108dcb86b5db1" id="r_ga68397aca39e8902ee26108dcb86b5db1"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1">Connection_lastactivity</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga68397aca39e8902ee26108dcb86b5db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection's last activity timestamp.  <br /></td></tr>
<tr class="separator:ga68397aca39e8902ee26108dcb86b5db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52bba490d68b2dd5448a61a1cc820a1" id="r_gaf52bba490d68b2dd5448a61a1cc820a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaf52bba490d68b2dd5448a61a1cc820a1">Connection_isactive</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:gaf52bba490d68b2dd5448a61a1cc820a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if connection is active.  <br /></td></tr>
<tr class="separator:gaf52bba490d68b2dd5448a61a1cc820a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b6b07007da08326b53c069a4c1f2ea" id="r_gae4b6b07007da08326b53c069a4c1f2ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae4b6b07007da08326b53c069a4c1f2ea">SocketPool_set_reconnect_policy</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *policy)</td></tr>
<tr class="memdesc:gae4b6b07007da08326b53c069a4c1f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default reconnection policy for pool.  <br /></td></tr>
<tr class="separator:gae4b6b07007da08326b53c069a4c1f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ef5658ee53e87337b931b549ff35f2" id="r_ga94ef5658ee53e87337b931b549ff35f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2">SocketPool_enable_reconnect</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn, const char *host, int port)</td></tr>
<tr class="memdesc:ga94ef5658ee53e87337b931b549ff35f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable auto-reconnect for a connection.  <br /></td></tr>
<tr class="separator:ga94ef5658ee53e87337b931b549ff35f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be3d82708a40f4d7601737467cdd51a" id="r_ga7be3d82708a40f4d7601737467cdd51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga7be3d82708a40f4d7601737467cdd51a">SocketPool_disable_reconnect</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn)</td></tr>
<tr class="memdesc:ga7be3d82708a40f4d7601737467cdd51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable auto-reconnect for a connection.  <br /></td></tr>
<tr class="separator:ga7be3d82708a40f4d7601737467cdd51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817b53044890ea7978afb73f51584bce" id="r_ga817b53044890ea7978afb73f51584bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga817b53044890ea7978afb73f51584bce">SocketPool_process_reconnects</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga817b53044890ea7978afb73f51584bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process reconnection state machines.  <br /></td></tr>
<tr class="separator:ga817b53044890ea7978afb73f51584bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bfa04a134354dcebd077ea54dbb2d9e" id="r_ga4bfa04a134354dcebd077ea54dbb2d9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4bfa04a134354dcebd077ea54dbb2d9e">SocketPool_reconnect_timeout_ms</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga4bfa04a134354dcebd077ea54dbb2d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time until next reconnection action.  <br /></td></tr>
<tr class="separator:ga4bfa04a134354dcebd077ea54dbb2d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea55ad82560acb8b5b44dceebc7c02f" id="r_ga0ea55ad82560acb8b5b44dceebc7c02f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0ea55ad82560acb8b5b44dceebc7c02f">Connection_reconnect</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga0ea55ad82560acb8b5b44dceebc7c02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reconnection context for connection.  <br /></td></tr>
<tr class="separator:ga0ea55ad82560acb8b5b44dceebc7c02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548e5fadc02daadb2388d09bf8aec167" id="r_ga548e5fadc02daadb2388d09bf8aec167"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga548e5fadc02daadb2388d09bf8aec167">Connection_has_reconnect</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:ga548e5fadc02daadb2388d09bf8aec167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if connection has auto-reconnect enabled.  <br /></td></tr>
<tr class="separator:ga548e5fadc02daadb2388d09bf8aec167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204d43047f820499ae59b7984f00b148" id="r_ga204d43047f820499ae59b7984f00b148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148">SocketPool_setconnrate</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int conns_per_sec, int burst)</td></tr>
<tr class="memdesc:ga204d43047f820499ae59b7984f00b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connection rate limit.  <br /></td></tr>
<tr class="separator:ga204d43047f820499ae59b7984f00b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0d9937eb377068134cab141b8bcfad" id="r_gadc0d9937eb377068134cab141b8bcfad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gadc0d9937eb377068134cab141b8bcfad">SocketPool_getconnrate</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gadc0d9937eb377068134cab141b8bcfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection rate limit.  <br /></td></tr>
<tr class="separator:gadc0d9937eb377068134cab141b8bcfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8991c65cdec81d2a8db01a2f820a42b" id="r_gaf8991c65cdec81d2a8db01a2f820a42b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b">SocketPool_setmaxperip</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int max_conns)</td></tr>
<tr class="memdesc:gaf8991c65cdec81d2a8db01a2f820a42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum connections per IP.  <br /></td></tr>
<tr class="separator:gaf8991c65cdec81d2a8db01a2f820a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952bad4a5d699878fef42407a1260cfe" id="r_ga952bad4a5d699878fef42407a1260cfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga952bad4a5d699878fef42407a1260cfe">SocketPool_getmaxperip</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga952bad4a5d699878fef42407a1260cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum connections per IP.  <br /></td></tr>
<tr class="separator:ga952bad4a5d699878fef42407a1260cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8b8b6c2075b758c5c85426194c2539" id="r_gaac8b8b6c2075b758c5c85426194c2539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaac8b8b6c2075b758c5c85426194c2539">SocketPool_accept_allowed</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const char *client_ip)</td></tr>
<tr class="memdesc:gaac8b8b6c2075b758c5c85426194c2539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if accepting is allowed.  <br /></td></tr>
<tr class="separator:gaac8b8b6c2075b758c5c85426194c2539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8219ceff615ad4a4064cf389f137a6" id="r_gabd8219ceff615ad4a4064cf389f137a6"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6">SocketPool_accept_limited</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T server)</td></tr>
<tr class="memdesc:gabd8219ceff615ad4a4064cf389f137a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connection with rate limiting.  <br /></td></tr>
<tr class="separator:gabd8219ceff615ad4a4064cf389f137a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b0182834888e8b3136846f5fca1bc64" id="r_ga9b0182834888e8b3136846f5fca1bc64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9b0182834888e8b3136846f5fca1bc64">SocketPool_track_ip</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const char *ip)</td></tr>
<tr class="memdesc:ga9b0182834888e8b3136846f5fca1bc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually track IP for per-IP limiting.  <br /></td></tr>
<tr class="separator:ga9b0182834888e8b3136846f5fca1bc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930ce5b0eddb884de4c8514e4d6068c4" id="r_ga930ce5b0eddb884de4c8514e4d6068c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4">SocketPool_release_ip</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const char *ip)</td></tr>
<tr class="memdesc:ga930ce5b0eddb884de4c8514e4d6068c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release tracked IP when connection closes.  <br /></td></tr>
<tr class="separator:ga930ce5b0eddb884de4c8514e4d6068c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0da0754ae023a89aee4b96a4e50845" id="r_gace0da0754ae023a89aee4b96a4e50845"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gace0da0754ae023a89aee4b96a4e50845">SocketPool_ip_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, const char *ip)</td></tr>
<tr class="memdesc:gace0da0754ae023a89aee4b96a4e50845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection count for IP.  <br /></td></tr>
<tr class="separator:gace0da0754ae023a89aee4b96a4e50845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847e3ae8d165d8a999ef76a68d21ffa5" id="r_ga847e3ae8d165d8a999ef76a68d21ffa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga847e3ae8d165d8a999ef76a68d21ffa5">SocketPool_set_syn_protection</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__security.html#structSocketSYNProtect__T">SocketSYNProtect_T</a> protect)</td></tr>
<tr class="memdesc:ga847e3ae8d165d8a999ef76a68d21ffa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable SYN flood protection for pool.  <br /></td></tr>
<tr class="separator:ga847e3ae8d165d8a999ef76a68d21ffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9047fb0f2c05a4f208c023b5e81196e3" id="r_ga9047fb0f2c05a4f208c023b5e81196e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__security.html#structSocketSYNProtect__T">SocketSYNProtect_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9047fb0f2c05a4f208c023b5e81196e3">SocketPool_get_syn_protection</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga9047fb0f2c05a4f208c023b5e81196e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current SYN protection module.  <br /></td></tr>
<tr class="separator:ga9047fb0f2c05a4f208c023b5e81196e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899c660b21bf96befd2b5ea9f6937988" id="r_ga899c660b21bf96befd2b5ea9f6937988"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga899c660b21bf96befd2b5ea9f6937988">SocketPool_accept_protected</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Socket_T server, <a class="el" href="group__security.html#gaca8f2a71ab649ccd408fd3fdb3b693b9">SocketSYN_Action</a> *action_out)</td></tr>
<tr class="memdesc:ga899c660b21bf96befd2b5ea9f6937988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept with full SYN flood protection.  <br /></td></tr>
<tr class="separator:ga899c660b21bf96befd2b5ea9f6937988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a62267ba3008f826b6952624dbc6a29" id="r_ga0a62267ba3008f826b6952624dbc6a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056">SocketPool_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0a62267ba3008f826b6952624dbc6a29">SocketPool_state</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga0a62267ba3008f826b6952624dbc6a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current pool lifecycle state.  <br /></td></tr>
<tr class="separator:ga0a62267ba3008f826b6952624dbc6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac801c2d9c4fd944334de2a551993bd89" id="r_gac801c2d9c4fd944334de2a551993bd89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae">SocketPool_Health</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gac801c2d9c4fd944334de2a551993bd89">SocketPool_health</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gac801c2d9c4fd944334de2a551993bd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pool health status for load balancers.  <br /></td></tr>
<tr class="separator:gac801c2d9c4fd944334de2a551993bd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5245d1cd6578a86f1045529d07fe511c" id="r_ga5245d1cd6578a86f1045529d07fe511c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga5245d1cd6578a86f1045529d07fe511c">SocketPool_is_draining</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga5245d1cd6578a86f1045529d07fe511c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if pool is currently draining.  <br /></td></tr>
<tr class="separator:ga5245d1cd6578a86f1045529d07fe511c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee3c9502d314b58f9eba33827dd28cf" id="r_ga6ee3c9502d314b58f9eba33827dd28cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga6ee3c9502d314b58f9eba33827dd28cf">SocketPool_is_stopped</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga6ee3c9502d314b58f9eba33827dd28cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if pool is fully stopped.  <br /></td></tr>
<tr class="separator:ga6ee3c9502d314b58f9eba33827dd28cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24cd4e2f757497906a5aef89b133b068" id="r_ga24cd4e2f757497906a5aef89b133b068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068">SocketPool_drain</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int timeout_ms)</td></tr>
<tr class="memdesc:ga24cd4e2f757497906a5aef89b133b068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate graceful shutdown.  <br /></td></tr>
<tr class="separator:ga24cd4e2f757497906a5aef89b133b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbe6c95119cbb4b30f981b9d07f3e9b" id="r_ga2cbe6c95119cbb4b30f981b9d07f3e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b">SocketPool_drain_poll</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga2cbe6c95119cbb4b30f981b9d07f3e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll drain progress (non-blocking).  <br /></td></tr>
<tr class="separator:ga2cbe6c95119cbb4b30f981b9d07f3e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14b85a2cd7a0a4302f84478840cfb23" id="r_gae14b85a2cd7a0a4302f84478840cfb23"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae14b85a2cd7a0a4302f84478840cfb23">SocketPool_drain_remaining_ms</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gae14b85a2cd7a0a4302f84478840cfb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time until forced shutdown.  <br /></td></tr>
<tr class="separator:gae14b85a2cd7a0a4302f84478840cfb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cbc1088d796c166f582de4d17e5d968" id="r_ga0cbc1088d796c166f582de4d17e5d968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0cbc1088d796c166f582de4d17e5d968">SocketPool_drain_force</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga0cbc1088d796c166f582de4d17e5d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force immediate shutdown.  <br /></td></tr>
<tr class="separator:ga0cbc1088d796c166f582de4d17e5d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0fdd6e4245f2844081d935b2d3c8a2" id="r_ga3f0fdd6e4245f2844081d935b2d3c8a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3f0fdd6e4245f2844081d935b2d3c8a2">SocketPool_drain_wait</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int timeout_ms)</td></tr>
<tr class="memdesc:ga3f0fdd6e4245f2844081d935b2d3c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking drain with internal poll loop.  <br /></td></tr>
<tr class="separator:ga3f0fdd6e4245f2844081d935b2d3c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254e5c125de7413e1fa2a8809350d4e0" id="r_ga254e5c125de7413e1fa2a8809350d4e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga254e5c125de7413e1fa2a8809350d4e0">SocketPool_set_drain_callback</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#gad7679db7b1be62e465d9896944f3ad20">SocketPool_DrainCallback</a> cb, void *data)</td></tr>
<tr class="memdesc:ga254e5c125de7413e1fa2a8809350d4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register drain completion callback.  <br /></td></tr>
<tr class="separator:ga254e5c125de7413e1fa2a8809350d4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76151bb579f44bdf79aeca57dbd8122e" id="r_ga76151bb579f44bdf79aeca57dbd8122e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e">SocketPool_set_idle_timeout</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, time_t timeout_sec)</td></tr>
<tr class="memdesc:ga76151bb579f44bdf79aeca57dbd8122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set idle connection timeout.  <br /></td></tr>
<tr class="separator:ga76151bb579f44bdf79aeca57dbd8122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee19a772a9cf21b2c50fd1deec498b0b" id="r_gaee19a772a9cf21b2c50fd1deec498b0b"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaee19a772a9cf21b2c50fd1deec498b0b">SocketPool_get_idle_timeout</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gaee19a772a9cf21b2c50fd1deec498b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get idle connection timeout.  <br /></td></tr>
<tr class="separator:gaee19a772a9cf21b2c50fd1deec498b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d0f088107c8034fff0a9f87d056100" id="r_gab0d0f088107c8034fff0a9f87d056100"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab0d0f088107c8034fff0a9f87d056100">SocketPool_idle_cleanup_due_ms</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:gab0d0f088107c8034fff0a9f87d056100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get time until next idle cleanup.  <br /></td></tr>
<tr class="separator:gab0d0f088107c8034fff0a9f87d056100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efd44a4a7089eea19819785b0e2de4b" id="r_ga8efd44a4a7089eea19819785b0e2de4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8efd44a4a7089eea19819785b0e2de4b">SocketPool_run_idle_cleanup</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga8efd44a4a7089eea19819785b0e2de4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run idle connection cleanup if due.  <br /></td></tr>
<tr class="separator:ga8efd44a4a7089eea19819785b0e2de4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6eccb3c5a10e8ac40b057a56e77ed5" id="r_ga3e6eccb3c5a10e8ac40b057a56e77ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf">SocketPool_ConnHealth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5">SocketPool_check_connection</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, Connection_T conn)</td></tr>
<tr class="memdesc:ga3e6eccb3c5a10e8ac40b057a56e77ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check health of a connection.  <br /></td></tr>
<tr class="separator:ga3e6eccb3c5a10e8ac40b057a56e77ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a46794f10d4d659cf75412e84cef31" id="r_ga11a46794f10d4d659cf75412e84cef31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga11a46794f10d4d659cf75412e84cef31">SocketPool_set_validation_callback</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#ga9a848b27d2034b028ceb2febdc6471b5">SocketPool_ValidationCallback</a> cb, void *data)</td></tr>
<tr class="memdesc:ga11a46794f10d4d659cf75412e84cef31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connection validation callback.  <br /></td></tr>
<tr class="separator:ga11a46794f10d4d659cf75412e84cef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7cd8aa28512bb3e73885f5968a46cd" id="r_ga9c7cd8aa28512bb3e73885f5968a46cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9c7cd8aa28512bb3e73885f5968a46cd">SocketPool_set_resize_callback</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#ga6ec7b7f0dae3b1366f32f93294dc8b4a">SocketPool_ResizeCallback</a> cb, void *data)</td></tr>
<tr class="memdesc:ga9c7cd8aa28512bb3e73885f5968a46cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register pool resize notification callback.  <br /></td></tr>
<tr class="separator:ga9c7cd8aa28512bb3e73885f5968a46cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8289eac993efd5cac1c6147c06d6d645" id="r_ga8289eac993efd5cac1c6147c06d6d645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645">SocketPool_get_stats</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#structSocketPool__Stats">SocketPool_Stats</a> *stats)</td></tr>
<tr class="memdesc:ga8289eac993efd5cac1c6147c06d6d645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pool statistics snapshot.  <br /></td></tr>
<tr class="separator:ga8289eac993efd5cac1c6147c06d6d645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8bfb464d9ab7068fefa9c0ba57c436" id="r_ga2f8bfb464d9ab7068fefa9c0ba57c436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2f8bfb464d9ab7068fefa9c0ba57c436">SocketPool_reset_stats</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga2f8bfb464d9ab7068fefa9c0ba57c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset pool statistics counters.  <br /></td></tr>
<tr class="separator:ga2f8bfb464d9ab7068fefa9c0ba57c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19433078a67ca838968245b41644fe7c" id="r_ga19433078a67ca838968245b41644fe7c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga19433078a67ca838968245b41644fe7c">SocketPool_get_idle_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga19433078a67ca838968245b41644fe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of currently idle connections.  <br /></td></tr>
<tr class="separator:ga19433078a67ca838968245b41644fe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996b6e1e70230dec597386572109b873" id="r_ga996b6e1e70230dec597386572109b873"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga996b6e1e70230dec597386572109b873">SocketPool_get_active_count</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga996b6e1e70230dec597386572109b873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of currently active connections.  <br /></td></tr>
<tr class="separator:ga996b6e1e70230dec597386572109b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d406e9dc8b20a64731630a38b5f027" id="r_ga86d406e9dc8b20a64731630a38b5f027"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga86d406e9dc8b20a64731630a38b5f027">SocketPool_get_hit_rate</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga86d406e9dc8b20a64731630a38b5f027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection reuse rate (hit rate).  <br /></td></tr>
<tr class="separator:ga86d406e9dc8b20a64731630a38b5f027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cef8507b62e5092e9064800c84f296f" id="r_ga4cef8507b62e5092e9064800c84f296f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4cef8507b62e5092e9064800c84f296f">SocketPool_shrink</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool)</td></tr>
<tr class="memdesc:ga4cef8507b62e5092e9064800c84f296f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release unused pool capacity.  <br /></td></tr>
<tr class="separator:ga4cef8507b62e5092e9064800c84f296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0f0813679f7ffbff6ff75adb3678c8c" id="r_gaa0f0813679f7ffbff6ff75adb3678c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa0f0813679f7ffbff6ff75adb3678c8c">SocketPool_set_idle_callback</a> (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, <a class="el" href="group__connection__mgmt.html#ga18f3ff7614b9968e5cc27f2017a0f058">SocketPool_IdleCallback</a> cb, void *data)</td></tr>
<tr class="memdesc:gaa0f0813679f7ffbff6ff75adb3678c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback for when connections become idle.  <br /></td></tr>
<tr class="separator:gaa0f0813679f7ffbff6ff75adb3678c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb31a2cef7f4d6b590baf9c3e4fd048" id="r_gadeb31a2cef7f4d6b590baf9c3e4fd048"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gadeb31a2cef7f4d6b590baf9c3e4fd048">Connection_created_at</a> (const Connection_T conn)</td></tr>
<tr class="memdesc:gadeb31a2cef7f4d6b590baf9c3e4fd048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection creation timestamp.  <br /></td></tr>
<tr class="separator:gadeb31a2cef7f4d6b590baf9c3e4fd048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2e9cd2b8dd8294f175991957b1b37b" id="r_ga8e2e9cd2b8dd8294f175991957b1b37b"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8e2e9cd2b8dd8294f175991957b1b37b">socketreconnect_now_ms</a> (void)</td></tr>
<tr class="memdesc:ga8e2e9cd2b8dd8294f175991957b1b37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current monotonic time in milliseconds for internal timing.  <br /></td></tr>
<tr class="separator:ga8e2e9cd2b8dd8294f175991957b1b37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb049b5716726216dec25cd2dfa2380" id="r_ga8bb049b5716726216dec25cd2dfa2380"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8bb049b5716726216dec25cd2dfa2380">socketreconnect_elapsed_ms</a> (int64_t start_ms)</td></tr>
<tr class="memdesc:ga8bb049b5716726216dec25cd2dfa2380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute elapsed monotonic time since provided start timestamp.  <br /></td></tr>
<tr class="separator:ga8bb049b5716726216dec25cd2dfa2380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768e9347e53fcf121c747b2430cdef40" id="r_ga768e9347e53fcf121c747b2430cdef40"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga768e9347e53fcf121c747b2430cdef40">reconnect_jitter</a> (void)</td></tr>
<tr class="memdesc:ga768e9347e53fcf121c747b2430cdef40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate uniform random double in [0.0, 1.0) for jitter in backoff calculations.  <br /></td></tr>
<tr class="separator:ga768e9347e53fcf121c747b2430cdef40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2064741bf60283ac3315823128fa2082" id="r_ga2064741bf60283ac3315823128fa2082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a> (const char *host, int port, const <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *policy, <a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220">SocketReconnect_Callback</a> callback, void *userdata)</td></tr>
<tr class="memdesc:ga2064741bf60283ac3315823128fa2082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance configured for a specific host and port.  <br /></td></tr>
<tr class="separator:ga2064741bf60283ac3315823128fa2082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8b4dd4a693ba7acb20ff8e78defe91" id="r_ga9d8b4dd4a693ba7acb20ff8e78defe91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91">SocketReconnect_free</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> *conn)</td></tr>
<tr class="memdesc:ga9d8b4dd4a693ba7acb20ff8e78defe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance and release all associated resources.  <br /></td></tr>
<tr class="separator:ga9d8b4dd4a693ba7acb20ff8e78defe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2669844f3ad8a19649f2bc204eee8401" id="r_ga2669844f3ad8a19649f2bc204eee8401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga2669844f3ad8a19649f2bc204eee8401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate or queue a connection attempt according to current state and policy.  <br /></td></tr>
<tr class="separator:ga2669844f3ad8a19649f2bc204eee8401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3794b861d4dad021064bae97ea12e78" id="r_gaa3794b861d4dad021064bae97ea12e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa3794b861d4dad021064bae97ea12e78">SocketReconnect_disconnect</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gaa3794b861d4dad021064bae97ea12e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully disconnect without triggering reconnect.  <br /></td></tr>
<tr class="separator:gaa3794b861d4dad021064bae97ea12e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6fc797f7fe9c6cd3319f540db4b672" id="r_gace6fc797f7fe9c6cd3319f540db4b672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gace6fc797f7fe9c6cd3319f540db4b672">SocketReconnect_reset</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gace6fc797f7fe9c6cd3319f540db4b672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset reconnection statistics and state machine.  <br /></td></tr>
<tr class="separator:gace6fc797f7fe9c6cd3319f540db4b672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c91b5c376059d9c35d2623cbc6bd7b5" id="r_ga4c91b5c376059d9c35d2623cbc6bd7b5"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5">SocketReconnect_socket</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga4c91b5c376059d9c35d2623cbc6bd7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying Socket_T when connected.  <br /></td></tr>
<tr class="separator:ga4c91b5c376059d9c35d2623cbc6bd7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a144f4c67fde49d88d0a53aa528c14" id="r_gac2a144f4c67fde49d88d0a53aa528c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14">SocketReconnect_state</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gac2a144f4c67fde49d88d0a53aa528c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current state of the reconnection instance.  <br /></td></tr>
<tr class="separator:gac2a144f4c67fde49d88d0a53aa528c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490043a4bfaba8214f5d10a3c7b956de" id="r_ga490043a4bfaba8214f5d10a3c7b956de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de">SocketReconnect_isconnected</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga490043a4bfaba8214f5d10a3c7b956de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if reconnection is currently in connected state.  <br /></td></tr>
<tr class="separator:ga490043a4bfaba8214f5d10a3c7b956de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae798b2ae7451bbc7247fe71481190ee6" id="r_gae798b2ae7451bbc7247fe71481190ee6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae798b2ae7451bbc7247fe71481190ee6">SocketReconnect_attempts</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gae798b2ae7451bbc7247fe71481190ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of connection attempts since last success or reset.  <br /></td></tr>
<tr class="separator:gae798b2ae7451bbc7247fe71481190ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f80ff5ac565edacc7b5c08a263ec73d" id="r_ga9f80ff5ac565edacc7b5c08a263ec73d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga9f80ff5ac565edacc7b5c08a263ec73d">SocketReconnect_failures</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga9f80ff5ac565edacc7b5c08a263ec73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of consecutive connection failures.  <br /></td></tr>
<tr class="separator:ga9f80ff5ac565edacc7b5c08a263ec73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2db0dea41db5bb5a7efeec947323da8" id="r_gaa2db0dea41db5bb5a7efeec947323da8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8">SocketReconnect_pollfd</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gaa2db0dea41db5bb5a7efeec947323da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve file descriptor for event loop integration (poll/epoll/kqueue/select).  <br /></td></tr>
<tr class="separator:gaa2db0dea41db5bb5a7efeec947323da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca4375d521b1eddcc4cf3f75fe3b538" id="r_ga4ca4375d521b1eddcc4cf3f75fe3b538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538">SocketReconnect_process</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga4ca4375d521b1eddcc4cf3f75fe3b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process I/O events from poll loop.  <br /></td></tr>
<tr class="separator:ga4ca4375d521b1eddcc4cf3f75fe3b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5bf725fe34ae1de58a3ee05fbe270fd" id="r_gaf5bf725fe34ae1de58a3ee05fbe270fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd">SocketReconnect_next_timeout_ms</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gaf5bf725fe34ae1de58a3ee05fbe270fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate milliseconds until next timer event or action.  <br /></td></tr>
<tr class="separator:gaf5bf725fe34ae1de58a3ee05fbe270fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd2c1fe7147188da2be29f7623d2822" id="r_ga8dd2c1fe7147188da2be29f7623d2822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga8dd2c1fe7147188da2be29f7623d2822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance timers and perform periodic maintenance for state transitions and checks.  <br /></td></tr>
<tr class="separator:ga8dd2c1fe7147188da2be29f7623d2822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf257c08816a36a97c02b32e034c0ea0" id="r_gacf257c08816a36a97c02b32e034c0ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0">SocketReconnect_set_health_check</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, <a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3">SocketReconnect_HealthCheck</a> check)</td></tr>
<tr class="memdesc:gacf257c08816a36a97c02b32e034c0ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a custom health check callback for proactive connection validation.  <br /></td></tr>
<tr class="separator:gacf257c08816a36a97c02b32e034c0ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc781f13408c70bfe9d28148ac87212" id="r_ga4bc781f13408c70bfe9d28148ac87212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212">SocketReconnect_policy_defaults</a> (<a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *policy)</td></tr>
<tr class="memdesc:ga4bc781f13408c70bfe9d28148ac87212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> with safe, production-recommended default values.  <br /></td></tr>
<tr class="separator:ga4bc781f13408c70bfe9d28148ac87212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f6cbe69ac37f9bae1efccfe98538ee" id="r_gae1f6cbe69ac37f9bae1efccfe98538ee"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee">SocketReconnect_send</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, const void *buf, size_t len)</td></tr>
<tr class="memdesc:gae1f6cbe69ac37f9bae1efccfe98538ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data over the reconnection-managed connection with automatic retry on transient errors.  <br /></td></tr>
<tr class="separator:gae1f6cbe69ac37f9bae1efccfe98538ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92485113993efb3a1302bbcb8f57a908" id="r_ga92485113993efb3a1302bbcb8f57a908"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga92485113993efb3a1302bbcb8f57a908">SocketReconnect_recv</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, void *buf, size_t len)</td></tr>
<tr class="memdesc:ga92485113993efb3a1302bbcb8f57a908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from the reconnection-managed connection, auto-reconnecting on close or errors.  <br /></td></tr>
<tr class="separator:ga92485113993efb3a1302bbcb8f57a908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0678924e4ecd0f43e1385d2e0b5354d4" id="r_ga0678924e4ecd0f43e1385d2e0b5354d4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4">SocketReconnect_state_name</a> (<a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> state)</td></tr>
<tr class="memdesc:ga0678924e4ecd0f43e1385d2e0b5354d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable name for a reconnection state.  <br /></td></tr>
<tr class="separator:ga0678924e4ecd0f43e1385d2e0b5354d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba120af42ef94401078aacf5b258145b" id="r_gaba120af42ef94401078aacf5b258145b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b">SocketReconnect_set_tls</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, <a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a> ctx, const char *hostname)</td></tr>
<tr class="memdesc:gaba120af42ef94401078aacf5b258145b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure TLS for reconnecting connections.  <br /></td></tr>
<tr class="separator:gaba120af42ef94401078aacf5b258145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5943a7adc872f2a89da06c7cf19300d" id="r_gae5943a7adc872f2a89da06c7cf19300d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gae5943a7adc872f2a89da06c7cf19300d">SocketReconnect_disable_tls</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:gae5943a7adc872f2a89da06c7cf19300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable TLS for future connections.  <br /></td></tr>
<tr class="separator:gae5943a7adc872f2a89da06c7cf19300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2487b042967310b7df99ebab41e105" id="r_ga3b2487b042967310b7df99ebab41e105"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3b2487b042967310b7df99ebab41e105">SocketReconnect_tls_enabled</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga3b2487b042967310b7df99ebab41e105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TLS is configured for this connection.  <br /></td></tr>
<tr class="separator:ga3b2487b042967310b7df99ebab41e105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga322b43d2dfe9735da6cbd891af3527ad" id="r_ga322b43d2dfe9735da6cbd891af3527ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga322b43d2dfe9735da6cbd891af3527ad">SocketReconnect_get_tls_hostname</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga322b43d2dfe9735da6cbd891af3527ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured TLS hostname.  <br /></td></tr>
<tr class="separator:ga322b43d2dfe9735da6cbd891af3527ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b84be023c19dc3f870a4c14250aceb9" id="r_ga8b84be023c19dc3f870a4c14250aceb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__security.html#gad092160c037d01929df1bb8d5b75b43c">TLSHandshakeState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga8b84be023c19dc3f870a4c14250aceb9">SocketReconnect_tls_handshake_state</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga8b84be023c19dc3f870a4c14250aceb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current TLS handshake state.  <br /></td></tr>
<tr class="separator:ga8b84be023c19dc3f870a4c14250aceb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c4eeb92b2367fd5dd731bcbea4acf2" id="r_gab2c4eeb92b2367fd5dd731bcbea4acf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gab2c4eeb92b2367fd5dd731bcbea4acf2">SocketReconnect_set_session_resumption</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, int enable)</td></tr>
<tr class="memdesc:gab2c4eeb92b2367fd5dd731bcbea4acf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TLS session resumption for faster reconnects.  <br /></td></tr>
<tr class="separator:gab2c4eeb92b2367fd5dd731bcbea4acf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee1c4c9f76873db39c01f25563ef743" id="r_ga7ee1c4c9f76873db39c01f25563ef743"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga7ee1c4c9f76873db39c01f25563ef743">SocketReconnect_is_session_reused</a> (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn)</td></tr>
<tr class="memdesc:ga7ee1c4c9f76873db39c01f25563ef743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if last connection used session resumption.  <br /></td></tr>
<tr class="separator:ga7ee1c4c9f76873db39c01f25563ef743"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaeea0045572d9693e0579e265d0e00981" id="r_gaeea0045572d9693e0579e265d0e00981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gaeea0045572d9693e0579e265d0e00981">SocketPool_DetailedException</a></td></tr>
<tr class="memdesc:gaeea0045572d9693e0579e265d0e00981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local exception for detailed error messages.  <br /></td></tr>
<tr class="separator:gaeea0045572d9693e0579e265d0e00981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba094d10381f1646de6a3e1e2bd0c36" id="r_gadba094d10381f1646de6a3e1e2bd0c36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a></td></tr>
<tr class="memdesc:gadba094d10381f1646de6a3e1e2bd0c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool operation failure.  <br /></td></tr>
<tr class="separator:gadba094d10381f1646de6a3e1e2bd0c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc308919d4ccef64b7674cae246d9c0" id="r_ga3dc308919d4ccef64b7674cae246d9c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__connection__mgmt.html#ga3dc308919d4ccef64b7674cae246d9c0">SocketReconnect_Failed</a></td></tr>
<tr class="memdesc:ga3dc308919d4ccef64b7674cae246d9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type for errors in the reconnection module.  <br /></td></tr>
<tr class="separator:ga3dc308919d4ccef64b7674cae246d9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> lifecycle management with pooling, reconnection, and resilience patterns. </p>
<p>The <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> Management group handles connection lifecycle, pooling, and resilience patterns. Key components include:</p><ul>
<li>SocketPool (pooling): <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> pooling with automatic lifecycle management</li>
<li>SocketReconnect (reconnection): Auto-reconnection with circuit breaker</li>
<li>SocketRateLimit (rate-limit): Token bucket rate limiting</li>
<li>SocketSYNProtect (syn-flood): SYN flood protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html">Core I/O Modules</a> for socket primitives. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System Modules</a> for event notification. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for memory management and exceptions. </dd>
<dd>
<a class="el" href="group__dns.html">Asynchronous DNS Resolution</a> for DNS resolution support. </dd>
<dd>
<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd>
<dd>
connection_mgmt::SocketReconnect_T for auto-reconnection. </dd>
<dd>
Connection_T for connection accessors. </dd>
<dd>
utilities::SocketRateLimit_T for rate limiting. </dd>
<dd>
security::SocketSYNProtect_T for SYN flood protection. </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structConnection" id="structConnection"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structConnection">&#9670;&#160;</a></span>Connection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Connection</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Internal structure representing a pooled connection slot. </p>
<p>Opaque connection handle within a pool.</p>
<p>Internal typedef for connection structure pointer.</p>
<p>Each instance manages a single socket connection with dedicated input/output buffers, activity timestamps, user data, and optional advanced features like auto-reconnection and TLS session persistence.</p>
<p>CORE MANAGEMENT:</p><ul>
<li>Pre-allocated in fixed-size array (pool-&gt;connections) for predictable memory</li>
<li>Fast O(1) lookup via hash table (pool-&gt;hash_table) keyed on socket FD</li>
<li>Free list (pool-&gt;free_list) for quick slot recycling</li>
<li>Linked lists for hash collisions (hash_next) and free slots (free_next)</li>
</ul>
<p>STATE TRACKING:</p><ul>
<li>active flag distinguishes used vs free slots</li>
<li>last_activity for idle timeout enforcement</li>
<li>created_at for age-based cleanup and stats</li>
</ul>
<p>EXTENSIONS:</p><ul>
<li>reconnect: Optional <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> for automatic reconnection</li>
<li>tracked_ip: Per-IP rate limiting via SocketIPTracker_T</li>
<li>TLS fields: Context, handshake state, session reuse (conditional on SOCKET_HAS_TLS)</li>
</ul>
<p>THREAD SAFETY: All modifications protected by pool-&gt;mutex. Readers should acquire mutex or use atomic checks for count/state. Accessors in public API handle locking transparently.</p>
<p>LIFECYCLE:</p><ul>
<li>Initialized via <a class="el" href="group__connection__mgmt.html#ga88ab86be313053fde04989b904bb957a" title="Allocate and zero-initialize array of connection structures.">SocketPool_connections_initialize_slot()</a></li>
<li>Buffers allocated in <a class="el" href="group__connection__mgmt.html#ga0baf2c21ed54520dcaab3460a9a987f7" title="Allocate input/output buffers for connection.">SocketPool_connections_alloc_buffers()</a></li>
<li>Added to pool via <a class="el" href="group__connection__mgmt.html#gae5693c260bb02fb1c779d497b35eb6db" title="Find existing connection or create new slot.">find_or_create_slot()</a> / <a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a></li>
<li>Removed via <a class="el" href="group__connection__mgmt.html#ga9710c881ae321ed9da843ca815ca0733" title="Remove connection from hash table.">remove_from_hash_table()</a> / <a class="el" href="group__connection__mgmt.html#gacf51388d2a06f1d1b1caa4d55fe29159" title="Securely clear (zero) connection&#39;s input/output buffers.">SocketPool_connections_reset_slot()</a></li>
<li>Buffers released in SocketPool_connections_release_buffers()</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Fields like hash_next/free_next are internal linking only; ignore for app logic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Direct field access bypasses thread safety - use accessors or lock pool. @security TLS session reuse reduces handshake overhead but validate saved_session via <a class="el" href="group__connection__mgmt.html#ga93e4d3464b3def2864e59849788aaf11" title="Validate TLS session for reuse.">validate_saved_session()</a> before reuse to prevent stale sessions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#a5a941bde63d21211b61fce7891f8ef90">SocketPool_T::connections</a> for array allocation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a> for FD-based hashing. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga344c2ab8a3e0b099bd74e65cc97cb66f" title="Find connection slot by socket (internal).">find_slot()</a> / <a class="el" href="group__connection__mgmt.html#ga122ba4bb8b8c2ed5400b544deefe8903" title="Find first available free connection slot.">find_free_slot()</a> for lookup/allocation logic. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> / <a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for public entry points. </dd>
<dd>
SocketPool.h::Connection_T for public opaque interface. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Mgmt Module</a> for pooling patterns. </dd>
<dd>
connection_mgmt::SocketReconnect_T for reconnection integration. </dd>
<dd>
security::SocketTLSContext for TLS support.</dd></dl>
<p>Opaque externally; provides handle to managed connection state including socket, buffers, timestamps, and optional TLS/reconnect contexts. Access internal fields only within SocketPool implementation files.</p>
<dl class="section note"><dt>Note</dt><dd>This typedef matches public Connection_T in <a class="el" href="SocketPool_8h.html" title="Connection pooling with automatic lifecycle management.">SocketPool.h</a> but includes full struct definition here for implementation convenience.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketPool.h::Connection_T for public opaque type documentation. </dd>
<dd>
struct <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> for detailed field descriptions. </dd>
<dd>
Connection_* accessor functions in <a class="el" href="SocketPool_8h.html" title="Connection pooling with automatic lifecycle management.">SocketPool.h</a>. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Mgmt Module</a> for usage patterns.</dd></dl>
<p>Represents a single socket connection within a pool, including associated buffers, metadata, and lifecycle state. Use accessor functions to read/write connection properties. All connection operations are thread-safe.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652" title="Get connection&#39;s socket.">Connection_socket()</a> for <a class="el" href="group__connection__mgmt.html#af3ca55263a8b8e33789a646ad07dd52d">socket</a> access. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf" title="Get connection&#39;s input buffer.">Connection_inbuf()</a> and <a class="el" href="group__connection__mgmt.html#ga6d7573f71d8853943029cfd55fa3fb3a" title="Get connection&#39;s output buffer.">Connection_outbuf()</a> for buffer access. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga1faf8c706d1ed9418446fc155fa289dd" title="Get connection&#39;s user data.">Connection_data()</a> and <a class="el" href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1" title="Set connection&#39;s user data.">Connection_setdata()</a> for user <a class="el" href="group__connection__mgmt.html#aa1c5ea7b08a60be3d90f9e63b1052732">data</a> storage. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1" title="Get connection&#39;s last activity timestamp.">Connection_lastactivity()</a> for activity tracking. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf52bba490d68b2dd5448a61a1cc820a1" title="Check if connection is active.">Connection_isactive()</a> for connection state. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for connection creation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for connection lookup. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d" title="Remove socket from pool.">SocketPool_remove()</a> for connection removal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00324">324</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Connection_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structConnection__coll__graph.svg" width="640" height="499"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0e1ccee39970ab15956c72b3da35e4a6" name="a0e1ccee39970ab15956c72b3da35e4a6"></a>int</td>
<td class="fieldname">
active</td>
<td class="fielddoc">
<p>Non-zero if slot contains active connection </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af3cfe477e7b8b2a42d8398044512b6e4" name="af3cfe477e7b8b2a42d8398044512b6e4"></a>time_t</td>
<td class="fieldname">
created_at</td>
<td class="fielddoc">
<p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> creation timestamp (for age tracking) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa1c5ea7b08a60be3d90f9e63b1052732" name="aa1c5ea7b08a60be3d90f9e63b1052732"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>User data pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a38ef96ac7a25a000832cd14d416c867e" name="a38ef96ac7a25a000832cd14d416c867e"></a>struct <a class="el" href="group__connection__mgmt.html#structConnection">Connection</a> *</td>
<td class="fieldname">
free_next</td>
<td class="fielddoc">
<p>Next in free list (when inactive) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa0ef1d4b935a5c3fbed00c327c40bb21" name="aa0ef1d4b935a5c3fbed00c327c40bb21"></a>struct <a class="el" href="group__connection__mgmt.html#structConnection">Connection</a> *</td>
<td class="fieldname">
hash_next</td>
<td class="fielddoc">
<p>Next in hash table collision chain </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3775ae58e73883cc5146854a499253b1" name="a3775ae58e73883cc5146854a499253b1"></a><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
<td class="fieldname">
inbuf</td>
<td class="fielddoc">
<p>Input buffer for reading data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8d7af8c7589e1f75022d0a2ea5f2e4b9" name="a8d7af8c7589e1f75022d0a2ea5f2e4b9"></a>time_t</td>
<td class="fieldname">
last_activity</td>
<td class="fielddoc">
<p>Last activity timestamp for idle timeout </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8536985e9ff11ebdfd11fa247bbfc05a" name="a8536985e9ff11ebdfd11fa247bbfc05a"></a>int</td>
<td class="fieldname">
last_socket_fd</td>
<td class="fielddoc">
<p>FD of last socket (for session persistence) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa7cbe58bed66dad8b781f27a17ba137d" name="aa7cbe58bed66dad8b781f27a17ba137d"></a><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
<td class="fieldname">
outbuf</td>
<td class="fielddoc">
<p>Output buffer for writing data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4c6c421e7e3c941ad76ea2df16fb5cd9" name="a4c6c421e7e3c941ad76ea2df16fb5cd9"></a><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a></td>
<td class="fieldname">
reconnect</td>
<td class="fielddoc">
<p>Auto-reconnection context (NULL if disabled) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af3ca55263a8b8e33789a646ad07dd52d" name="af3ca55263a8b8e33789a646ad07dd52d"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Associated socket (NULL if free) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1347faafbfc9b4e9e650efc3503cda8a" name="a1347faafbfc9b4e9e650efc3503cda8a"></a><a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a></td>
<td class="fieldname">
tls_ctx</td>
<td class="fielddoc">
<p>TLS context for this connection </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abd28c3d29b4bb60e9e670344f24922d6" name="abd28c3d29b4bb60e9e670344f24922d6"></a>int</td>
<td class="fieldname">
tls_handshake_complete</td>
<td class="fielddoc">
<p>TLS handshake state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab851f80ce538e45fd4918bbb47a88de0" name="ab851f80ce538e45fd4918bbb47a88de0"></a>SSL_SESSION *</td>
<td class="fieldname">
tls_session</td>
<td class="fielddoc">
<p>Saved session for potential reuse </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7a723553d56d045e73c143304424df41" name="a7a723553d56d045e73c143304424df41"></a>char *</td>
<td class="fieldname">
tracked_ip</td>
<td class="fielddoc">
<p>Tracked IP for per-IP limiting (NULL if not tracked) </p>
</td></tr>
</table>

</div>
</div>
<a name="structAsyncConnectContext" id="structAsyncConnectContext"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structAsyncConnectContext">&#9670;&#160;</a></span>AsyncConnectContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AsyncConnectContext</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Internal context structure for tracking asynchronous connect operations. </p>
<p>Internal typedef for async connect context pointer.</p>
<p>Manages state for pending connections initiated via <a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a>, which combines DNS resolution, socket connection, and pool integration. Instances are allocated from the pool's arena and chained in pool-&gt;async_ctx list.</p>
<p>LIFECYCLE:</p><ul>
<li>Allocated in <a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a> with user callback and data</li>
<li>DNS resolution started via <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> (req field)</li>
<li>Socket created and connect() initiated upon DNS success</li>
<li>Moved to active pool slot on successful connect, callback invoked</li>
<li>Removed and freed on failure, timeout, or pool destruction</li>
<li>Sockets in failed contexts are closed and freed during pool cleanup</li>
</ul>
<p>THREAD SAFETY: List operations protected by pool mutex. DNS callbacks execute in worker threads; user SocketPool_ConnectCallback must be thread-safe.</p>
<p>MEMORY: All fields arena-allocated; no individual free() calls needed.</p>
<dl class="section note"><dt>Note</dt><dd>Limit concurrent async connects via pool configuration to prevent resource exhaustion. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>User callback runs in DNS worker thread context - avoid blocking operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a> for public async connect initiation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd" title="Completion callback for async connections.">SocketPool_ConnectCallback</a> for completion notification requirements. </dd>
<dd>
SocketDNS.h::Request_T for DNS request handling (<a class="el" href="group__dns.html">Asynchronous DNS Resolution</a>). </dd>
<dd>
AsyncConnectContext_T for opaque typedef. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> for ensuring pending sockets are cleaned up. </dd>
<dd>
<a class="el" href="SocketPool_8h.html" title="Connection pooling with automatic lifecycle management.">SocketPool.h</a> for overall connection <a class="el" href="group__connection__mgmt.html#af09ecafa78f4a4445d8c80aa534bf867">pool</a> API. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management</a> for resilience patterns. </dd>
<dd>
<a class="el" href="group__dns.html">DNS Module</a> for asynchronous resolution details.</dd></dl>
<p>Opaque handle for tracking asynchronous connection operations involving DNS resolution, socket creation, and pool integration. Managed internally by SocketPool during async connect lifecycle.</p>
<dl class="section note"><dt>Note</dt><dd>Not exposed in public API; used only within SocketPool implementation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="group__connection__mgmt.html#structAsyncConnectContext" title="Internal context structure for tracking asynchronous connect operations.">AsyncConnectContext</a> for private fields. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a> in <a class="el" href="SocketPool_8h.html" title="Connection pooling with automatic lifecycle management.">SocketPool.h</a> for public async API. </dd>
<dd>
<a class="el" href="SocketPool-private_8h.html" title="Private implementation details and internal structures for SocketPool module.">SocketPool-private.h</a> for internal async connect details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00408">408</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for AsyncConnectContext_T:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structAsyncConnectContext__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7d2ae7b39adc48ef126be349f9fcb75f" name="a7d2ae7b39adc48ef126be349f9fcb75f"></a><a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd">SocketPool_ConnectCallback</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>User callback </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9459387f9d3bf36a5832ea7b71de641" name="ae9459387f9d3bf36a5832ea7b71de641"></a>struct <a class="el" href="group__connection__mgmt.html#structAsyncConnectContext">AsyncConnectContext</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
<p>Next context in list </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af09ecafa78f4a4445d8c80aa534bf867" name="af09ecafa78f4a4445d8c80aa534bf867"></a><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></td>
<td class="fieldname">
pool</td>
<td class="fielddoc">
<p>Pool instance </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7ec273e20a31a5241712c20451f2177c" name="a7ec273e20a31a5241712c20451f2177c"></a><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a></td>
<td class="fieldname">
req</td>
<td class="fielddoc">
<p>DNS resolution request (dns::Request_T). Used to track and retrieve results from async DNS lookup for host resolution. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for initiating resolution, <a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> for aborting, <a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> for retrieving addrinfo results. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a38c5da7edeb9fc559af76031505ec06a" name="a38c5da7edeb9fc559af76031505ec06a"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Socket being connected </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa4d4a5f5db2a9a6f4a9455249a89202b" name="aa4d4a5f5db2a9a6f4a9455249a89202b"></a>void *</td>
<td class="fieldname">
user_data</td>
<td class="fielddoc">
<p>User data for callback </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketPool__Stats" id="structSocketPool__Stats"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketPool__Stats">&#9670;&#160;</a></span>SocketPool_Stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketPool_Stats</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Pool statistics snapshot structure. </p>
<p>All counters are cumulative since pool creation or last reset. Rates are calculated over the configured statistics window. Thread-safe: All fields are read atomically during snapshot.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a> for retrieving statistics. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2f8bfb464d9ab7068fefa9c0ba57c436" title="Reset pool statistics counters.">SocketPool_reset_stats()</a> for resetting counters. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#structSocketPool__Stats" title="Pool statistics snapshot structure.">SocketPool_Stats</a> for field descriptions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l01492">1492</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a95ea2264615189143e51b08b2372bde5" name="a95ea2264615189143e51b08b2372bde5"></a>double</td>
<td class="fieldname">
avg_connection_age_sec</td>
<td class="fielddoc">
<p>Average age of active connections (seconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a58155d80879fa628a209dcf26d9ed813" name="a58155d80879fa628a209dcf26d9ed813"></a>double</td>
<td class="fieldname">
churn_rate_per_sec</td>
<td class="fielddoc">
<p>Churn rate: (added + removed) / window_sec </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a27243a0956a835deca459b97c6d102f6" name="a27243a0956a835deca459b97c6d102f6"></a>size_t</td>
<td class="fieldname">
current_active</td>
<td class="fielddoc">
<p>Current active connection count </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae3f9de28a86d86ad1fb47f81934396e4" name="ae3f9de28a86d86ad1fb47f81934396e4"></a>size_t</td>
<td class="fieldname">
current_idle</td>
<td class="fielddoc">
<p>Current idle connection count (active but not in use) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeb1d2bc03018eb8cf873ca9c7cf1d591" name="aeb1d2bc03018eb8cf873ca9c7cf1d591"></a>size_t</td>
<td class="fieldname">
max_connections</td>
<td class="fielddoc">
<p>Maximum connection capacity </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acddc4228468fcc3b685ed125e6dcbe4c" name="acddc4228468fcc3b685ed125e6dcbe4c"></a>double</td>
<td class="fieldname">
reuse_rate</td>
<td class="fielddoc">
<p>Reuse rate: reused / (added + reused) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab6181f0361304b9dc0ca22b2b5b63422" name="ab6181f0361304b9dc0ca22b2b5b63422"></a>uint64_t</td>
<td class="fieldname">
total_added</td>
<td class="fielddoc">
<p>Total connections added to pool </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2b87e1f7d01cca34d283f2a198d55582" name="a2b87e1f7d01cca34d283f2a198d55582"></a>uint64_t</td>
<td class="fieldname">
total_health_checks</td>
<td class="fielddoc">
<p>Total health checks performed </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abc785aa6c8bf923e442c2d8ff6de17ea" name="abc785aa6c8bf923e442c2d8ff6de17ea"></a>uint64_t</td>
<td class="fieldname">
total_health_failures</td>
<td class="fielddoc">
<p>Total health check failures </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a93f503d21a575444867f078913f9fdeb" name="a93f503d21a575444867f078913f9fdeb"></a>uint64_t</td>
<td class="fieldname">
total_idle_cleanups</td>
<td class="fielddoc">
<p>Connections removed due to idle timeout </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af3a48d372811cdc1995449539e7fa244" name="af3a48d372811cdc1995449539e7fa244"></a>uint64_t</td>
<td class="fieldname">
total_removed</td>
<td class="fielddoc">
<p>Total connections removed from pool </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae4a38edcc6f06de4427a3fab17df8059" name="ae4a38edcc6f06de4427a3fab17df8059"></a>uint64_t</td>
<td class="fieldname">
total_reused</td>
<td class="fielddoc">
<p>Total connections reused (returned via get) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a12b67886dc33365dacefdbf6898dbaa9" name="a12b67886dc33365dacefdbf6898dbaa9"></a>uint64_t</td>
<td class="fieldname">
total_validation_failures</td>
<td class="fielddoc">
<p>Total validation callback failures </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketReconnect__T" id="structSocketReconnect__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketReconnect__T">&#9670;&#160;</a></span>SocketReconnect_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketReconnect_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Opaque internal context for reconnecting socket management. </p>
<p>Opaque handle for a reconnecting socket connection.</p>
<p>Core data structure holding all configuration, state, timers, and resources for a single reconnection instance. Supports exponential backoff with jitter, circuit breaker pattern, periodic health checks, and automatic I/O recovery.</p>
<p>Key Responsibilities</p>
<ul>
<li>State machine transitions (connect, backoff, circuit states)</li>
<li>Timer management (backoff delays, health intervals, circuit timeouts)</li>
<li>Failure counting and retry limits</li>
<li>Error logging and last-error tracking</li>
<li><p class="startli">Resource ownership (arena, socket, callbacks)</p>
<p class="startli">Field Groups Overview</p>
</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Group   </th><th class="markdownTableHeadNone">Fields   </th><th class="markdownTableHeadNone">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Configuration   </td><td class="markdownTableBodyNone">policy, host, port   </td><td class="markdownTableBodyNone">Backoff policy and target endpoint    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Resources   </td><td class="markdownTableBodyNone">arena, socket   </td><td class="markdownTableBodyNone">Memory and current connection handle    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Callbacks   </td><td class="markdownTableBodyNone">callback, health_check, userdata   </td><td class="markdownTableBodyNone">Event notifications and   </td></tr>
</table>
<p>custom checks | | State | state, circuit_state | Current FSM and breaker status | | Tracking | attempt_*, failures, successes | Metrics for retries and reliability | | Timing | *_time_ms, backoff_until_ms, etc. | Monotonic timestamps for scheduling | | <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> | connect_in_progress | Async connect flags | | Errors | error_buf, last_error | Diagnostic information |</p>
<p>Lifecycle</p>
<ol type="1">
<li><b>Creation</b>: <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> allocates via arena, initializes policy, copies host/port</li>
<li><b>Operation</b>: Public functions update fields atomically (e.g., connect starts async, updates timers)</li>
<li><b>Destruction</b>: <a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> closes socket, disposes arena, clears pointers</li>
</ol>
<p>Invariants:</p><ul>
<li>arena always valid until free</li>
<li>socket NULL when not CONNECTED</li>
<li>Timestamps use monotonic ms (non-decreasing)</li>
<li><p class="startli">error_buf null-terminated, sized to SOCKET_RECONNECT_ERROR_BUFSIZE</p>
<p class="startli">Thread Safety</p>
</li>
</ul>
<dl class="section user"><dt>Thread Safety\n No - Designed for single-threaded access from event loop</dt><dd><ul>
<li>All modifications via public API calls</li>
<li>Internal helpers (time, random) are thread-safe</li>
<li><p class="startli">Callbacks invoked from caller's thread context</p>
<p class="startli">Performance Notes</p>
</li>
<li><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">O(1)</a> most operations (state checks, timer updates)</li>
<li>Minimal allocations (arena-backed)</li>
<li>Low memory footprint (~200-300 bytes + socket/arena)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity\n Varies by operation; generally O(1)</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Host string copied to arena for lifetime management </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Direct field access undefined; use accessors where public </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For leak detection, arena tracks all sub-allocs</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">creation</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">destruction</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">embedded</a> <a class="el" href="group__reconnect__private.html#ad5fa2306cda2167c0288bf4fc2885f55">policy</a> </dd>
<dd>
<a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">socketreconnect_get_time_ms()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">for</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">timing</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">helpers</a></dd></dl>
<p>Represents a resilient TCP connection that automatically manages reconnections using a state machine with exponential backoff, circuit breaker protection, and health monitoring.</p>
<p>The handle encapsulates:</p><ul>
<li>Internal state machine tracking DISCONNECTED, CONNECTING, CONNECTED, BACKOFF, CIRCUIT_OPEN states</li>
<li>Timers for backoff delays, circuit reset, and health checks</li>
<li>Underlying Socket_T instance when connected</li>
<li>Statistics for attempts and failures</li>
<li>Optional callbacks for state changes and custom health checks</li>
</ul>
<ol type="1">
<li>Create with <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a></li>
<li>Configure policy, callbacks, health check if needed</li>
<li>Call <a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> to start</li>
<li>Integrate with event loop or use passthrough I/O</li>
<li>Call <a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> to cleanup</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Full lifecycle</span></div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(<a class="code hl_variable" href="group__reconnect__private.html#a84b94071188ac92ecae8453cdbe0a604">host</a>, <a class="code hl_variable" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">port</a>, <a class="code hl_variable" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">NULL</a>, <a class="code hl_variable" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">state_cb</a>,</div>
<div class="line"><a class="code hl_variable" href="group__reconnect__private.html#a31140778b660ef58bf93500821501979">userdata</a>); <a class="code hl_function" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a>(conn);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de">SocketReconnect_isconnected</a>(conn)) {</div>
<div class="line">    <span class="comment">// Use conn...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91">SocketReconnect_free</a>(&amp;conn);</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga2064741bf60283ac3315823128fa2082"><div class="ttname"><a href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a></div><div class="ttdeci">SocketReconnect_T SocketReconnect_new(const char *host, int port, const SocketReconnect_Policy_T *policy, SocketReconnect_Callback callback, void *userdata)</div><div class="ttdoc">Create a new SocketReconnect_T instance configured for a specific host and port.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga2669844f3ad8a19649f2bc204eee8401"><div class="ttname"><a href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a></div><div class="ttdeci">void SocketReconnect_connect(SocketReconnect_T conn)</div><div class="ttdoc">Initiate or queue a connection attempt according to current state and policy.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga490043a4bfaba8214f5d10a3c7b956de"><div class="ttname"><a href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de">SocketReconnect_isconnected</a></div><div class="ttdeci">int SocketReconnect_isconnected(SocketReconnect_T conn)</div><div class="ttdoc">Check if reconnection is currently in connected state.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga9d8b4dd4a693ba7acb20ff8e78defe91"><div class="ttname"><a href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91">SocketReconnect_free</a></div><div class="ttdeci">void SocketReconnect_free(SocketReconnect_T *conn)</div><div class="ttdoc">Destroy a SocketReconnect_T instance and release all associated resources.</div></div>
<div class="ttc" id="agroup__reconnect__private_html_a31140778b660ef58bf93500821501979"><div class="ttname"><a href="group__reconnect__private.html#a31140778b660ef58bf93500821501979">SocketReconnect_T::userdata</a></div><div class="ttdeci">void * userdata</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00333">SocketReconnect-private.h:333</a></div></div>
<div class="ttc" id="agroup__reconnect__private_html_a84b94071188ac92ecae8453cdbe0a604"><div class="ttname"><a href="group__reconnect__private.html#a84b94071188ac92ecae8453cdbe0a604">SocketReconnect_T::host</a></div><div class="ttdeci">char * host</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00309">SocketReconnect-private.h:309</a></div></div>
<div class="ttc" id="agroup__reconnect__private_html_a9e409328803ca46c73908e0f6b35b275"><div class="ttname"><a href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">SocketReconnect_T::port</a></div><div class="ttdeci">int port</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00312">SocketReconnect-private.h:312</a></div></div>
<div class="ttc" id="agroup__reconnect__private_html_structSocketReconnect__T"><div class="ttname"><a href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a></div><div class="ttdoc">Opaque internal context for reconnecting socket management.</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00301">SocketReconnect-private.h:302</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md539"></a>
Thread Safety Characteristics</h2>
<ul>
<li>Not thread-safe: All operations must occur from the same thread</li>
<li>Callbacks execute in the caller's thread context</li>
<li>Internal state protected by non-reentrant design</li>
</ul>
<h2><a class="anchor" id="autotoc_md540"></a>
Integration Notes</h2>
<ul>
<li>For event-driven apps: Use <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">pollfd()</a>, <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">process()</a>, <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">tick()</a>, <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">next_timeout_ms()</a></li>
<li>For simple apps: Use <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">send()</a>/recv() wrappers for auto-reconnect</li>
<li>Combine with SocketPool for managing multiple reconnections</li>
<li>Host/port are fixed at creation; for dynamic endpoints create new instances</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Underlying socket is created/destroyed internally; do not access directly except via <a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5" title="Get the underlying Socket_T when connected.">SocketReconnect_socket()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Frequent state changes may indicate network issues; monitor via callbacks and statistics </dd></dl>
<dl class="section user"><dt>Complexity\n State queries and timers O(1); connection establishment depends</dt><dd>on network latency</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">Creation</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">Destruction</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">Current</a> <a class="el" href="group__reconnect__private.html#a2ce9284086f2282054019a446b65f720">state</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5" title="Get the underlying Socket_T when connected.">SocketReconnect_socket()</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">Underlying</a> <a class="el" href="group__reconnect__private.html#a8a5a023250774eb20e665286b9f1126c">socket</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">access</a> </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">Configuration</a> options </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00301">301</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>
</div><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketReconnect_T:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketReconnect__T__coll__graph.svg" width="619" height="304"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6c7913840f62959b714f4a0b952f7df3" name="a6c7913840f62959b714f4a0b952f7df3"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Memory arena owning host string, error_buf contents, and any sub-allocs; Disposed on <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">free()</a>; all pointers invalidated after </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae7667416df66d9ff7f22a686e91173fa" name="ae7667416df66d9ff7f22a686e91173fa"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
attempt_count</td>
<td class="fielddoc">
<p>Attempts since last success or reset; resets on connect success </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac2cfa6c7de296d34b8cc110d7d0a6c5b" name="ac2cfa6c7de296d34b8cc110d7d0a6c5b"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
backoff_until_ms</td>
<td class="fielddoc">
<p>Absolute time when current backoff period expires; used for next_timeout_ms </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac327afc59d110b4feded1c24acc20bd0" name="ac327afc59d110b4feded1c24acc20bd0"></a><a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220">SocketReconnect_Callback</a></td>
<td class="fieldname">
callback</td>
<td class="fielddoc">
<p>Optional state transition notifier (old-&gt;new state); Invoked synchronously from public API calls </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a72f1c5f160e7e5caa258655949081197" name="a72f1c5f160e7e5caa258655949081197"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
circuit_open_time_ms</td>
<td class="fielddoc">
<p>Timestamp when circuit opened; used for half-open transition </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa5865aa0b188f50f624785067341cb9d" name="aa5865aa0b188f50f624785067341cb9d"></a><a class="el" href="group__connection__mgmt.html#gad94358cbf0bb7d00f70705a6c5245433">SocketReconnect_CircuitState</a></td>
<td class="fieldname">
circuit_state</td>
<td class="fielddoc">
<p>Internal circuit breaker state; drives protection logic beyond public view </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a687b3c6cdc5b1250373bf27cd278b5f8" name="a687b3c6cdc5b1250373bf27cd278b5f8"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
connect_in_progress</td>
<td class="fielddoc">
<p>Flag: non-zero if non-blocking connect pending; cleared on completion/error </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a42da393060d75d41640ab7069af73dbe" name="a42da393060d75d41640ab7069af73dbe"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
consecutive_failures</td>
<td class="fielddoc">
<p>Consecutive failures; triggers circuit open at threshold </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acfa676687672966b58f578529cc8d90b" name="acfa676687672966b58f578529cc8d90b"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
current_backoff_delay_ms</td>
<td class="fielddoc">
<p>Currently computed backoff delay (with jitter applied); for logging/metrics </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5b09dfa6f3fb92343adc72e8ed34ecdb" name="a5b09dfa6f3fb92343adc72e8ed34ecdb"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">char</a></td>
<td class="fieldname">
error_buf[256]</td>
<td class="fielddoc">
<p>Fixed-size buffer for formatted last error (e.g., "connect failed:
Connection refused"); Null-terminated; overwritten on new errors </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9cca95f98967cbc2c1884604c38fe53a" name="a9cca95f98967cbc2c1884604c38fe53a"></a><a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3">SocketReconnect_HealthCheck</a></td>
<td class="fieldname">
health_check</td>
<td class="fielddoc">
<p>Optional custom health check; if NULL, uses default poll-based check; Must respect timeout_ms param to avoid blocking </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a84b94071188ac92ecae8453cdbe0a604" name="a84b94071188ac92ecae8453cdbe0a604"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">char</a> *</td>
<td class="fieldname">
host</td>
<td class="fielddoc">
<p>Target hostname/IP; null-terminated string allocated from arena; Length limited to SOCKET_RECONNECT_MAX_HOST_LEN (255 chars) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a54ee3868401a010bbeeca9679a842537" name="a54ee3868401a010bbeeca9679a842537"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
last_attempt_time_ms</td>
<td class="fielddoc">
<p>Timestamp of most recent connect attempt </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a52dfbb00e9f5b907cb163d55418fa039" name="a52dfbb00e9f5b907cb163d55418fa039"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
last_error</td>
<td class="fielddoc">
<p>Cached errno from last failure; 0 if no error </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a38bbb8f63052882c9251d6fb641c7b3f" name="a38bbb8f63052882c9251d6fb641c7b3f"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
last_health_check_ms</td>
<td class="fielddoc">
<p>Timestamp of last health check invocation </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae2d7b54aa971f1bc9a282176425f895c" name="ae2d7b54aa971f1bc9a282176425f895c"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
last_success_time_ms</td>
<td class="fielddoc">
<p>Timestamp of last successful connection </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad5fa2306cda2167c0288bf4fc2885f55" name="ad5fa2306cda2167c0288bf4fc2885f55"></a><a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a></td>
<td class="fieldname">
policy</td>
<td class="fielddoc">
<p>Embedded backoff, circuit, and health policy; copied from input or defaults </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9e409328803ca46c73908e0f6b35b275" name="a9e409328803ca46c73908e0f6b35b275"></a>int</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
<p>Target TCP/UDP port (1-65535); validated at creation </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8a5a023250774eb20e665286b9f1126c" name="a8a5a023250774eb20e665286b9f1126c"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Current underlying socket; NULL when disconnected or connecting; Owned until closed on error/disconnect; do not free externally </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2ce9284086f2282054019a446b65f720" name="a2ce9284086f2282054019a446b65f720"></a><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Public-facing state; updated on transitions </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0f4e3c63a4b32a25fa04cd59ff2cb119" name="a0f4e3c63a4b32a25fa04cd59ff2cb119"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int64_t</a></td>
<td class="fieldname">
state_start_time_ms</td>
<td class="fielddoc">
<p>Timestamp when current state entered </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afdf5d8464a39d02623eed54d9821b578" name="afdf5d8464a39d02623eed54d9821b578"></a><a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a></td>
<td class="fieldname">
tls_ctx</td>
<td class="fielddoc">
<p>TLS context for secure connections; NULL if TLS not configured. NOT owned by SocketReconnect - caller must ensure ctx outlives conn. Applied via <a class="el" href="group__security.html#gab9a8fb788aa1f0d21b5773bc43a48d6f" title="Enable TLS on a socket using the provided context.">SocketTLS_enable()</a> after each successful TCP connect. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0d667711eccfa1277ec0cd5ca14640ee" name="a0d667711eccfa1277ec0cd5ca14640ee"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
tls_handshake_started</td>
<td class="fielddoc">
<p>Flag: TLS handshake has been initiated for current connection. Set after <a class="el" href="group__security.html#gab9a8fb788aa1f0d21b5773bc43a48d6f" title="Enable TLS on a socket using the provided context.">SocketTLS_enable()</a>; cleared on disconnect/error. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a38f1bb1afc303abdcad29e94d6ef83b1" name="a38f1bb1afc303abdcad29e94d6ef83b1"></a><a class="el" href="group__security.html#gad092160c037d01929df1bb8d5b75b43c">TLSHandshakeState</a></td>
<td class="fieldname">
tls_handshake_state</td>
<td class="fielddoc">
<p>Current TLS handshake state; tracks progress during async handshake. Reset to TLS_HANDSHAKE_NOT_STARTED on each new connection attempt. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9e63c900de003b9cca6b0c28fe4b5dae" name="a9e63c900de003b9cca6b0c28fe4b5dae"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">char</a> *</td>
<td class="fieldname">
tls_hostname</td>
<td class="fielddoc">
<p>SNI hostname for TLS certificate verification; arena-allocated. Used for <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">SSL_set_tlsext_host_name()</a> and X509 hostname check. NULL if TLS not configured. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa1075cf1fbbf80ab405cf7248653da2a" name="aa1075cf1fbbf80ab405cf7248653da2a"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">unsigned</a> <a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">char</a> *</td>
<td class="fieldname">
tls_session_data</td>
<td class="fielddoc">
<p>Saved TLS session data for resumption; arena-allocated. Populated after successful handshake if resumption enabled. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a31fa9400b92fb9dfd48dc39c0dc5dd56" name="a31fa9400b92fb9dfd48dc39c0dc5dd56"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">size_t</a></td>
<td class="fieldname">
tls_session_data_len</td>
<td class="fielddoc">
<p>Length of saved TLS session data in bytes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa234319d18939dae9f2e0d14560c76ea" name="aa234319d18939dae9f2e0d14560c76ea"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
tls_session_resumption_enabled</td>
<td class="fielddoc">
<p>Flag: Enable session resumption for faster reconnects. When enabled, saves session after handshake and restores on reconnect. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a93f6f4ab97532b4b9db422a1f19b882d" name="a93f6f4ab97532b4b9db422a1f19b882d"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
total_attempts</td>
<td class="fielddoc">
<p>Lifetime total connection attempts; for long-term metrics </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acde4740d8c3de915c4185a0dcd967f35" name="acde4740d8c3de915c4185a0dcd967f35"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">int</a></td>
<td class="fieldname">
total_successes</td>
<td class="fielddoc">
<p>Lifetime successful connections; for reliability stats </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a31140778b660ef58bf93500821501979" name="a31140778b660ef58bf93500821501979"></a><a class="el" href="group__reconnect__private.html#a9e409328803ca46c73908e0f6b35b275">void</a> *</td>
<td class="fieldname">
userdata</td>
<td class="fielddoc">
<p>Opaque user data forwarded to callbacks; stored as-is, no ownership </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketReconnect__Policy__T" id="structSocketReconnect__Policy__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketReconnect__Policy__T">&#9670;&#160;</a></span>SocketReconnect_Policy_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketReconnect_Policy_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Configuration structure defining backoff policy, circuit breaker thresholds, and health check parameters for <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a>. </p>
<p>This structure allows fine-tuning of the reconnection behavior:</p><ul>
<li><b>Backoff Settings</b>: Control retry timing with exponential growth and randomization</li>
<li><b>Circuit Breaker</b>: Prevent connection storms after repeated failures</li>
<li><b>Health Monitoring</b>: Periodic checks to detect connection degradation early</li>
</ul>
<p>All fields are optional if using defaults via <a class="el" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212" title="Populate a SocketReconnect_Policy_T with safe, production-recommended default values.">SocketReconnect_policy_defaults()</a>. Invalid values (e.g., negative delays, multiplier &lt;= 1.0) may raise SocketReconnect_Failed.</p>
<h2><a class="anchor" id="autotoc_md544"></a>
Field Documentation</h2>
<p>See individual field comments for details. Recommended to start with defaults and tune based on application needs.</p>
<h2><a class="anchor" id="autotoc_md545"></a>
Default Values Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">Range/Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_delay_ms   </td><td class="markdownTableBodyNone">100   </td><td class="markdownTableBodyNone">&gt;0, first retry delay    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_delay_ms   </td><td class="markdownTableBodyNone">30000   </td><td class="markdownTableBodyNone">&gt; initial, cap for backoff    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multiplier   </td><td class="markdownTableBodyNone">2.0   </td><td class="markdownTableBodyNone">&gt;1.0, exponential factor    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">jitter   </td><td class="markdownTableBodyNone">0.25   </td><td class="markdownTableBodyNone">0.0-1.0, randomization %    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_attempts   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">&gt;0 or 0=unlimited    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">circuit_failure_threshold   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">&gt;0, consecutive fails to open    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">circuit_reset_timeout_ms   </td><td class="markdownTableBodyNone">60000   </td><td class="markdownTableBodyNone">&gt;0, time to attempt recovery    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">health_check_interval_ms   </td><td class="markdownTableBodyNone">30000   </td><td class="markdownTableBodyNone">&gt;0 or 0=disabled    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">health_check_timeout_ms   </td><td class="markdownTableBodyNone">5000   </td><td class="markdownTableBodyNone">&gt;0, max block time for check   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md546"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> policy;</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212">SocketReconnect_policy_defaults</a>(&amp;policy);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Customize for aggressive retry</span></div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#abf740738ffd922747329556ebd6052ca">initial_delay_ms</a> = 50;</div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#aea494798fa2b191e8a0cc3b7c64ca0a2">max_delay_ms</a> = 10000;</div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#ae9bbefd1a50c5e291395ca3af920a22d">multiplier</a> = 1.5;</div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#abd49613f2c70d36afe1822ca33ec1a0e">max_attempts</a> = 0;  <span class="comment">// Unlimited</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(host, port, &amp;policy, NULL,</div>
<div class="line">NULL);</div>
<div class="ttc" id="agroup__connection__mgmt_html_abd49613f2c70d36afe1822ca33ec1a0e"><div class="ttname"><a href="group__connection__mgmt.html#abd49613f2c70d36afe1822ca33ec1a0e">SocketReconnect_Policy_T::max_attempts</a></div><div class="ttdeci">int max_attempts</div><div class="ttdoc">Maximum retry attempts before permanent failure (default: 10). 0 means unlimited retries (use with ca...</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00391">SocketReconnect.h:391</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_abf740738ffd922747329556ebd6052ca"><div class="ttname"><a href="group__connection__mgmt.html#abf740738ffd922747329556ebd6052ca">SocketReconnect_Policy_T::initial_delay_ms</a></div><div class="ttdeci">int initial_delay_ms</div><div class="ttdoc">Initial delay before first retry after failure (default: 100ms). Must be positive (&gt;0)....</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00365">SocketReconnect.h:365</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ae9bbefd1a50c5e291395ca3af920a22d"><div class="ttname"><a href="group__connection__mgmt.html#ae9bbefd1a50c5e291395ca3af920a22d">SocketReconnect_Policy_T::multiplier</a></div><div class="ttdeci">double multiplier</div><div class="ttdoc">Multiplier for exponential backoff (default: 2.0). New delay = previous * multiplier....</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00378">SocketReconnect.h:378</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_aea494798fa2b191e8a0cc3b7c64ca0a2"><div class="ttname"><a href="group__connection__mgmt.html#aea494798fa2b191e8a0cc3b7c64ca0a2">SocketReconnect_Policy_T::max_delay_ms</a></div><div class="ttdeci">int max_delay_ms</div><div class="ttdoc">Maximum delay cap for backoff (default: 30000ms / 30s). Prevents unbounded growth....</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00372">SocketReconnect.h:372</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga4bc781f13408c70bfe9d28148ac87212"><div class="ttname"><a href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212">SocketReconnect_policy_defaults</a></div><div class="ttdeci">void SocketReconnect_policy_defaults(SocketReconnect_Policy_T *policy)</div><div class="ttdoc">Populate a SocketReconnect_Policy_T with safe, production-recommended default values.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_structSocketReconnect__Policy__T"><div class="ttname"><a href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a></div><div class="ttdoc">Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00362">SocketReconnect.h:363</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Changes take effect only at creation; recreate instance to apply new policy </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - plain struct, safe to initialize concurrently</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Setting jitter=0 may cause thundering herd in multi-instance scenarios </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212" title="Populate a SocketReconnect_Policy_T with safe, production-recommended default values.">SocketReconnect_policy_defaults()</a> Initialize with safe defaults </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> Apply policy during creation </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect_8h_source.html#l00362">362</a> of file <a class="el" href="SocketReconnect_8h_source.html">SocketReconnect.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af4176c02c394de525164d44893fd5c5a" name="af4176c02c394de525164d44893fd5c5a"></a>int</td>
<td class="fieldname">
circuit_failure_threshold</td>
<td class="fielddoc">
Consecutive failures to trigger circuit open (default: 5). After this many rapid failures, enters CIRCUIT_OPEN state blocking further attempts. Helps prevent cascading failures during outages. <dl class="section note"><dt>Note</dt><dd>Failures include connect errors and immediate post-connect issues. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ae99b002f9e873e6b101c1356f5a7df02" name="ae99b002f9e873e6b101c1356f5a7df02"></a>int</td>
<td class="fieldname">
circuit_reset_timeout_ms</td>
<td class="fielddoc">
Time in CIRCUIT_OPEN before attempting recovery probe (default: 60000ms / 60s). During this period, all connect() calls are ignored. After timeout, transitions to CONNECTING for one probe attempt. <dl class="section warning"><dt>Warning</dt><dd>Too short may retry into ongoing outage; too long delays recovery. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="aaa80956d1e58e84adfab7063e1936f95" name="aaa80956d1e58e84adfab7063e1936f95"></a>int</td>
<td class="fieldname">
health_check_interval_ms</td>
<td class="fielddoc">
Interval between health checks when CONNECTED (default: 30000ms / 30s). 0 disables health checks entirely. Checks run via tick() or internal timer. Failed check triggers transition to BACKOFF. <dl class="section note"><dt>Note</dt><dd>Overhead: Each check blocks briefly (up to health_check_timeout_ms). </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ade4054b2276dfc3c6b06a4b759241208" name="ade4054b2276dfc3c6b06a4b759241208"></a>int</td>
<td class="fieldname">
health_check_timeout_ms</td>
<td class="fielddoc">
Maximum time a health check may block (default: 5000ms / 5s). Custom health callbacks must respect this limit to avoid DoS. Default check polls socket for readability. <dl class="section warning"><dt>Warning</dt><dd>Exceeding this may cause tick()/process() to hang. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="abf740738ffd922747329556ebd6052ca" name="abf740738ffd922747329556ebd6052ca"></a>int</td>
<td class="fieldname">
initial_delay_ms</td>
<td class="fielddoc">
Initial delay before first retry after failure (default: 100ms). Must be positive (&gt;0). This is the starting point for exponential backoff: delay = initial * (multiplier ^ attempt) +/- jitter. <dl class="section note"><dt>Note</dt><dd>Too small values may overload the target during recovery. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="a803e0eaa631385205819346d33db4974" name="a803e0eaa631385205819346d33db4974"></a>double</td>
<td class="fieldname">
jitter</td>
<td class="fielddoc">
Jitter factor for randomization (default: 0.25 / 25%). Adds +/- jitter * delay randomness to avoid synchronized retries (thundering herd). Range: 0.0 (no jitter) to 1.0 (full randomization). <dl class="section warning"><dt>Warning</dt><dd>Jitter=0 with multiple instances may cause retry storms. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="abd49613f2c70d36afe1822ca33ec1a0e" name="abd49613f2c70d36afe1822ca33ec1a0e"></a>int</td>
<td class="fieldname">
max_attempts</td>
<td class="fielddoc">
Maximum retry attempts before permanent failure (default: 10). 0 means unlimited retries (use with caution to avoid infinite loops). Counts only connection attempts, not health check failures. <dl class="section note"><dt>Note</dt><dd>Reset via <a class="el" href="group__connection__mgmt.html#gace6fc797f7fe9c6cd3319f540db4b672" title="Reset reconnection statistics and state machine.">SocketReconnect_reset()</a> to retry indefinitely. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="aea494798fa2b191e8a0cc3b7c64ca0a2" name="aea494798fa2b191e8a0cc3b7c64ca0a2"></a>int</td>
<td class="fieldname">
max_delay_ms</td>
<td class="fielddoc">
Maximum delay cap for backoff (default: 30000ms / 30s). Prevents unbounded growth. Actual delay clamped to this value. <dl class="section warning"><dt>Warning</dt><dd>Set higher than typical outage duration but low enough to meet SLA. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a id="ae9bbefd1a50c5e291395ca3af920a22d" name="ae9bbefd1a50c5e291395ca3af920a22d"></a>double</td>
<td class="fieldname">
multiplier</td>
<td class="fielddoc">
Multiplier for exponential backoff (default: 2.0). New delay = previous * multiplier. Must be &gt;1.0 for growth. Common values: 1.5 (aggressive), 2.0 (standard), 3.0 (conservative). <dl class="section note"><dt>Note</dt><dd>Values &lt;=1.0 will raise SocketReconnect_Failed. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga019e030e52afae45ed11af4470267f3d" name="ga019e030e52afae45ed11af4470267f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga019e030e52afae45ed11af4470267f3d">&#9670;&#160;</a></span>POOL_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_LOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      pthread_mutex_lock (&amp;(p)-&gt;mutex);                                       \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Acquire pool mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Convenience macro for consistent mutex locking across implementation files.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gab23175b8e98780e2f7f52a917e7d0862" title="Release pool mutex.">POOL_UNLOCK</a> for releasing the mutex. </dd>
<dd>
pthread_mutex_lock() for underlying operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00116">116</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="gab23175b8e98780e2f7f52a917e7d0862" name="gab23175b8e98780e2f7f52a917e7d0862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab23175b8e98780e2f7f52a917e7d0862">&#9670;&#160;</a></span>POOL_UNLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POOL_UNLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      pthread_mutex_unlock (&amp;(p)-&gt;mutex);                                     \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Release pool mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Convenience macro for consistent mutex unlocking across implementation files.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga019e030e52afae45ed11af4470267f3d" title="Acquire pool mutex.">POOL_LOCK</a> for acquiring the mutex. </dd>
<dd>
pthread_mutex_unlock() for underlying operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00133">133</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="gaf1430b907c84491b37ab7b18f7fd75a4" name="gaf1430b907c84491b37ab7b18f7fd75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1430b907c84491b37ab7b18f7fd75a4">&#9670;&#160;</a></span>RAISE_POOL_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_POOL_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exception</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      <a class="code hl_variable" href="group__connection__mgmt.html#gaeea0045572d9693e0579e265d0e00981">SocketPool_DetailedException</a> = (exception);                             \</div>
<div class="line">      <a class="code hl_variable" href="group__connection__mgmt.html#gaeea0045572d9693e0579e265d0e00981">SocketPool_DetailedException</a>.<a class="code hl_variable" href="group__foundation.html#a6a35b57fc58f0ba7cc0d4f939dd3f773">reason</a> = <a class="code hl_variable" href="SocketUtil_8h.html#aad11dd8cef83792df92437f8d7ae3991">socket_error_buf</a>;                 \</div>
<div class="line">      RAISE (<a class="code hl_variable" href="group__connection__mgmt.html#gaeea0045572d9693e0579e265d0e00981">SocketPool_DetailedException</a>);                                   \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
<div class="ttc" id="aSocketUtil_8h_html_aad11dd8cef83792df92437f8d7ae3991"><div class="ttname"><a href="SocketUtil_8h.html#aad11dd8cef83792df92437f8d7ae3991">socket_error_buf</a></div><div class="ttdeci">char socket_error_buf[1024]</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gaeea0045572d9693e0579e265d0e00981"><div class="ttname"><a href="group__connection__mgmt.html#gaeea0045572d9693e0579e265d0e00981">SocketPool_DetailedException</a></div><div class="ttdeci">Except_T SocketPool_DetailedException</div><div class="ttdoc">Thread-local exception for detailed error messages.</div></div>
<div class="ttc" id="agroup__foundation_html_a6a35b57fc58f0ba7cc0d4f939dd3f773"><div class="ttname"><a href="group__foundation.html#a6a35b57fc58f0ba7cc0d4f939dd3f773">Except_T::reason</a></div><div class="ttdeci">const char * reason</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00219">Except.h:219</a></div></div>
</div><!-- fragment -->
<p>Raise exception with detailed error message. </p>
<p>Creates thread-local copy of exception with reason from socket_error_buf. </p><dl class="section user"><dt>Thread Safety\n Prevents race conditions when multiple threads raise same</dt><dd>exception type. Used throughout SocketPool implementation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac9e22f6917e11a16763e27d6ec2a5ccb" title="Format error message (without errno) and raise.">RAISE_POOL_MSG</a> for formatted messages. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga5125f82ee57c3f482b9371081caa3b0d" title="Format error message (with errno) and raise.">RAISE_POOL_FMT</a> for errno-formatted messages. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36" title="Pool operation failure.">SocketPool_Failed</a> exception type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00220">220</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="ga5125f82ee57c3f482b9371081caa3b0d" name="ga5125f82ee57c3f482b9371081caa3b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5125f82ee57c3f482b9371081caa3b0d">&#9670;&#160;</a></span>RAISE_POOL_FMT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_POOL_FMT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exception, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      SOCKET_ERROR_FMT (fmt, ##__VA_ARGS__);                                  \</div>
<div class="line">      RAISE_POOL_ERROR (exception);                                           \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Format error message (with errno) and raise. </p>
<p>Combines SOCKET_ERROR_FMT + RAISE_POOL_ERROR for cleaner code. </p><dl class="section user"><dt>Thread Safety\n Uses thread-local buffers.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac9e22f6917e11a16763e27d6ec2a5ccb" title="Format error message (without errno) and raise.">RAISE_POOL_MSG</a> for non-errno messages. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf1430b907c84491b37ab7b18f7fd75a4" title="Raise exception with detailed error message.">RAISE_POOL_ERROR</a> for direct exception raising. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00257">257</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="gac9e22f6917e11a16763e27d6ec2a5ccb" name="gac9e22f6917e11a16763e27d6ec2a5ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9e22f6917e11a16763e27d6ec2a5ccb">&#9670;&#160;</a></span>RAISE_POOL_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_POOL_MSG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exception, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      SOCKET_ERROR_MSG (fmt, ##__VA_ARGS__);                                  \</div>
<div class="line">      RAISE_POOL_ERROR (exception);                                           \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Format error message (without errno) and raise. </p>
<p>Combines SOCKET_ERROR_MSG + RAISE_POOL_ERROR for cleaner code. </p><dl class="section user"><dt>Thread Safety\n Uses thread-local buffers.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga5125f82ee57c3f482b9371081caa3b0d" title="Format error message (with errno) and raise.">RAISE_POOL_FMT</a> for errno-formatted messages. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf1430b907c84491b37ab7b18f7fd75a4" title="Raise exception with detailed error message.">RAISE_POOL_ERROR</a> for direct exception raising. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00239">239</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="gaa656899af348069271d2878e221b95e3" name="gaa656899af348069271d2878e221b95e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa656899af348069271d2878e221b95e3">&#9670;&#160;</a></span>SOCKET_DEFAULT_IDLE_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_IDLE_TIMEOUT&#160;&#160;&#160;300 /* 5 minutes */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default idle timeout. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pool timeouts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01433">1433</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae566ef3ebb6568218b7f7dbf8feea2c6" name="gae566ef3ebb6568218b7f7dbf8feea2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae566ef3ebb6568218b7f7dbf8feea2c6">&#9670;&#160;</a></span>SOCKET_DEFAULT_POOL_BUFSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_POOL_BUFSIZE&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default pool buffer size. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01596">1596</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2ab0335d59ba489638143cfcdbeb131c" name="ga2ab0335d59ba489638143cfcdbeb131c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ab0335d59ba489638143cfcdbeb131c">&#9670;&#160;</a></span>SOCKET_DEFAULT_POOL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_POOL_SIZE&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default connection pool size. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01586">1586</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga4a354a257cb7d9a1f7cd2befa6d72d0f" name="ga4a354a257cb7d9a1f7cd2befa6d72d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a354a257cb7d9a1f7cd2befa6d72d0f">&#9670;&#160;</a></span>SOCKET_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HASH_SIZE&#160;&#160;&#160;<a class="el" href="group__foundation.html#ga9aab9f1282519c6c66aca1271deffe84">SOCKET_HASH_TABLE_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the library's central hash table size configuration. </p>
<p>Reuses foundation::SOCKET_HASH_TABLE_SIZE (default: 1021, a prime number) for consistent hash table sizing across modules like pools, polls, DNS, and timers. This uniformity ensures predictable performance and collision characteristics.</p>
<p>Can be overridden at compile time via -DSOCKET_HASH_TABLE_SIZE=</p>
<p>.</p>
<dl class="section note"><dt>Note</dt><dd>Prime table sizes minimize hash clustering and improve lookup efficiency. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Changing this may affect hash distribution; test thoroughly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketConfig.h::SOCKET_HASH_TABLE_SIZE for definition and rationale. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a> for SocketPool hash computation. </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd()</a> and related functions in <a class="el" href="group__utilities.html">Utilities Module</a>. </dd>
<dd>
<a class="el" href="group__foundation.html">Foundation Module</a> for core configs. </dd>
<dd>
<a class="el" href="group__foundation.html#gae5597cbeaa3012e797eb99aaf9570030" title="Golden ratio constant for multiplicative hashing.">HASH_GOLDEN_RATIO</a> constant in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for hash multiplier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00167">167</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="gae461bf5ddae6eda683926a6303af87f6" name="gae461bf5ddae6eda683926a6303af87f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae461bf5ddae6eda683926a6303af87f6">&#9670;&#160;</a></span>SOCKET_LOG_COMPONENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_LOG_COMPONENT&#160;&#160;&#160;&quot;SocketPool&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default log component for all SocketPool implementation files. </p>
<p>Overrides SOCKET_LOG_COMPONENT from <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for consistent logging. Each implementation file (.c) should not need to redefine this. </p>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00099">99</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="ga775d9db592e6205d00a2b6ad81bf3492" name="ga775d9db592e6205d00a2b6ad81bf3492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga775d9db592e6205d00a2b6ad81bf3492">&#9670;&#160;</a></span>SOCKET_PERCENTAGE_DIVISOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_PERCENTAGE_DIVISOR&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Percentage divisor for calculations. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01638">1638</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga46e9cd9dc6e5eabbe91e5fa71ec00b81" name="ga46e9cd9dc6e5eabbe91e5fa71ec00b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46e9cd9dc6e5eabbe91e5fa71ec00b81">&#9670;&#160;</a></span>SOCKET_POOL_DEFAULT_PREWARM_PCT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_DEFAULT_PREWARM_PCT&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default pool prewarm percentage. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01606">1606</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae34901523f9a628eab93a9f50bf70366" name="gae34901523f9a628eab93a9f50bf70366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae34901523f9a628eab93a9f50bf70366">&#9670;&#160;</a></span>SOCKET_POOL_MAX_ASYNC_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_MAX_ASYNC_PENDING&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum pending async connect operations per pool. </p>
<p>Prevents resource exhaustion from excessive concurrent connect attempts. Security: Limits memory consumption from async context allocations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01629">1629</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga331e1002cf6dfb30695f5af41625cf46" name="ga331e1002cf6dfb30695f5af41625cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331e1002cf6dfb30695f5af41625cf46">&#9670;&#160;</a></span>SOCKET_POOL_MAX_BATCH_ACCEPTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_MAX_BATCH_ACCEPTS&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum batch accepts per iteration. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01616">1616</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7ea8374cf5055b8fe5b30a0f57b4405e" name="ga7ea8374cf5055b8fe5b30a0f57b4405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea8374cf5055b8fe5b30a0f57b4405e">&#9670;&#160;</a></span>SOCKET_POOL_MAX_BURST_MULTIPLIER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_MAX_BURST_MULTIPLIER&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum burst multiplier relative to rate. </p>
<p>Limits burst size to prevent memory exhaustion in rate limiter. Burst capacity = rate * multiplier.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> for rate limiting. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01685">1685</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga91891177acf4458552ad96ff6e2ae29e" name="ga91891177acf4458552ad96ff6e2ae29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91891177acf4458552ad96ff6e2ae29e">&#9670;&#160;</a></span>SOCKET_POOL_MAX_CONNECTIONS_PER_IP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_MAX_CONNECTIONS_PER_IP&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum connections allowed per IP address. </p>
<p>Security limit to prevent single-source attacks via per-IP limiting. Generous default allows legitimate load balancers while limiting abuse.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b" title="Set maximum connections per IP.">SocketPool_setmaxperip()</a> for per-IP limiting. </dd>
<dd>
<a class="el" href="group__ip__tracker.html#ga763b573474982e2761d5b7fbdf9155fc">SocketIPTracker_T</a> for IP tracking implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01699">1699</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa74a3828cb86356140cb80cd1d0e688e" name="gaa74a3828cb86356140cb80cd1d0e688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa74a3828cb86356140cb80cd1d0e688e">&#9670;&#160;</a></span>SOCKET_POOL_MAX_RATE_PER_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_MAX_RATE_PER_SEC&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum rate limit value (connections per second). </p>
<p>Security limit to prevent resource exhaustion from overly permissive rate configurations. Practical upper bound for most servers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> for rate limiting. </dd>
<dd>
<a class="el" href="group__utilities.html#structSocketRateLimit__T" title="Internal structure implementing the token bucket rate limiter.">SocketRateLimit_T</a> for token bucket implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01672">1672</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa6d9e9b8f4116f114766da91e8dd0744" name="gaa6d9e9b8f4116f114766da91e8dd0744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d9e9b8f4116f114766da91e8dd0744">&#9670;&#160;</a></span>SOCKET_POOL_STATS_WINDOW_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_STATS_WINDOW_SEC&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time window for pool statistics calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01658">1658</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa73d5adbdff8bd8738401ab2b2a7a9a3" name="gaa73d5adbdff8bd8738401ab2b2a7a9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73d5adbdff8bd8738401ab2b2a7a9a3">&#9670;&#160;</a></span>SOCKET_POOL_TOKENS_PER_ACCEPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_POOL_TOKENS_PER_ACCEPT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokens consumed per connection accept. </p>
<p>Number of rate limit tokens consumed per successful connection accept. Typically 1 for simple connection counting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for rate-limited accepting. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01712">1712</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacb408f000a8df7938e79ddf2a1e26ae7" name="gacb408f000a8df7938e79ddf2a1e26ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb408f000a8df7938e79ddf2a1e26ae7">&#9670;&#160;</a></span>SOCKET_RECONNECT_ERROR_BUFSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_RECONNECT_ERROR_BUFSIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum buffer capacity for internal error message strings. </p>
<p>Defines the fixed size (including null terminator) for error_buf in <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a>. Selected to fit detailed messages: errno description + connection context (host, port, attempt #).</p>
<p>Example capacity usage: "connection attempt 5 to host:port failed: [errno
str] (err=123)"</p>
<dl class="section note"><dt>Note</dt><dd>Avoids dynamic allocations in hot error paths; snprintf-safe size </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Messages truncated if exceeding limit; prioritize essential info</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reconnect__private.html#a5b09dfa6f3fb92343adc72e8ed34ecdb">SocketReconnect_T::error_buf</a> field </dd>
<dd>
socketreconnect_error_fmt() internal formatting (in .c) </dd>
<dd>
strerror() or <a class="el" href="group__foundation.html#ga481ecfe6b9e5c83515c92d1808e4b2f9" title="Provides a thread-safe and bounds-checked implementation of strerror().">Socket_safe_strerror()</a> sources </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00137">137</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

</div>
</div>
<a id="ga2b81d768340db7dd2d315d1037f85c5e" name="ga2b81d768340db7dd2d315d1037f85c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b81d768340db7dd2d315d1037f85c5e">&#9670;&#160;</a></span>SOCKET_RECONNECT_MAX_HOST_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_RECONNECT_MAX_HOST_LEN&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length for target hostname/IP strings (excluding null terminator). </p>
<p>Limits size of host field in <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a>. Aligns with DNS max label length and accommodates IPv6 literals (e.g., "[2001:db8::1]"), Unix paths if extended.</p>
<p>Validation occurs at <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a>: truncates or raises exception if exceeded.</p>
<dl class="section note"><dt>Note</dt><dd>255 chars +1 for null = 256 bytes allocated from arena </dd>
<dd>
Excludes port; full URI not supported here </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Longer hosts rejected to prevent buffer issues or DoS via oversized alloc</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reconnect__private.html#a84b94071188ac92ecae8453cdbe0a604">SocketReconnect_T::host</a> field storage </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> validation and copying </dd>
<dd>
getaddrinfo() compatibility for resolution </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00163">163</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core internal structure defining the complete SocketPool state. </p>
<p>High-level connection pool with lifecycle management.</p>
<p>Comprehensive state container for connection pooling, including pre-allocated slots, hash tables, rate limiters, SYN protection, drain logic, and statistics. Designed for thread-safe concurrent access with minimal contention.</p>
<p>CORE STRUCTURES:</p><ul>
<li>connections[]: Fixed array of <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> slots (pre-allocated for performance)</li>
<li>hash_table[]: O(1) lookup by socket FD using <a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a></li>
<li>free_list: Linked free slots for rapid recycling</li>
<li>cleanup_buffer: Temp storage for bulk operations like idle cleanup</li>
</ul>
<p>SYNCHRONIZATION:</p><ul>
<li>mutex: pthread_mutex_t protects all mutable state except atomic fields</li>
<li>state: <em>Atomic int for lock-free drain state reads (POOL_STATE</em>* enums)</li>
</ul>
<p>ASYNC OPERATIONS:</p><ul>
<li>dns: Lazy-init <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> for async resolution in connect_async()</li>
<li>async_ctx: Linked list of pending AsyncConnectContext_T</li>
<li>async_pending_count: Security limit on concurrent async operations</li>
</ul>
<p>RESILIENCE FEATURES:</p><ul>
<li>reconnect_policy: Default policy for SocketReconnect integration</li>
<li>conn_limiter: <a class="el" href="group__utilities.html#structSocketRateLimit__T" title="Internal structure implementing the token bucket rate limiter.">SocketRateLimit_T</a> for global connection rate</li>
<li>ip_tracker: SocketIPTracker_T for per-IP limits</li>
<li>syn_protect: <a class="el" href="group__security.html#structSocketSYNProtect__T" title="Core internal structure for the SYN protection module.">SocketSYNProtect_T</a> for flood protection</li>
</ul>
<p>GRACEFUL SHUTDOWN (DRAIN):</p><ul>
<li>state: Atomic enum (RUNNING/DRAINING/STOPPED)</li>
<li>drain_deadline_ms: Monotonic timer for force-stop after timeout</li>
<li>drain_cb: Optional user notification on drain complete</li>
</ul>
<p>CLEANUP &amp; MONITORING:</p><ul>
<li>idle_timeout_sec: Per-connection idle eviction</li>
<li>last_cleanup_ms / cleanup_interval_ms: Periodic maintenance scheduling</li>
<li>validation_cb: User-defined health checks before reuse</li>
<li>resize_cb: Notification on pool capacity changes</li>
<li>stats_*: Atomic counters for performance metrics (added/removed/reused/etc.)</li>
<li>stats_start_time_ms: Sliding window for rate calculations</li>
</ul>
<p>THREAD SAFETY:</p><ul>
<li>Mutex guards all operations except atomic state/count reads</li>
<li>Accessors (public API) acquire/release mutex transparently</li>
<li>Stats counters use atomic increments for concurrent updates</li>
<li>DNS callbacks execute in worker threads (user must handle synchronization)</li>
</ul>
<p>MEMORY MANAGEMENT:</p><ul>
<li>arena: Root allocator; all internal allocations (buffers, lists, trackers) from here</li>
<li>No manual free(); arena_clear() or dispose() handles bulk cleanup</li>
<li>Pre-warming allocates buffers proactively to reduce latency</li>
</ul>
<p>CONFIGURATION ENFORCEMENT:</p><ul>
<li>Limits clamped via socketpool_enforce_*() inline functions</li>
<li>Compile-time overrides via <a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> defines</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Atomic state enables non-blocking checks for draining/stopped conditions. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid long-held locks in callbacks; prefer quick operations or defer work. @security Rate limiters and trackers prevent DoS; configure conservatively for prod. @performance Hash table size (SOCKET_HASH_SIZE) impacts lookup speed; tune if needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for public opaque typedef (in <a class="el" href="SocketPool_8h.html" title="Connection pooling with automatic lifecycle management.">SocketPool.h</a>). </dd>
<dd>
struct <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> for per-connection state. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0c16fe70b77643b386b314b1c5e23575" title="Clamp value to min/max bounds.">socketpool_enforce_range()</a> family for param validation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> / <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> for lifecycle. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> / <a class="el" href="group__connection__mgmt.html#ga8363470d36d9cac714f087b8dcb1a048" title="Pre-allocate buffers for percentage of free slots.">SocketPool_prewarm()</a> for dynamic sizing. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for idle management. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for graceful shutdown. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> / <a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b" title="Set maximum connections per IP.">SocketPool_setmaxperip()</a> for limits. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for module overview and patterns. </dd>
<dd>
foundation::Arena_T for memory model. </dd>
<dd>
utilities::SocketRateLimit_T for rate limiting details.</dd></dl>
<p>Opaque type representing a pool of socket connections with automatic lifecycle management, rate limiting, SYN flood protection, and health monitoring.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for graceful shutdown. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> for rate limiting. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga847e3ae8d165d8a999ef76a68d21ffa5" title="Enable SYN flood protection for pool.">SocketPool_set_syn_protection()</a> for SYN flood protection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l00524">524</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High-level connection pool with lifecycle management. </p>
<p>Opaque type representing a pool of socket connections with automatic lifecycle management, rate limiting, SYN flood protection, and health monitoring.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for graceful shutdown. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> for rate limiting. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga847e3ae8d165d8a999ef76a68d21ffa5" title="Enable SYN flood protection for pool.">SocketPool_set_syn_protection()</a> for SYN flood protection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00091">91</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5441c8cf779cd74fbb9f39bd322c33bd" name="ga5441c8cf779cd74fbb9f39bd322c33bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5441c8cf779cd74fbb9f39bd322c33bd">&#9670;&#160;</a></span>SocketPool_ConnectCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketPool_ConnectCallback) (Connection_T conn, int error, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion callback for async connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td>Completed connection or NULL on error/failure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">error</td><td>0 on success, error code on failure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from <a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called when async connection (DNS + connect + pool add) completes. Invoked from DNS worker thread - MUST be thread-safe.</p>
<p>THREAD SAFETY REQUIREMENTS:</p><ul>
<li>MUST NOT access thread-local storage from main thread</li>
<li>MUST NOT call non-thread-safe functions without synchronization</li>
<li>Pool mutex is NOT held - MAY safely call other SocketPool functions</li>
<li>MAY call <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> if connection failed</li>
</ul>
<p>Safe patterns: mutex protection, atomic operations, work queueing, condition variables, self-pipes, event loop signaling.</p>
<p>Error codes: ENOTFOUND (DNS), ECONNREFUSED (connect), ETIMEDOUT (timeout), EHOSTUNREACH (routing), ECONNRESET (reset), or other socket errors.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a> for initiation. </dd>
<dd>
<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> for DNS resolution details. </dd>
<dd>
async_dns for async DNS patterns. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd" title="Completion callback for async connections.">SocketPool_ConnectCallback</a> for callback requirements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00236">236</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="gad7679db7b1be62e465d9896944f3ad20" name="gad7679db7b1be62e465d9896944f3ad20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7679db7b1be62e465d9896944f3ad20">&#9670;&#160;</a></span>SocketPool_DrainCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketPool_DrainCallback) (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, int timed_out, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notification callback when drain completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Pool instance that completed draining. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timed_out</td><td>1 if drain timed out (forced), 0 if graceful completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from <a class="el" href="group__connection__mgmt.html#ga254e5c125de7413e1fa2a8809350d4e0" title="Register drain completion callback.">SocketPool_set_drain_callback()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called exactly once when pool transitions to STOPPED state. Safe to call <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> from within this callback. Invoked from thread calling drain_poll/drain_wait.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for initiating drain. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga254e5c125de7413e1fa2a8809350d4e0" title="Register drain completion callback.">SocketPool_set_drain_callback()</a> for registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b" title="Poll drain progress (non-blocking).">SocketPool_drain_poll()</a> for non-blocking drain monitoring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l01170">1170</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga18f3ff7614b9968e5cc27f2017a0f058" name="ga18f3ff7614b9968e5cc27f2017a0f058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f3ff7614b9968e5cc27f2017a0f058">&#9670;&#160;</a></span>SocketPool_IdleCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketPool_IdleCallback) (Connection_T conn, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked when a connection becomes idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> that became idle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from <a class="el" href="group__connection__mgmt.html#gaa0f0813679f7ffbff6ff75adb3678c8c" title="Register callback for when connections become idle.">SocketPool_set_idle_callback()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called when a connection transitions to idle state (e.g., after being returned to the pool or after activity timeout). Useful for connection monitoring, logging, or cleanup of per-connection state.</p>
<p>THREAD SAFETY REQUIREMENTS:</p><ul>
<li>MAY be called from pool operations with pool mutex held</li>
<li>MUST NOT call SocketPool_add/remove/get (will deadlock)</li>
<li>SHOULD complete quickly (&lt;1ms) to avoid blocking pool ops</li>
<li>MAY use Connection_* accessors safely</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaa0f0813679f7ffbff6ff75adb3678c8c" title="Register callback for when connections become idle.">SocketPool_set_idle_callback()</a> for registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for automatic idle cleanup. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00187">187</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga1277558455541e0ec64e20bf8d21b71c" name="ga1277558455541e0ec64e20bf8d21b71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1277558455541e0ec64e20bf8d21b71c">&#9670;&#160;</a></span>SocketPool_Predicate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* SocketPool_Predicate) (Connection_T conn, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate callback for filtering connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from SocketPool_find/filter(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if connection matches criteria, 0 otherwise.</dd></dl>
<p>Used with <a class="el" href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f" title="Find first connection matching a predicate.">SocketPool_find()</a> and <a class="el" href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac" title="Find all connections matching a predicate.">SocketPool_filter()</a> to select connections based on custom criteria. Called with pool mutex held.</p>
<p>THREAD SAFETY REQUIREMENTS:</p><ul>
<li>Called with pool mutex held - keep operations quick</li>
<li>MUST NOT call SocketPool_add/remove (will deadlock)</li>
<li>MAY use Connection_* accessors safely</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f" title="Find first connection matching a predicate.">SocketPool_find()</a> for finding first matching connection. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac" title="Find all connections matching a predicate.">SocketPool_filter()</a> for finding all matching connections. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00207">207</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga6ec7b7f0dae3b1366f32f93294dc8b4a" name="ga6ec7b7f0dae3b1366f32f93294dc8b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec7b7f0dae3b1366f32f93294dc8b4a">&#9670;&#160;</a></span>SocketPool_ResizeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketPool_ResizeCallback) (<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool, size_t old_size, size_t new_size, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked after pool resize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Pool instance that was resized. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">old_size</td><td>Previous maximum connection capacity. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_size</td><td>New maximum connection capacity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from <a class="el" href="group__connection__mgmt.html#ga9c7cd8aa28512bb3e73885f5968a46cd" title="Register pool resize notification callback.">SocketPool_set_resize_callback()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called after successful pool resize operations for monitoring/logging.</p>
<dl class="section user"><dt>Thread Safety\n Yes - callback is invoked outside pool mutex.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9c7cd8aa28512bb3e73885f5968a46cd" title="Register pool resize notification callback.">SocketPool_set_resize_callback()</a> for registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for resize operations. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00165">165</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga9a848b27d2034b028ceb2febdc6471b5" name="ga9a848b27d2034b028ceb2febdc6471b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a848b27d2034b028ceb2febdc6471b5">&#9670;&#160;</a></span>SocketPool_ValidationCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* SocketPool_ValidationCallback) (Connection_T conn, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to validate connection before reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> being validated for reuse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data from <a class="el" href="group__connection__mgmt.html#ga11a46794f10d4d659cf75412e84cef31" title="Set connection validation callback.">SocketPool_set_validation_callback()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if connection is valid for reuse, 0 to remove it (forces removal from pool).</dd></dl>
<p>Called during <a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> before returning the connection to the caller. If returns 0, the connection is automatically removed from the pool and NULL is returned to the caller.</p>
<p>CRITICAL THREAD SAFETY REQUIREMENTS: The callback is invoked with the pool mutex held:</p><ul>
<li>MUST NOT call any SocketPool_* functions (will cause deadlock)</li>
<li>MUST NOT call functions that acquire the pool mutex</li>
<li>MUST NOT block for extended periods (degrades pool performance for all users)</li>
<li>SHOULD complete in &lt;1ms for optimal performance</li>
<li>MAY safely read via Connection_* accessors (thread-safe)</li>
<li>MAY perform quick socket health checks (e.g., poll(fd, 0 timeout))</li>
</ul>
<p>Violating these may cause deadlocks or severe performance degradation. For complex validation:</p><ul>
<li>Use a separate validation thread with async notification</li>
<li>Perform additional validation after <a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> returns</li>
<li>Rely on <a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5" title="Check health of a connection.">SocketPool_check_connection()</a> for simple cases</li>
</ul>
<p>Use for application-specific health checks beyond built-in validation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga11a46794f10d4d659cf75412e84cef31" title="Set connection validation callback.">SocketPool_set_validation_callback()</a> for registration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5" title="Check health of a connection.">SocketPool_check_connection()</a> for built-in health checks. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for invocation context. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for connection management patterns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l00148">148</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga0d4cc030dc9989344d20a170b6410220" name="ga0d4cc030dc9989344d20a170b6410220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4cc030dc9989344d20a170b6410220">&#9670;&#160;</a></span>SocketReconnect_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketReconnect_Callback) (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, <a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> old_state, <a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> new_state, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked on reconnection state transitions for monitoring and custom logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>The <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance changing state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_state</td><td>State before the transition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_state</td><td>State after the transition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>User data provided at <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This callback is invoked synchronously from the thread calling process(), tick(), or I/O functions that trigger state changes. Useful for:</p><ul>
<li>Logging state transitions for debugging</li>
<li>Updating metrics (e.g., increment failure counters)</li>
<li>Triggering application-level actions (e.g., alert on CIRCUIT_OPEN)</li>
<li>Custom backoff adjustments (but avoid blocking)</li>
</ul>
<h2><a class="anchor" id="autotoc_md547"></a>
Invocation Guarantees</h2>
<ul>
<li>Called exactly once per state transition</li>
<li>Non-reentrant: No nested calls from within callback</li>
<li>Short-lived: Should complete quickly to avoid delaying I/O processing</li>
</ul>
<h2><a class="anchor" id="autotoc_md548"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div>
<div class="line">state_change_cb(<a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, <a class="code hl_enumeration" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> old,</div>
<div class="line"><a class="code hl_enumeration" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> <span class="keyword">new</span>, <span class="keywordtype">void</span> *ud) { <span class="keyword">const</span> <span class="keywordtype">char</span> *old_name =</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4">SocketReconnect_state_name</a>(old); <span class="keyword">const</span> <span class="keywordtype">char</span> *new_name =</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4">SocketReconnect_state_name</a>(<span class="keyword">new</span>); <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Reconnect %p: %s -&gt;</span></div>
<div class="line"><span class="stringliteral">%s&quot;</span>, conn, old_name, new_name);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">new</span> == <a class="code hl_enumvalue" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db">RECONNECT_CIRCUIT_OPEN</a>) {</div>
<div class="line">        <span class="comment">// Alert or log outage</span></div>
<div class="line">        <span class="comment">// ud might be app context</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">new</span> == <a class="code hl_enumvalue" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1">RECONNECT_CONNECTED</a>) {</div>
<div class="line">        <span class="comment">// Resume operations</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register at creation</span></div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(host, port, NULL,</div>
<div class="line">state_change_cb, app_context);</div>
<div class="ttc" id="aSocketUtil_8h_html_a9fe70c7ab8b971af2971f3a102b82819"><div class="ttname"><a href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_INFO_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00540">SocketUtil.h:540</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga0678924e4ecd0f43e1385d2e0b5354d4"><div class="ttname"><a href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4">SocketReconnect_state_name</a></div><div class="ttdeci">const char * SocketReconnect_state_name(SocketReconnect_State state)</div><div class="ttdoc">Get human-readable name for a reconnection state.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gab0f7f9254ebc5d681f058d6b2c26f548"><div class="ttname"><a href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a></div><div class="ttdeci">SocketReconnect_State</div><div class="ttdoc">States of the reconnection state machine for tracking connection lifecycle and backoff status.</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00289">SocketReconnect.h:290</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db"><div class="ttname"><a href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db">RECONNECT_CIRCUIT_OPEN</a></div><div class="ttdeci">@ RECONNECT_CIRCUIT_OPEN</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00296">SocketReconnect.h:295</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1"><div class="ttname"><a href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1">RECONNECT_CONNECTED</a></div><div class="ttdeci">@ RECONNECT_CONNECTED</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00293">SocketReconnect.h:293</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Do not call <a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a>, connect(), or other mutating functions from within the callback to avoid recursion or use-after-free </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Blocking operations (e.g., I/O, sleeps) in callback may stall the event loop </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - executes in caller's thread; ensure caller is</dt><dd>single-threaded per instance</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> Register callback during creation </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> Query state directly </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4" title="Get human-readable name for a reconnection state.">SocketReconnect_state_name()</a> String names for logging </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect_8h_source.html#l00534">534</a> of file <a class="el" href="SocketReconnect_8h_source.html">SocketReconnect.h</a>.</p>

</div>
</div>
<a id="gae24b576ed367f734f434ef30ad8386c3" name="gae24b576ed367f734f434ef30ad8386c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24b576ed367f734f434ef30ad8386c3">&#9670;&#160;</a></span>SocketReconnect_HealthCheck</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* SocketReconnect_HealthCheck) (<a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, Socket_T socket, int timeout_ms, void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom health check callback to verify connection liveness beyond basic connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context performing the check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Underlying connected Socket_T to test </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Maximum milliseconds to block/wait for the check; 0=non-blocking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>User data from <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> or set_health_check()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if healthy (connection responsive), 0 if unhealthy (triggers BACKOFF transition)</dd></dl>
<p>Invoked periodically (per policy.health_check_interval_ms) during CONNECTED state to proactively detect issues like high latency or partial failures. The check should verify application-level health if possible (e.g., ping endpoint, read heartbeat).</p>
<h2><a class="anchor" id="autotoc_md549"></a>
Requirements</h2>
<ul>
<li>Must complete within timeout_ms or risk blocking the event loop</li>
<li>Non-blocking preferred when timeout_ms=0</li>
<li>Return 0 on any failure to err on side of caution</li>
<li>Default: Polls socket for readability (detects dead peers)</li>
</ul>
<h2><a class="anchor" id="autotoc_md550"></a>
Security Considerations</h2>
<ul>
<li>Respect timeout to prevent DoS from slow/malicious health checks</li>
<li>Avoid external calls (DNS, HTTP) that could be exploited</li>
<li>Use Socket_set_timeout() on socket if needed for check operations</li>
</ul>
<h2><a class="anchor" id="autotoc_md551"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span></div>
<div class="line">my_health_check(<a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn, Socket_T sock, <span class="keywordtype">int</span> timeout_ms, <span class="keywordtype">void</span></div>
<div class="line">*ud) {</div>
<div class="line">    <span class="comment">// Simple ping: send heartbeat, expect response within timeout</span></div>
<div class="line">    <span class="keywordtype">char</span> ping[] = <span class="stringliteral">&quot;PING&quot;</span>;</div>
<div class="line">    <span class="keywordtype">char</span> buf[64];</div>
<div class="line"> </div>
<div class="line">    ssize_t sent = <a class="code hl_function" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a>(sock, ping, <span class="keyword">sizeof</span>(ping)-1);</div>
<div class="line">    <span class="keywordflow">if</span> (sent &lt; 0) <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>pollfd pfd = { <a class="code hl_function" href="group__core__io.html#ga4d727948c677509eec04746585819877">Socket_fd</a>(sock), POLLIN, 0 };</div>
<div class="line">    <span class="keywordtype">int</span> ready = poll(&amp;pfd, 1, timeout_ms);</div>
<div class="line">    <span class="keywordflow">if</span> (ready &lt;= 0) <span class="keywordflow">return</span> 0;  <span class="comment">// Timeout or error</span></div>
<div class="line"> </div>
<div class="line">    ssize_t rcvd = <a class="code hl_function" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a>(sock, buf, <span class="keyword">sizeof</span>(buf)-1);</div>
<div class="line">    <span class="keywordflow">return</span> (rcvd &gt; 0 &amp;&amp; strncmp(buf, <span class="stringliteral">&quot;PONG&quot;</span>, 4) == 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set after creation</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0">SocketReconnect_set_health_check</a>(conn, my_health_check);</div>
<div class="ttc" id="agroup__connection__mgmt_html_gacf257c08816a36a97c02b32e034c0ea0"><div class="ttname"><a href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0">SocketReconnect_set_health_check</a></div><div class="ttdeci">void SocketReconnect_set_health_check(SocketReconnect_T conn, SocketReconnect_HealthCheck check)</div><div class="ttdoc">Register a custom health check callback for proactive connection validation.</div></div>
<div class="ttc" id="agroup__core__io_html_ga23ace6e065fe4b9a01db8caa6513515b"><div class="ttname"><a href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a></div><div class="ttdeci">ssize_t Socket_send(Socket_T socket, const void *buf, size_t len)</div><div class="ttdoc">Send data.</div></div>
<div class="ttc" id="agroup__core__io_html_ga4d727948c677509eec04746585819877"><div class="ttname"><a href="group__core__io.html#ga4d727948c677509eec04746585819877">Socket_fd</a></div><div class="ttdeci">int Socket_fd(const Socket_T socket)</div><div class="ttdoc">Get underlying file descriptor.</div></div>
<div class="ttc" id="agroup__core__io_html_ga95db343f47445925cecd6b20054518e9"><div class="ttname"><a href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a></div><div class="ttdeci">ssize_t Socket_recv(Socket_T socket, void *buf, size_t len)</div><div class="ttdoc">Receive data.</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Exceeding timeout_ms may cause overall system hangs; always check time remaining </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Custom checks run in caller's thread; ensure non-blocking where possible </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - executes in tick()/process() caller's context</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0" title="Register a custom health check callback for proactive connection validation.">SocketReconnect_set_health_check()</a> Register custom check </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#aaa80956d1e58e84adfab7063e1936f95" title="Interval between health checks when CONNECTED (default: 30000ms / 30s). 0 disables health checks enti...">SocketReconnect_Policy_T::health_check_interval_ms</a> Control frequency </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ade4054b2276dfc3c6b06a4b759241208" title="Maximum time a health check may block (default: 5000ms / 5s). Custom health callbacks must respect th...">SocketReconnect_Policy_T::health_check_timeout_ms</a> Set max block time </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect_8h_source.html#l00604">604</a> of file <a class="el" href="SocketReconnect_8h_source.html">SocketReconnect.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga92931382e16ec0f93619d6fe95c68fdf" name="ga92931382e16ec0f93619d6fe95c68fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92931382e16ec0f93619d6fe95c68fdf">&#9670;&#160;</a></span>SocketPool_ConnHealth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf">SocketPool_ConnHealth</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> health status enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga92931382e16ec0f93619d6fe95c68fdfa92d5c5da87579cc06fcbe3ff7f3c312e" name="gga92931382e16ec0f93619d6fe95c68fdfa92d5c5da87579cc06fcbe3ff7f3c312e"></a>POOL_CONN_HEALTHY&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> is healthy and usable </p>
</td></tr>
<tr><td class="fieldname"><a id="gga92931382e16ec0f93619d6fe95c68fdfae8b36f49ecaf54a76a78bed5a38da457" name="gga92931382e16ec0f93619d6fe95c68fdfae8b36f49ecaf54a76a78bed5a38da457"></a>POOL_CONN_DISCONNECTED&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> has been disconnected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga92931382e16ec0f93619d6fe95c68fdfa6d7a0c62f6bf32b8e47f29eed6533f69" name="gga92931382e16ec0f93619d6fe95c68fdfa6d7a0c62f6bf32b8e47f29eed6533f69"></a>POOL_CONN_ERROR&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> has a socket error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga92931382e16ec0f93619d6fe95c68fdfa38972b76d931672d61056eea4fec704a" name="gga92931382e16ec0f93619d6fe95c68fdfa38972b76d931672d61056eea4fec704a"></a>POOL_CONN_STALE&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> has exceeded max age </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l01397">1397</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="ga97c30d41df98c69bb394f0a91c3759ae" name="ga97c30d41df98c69bb394f0a91c3759ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97c30d41df98c69bb394f0a91c3759ae">&#9670;&#160;</a></span>SocketPool_Health</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae">SocketPool_Health</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Health status for load balancer integration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga97c30d41df98c69bb394f0a91c3759aea42517e08f6d9119b5f96fe68b5623e2d" name="gga97c30d41df98c69bb394f0a91c3759aea42517e08f6d9119b5f96fe68b5623e2d"></a>POOL_HEALTH_HEALTHY&#160;</td><td class="fielddoc"><p>Accept traffic normally </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c30d41df98c69bb394f0a91c3759aea972a5e12c8d2b2b17477779aece54c74" name="gga97c30d41df98c69bb394f0a91c3759aea972a5e12c8d2b2b17477779aece54c74"></a>POOL_HEALTH_DRAINING&#160;</td><td class="fielddoc"><p>Finishing existing connections, reject new </p>
</td></tr>
<tr><td class="fieldname"><a id="gga97c30d41df98c69bb394f0a91c3759aea083eb1503d53d80d116c0ee25022b819" name="gga97c30d41df98c69bb394f0a91c3759aea083eb1503d53d80d116c0ee25022b819"></a>POOL_HEALTH_STOPPED&#160;</td><td class="fielddoc"><p>Not accepting any traffic </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l01148">1148</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="gae5f905ecace343c3b462dfadd5fa8056" name="gae5f905ecace343c3b462dfadd5fa8056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5f905ecace343c3b462dfadd5fa8056">&#9670;&#160;</a></span>SocketPool_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056">SocketPool_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pool lifecycle states for graceful shutdown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae5f905ecace343c3b462dfadd5fa8056a6c2b7ace544a9999526d4314075694f5" name="ggae5f905ecace343c3b462dfadd5fa8056a6c2b7ace544a9999526d4314075694f5"></a>POOL_STATE_RUNNING&#160;</td><td class="fielddoc"><p>Normal operation - accepting connections </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae5f905ecace343c3b462dfadd5fa8056a24af61ac7dffa2f526a693507b11075b" name="ggae5f905ecace343c3b462dfadd5fa8056a24af61ac7dffa2f526a693507b11075b"></a>POOL_STATE_DRAINING&#160;</td><td class="fielddoc"><p>Rejecting new, waiting for existing to close </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae5f905ecace343c3b462dfadd5fa8056a937e01590410f41013603cedffd2d2d9" name="ggae5f905ecace343c3b462dfadd5fa8056a937e01590410f41013603cedffd2d2d9"></a>POOL_STATE_STOPPED&#160;</td><td class="fielddoc"><p>Fully stopped - safe to free </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketPool_8h_source.html#l01137">1137</a> of file <a class="el" href="SocketPool_8h_source.html">SocketPool.h</a>.</p>

</div>
</div>
<a id="gad94358cbf0bb7d00f70705a6c5245433" name="gad94358cbf0bb7d00f70705a6c5245433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad94358cbf0bb7d00f70705a6c5245433">&#9670;&#160;</a></span>SocketReconnect_CircuitState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__connection__mgmt.html#gad94358cbf0bb7d00f70705a6c5245433">SocketReconnect_CircuitState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal circuit breaker states for reconnection resilience. </p>
<p>Manages the circuit breaker pattern to prevent connection storms and cascading failures during service outages. Provides three internal states that map to public SocketReconnect_State behaviors but allow precise control over transitions.</p>
<p>State Descriptions</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CIRCUIT_CLOSED   </td><td class="markdownTableBodyNone">Normal operation   </td><td class="markdownTableBodyNone">Allows all connection attempts;   </td></tr>
</table>
<p>failures increment counters | | CIRCUIT_OPEN | Protection mode | Blocks attempts after failure threshold; waits for reset timeout | | CIRCUIT_HALF_OPEN | Probe mode | Permits one probe connection; success closes circuit, failure re-opens |</p>
<p>Transitions</p>
<ul>
<li>CLOSED  OPEN: Consecutive failures reach policy.circuit_failure_threshold</li>
<li>OPEN  HALF_OPEN: Timeout expires (policy.circuit_reset_timeout_ms)</li>
<li>HALF_OPEN  CLOSED: Probe connection succeeds</li>
<li>HALF_OPEN  OPEN: Probe fails</li>
<li>CLOSED  CLOSED: Successful connections reset failure counters</li>
</ul>
<p>Transitions are atomic and handled internally by the state machine.</p>
<p>Usage</p>
<p>Accessed only via <a class="el" href="group__reconnect__private.html#aa5865aa0b188f50f624785067341cb9d">SocketReconnect_T::circuit_state</a>. Never set directly from outside the module. Public API reflects these states through SocketReconnect_State.</p>
<dl class="section user"><dt>Complexity\n O(1) for state checks and transitions</dt><dd></dd></dl>
<dl class="section user"><dt>Thread Safety\n Internal - modifications protected by reconnect instance logic</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Resets to CLOSED on <a class="el" href="group__connection__mgmt.html#gace6fc797f7fe9c6cd3319f540db4b672" title="Reset reconnection statistics and state machine.">SocketReconnect_reset()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Manipulating directly may cause inconsistent state or infinite loops</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548" title="States of the reconnection state machine for tracking connection lifecycle and backoff status.">SocketReconnect_State</a> for public state view </dd>
<dd>
<a class="el" href="group__reconnect__private.html#aa5865aa0b188f50f624785067341cb9d">SocketReconnect_T::circuit_state</a> for storage </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#af4176c02c394de525164d44893fd5c5a" title="Consecutive failures to trigger circuit open (default: 5). After this many rapid failures,...">SocketReconnect_Policy_T::circuit_failure_threshold</a> configuration </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad94358cbf0bb7d00f70705a6c5245433a12c918198345e8aefaaabab17a21f9bf" name="ggad94358cbf0bb7d00f70705a6c5245433a12c918198345e8aefaaabab17a21f9bf"></a>CIRCUIT_CLOSED&#160;</td><td class="fielddoc"><p>Normal operation: connections allowed, failures tracked </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e" name="ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e"></a>CIRCUIT_OPEN&#160;</td><td class="fielddoc"><p>Blocked: too many consecutive failures, waiting timeout </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad94358cbf0bb7d00f70705a6c5245433a41651f787427ec87c589c4c5c912a6f9" name="ggad94358cbf0bb7d00f70705a6c5245433a41651f787427ec87c589c4c5c912a6f9"></a>CIRCUIT_HALF_OPEN&#160;</td><td class="fielddoc"><p>Probe allowed: single connection attempt to test recovery </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00218">218</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

</div>
</div>
<a id="gab0f7f9254ebc5d681f058d6b2c26f548" name="gab0f7f9254ebc5d681f058d6b2c26f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f7f9254ebc5d681f058d6b2c26f548">&#9670;&#160;</a></span>SocketReconnect_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States of the reconnection state machine for tracking connection lifecycle and backoff status. </p>
<p>The state machine transitions as follows:</p><ul>
<li>DISCONNECTED: Idle state, ready for connect() or after graceful disconnect</li>
<li>CONNECTING: Active connection attempt in progress (non-blocking connect)</li>
<li>CONNECTED: Successfully established and healthy connection</li>
<li>BACKOFF: Waiting exponential delay before next retry after failure</li>
<li>CIRCUIT_OPEN: Circuit breaker tripped, blocking attempts until reset timeout</li>
</ul>
<p>Transitions are triggered by connect(), process(), tick(), send/recv errors, health checks, and timeouts.</p>
<h2><a class="anchor" id="autotoc_md542"></a>
State Transition Diagram</h2>
<div class="fragment"><div class="line">+-------------+     connect()     +-------------+</div>
<div class="line">| DISCONNECTED| ----------------&gt; | CONNECTING  |</div>
<div class="line">+-------------+                  +-------------+</div>
<div class="line">     ^                                   |</div>
<div class="line">     | disconnect()                      | success/fail</div>
<div class="line">     |                                   v</div>
<div class="line">+-------------+    timeout/error    +-------------+    health fail</div>
<div class="line">| <a class="code hl_enumvalue" href="group__connection__mgmt.html#ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e">CIRCUIT_OPEN</a>| &lt;-------------------|   BACKOFF   | &lt;-------------- |</div>
<div class="line">+-------------+                     +-------------+                 |</div>
<div class="line">     ^                                             |                |</div>
<div class="line">     | timeout                                     |                |</div>
<div class="line">     |                                             |                |</div>
<div class="line">     +--------------------------- reset() ---------+                |</div>
<div class="line">                                                            failure |</div>
<div class="line">                                                             |     |</div>
<div class="line">                                                             v     |</div>
<div class="line">                                                      +-------------+</div>
<div class="line">                                                      | CONNECTED   |</div>
<div class="line">                                                      +-------------+</div>
<div class="line">                                                             |</div>
<div class="line">                                                        send/recv |</div>
<div class="line">                                                             |</div>
<div class="line">                                                      disconnect() |</div>
<div class="line">                                                             v</div>
<div class="line">                                                      DISCONNECTED</div>
<div class="ttc" id="agroup__connection__mgmt_html_ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e"><div class="ttname"><a href="group__connection__mgmt.html#ggad94358cbf0bb7d00f70705a6c5245433a2a8a3b681ff1a0abc1cf43de46db913e">CIRCUIT_OPEN</a></div><div class="ttdeci">@ CIRCUIT_OPEN</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00222">SocketReconnect-private.h:222</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md543"></a>
State Properties Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">pollfd()   </th><th class="markdownTableHeadNone">send/recv   </th><th class="markdownTableHeadNone">Actions    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DISCONNECTED   </td><td class="markdownTableBodyNone">Not connected, idle   </td><td class="markdownTableBodyNone">-1   </td><td class="markdownTableBodyNone">Block/0   </td><td class="markdownTableBodyNone">connect() starts    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transition   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">CONNECTING   </td><td class="markdownTableBodyNone">Non-blocking connect in progress   </td><td class="markdownTableBodyNone">Valid FD   </td></tr>
</table>
<p>Block | process() completes | | CONNECTED | Active connection | Valid FD | Available | Errors trigger BACKOFF | | BACKOFF | Exponential wait | -1 | Block | tick() advances timer | | CIRCUIT_OPEN | Breaker open, no attempts | -1 | Block | tick() resets after timeout |</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4" title="Get human-readable name for a reconnection state.">SocketReconnect_state_name()</a> for logging/debugging state strings </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid direct state manipulation; use public API functions</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> Query current state </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4" title="Get human-readable name for a reconnection state.">SocketReconnect_state_name()</a> Human-readable names </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220" title="Callback invoked on reconnection state transitions for monitoring and custom logic.">SocketReconnect_Callback()</a> For state change notifications </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab0f7f9254ebc5d681f058d6b2c26f548aad8113419cbfb25276d1139df9831611" name="ggab0f7f9254ebc5d681f058d6b2c26f548aad8113419cbfb25276d1139df9831611"></a>RECONNECT_DISCONNECTED&#160;</td><td class="fielddoc"><p>Not connected, not attempting </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0f7f9254ebc5d681f058d6b2c26f548aa8ce7a5b74cbcbbaf91d733e39ec0c07" name="ggab0f7f9254ebc5d681f058d6b2c26f548aa8ce7a5b74cbcbbaf91d733e39ec0c07"></a>RECONNECT_CONNECTING&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> attempt in progress </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1" name="ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1"></a>RECONNECT_CONNECTED&#160;</td><td class="fielddoc"><p>Successfully connected </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0f7f9254ebc5d681f058d6b2c26f548a32ae482a193f2b27c73f934837a458a6" name="ggab0f7f9254ebc5d681f058d6b2c26f548a32ae482a193f2b27c73f934837a458a6"></a>RECONNECT_BACKOFF&#160;</td><td class="fielddoc"><p>Waiting before retry (exponential backoff) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db" name="ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db"></a>RECONNECT_CIRCUIT_OPEN&#160;</td><td class="fielddoc"><p>Circuit breaker open, blocking attempts </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketReconnect_8h_source.html#l00289">289</a> of file <a class="el" href="SocketReconnect_8h_source.html">SocketReconnect.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaae4e8594fc75b148281c6b7874c279d3" name="gaae4e8594fc75b148281c6b7874c279d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae4e8594fc75b148281c6b7874c279d3">&#9670;&#160;</a></span>check_pool_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int check_pool_full </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if pool has reached maximum capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if pool is full, 0 if slots available.</dd></dl>
<p>Fast check without acquiring locks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for capacity enforcement. </dd></dl>

</div>
</div>
<a id="gadeb31a2cef7f4d6b590baf9c3e4fd048" name="gadeb31a2cef7f4d6b590baf9c3e4fd048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb31a2cef7f4d6b590baf9c3e4fd048">&#9670;&#160;</a></span>Connection_created_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t Connection_created_at </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection creation timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Creation timestamp as time_t. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1" title="Get connection&#39;s last activity timestamp.">Connection_lastactivity()</a> for last activity time. </dd></dl>

</div>
</div>
<a id="ga1faf8c706d1ed9418446fc155fa289dd" name="ga1faf8c706d1ed9418446fc155fa289dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1faf8c706d1ed9418446fc155fa289dd">&#9670;&#160;</a></span>Connection_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Connection_data </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection's user data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User data pointer. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1" title="Set connection&#39;s user data.">Connection_setdata()</a> for setting user data. </dd></dl>

</div>
</div>
<a id="ga548e5fadc02daadb2388d09bf8aec167" name="ga548e5fadc02daadb2388d09bf8aec167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga548e5fadc02daadb2388d09bf8aec167">&#9670;&#160;</a></span>Connection_has_reconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Connection_has_reconnect </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if connection has auto-reconnect enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if auto-reconnect is enabled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> to enable reconnection. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0ea55ad82560acb8b5b44dceebc7c02f" title="Get reconnection context for connection.">Connection_reconnect()</a> to get context. </dd></dl>

</div>
</div>
<a id="ga24170577512ce3a19fe195ab9c3576bf" name="ga24170577512ce3a19fe195ab9c3576bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24170577512ce3a19fe195ab9c3576bf">&#9670;&#160;</a></span>Connection_inbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> Connection_inbuf </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection's input buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input buffer for reading data. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga6d7573f71d8853943029cfd55fa3fb3a" title="Get connection&#39;s output buffer.">Connection_outbuf()</a> for output buffer. </dd>
<dd>
<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer operations. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gaf52bba490d68b2dd5448a61a1cc820a1" name="gaf52bba490d68b2dd5448a61a1cc820a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf52bba490d68b2dd5448a61a1cc820a1">&#9670;&#160;</a></span>Connection_isactive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Connection_isactive </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if connection is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if connection is active. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for automatic activity timestamp updates. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for inactive connection removal. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00058">is_idle_connection()</a>.</p>

</div>
</div>
<a id="ga68397aca39e8902ee26108dcb86b5db1" name="ga68397aca39e8902ee26108dcb86b5db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68397aca39e8902ee26108dcb86b5db1">&#9670;&#160;</a></span>Connection_lastactivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t Connection_lastactivity </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection's last activity timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last activity time as time_t. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gadeb31a2cef7f4d6b590baf9c3e4fd048" title="Get connection creation timestamp.">Connection_created_at()</a> for creation timestamp. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for idle connection removal. </dd></dl>

</div>
</div>
<a id="ga6d7573f71d8853943029cfd55fa3fb3a" name="ga6d7573f71d8853943029cfd55fa3fb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7573f71d8853943029cfd55fa3fb3a">&#9670;&#160;</a></span>Connection_outbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> Connection_outbuf </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection's output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output buffer for writing data. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf" title="Get connection&#39;s input buffer.">Connection_inbuf()</a> for input buffer. </dd>
<dd>
<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer operations. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga0ea55ad82560acb8b5b44dceebc7c02f" name="ga0ea55ad82560acb8b5b44dceebc7c02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea55ad82560acb8b5b44dceebc7c02f">&#9670;&#160;</a></span>Connection_reconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> Connection_reconnect </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reconnection context for connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> context, or NULL if reconnection not enabled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - returned context is not thread-safe.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga548e5fadc02daadb2388d09bf8aec167" title="Check if connection has auto-reconnect enabled.">Connection_has_reconnect()</a> to check if enabled. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> to enable reconnection. </dd></dl>

</div>
</div>
<a id="gab48a53bc1b36954d521104fedf9012c1" name="gab48a53bc1b36954d521104fedf9012c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48a53bc1b36954d521104fedf9012c1">&#9670;&#160;</a></span>Connection_setdata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Connection_setdata </td>
          <td>(</td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connection's user data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection_T instance (must not be NULL). </td></tr>
    <tr><td class="paramname">data</td><td>void* data pointer to store (may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - requires external synchronization for concurrent access.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Other Connection_* accessors are thread-safe, but this modifies state. </dd>
<dd>
Data is not freed automatically - caller responsible for cleanup. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Concurrent calls to <a class="el" href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1" title="Set connection&#39;s user data.">Connection_setdata()</a> without synchronization will cause data races. Use mutex or atomic operations if needed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga1faf8c706d1ed9418446fc155fa289dd" title="Get connection&#39;s user data.">Connection_data()</a> for reading user data. </dd>
<dd>
Connection_T for connection management. </dd></dl>

</div>
</div>
<a id="gaaeff7efb1109a312f56e35689b67c652" name="gaaeff7efb1109a312f56e35689b67c652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeff7efb1109a312f56e35689b67c652">&#9670;&#160;</a></span>Connection_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Connection_socket </td>
          <td>(</td>
          <td class="paramtype">const Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection's socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Connection_T instance (must not be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Associated Socket_T (never NULL for valid connections). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only accessor, no synchronization needed.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Socket remains valid until connection is removed from pool. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf" title="Get connection&#39;s input buffer.">Connection_inbuf()</a> and <a class="el" href="group__connection__mgmt.html#ga6d7573f71d8853943029cfd55fa3fb3a" title="Get connection&#39;s output buffer.">Connection_outbuf()</a> for buffer access. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga1faf8c706d1ed9418446fc155fa289dd" title="Get connection&#39;s user data.">Connection_data()</a> for user data access. </dd>
<dd>
Socket_T for socket operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877" title="Get underlying file descriptor.">Socket_fd()</a> for getting file descriptor. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>, and <a class="el" href="connection__pool_8c_source.html#l00040">simulate_work_wrapper()</a>.</p>

</div>
</div>
<a id="ga5374f9969a32eb12ea7794b1f1a20d77" name="ga5374f9969a32eb12ea7794b1f1a20d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5374f9969a32eb12ea7794b1f1a20d77">&#9670;&#160;</a></span>decrement_pool_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void decrement_pool_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement active connection count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Thread-safe decrement of pool's active connection counter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga5426648c6c6a14ebaff48ee2160856c3" title="Increment active connection count.">increment_pool_count()</a> for reverse operation. </dd></dl>

</div>
</div>
<a id="ga122ba4bb8b8c2ed5400b544deefe8903" name="ga122ba4bb8b8c2ed5400b544deefe8903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga122ba4bb8b8c2ed5400b544deefe8903">&#9670;&#160;</a></span>find_free_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T find_free_slot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first available free connection slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free connection slot or NULL if pool is full.</dd></dl>
<p>Scans free list to find available slot for new connections.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for usage. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaae4e8594fc75b148281c6b7874c279d3" title="Check if pool has reached maximum capacity.">check_pool_full()</a> for pool capacity checking. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8d3db0f18f008462c96cd8dc85be8c40" title="Remove connection from free list.">remove_from_free_list()</a> for slot activation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga7024a2a77a04587e061d67a1172cdbfc" title="Return connection to free list.">return_to_free_list()</a> for slot deactivation. </dd></dl>

</div>
</div>
<a id="gae5693c260bb02fb1c779d497b35eb6db" name="gae5693c260bb02fb1c779d497b35eb6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5693c260bb02fb1c779d497b35eb6db">&#9670;&#160;</a></span>find_or_create_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T find_or_create_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find existing connection or create new slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket to find or add. </td></tr>
    <tr><td class="paramname">now</td><td>Current timestamp. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Existing connection or new slot, NULL if pool full.</dd></dl>
<p>Core function for <a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> and <a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for lookup-only. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for add-only. </dd></dl>

</div>
</div>
<a id="ga344c2ab8a3e0b099bd74e65cc97cb66f" name="ga344c2ab8a3e0b099bd74e65cc97cb66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga344c2ab8a3e0b099bd74e65cc97cb66f">&#9670;&#160;</a></span>find_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T find_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find connection slot by socket (internal). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> slot or NULL if not found.</dd></dl>
<p>Performs O(1) hash table lookup to find existing connection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for public interface. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a> for insertion. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga9710c881ae321ed9da843ca815ca0733" title="Remove connection from hash table.">remove_from_hash_table()</a> for removal. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a> for hash computation. </dd></dl>

</div>
</div>
<a id="ga5426648c6c6a14ebaff48ee2160856c3" name="ga5426648c6c6a14ebaff48ee2160856c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5426648c6c6a14ebaff48ee2160856c3">&#9670;&#160;</a></span>increment_pool_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void increment_pool_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment active connection count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Thread-safe increment of pool's active connection counter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga5374f9969a32eb12ea7794b1f1a20d77" title="Decrement active connection count.">decrement_pool_count()</a> for reverse operation. </dd></dl>

</div>
</div>
<a id="ga6c55ecf49e5103925192159127088241" name="ga6c55ecf49e5103925192159127088241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c55ecf49e5103925192159127088241">&#9670;&#160;</a></span>initialize_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_connection </td>
          <td>(</td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize connection with socket and timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to initialize. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket for connection. </td></tr>
    <tr><td class="paramname">now</td><td>Current timestamp.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets up connection with socket, timestamps, and initial state.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga7821321479544a6e24fb4c2946e22c60" title="Prepare free slot for new connection.">prepare_free_slot()</a> for buffer allocation. </dd></dl>

</div>
</div>
<a id="gac073c8a892a77bae682cec8398d10518" name="gac073c8a892a77bae682cec8398d10518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac073c8a892a77bae682cec8398d10518">&#9670;&#160;</a></span>insert_into_hash_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void insert_into_hash_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert connection into hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to insert. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket for hash computation.</td></tr>
  </table>
  </dd>
</dl>
<p>Inserts connection into hash table for O(1) lookup.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9710c881ae321ed9da843ca815ca0733" title="Remove connection from hash table.">remove_from_hash_table()</a> for removal. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a> for hash computation. </dd></dl>

</div>
</div>
<a id="ga7821321479544a6e24fb4c2946e22c60" name="ga7821321479544a6e24fb4c2946e22c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7821321479544a6e24fb4c2946e22c60">&#9670;&#160;</a></span>prepare_free_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int prepare_free_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare free slot for new connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">conn</td><td>Free slot to prepare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on buffer allocation failure.</dd></dl>
<p>Cleans up old connection state and allocates new buffers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga6c55ecf49e5103925192159127088241" title="Initialize connection with socket and timestamp.">initialize_connection()</a> for connection setup. </dd></dl>

</div>
</div>
<a id="ga768e9347e53fcf121c747b2430cdef40" name="ga768e9347e53fcf121c747b2430cdef40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768e9347e53fcf121c747b2430cdef40">&#9670;&#160;</a></span>reconnect_jitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double reconnect_jitter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate uniform random double in [0.0, 1.0) for jitter in backoff calculations. </p>
<p>Produces randomness for exponential backoff jitter to avoid thundering herd (synchronized retries). Prioritizes secure crypto RNG, falls back to fast thread-local PRNG for performance.</p>
<dl class="section return"><dt>Returns</dt><dd>double uniformly distributed in [0.0, 1.0)</dd></dl>
<p>Usage in Backoff</p>
<p>Jitter applied as: delay *= (1.0 + jitter_factor * (2*rand - 1)) Where jitter_factor from policy (0.0-1.0).</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> r = socketreconnect_random_double();</div>
<div class="line">int64_t jittered_delay = base_delay * (1.0 + policy.jitter * (2*r - 1.0));</div>
</div><!-- fragment --><p>Implementation Details</p>
<ol type="1">
<li><b>Primary</b>: <a class="el" href="group__foundation.html#gae153fb5408e633479d6a61ac233d3676" title="Generate cryptographically secure random bytes.">SocketCrypto_random_bytes()</a> for 32-bit uint  normalized double</li>
<li><b>Fallback</b>: Thread-local xorshift32 PRNG, seeded once by monotonic time<ul>
<li>xorshift: seed ^= seed &lt;&lt;13; ^= &gt;&gt;17; ^= &lt;&lt;5</li>
<li>Period: 2^32 -1; good for non-crypto use</li>
</ul>
</li>
</ol>
<p>Secure source preferred but not required; fallback ensures availability.</p>
<dl class="section user"><dt>Complexity\n O(1) amortized - crypto may block briefly, PRNG instant</dt><dd></dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - crypto reentrant, PRNG per-thread (__thread static)</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Fallback seeded lazily on first call per thread </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>NON-CRYPTO: Do not use for keys, nonces, or security decisions </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If crypto fails (e.g., /dev/urandom unavailable), logs warning internally</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#gae153fb5408e633479d6a61ac233d3676" title="Generate cryptographically secure random bytes.">SocketCrypto_random_bytes()</a> primary secure source </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#a803e0eaa631385205819346d33db4974" title="Jitter factor for randomization (default: 0.25 / 25%). Adds +/- jitter * delay randomness to avoid sy...">SocketReconnect_Policy_T::jitter</a> usage context </dd>
<dd>
xorshift algorithm for PRNG details </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00560">560</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

<p class="reference">References <a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms()</a>, and <a class="el" href="group__foundation.html#gae153fb5408e633479d6a61ac233d3676">SocketCrypto_random_bytes()</a>.</p>

</div>
</div>
<a id="ga8d3db0f18f008462c96cd8dc85be8c40" name="ga8d3db0f18f008462c96cd8dc85be8c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3db0f18f008462c96cd8dc85be8c40">&#9670;&#160;</a></span>remove_from_free_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_free_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove connection from free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to remove from free list.</td></tr>
  </table>
  </dd>
</dl>
<p>Updates free list pointers when slot becomes active.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga7024a2a77a04587e061d67a1172cdbfc" title="Return connection to free list.">return_to_free_list()</a> for reverse operation. </dd></dl>

</div>
</div>
<a id="ga9710c881ae321ed9da843ca815ca0733" name="ga9710c881ae321ed9da843ca815ca0733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9710c881ae321ed9da843ca815ca0733">&#9670;&#160;</a></span>remove_from_hash_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_hash_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove connection from hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to remove. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket for hash computation.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes connection from hash table during cleanup/removal.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a> for insertion. </dd></dl>

</div>
</div>
<a id="ga7024a2a77a04587e061d67a1172cdbfc" name="ga7024a2a77a04587e061d67a1172cdbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7024a2a77a04587e061d67a1172cdbfc">&#9670;&#160;</a></span>return_to_free_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void return_to_free_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return connection to free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to return to free list.</td></tr>
  </table>
  </dd>
</dl>
<p>Updates free list pointers when slot becomes inactive.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga8d3db0f18f008462c96cd8dc85be8c40" title="Remove connection from free list.">remove_from_free_list()</a> for reverse operation. </dd></dl>

</div>
</div>
<a id="gaab8dfea746f7edd426d43574e437ffc7" name="gaab8dfea746f7edd426d43574e437ffc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab8dfea746f7edd426d43574e437ffc7">&#9670;&#160;</a></span>safe_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t safe_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current time with error handling. </p>
<dl class="section return"><dt>Returns</dt><dd>Current time as time_t. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on system error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Safe wrapper around time() that raises exception on failure. Used for connection timestamps and idle timeout tracking.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1" title="Get connection&#39;s last activity timestamp.">Connection_lastactivity()</a> for usage. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gadeb31a2cef7f4d6b590baf9c3e4fd048" title="Get connection creation timestamp.">Connection_created_at()</a> for creation timestamps. </dd></dl>

</div>
</div>
<a id="gaac8b8b6c2075b758c5c85426194c2539" name="gaac8b8b6c2075b758c5c85426194c2539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8b8b6c2075b758c5c85426194c2539">&#9670;&#160;</a></span>SocketPool_accept_allowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_accept_allowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>client_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if accepting is allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">client_ip</td><td>Client IP address (NULL to skip IP check). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if allowed, 0 if rate limited or IP limit reached. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Checks both connection rate and per-IP limits. Does NOT consume rate limit tokens - use <a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for that.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for actual accepting with rate limiting. </dd></dl>

</div>
</div>
<a id="ga283d343a8192530c349dc9a02b987c26" name="ga283d343a8192530c349dc9a02b987c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga283d343a8192530c349dc9a02b987c26">&#9670;&#160;</a></span>SocketPool_accept_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_accept_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_accepts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>accepted_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T *&#160;</td>
          <td class="paramname"><em>accepted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept multiple connections from server socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">server</td><td>Server socket (listening, non-blocking). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">max_accepts</td><td>Maximum number to accept (1 to SOCKET_POOL_MAX_BATCH_ACCEPTS). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">accepted_capacity</td><td>Size of accepted array (must be &gt;= max_accepts). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">accepted</td><td>Output array for accepted Socket_T pointers (caller-allocated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number accepted (0 to max_accepts). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Efficient batch accept using accept4() where available. Automatically adds accepted sockets to pool.</p>
<p>CALLER RESPONSIBILITY: The accepted array MUST be pre-allocated with at least max_accepts elements. No bounds checking - undersized array causes overflow.</p>
<p>Safe usage: Socket_T accepted[100]; int count = SocketPool_accept_batch(pool, server, 100, 100, accepted);</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for rate-limited single accept. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga899c660b21bf96befd2b5ea9f6937988" title="Accept with full SYN flood protection.">SocketPool_accept_protected()</a> for SYN protection. </dd></dl>

</div>
</div>
<a id="gabd8219ceff615ad4a4064cf389f137a6" name="gabd8219ceff615ad4a4064cf389f137a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8219ceff615ad4a4064cf389f137a6">&#9670;&#160;</a></span>SocketPool_accept_limited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketPool_accept_limited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept connection with rate limiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">server</td><td>Server Socket_T to accept from (must be listening). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Socket_T or NULL if draining/stopped, rate limited, or accept failed. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - acquires pool mutex internally.</dt><dd></dd></dl>
<p>Comprehensive accept function combining multiple protection mechanisms:</p><ul>
<li>Returns NULL immediately if pool is draining or stopped</li>
<li>Consumes rate token before attempting accept</li>
<li>If per-IP limiting enabled, automatically tracks client IP</li>
<li>On SocketPool_add failure, caller MUST call <a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4" title="Release tracked IP when connection closes.">SocketPool_release_ip()</a> and <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a></li>
</ul>
<p>FAILURE MODES:</p><ul>
<li>Pool draining/stopped: Returns NULL immediately</li>
<li>Rate limited: Returns NULL, no tokens consumed</li>
<li>IP limit reached: Returns NULL, tracked IP remains blocked</li>
<li>Accept failed: Returns NULL (network error)</li>
<li>Pool full: Returns Socket_T but <a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> returns NULL</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> to configure rate limits. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b" title="Set maximum connections per IP.">SocketPool_setmaxperip()</a> for per-IP limits. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga899c660b21bf96befd2b5ea9f6937988" title="Accept with full SYN flood protection.">SocketPool_accept_protected()</a> for SYN protection. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4" title="Release tracked IP when connection closes.">SocketPool_release_ip()</a> for cleanup on <a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> failure. </dd>
<dd>
<a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> for socket cleanup. </dd>
<dd>
utilities::SocketRateLimit_T for token bucket implementation. </dd></dl>

</div>
</div>
<a id="ga899c660b21bf96befd2b5ea9f6937988" name="ga899c660b21bf96befd2b5ea9f6937988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899c660b21bf96befd2b5ea9f6937988">&#9670;&#160;</a></span>SocketPool_accept_protected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketPool_accept_protected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__security.html#gaca8f2a71ab649ccd408fd3fdb3b693b9">SocketSYN_Action</a> *&#160;</td>
          <td class="paramname"><em>action_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept with full SYN flood protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">server</td><td>Server socket (listening, non-blocking). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">action_out</td><td>Output - action taken (optional, may be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New socket if allowed, NULL if blocked/would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on actual errors (not protection blocking). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Combines rate limiting, per-IP limits, and SYN protection into a single accept operation. Actions taken depend on SYN protection result:</p>
<ul>
<li>SYN_ACTION_ALLOW: Accept normally (fastest path)</li>
<li>SYN_ACTION_THROTTLE: Accept after artificial delay (congestion control)</li>
<li>SYN_ACTION_CHALLENGE: Set TCP_DEFER_ACCEPT on socket (require data)</li>
<li>SYN_ACTION_BLOCK: Close connection immediately, return NULL</li>
</ul>
<p>If SYN protection is not enabled, behaves like <a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a>.</p>
<p>Reports success/failure to SYN protection module automatically based on whether connection completes or fails. </p>

</div>
</div>
<a id="gac7720c7b7d679624fa95bdefe9a38494" name="gac7720c7b7d679624fa95bdefe9a38494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7720c7b7d679624fa95bdefe9a38494">&#9670;&#160;</a></span>SocketPool_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T SocketPool_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a connected socket to the pool, creating a Connection_T wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected Socket_T (must not be NULL or already in pool). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Connection_T wrapper or NULL if pool full, socket invalid, or allocation failed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on invalid parameters or internal allocation failures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - acquires pool mutex internally.</dt><dd></dd></dl>
<p>Allocates per-connection I/O buffers, initializes metadata (timestamps, user data = NULL), adds to hash table for O(1) lookup, and increments active count/statistics.</p>
<p>Failure cases:</p><ul>
<li>Pool at capacity: Returns NULL (no exception)</li>
<li>Socket already in pool: Returns NULL (no exception)</li>
<li>Invalid socket (not connected): Returns NULL (no exception)</li>
<li>Allocation failure: Raises SocketPool_Failed</li>
<li>Mutex deadlock (rare): Raises SocketPool_Failed</li>
</ul>
<h2><a class="anchor" id="autotoc_md389"></a>
Usage Example</h2>
<div class="fragment"><div class="line">Socket_T client_sock = <a class="code hl_function" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a>(server_sock);</div>
<div class="line"><span class="keywordflow">if</span> (client_sock != NULL) {</div>
<div class="line">    <a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">        Connection_T conn = <a class="code hl_function" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494">SocketPool_add</a>(pool, client_sock);</div>
<div class="line">        <span class="keywordflow">if</span> (conn != NULL) {</div>
<div class="line">            <span class="comment">// Connection successfully added - use conn-&gt;socket, buffers,</span></div>
<div class="line">etc. <a class="code hl_function" href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1">Connection_setdata</a>(conn, my_user_data); } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Pool full or invalid - close socket</span></div>
<div class="line">            <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;client_sock);</div>
<div class="line">        }</div>
<div class="line">    } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a> (<a class="code hl_variable" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a>) {</div>
<div class="line">        <span class="comment">// Allocation or param error - cleanup</span></div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;client_sock);</div>
<div class="line">    } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_gab48a53bc1b36954d521104fedf9012c1"><div class="ttname"><a href="group__connection__mgmt.html#gab48a53bc1b36954d521104fedf9012c1">Connection_setdata</a></div><div class="ttdeci">void Connection_setdata(Connection_T conn, void *data)</div><div class="ttdoc">Set connection's user data.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gac7720c7b7d679624fa95bdefe9a38494"><div class="ttname"><a href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494">SocketPool_add</a></div><div class="ttdeci">Connection_T SocketPool_add(SocketPool_T pool, Socket_T socket)</div><div class="ttdoc">Add a connected socket to the pool, creating a Connection_T wrapper.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gadba094d10381f1646de6a3e1e2bd0c36"><div class="ttname"><a href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a></div><div class="ttdeci">const Except_T SocketPool_Failed</div><div class="ttdoc">Pool operation failure.</div></div>
<div class="ttc" id="agroup__core__io_html_ga32b67d95639513cd6a602f6175b48f15"><div class="ttname"><a href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a></div><div class="ttdeci">Socket_T Socket_accept(Socket_T socket)</div><div class="ttdoc">Accept incoming connection.</div></div>
<div class="ttc" id="agroup__core__io_html_ga74ad7a9bb8deaf499c59d90d6e411f37"><div class="ttname"><a href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a></div><div class="ttdeci">void Socket_free(Socket_T *socket)</div><div class="ttdoc">Dispose of a socket instance and close the underlying file descriptor.</div></div>
<div class="ttc" id="agroup__foundation_html_gab5e72fc2bd41014c75e0ace4feabfe8e"><div class="ttname"><a href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a></div><div class="ttdeci">#define EXCEPT(e)</div><div class="ttdoc">Catch a specific exception type within a TRY block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01105">Except.h:1105</a></div></div>
<div class="ttc" id="agroup__foundation_html_gad2746371528bdf15c3910b7bf217dac0"><div class="ttname"><a href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a></div><div class="ttdeci">#define TRY</div><div class="ttdoc">Start a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00991">Except.h:991</a></div></div>
<div class="ttc" id="agroup__foundation_html_gae6628ac788ad213363b89dba9868420b"><div class="ttname"><a href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a></div><div class="ttdeci">#define END_TRY</div><div class="ttdoc">Complete a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01439">Except.h:1439</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Socket must be connected and valid before adding. </dd>
<dd>
Buffers are allocated from pool's arena - share lifecycle with pool. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not add the same socket twice - results in undefined behavior. </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average - hash insertion, buffer allocation is amortized</dt><dd>constant</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for looking up connections by socket. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d" title="Remove socket from pool.">SocketPool_remove()</a> for removing connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for rate-limited server accepting. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for changing pool capacity. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga618413d296dac8730047cf248273461e" title="Get active connection count.">SocketPool_count()</a> for current connection statistics. </dd>
<dd>
Connection_T for connection wrapper details. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga3e6eccb3c5a10e8ac40b057a56e77ed5" name="ga3e6eccb3c5a10e8ac40b057a56e77ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e6eccb3c5a10e8ac40b057a56e77ed5">&#9670;&#160;</a></span>SocketPool_check_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf">SocketPool_ConnHealth</a> SocketPool_check_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check health of a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Health status of the connection. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Checks:</p><ul>
<li>Socket is still connected (SO_ERROR check)</li>
<li>Socket is not in error state</li>
<li><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> has not exceeded idle timeout.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga92931382e16ec0f93619d6fe95c68fdf" title="Connection health status enumeration.">SocketPool_ConnHealth</a> for health status values. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga11a46794f10d4d659cf75412e84cef31" title="Set connection validation callback.">SocketPool_set_validation_callback()</a> for custom validation. </dd></dl>

</div>
</div>
<a id="gab2a7df0479b8f9ac899672afdb488b94" name="gab2a7df0479b8f9ac899672afdb488b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a7df0479b8f9ac899672afdb488b94">&#9670;&#160;</a></span>SocketPool_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>idle_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove idle connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idle_timeout</td><td>Seconds inactive before removal (0 = remove all). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(n) scan of all slots; closes/removes idle ones. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga618413d296dac8730047cf248273461e" title="Get active connection count.">SocketPool_count()</a> for counting connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for configuring timeout. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>.</p>

</div>
</div>
<a id="gabaca1689f64e0266f4b3366e99bcb766" name="gabaca1689f64e0266f4b3366e99bcb766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaca1689f64e0266f4b3366e99bcb766">&#9670;&#160;</a></span>SocketPool_connect_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> SocketPool_connect_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd">SocketPool_ConnectCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create async connection to remote host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">host</td><td>Remote hostname or IP address. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port</td><td>Remote port number (1-65535). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">callback</td><td>Completion callback (see SocketPool_ConnectCallback). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Request_T (DNS request handle) for monitoring completion. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on invalid params, allocation error, or limit reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Starts async DNS resolution + connect + pool add. On completion:</p><ul>
<li>Success: callback(conn, 0, data) with Connection_T added to pool</li>
<li>Failure: callback(NULL, error_code, data)</li>
</ul>
<p>Callback invoked from DNS worker thread - see SocketPool_ConnectCallback for thread safety requirements. Limited to SOCKET_POOL_MAX_ASYNC_PENDING concurrent operations for security.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaef36179b23774c639bb9fd68a99001c7" title="Prepare async connection using DNS resolution.">SocketPool_prepare_connection()</a> for lower-level control. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga5441c8cf779cd74fbb9f39bd322c33bd" title="Completion callback for async connections.">SocketPool_ConnectCallback</a> for callback requirements. </dd>
<dd>
<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> for DNS resolution details. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding completed connections to pool. </dd></dl>

</div>
</div>
<a id="ga0baf2c21ed54520dcaab3460a9a987f7" name="ga0baf2c21ed54520dcaab3460a9a987f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0baf2c21ed54520dcaab3460a9a987f7">&#9670;&#160;</a></span>SocketPool_connections_alloc_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_connections_alloc_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate input/output buffers for connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arena</td><td>Memory arena for allocation. </td></tr>
    <tr><td class="paramname">bufsize</td><td>Size of each buffer. </td></tr>
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to allocate buffers for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on allocation failure.</dd></dl>
<p>Allocates SocketBuf_T instances for connection's input and output buffers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for buffer allocation. </dd>
<dd>
<a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef" title="Create a new circular buffer with specified initial capacity.">SocketBuf_new()</a> for buffer creation. </dd>
<dd>
SocketPool_connections_release_buffers() for cleanup. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf" title="Get connection&#39;s input buffer.">Connection_inbuf()</a> and <a class="el" href="group__connection__mgmt.html#ga6d7573f71d8853943029cfd55fa3fb3a" title="Get connection&#39;s output buffer.">Connection_outbuf()</a> for access. </dd></dl>

</div>
</div>
<a id="ga88ab86be313053fde04989b904bb957a" name="ga88ab86be313053fde04989b904bb957a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88ab86be313053fde04989b904bb957a">&#9670;&#160;</a></span>SocketPool_connections_initialize_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_connections_initialize_slot </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__connection__mgmt.html#structConnection">Connection</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and zero-initialize array of connection structures. </p>
<p>Pre-allocates fixed-size array of <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> structs for efficient pool slot management. Uses direct system calloc() for large arrays to avoid arena fragmentation and overhead. All slots are zero-initialized, ready for <a class="el" href="group__connection__mgmt.html#ga88ab86be313053fde04989b904bb957a" title="Allocate and zero-initialize array of connection structures.">SocketPool_connections_initialize_slot()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxconns</td><td>Number of <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> slots to allocate (enforced 1 to SOCKET_MAX_CONNECTIONS).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated and zeroed array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>if calloc() fails due to ENOMEM or system limits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - no shared state, pure allocation function.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(maxconns) time and space - allocates and memset-zeros the</dt><dd>entire array.</dd></dl>
<p>Internal Usage Pattern</p>
<div class="fragment"><div class="line"><span class="comment">// Called during SocketPool_new() after parameter validation</span></div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">  pool-&gt;connections = SocketPool_connections_allocate_array(safe_maxconns);</div>
<div class="line">  <span class="comment">// Success: array allocated and zeroed</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a>) {</div>
<div class="line">  <span class="comment">// Handle allocation failure (e.g., log, propagate)</span></div>
<div class="line">  <a class="code hl_define" href="group__foundation.html#ga947ef43f0f0def3fcc050a8df849fd16">RERAISE</a>;  <span class="comment">// Or clean up and return error</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga947ef43f0f0def3fcc050a8df849fd16"><div class="ttname"><a href="group__foundation.html#ga947ef43f0f0def3fcc050a8df849fd16">RERAISE</a></div><div class="ttdeci">#define RERAISE</div><div class="ttdoc">Re-raise the currently caught exception.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00725">Except.h:725</a></div></div>
</div><!-- fragment --><p>Error Handling</p>
<p>Allocation failure typically indicates:</p><ul>
<li>System memory exhaustion (ulimit -v exceeded)</li>
<li>Process memory limits reached</li>
<li>Kernel OOM killer intervention imminent</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Direct calloc() allocation - not managed by pool arena. Freed explicitly with free() in <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Avoid calling with very large maxconns (&gt;1M) without checking system limits (e.g., via getrlimit(RLIMIT_AS)). </dd>
<dd>
Zero-initialization ensures safe default state but does not initialize buffers or complex fields - use initialize_slot().</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga63eed07eef58937549d0d7139d869189" title="Enforce maximum connection limit.">socketpool_enforce_max_connections()</a> for parameter clamping. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for full pool creation context. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga88ab86be313053fde04989b904bb957a" title="Allocate and zero-initialize array of connection structures.">SocketPool_connections_initialize_slot()</a> for post-allocation slot setup (links free list, etc.). </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> for explicit free() of this array. </dd>
<dd>
calloc(3) for underlying POSIX allocation primitive. </dd>
<dd>
foundation::Arena_T for arena-based alternatives (used for other components).</dd></dl>
<p>Allocate and zero-initialize hash table array from arena.</p>
<p>Allocates fixed-size array of Connection_T* pointers for O(1) average-case connection lookup. Uses arena-managed CALLOC for integration with pool's memory lifecycle. All entries zero-initialized (NULL), ready for <a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a>. Table size fixed to SOCKET_HASH_SIZE (compile-time prime for low collisions).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Arena_T for allocation (must not be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated and zeroed hash table array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>if <a class="el" href="group__foundation.html#ga3b920b3eed0306dc5afb36934955f6a2" title="Allocate and zero-initialize a block of memory elements from the arena.">Arena_calloc()</a> fails (Arena_Failed wrapped). </td></tr>
    <tr><td class="paramname">Arena_Failed</td><td>if arena has insufficient space (propagates through wrapper).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - arena allocation not thread-safe without external</dt><dd>synchronization. Caller must ensure exclusive arena access or use thread-local arenas.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) time and space - fixed-size allocation independent of pool</dt><dd>size.</dd></dl>
<p>Internal Usage Pattern</p>
<div class="fragment"><div class="line"><span class="comment">// Called during SocketPool_new() in allocate_pool_components()</span></div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">  pool-&gt;hash_table =</div>
<div class="line">SocketPool_connections_allocate_hash_table(pool-&gt;arena);</div>
<div class="line">  <span class="comment">// Success: hash_table ready for insertions</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a> | <a class="code hl_variable" href="group__foundation.html#ga6053a34c90a976ac971313bd5f201fb3">Arena_Failed</a>) {</div>
<div class="line">  <span class="comment">// Handle: log, cleanup partial allocations, propagate exception</span></div>
<div class="line">  <a class="code hl_define" href="group__foundation.html#ga947ef43f0f0def3fcc050a8df849fd16">RERAISE</a>;</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga6053a34c90a976ac971313bd5f201fb3"><div class="ttname"><a href="group__foundation.html#ga6053a34c90a976ac971313bd5f201fb3">Arena_Failed</a></div><div class="ttdeci">const Except_T Arena_Failed</div><div class="ttdoc">Exception raised when arena allocation fails.</div></div>
</div><!-- fragment --><p>Allocation Details</p>
<ul>
<li>Size: SOCKET_HASH_SIZE * sizeof(Connection_T*) (typically ~8KB for 1021 entries)</li>
<li>Zero-initialized: All buckets NULL, no chaining needed initially</li>
<li>Arena-managed: Freed automatically via Arena_clear/dispose in SocketPool_free</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Fixed size at compile-time - override via -DSOCKET_HASH_SIZE=N (prime recommended). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Small table sizes increase collision chains, degrading to O(n) worst-case lookup. </dd>
<dd>
Arena exhaustion may occur if pool creation coincides with high memory pressure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4a354a257cb7d9a1f7cd2befa6d72d0f" title="Alias for the library&#39;s central hash table size configuration.">SOCKET_HASH_SIZE</a> in <a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> for configuration and rationale. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3eec83919427223173cdaae6f1b36b8a" title="Allocate temporary buffer for bulk cleanup operations from arena.">socketpool_hash()</a> for FD-based hashing into table buckets. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a> / <a class="el" href="group__connection__mgmt.html#ga9710c881ae321ed9da843ca815ca0733" title="Remove connection from hash table.">remove_from_hash_table()</a> for chain management. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga344c2ab8a3e0b099bd74e65cc97cb66f" title="Find connection slot by socket (internal).">find_slot()</a> for traversal of collision chains. </dd>
<dd>
foundation::Arena_T::Arena_calloc() for underlying allocation (via <a class="el" href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934" title="Convenience macro for zero-initialized multi-element allocation with source tracking.">CALLOC</a> macro). </dd>
<dd>
utilities::socket_util_hash_fd() for hash function implementation.</dd></dl>
<p>Initialize a connection slot to default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> structure to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>Zeroes all fields and sets up initial state for a connection slot.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gacf51388d2a06f1d1b1caa4d55fe29159" title="Securely clear (zero) connection&#39;s input/output buffers.">SocketPool_connections_reset_slot()</a> for cleanup. </dd>
<dd>
SocketPool_connections_allocate_array() for allocation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga122ba4bb8b8c2ed5400b544deefe8903" title="Find first available free connection slot.">find_free_slot()</a> for finding available slots. </dd></dl>

</div>
</div>
<a id="gacf51388d2a06f1d1b1caa4d55fe29159" name="gacf51388d2a06f1d1b1caa4d55fe29159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf51388d2a06f1d1b1caa4d55fe29159">&#9670;&#160;</a></span>SocketPool_connections_reset_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_connections_reset_slot </td>
          <td>(</td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Securely clear (zero) connection's input/output buffers. </p>
<p>Performs secure zeroing of buffer contents using <a class="el" href="group__core__io.html#gaf0f12ab9bbed33398141c41561c1fcb7" title="Securely erase all data by zeroing memory contents.">SocketBuf_secureclear()</a>. Used before buffer reuse (to erase sensitive data) or final disposal. Does NOT deallocate memory (arena-managed) or NULL pointers - only clears data. Callers typically follow with SocketBuf_release(&amp;conn-&gt;inbuf) if deallocating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> whose buffers to securely clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - individual buffer operations are atomic/thread-safe.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(bufsize) - linearly scans and zeros buffer contents (inbuf +</dt><dd>outbuf).</dd></dl>
<p>Usage for Buffer Reuse</p>
<div class="fragment"><div class="line"><span class="comment">// Before reusing existing buffers in prepare_free_slot()</span></div>
<div class="line"><span class="keywordflow">if</span> (buffers_exist(conn)) {</div>
<div class="line">  SocketPool_connections_release_buffers(conn);  <span class="comment">// Zero sensitive data</span></div>
<div class="line">  <span class="comment">// Buffers now safe for reuse, pointers still valid</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <a class="code hl_function" href="group__connection__mgmt.html#ga0baf2c21ed54520dcaab3460a9a987f7">SocketPool_connections_alloc_buffers</a>(arena, bufsize, conn);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga0baf2c21ed54520dcaab3460a9a987f7"><div class="ttname"><a href="group__connection__mgmt.html#ga0baf2c21ed54520dcaab3460a9a987f7">SocketPool_connections_alloc_buffers</a></div><div class="ttdeci">int SocketPool_connections_alloc_buffers(Arena_T arena, size_t bufsize, Connection_T conn)</div><div class="ttdoc">Allocate input/output buffers for connection.</div></div>
</div><!-- fragment --><p>Usage for Final Cleanup</p>
<div class="fragment"><div class="line"><span class="comment">// In SocketPool_connections_reset_slot() or removal</span></div>
<div class="line">SocketPool_connections_release_buffers(conn);  <span class="comment">// Zero data</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a>(&amp;conn-&gt;inbuf);               <span class="comment">// NULL pointer</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a>(&amp;conn-&gt;outbuf);              <span class="comment">// NULL pointer</span></div>
<div class="ttc" id="agroup__core__io_html_ga7e38c8dbadd8bd771d70ec98eda9f448"><div class="ttname"><a href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a></div><div class="ttdeci">void SocketBuf_release(SocketBuf_T *buf)</div><div class="ttdoc">Release the buffer handle and invalidate the pointer.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Arena-managed buffers: Memory freed only on Arena_clear/dispose(). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Secure clearing prevents data leaks (e.g., passwords, tokens) on reuse/disposal. </dd>
<dd>
Does not NULL pointers - use <a class="el" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448" title="Release the buffer handle and invalidate the pointer.">SocketBuf_release()</a> for that (sets buf = NULL).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf0f12ab9bbed33398141c41561c1fcb7" title="Securely erase all data by zeroing memory contents.">SocketBuf_secureclear()</a> for underlying zeroing primitive (handles circular buffer semantics). </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0baf2c21ed54520dcaab3460a9a987f7" title="Allocate input/output buffers for connection.">SocketPool_connections_alloc_buffers()</a> for buffer allocation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448" title="Release the buffer handle and invalidate the pointer.">SocketBuf_release()</a> for pointer nullification (post-clearing). </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gacf51388d2a06f1d1b1caa4d55fe29159" title="Securely clear (zero) connection&#39;s input/output buffers.">SocketPool_connections_reset_slot()</a> for full slot reset including buffers. </dd>
<dd>
core_io::SocketBuf_T for buffer lifecycle management.</dd></dl>
<p>Reset connection slot to clean state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> slot to reset.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears all fields and prepares slot for reuse.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga88ab86be313053fde04989b904bb957a" title="Allocate and zero-initialize array of connection structures.">SocketPool_connections_initialize_slot()</a> for initial setup. </dd></dl>

</div>
</div>
<a id="ga618413d296dac8730047cf248273461e" name="ga618413d296dac8730047cf248273461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618413d296dac8730047cf248273461e">&#9670;&#160;</a></span>SocketPool_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get active connection count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of active connections. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for changing capacity. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for removing idle connections. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga7be3d82708a40f4d7601737467cdd51a" name="ga7be3d82708a40f4d7601737467cdd51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be3d82708a40f4d7601737467cdd51a">&#9670;&#160;</a></span>SocketPool_disable_reconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_disable_reconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable auto-reconnect for a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to disable reconnection for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Disables automatic reconnection for the specified connection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> for enabling reconnection. </dd></dl>

</div>
</div>
<a id="ga24cd4e2f757497906a5aef89b133b068" name="ga24cd4e2f757497906a5aef89b133b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24cd4e2f757497906a5aef89b133b068">&#9670;&#160;</a></span>SocketPool_drain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate graceful shutdown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout_ms</td><td>Maximum time to wait for connections to close (milliseconds). Use 0 for immediate force-close, -1 for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic state transitions.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Transitions pool from RUNNING to DRAINING state. </dd>
<dd>
Rejects new connections, allows existing to close naturally. </dd>
<dd>
Force-closes remaining connections after timeout. </dd>
<dd>
Multiple calls are idempotent - extends timeout if already draining.</dd></dl>
<p>STATE TRANSITIONS:</p><ul>
<li>RUNNING -&gt; DRAINING: Start rejecting new connections</li>
<li>DRAINING -&gt; STOPPED: When all connections closed or timeout reached</li>
<li>STOPPED: Final state, pool can be safely freed</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b" title="Poll drain progress (non-blocking).">SocketPool_drain_poll()</a> for non-blocking completion. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3f0fdd6e4245f2844081d935b2d3c8a2" title="Blocking drain with internal poll loop.">SocketPool_drain_wait()</a> for blocking completion. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0cbc1088d796c166f582de4d17e5d968" title="Force immediate shutdown.">SocketPool_drain_force()</a> for immediate shutdown. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0a62267ba3008f826b6952624dbc6a29" title="Get current pool lifecycle state.">SocketPool_state()</a> to check current state. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056" title="Pool lifecycle states for graceful shutdown.">SocketPool_State</a> for state definitions. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gad7679db7b1be62e465d9896944f3ad20" title="Notification callback when drain completes.">SocketPool_DrainCallback</a> for completion notifications. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga0cbc1088d796c166f582de4d17e5d968" name="ga0cbc1088d796c166f582de4d17e5d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cbc1088d796c166f582de4d17e5d968">&#9670;&#160;</a></span>SocketPool_drain_force()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_drain_force </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force immediate shutdown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(n) where n = active connections.</dd></dl>
<p>Immediately closes all connections and transitions to STOPPED. Can be called at any time, regardless of current state. Invokes drain callback with timed_out=1.</p>
<p>Logs: "Pool drain forced" at WARN level.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for graceful shutdown. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga2cbe6c95119cbb4b30f981b9d07f3e9b" name="ga2cbe6c95119cbb4b30f981b9d07f3e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbe6c95119cbb4b30f981b9d07f3e9b">&#9670;&#160;</a></span>SocketPool_drain_poll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_drain_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poll drain progress (non-blocking). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 active connections (keep polling), 0 graceful completion, -1 timeout. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Call periodically to check drain progress and trigger force-close on timeout. Invokes drain callback on completion. If not draining, returns current count.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> to initiate drain. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3f0fdd6e4245f2844081d935b2d3c8a2" title="Blocking drain with internal poll loop.">SocketPool_drain_wait()</a> for blocking version. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae14b85a2cd7a0a4302f84478840cfb23" title="Get time until forced shutdown.">SocketPool_drain_remaining_ms()</a> for timeout info. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gae14b85a2cd7a0a4302f84478840cfb23" name="gae14b85a2cd7a0a4302f84478840cfb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae14b85a2cd7a0a4302f84478840cfb23">&#9670;&#160;</a></span>SocketPool_drain_remaining_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketPool_drain_remaining_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get time until forced shutdown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until timeout, 0 if already expired, -1 if not draining. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1). Use as timeout hint for poll/select during drain. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for drain initiation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b" title="Poll drain progress (non-blocking).">SocketPool_drain_poll()</a> for progress monitoring. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga3f0fdd6e4245f2844081d935b2d3c8a2" name="ga3f0fdd6e4245f2844081d935b2d3c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f0fdd6e4245f2844081d935b2d3c8a2">&#9670;&#160;</a></span>SocketPool_drain_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_drain_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking drain with internal poll loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout_ms</td><td>Maximum wait time (milliseconds), -1 for infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if graceful completion, -1 if timed out (forced). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Convenience function: calls drain(), polls with backoff, returns on completion. For event-driven apps, prefer drain() + drain_poll() pattern.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for manual control. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b" title="Poll drain progress (non-blocking).">SocketPool_drain_poll()</a> for non-blocking polling. </dd></dl>

</div>
</div>
<a id="ga94ef5658ee53e87337b931b549ff35f2" name="ga94ef5658ee53e87337b931b549ff35f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ef5658ee53e87337b931b549ff35f2">&#9670;&#160;</a></span>SocketPool_enable_reconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_enable_reconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable auto-reconnect for a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> to enable reconnection for. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">host</td><td>Original hostname for reconnection. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port</td><td>Original port for reconnection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Enables automatic reconnection for the specified connection using the pool's reconnection policy. When the connection fails, it will be automatically reconnected.</p>
<p>NOTE: The original host/port must be provided since the socket may have been created with just an IP address from DNS resolution.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae4b6b07007da08326b53c069a4c1f2ea" title="Set default reconnection policy for pool.">SocketPool_set_reconnect_policy()</a> for setting the policy. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga7be3d82708a40f4d7601737467cdd51a" title="Disable auto-reconnect for a connection.">SocketPool_disable_reconnect()</a> for disabling reconnection. </dd>
<dd>
reconnection for reconnection patterns. </dd></dl>

</div>
</div>
<a id="gaf2f4277a3a98a8ce25680796876e17a9" name="gaf2f4277a3a98a8ce25680796876e17a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2f4277a3a98a8ce25680796876e17a9">&#9670;&#160;</a></span>socketpool_enforce_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t socketpool_enforce_buffer_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforce buffer size limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsize</td><td>Requested buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enforced buffer size (clamped between min and max). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga83ad1fb6ad736f4169297af3fd255410" title="Set buffer size for future connections.">SocketPool_set_bufsize()</a> for runtime buffer size changes. </dd>
<dd>
<a class="el" href="group__foundation.html#ga8ae494bcc57f791a1f8cbcf48b96b9a8" title="Minimum buffer size per connection.">SOCKET_MIN_BUFFER_SIZE</a> and <a class="el" href="group__foundation.html#ga72443e4b95fbd8ef4d191b754b4324dc" title="Maximum buffer size per connection.">SOCKET_MAX_BUFFER_SIZE</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l01154">1154</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketConfig_8h_source.html#l00266">SOCKET_MAX_BUFFER_SIZE</a>, <a class="el" href="SocketConfig_8h_source.html#l00276">SOCKET_MIN_BUFFER_SIZE</a>, and <a class="el" href="SocketPool-private_8h_source.html#l01122">socketpool_enforce_range()</a>.</p>

</div>
</div>
<a id="ga63eed07eef58937549d0d7139d869189" name="ga63eed07eef58937549d0d7139d869189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63eed07eef58937549d0d7139d869189">&#9670;&#160;</a></span>socketpool_enforce_max_connections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t socketpool_enforce_max_connections </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxconns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforce maximum connection limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxconns</td><td>Requested maximum number of connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enforced value (clamped to SOCKET_MAX_CONNECTIONS, min 1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for runtime resizing. </dd>
<dd>
<a class="el" href="group__foundation.html#ga72f1e9bc10cc82fb4ee1915335d60152" title="Maximum number of connections in pool.">SOCKET_MAX_CONNECTIONS</a> for global limit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l01138">1138</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketConfig_8h_source.html#l00254">SOCKET_MAX_CONNECTIONS</a>, and <a class="el" href="SocketPool-private_8h_source.html#l01122">socketpool_enforce_range()</a>.</p>

</div>
</div>
<a id="ga0c16fe70b77643b386b314b1c5e23575" name="ga0c16fe70b77643b386b314b1c5e23575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c16fe70b77643b386b314b1c5e23575">&#9670;&#160;</a></span>socketpool_enforce_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t socketpool_enforce_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamp value to min/max bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>size_t value to clamp. </td></tr>
    <tr><td class="paramname">minv</td><td>size_t minimum allowed value. </td></tr>
    <tr><td class="paramname">maxv</td><td>size_t maximum allowed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clamped value within bounds. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no side effects.</dt><dd></dd></dl>
<p>Used for enforcing configuration limits on pool parameters. Prevents invalid values from causing security issues or crashes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga63eed07eef58937549d0d7139d869189" title="Enforce maximum connection limit.">socketpool_enforce_max_connections()</a>. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf2f4277a3a98a8ce25680796876e17a9" title="Enforce buffer size limits.">socketpool_enforce_buffer_size()</a>. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for parameter validation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketPool-private_8h_source.html#l01122">1122</a> of file <a class="el" href="SocketPool-private_8h_source.html">SocketPool-private.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketPool-private_8h_source.html#l01154">socketpool_enforce_buffer_size()</a>, and <a class="el" href="SocketPool-private_8h_source.html#l01138">socketpool_enforce_max_connections()</a>.</p>

</div>
</div>
<a id="ga90825b0b38b8aa9afef5fc1d63458dac" name="ga90825b0b38b8aa9afef5fc1d63458dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90825b0b38b8aa9afef5fc1d63458dac">&#9670;&#160;</a></span>SocketPool_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c">SocketPool_Predicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Connection_T *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all connections matching a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">predicate</td><td>Callback that returns non-zero for matching connections. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>User data passed to predicate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>Array to receive matching connections. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">max_results</td><td>Maximum number of results to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of matching connections found (may be less than max_results). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - holds mutex during search.</dt><dd></dd></dl>
<p>Iterates through active connections and returns all that match the predicate, up to max_results. Results array must be pre-allocated by caller.</p>
<h2><a class="anchor" id="autotoc_md391"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> is_idle(Connection_T conn, <span class="keywordtype">void</span> *data) {</div>
<div class="line">    time_t threshold = *(time_t *)data;</div>
<div class="line">    <span class="keywordflow">return</span> time(NULL) - <a class="code hl_function" href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1">Connection_lastactivity</a>(conn) &gt; threshold;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Connection_T idle_conns[100];</div>
<div class="line">time_t threshold = 300;  <span class="comment">// 5 minutes</span></div>
<div class="line"><span class="keywordtype">size_t</span> count = <a class="code hl_function" href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac">SocketPool_filter</a>(pool, is_idle, &amp;threshold, idle_conns, 100);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i++) {</div>
<div class="line">    <span class="comment">// Process idle connection</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga68397aca39e8902ee26108dcb86b5db1"><div class="ttname"><a href="group__connection__mgmt.html#ga68397aca39e8902ee26108dcb86b5db1">Connection_lastactivity</a></div><div class="ttdeci">time_t Connection_lastactivity(const Connection_T conn)</div><div class="ttdoc">Get connection's last activity timestamp.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga90825b0b38b8aa9afef5fc1d63458dac"><div class="ttname"><a href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac">SocketPool_filter</a></div><div class="ttdeci">size_t SocketPool_filter(SocketPool_T pool, SocketPool_Predicate predicate, void *userdata, Connection_T *results, size_t max_results)</div><div class="ttdoc">Find all connections matching a predicate.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(n) - scans all active connections</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c" title="Predicate callback for filtering connections.">SocketPool_Predicate</a> for predicate requirements. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f" title="Find first connection matching a predicate.">SocketPool_find()</a> for finding first matching connection. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab6ffb3b44d5214daeed16af0c4cae08c" title="Iterate over active connections.">SocketPool_foreach()</a> for iterating all connections. </dd></dl>

</div>
</div>
<a id="ga3180e20634cf447edc962d5cdbf7253f" name="ga3180e20634cf447edc962d5cdbf7253f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3180e20634cf447edc962d5cdbf7253f">&#9670;&#160;</a></span>SocketPool_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T SocketPool_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c">SocketPool_Predicate</a>&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first connection matching a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">predicate</td><td>Callback that returns non-zero for matching connections. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>User data passed to predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First matching Connection_T or NULL if none found. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - holds mutex during search.</dt><dd></dd></dl>
<p>Iterates through active connections and returns the first one for which predicate returns non-zero. Stops immediately on first match.</p>
<h2><a class="anchor" id="autotoc_md390"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> is_client_ip(Connection_T conn, <span class="keywordtype">void</span> *data) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *target_ip = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)data;</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a>(conn);</div>
<div class="line">    <span class="keywordflow">return</span> strcmp(<a class="code hl_function" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c">Socket_getpeeraddr</a>(sock), target_ip) == 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Connection_T conn = <a class="code hl_function" href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f">SocketPool_find</a>(pool, is_client_ip, <span class="stringliteral">&quot;192.168.1.100&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (conn) {</div>
<div class="line">    <span class="comment">// Found connection from that IP</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga3180e20634cf447edc962d5cdbf7253f"><div class="ttname"><a href="group__connection__mgmt.html#ga3180e20634cf447edc962d5cdbf7253f">SocketPool_find</a></div><div class="ttdeci">Connection_T SocketPool_find(SocketPool_T pool, SocketPool_Predicate predicate, void *userdata)</div><div class="ttdoc">Find first connection matching a predicate.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gaaeff7efb1109a312f56e35689b67c652"><div class="ttname"><a href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a></div><div class="ttdeci">Socket_T Connection_socket(const Connection_T conn)</div><div class="ttdoc">Get connection's socket.</div></div>
<div class="ttc" id="agroup__core__io_html_gab0957f43694d0728e70b23364a89623c"><div class="ttname"><a href="group__core__io.html#gab0957f43694d0728e70b23364a89623c">Socket_getpeeraddr</a></div><div class="ttdeci">const char * Socket_getpeeraddr(const Socket_T socket)</div><div class="ttdoc">Get peer IP address.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(n) worst case - scans until match or end</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga1277558455541e0ec64e20bf8d21b71c" title="Predicate callback for filtering connections.">SocketPool_Predicate</a> for predicate requirements. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga90825b0b38b8aa9afef5fc1d63458dac" title="Find all connections matching a predicate.">SocketPool_filter()</a> for finding all matching connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab6ffb3b44d5214daeed16af0c4cae08c" title="Iterate over active connections.">SocketPool_foreach()</a> for iterating all connections. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>.</p>

</div>
</div>
<a id="gab6ffb3b44d5214daeed16af0c4cae08c" name="gab6ffb3b44d5214daeed16af0c4cae08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6ffb3b44d5214daeed16af0c4cae08c">&#9670;&#160;</a></span>SocketPool_foreach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(Connection_T, void *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over active connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">func</td><td>Callback function (Connection_T, void*). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arg</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - holds mutex during iteration.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>O(n) scan; callback must not modify pool structure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga618413d296dac8730047cf248273461e" title="Get active connection count.">SocketPool_count()</a> for getting connection count. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>.</p>

</div>
</div>
<a id="gafb57544a14c977302953fd36634bd004" name="gafb57544a14c977302953fd36634bd004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb57544a14c977302953fd36634bd004">&#9670;&#160;</a></span>SocketPool_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a connection pool and release all resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pool</td><td>Pointer to pool (set to NULL on success). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md387"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004">SocketPool_free</a>(&amp;pool);  <span class="comment">// Automatically closes pool resources</span></div>
<div class="line"><span class="comment">// pool == NULL after call</span></div>
<div class="ttc" id="agroup__connection__mgmt_html_gafb57544a14c977302953fd36634bd004"><div class="ttname"><a href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004">SocketPool_free</a></div><div class="ttdeci">void SocketPool_free(SocketPool_T *pool)</div><div class="ttdoc">Free a connection pool and release all resources.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Does NOT close underlying sockets - caller must close them explicitly or use <a class="el" href="group__connection__mgmt.html#ga0cbc1088d796c166f582de4d17e5d968" title="Force immediate shutdown.">SocketPool_drain_force()</a> before freeing. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If draining, ensure <a class="el" href="group__connection__mgmt.html#ga3f0fdd6e4245f2844081d935b2d3c8a2" title="Blocking drain with internal poll loop.">SocketPool_drain_wait()</a> or <a class="el" href="group__connection__mgmt.html#ga2cbe6c95119cbb4b30f981b9d07f3e9b" title="Poll drain progress (non-blocking).">SocketPool_drain_poll()</a> completes first to avoid resource leaks. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for graceful shutdown before freeing. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d" title="Remove socket from pool.">SocketPool_remove()</a> for individual connection cleanup. </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - quick resource release, no socket operations</dt><dd></dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga21b17f01e3036b53fed194c6b3c0b95f" name="ga21b17f01e3036b53fed194c6b3c0b95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b17f01e3036b53fed194c6b3c0b95f">&#9670;&#160;</a></span>SocketPool_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Connection_T SocketPool_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve Connection_T wrapper for a socket in the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket_T to look up (must be valid file descriptor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Connection_T if found and valid, NULL if not in pool, invalid, or validation failed. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - acquires pool mutex for duration of lookup.</dt><dd></dd></dl>
<p>Performs hash table lookup using socket FD hashed with golden ratio function. If found, runs built-in health check (<a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5" title="Check health of a connection.">SocketPool_check_connection()</a>) and optional user validation callback. Updates last_activity timestamp to prevent idle timeout. Returns NULL without exception if:</p><ul>
<li>Socket not in pool</li>
<li><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> unhealthy (disconnected, error, stale)</li>
<li>Validation callback returns 0</li>
</ul>
<h2><a class="anchor" id="autotoc_md388"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// In event loop, after poll indicates readable socket</span></div>
<div class="line">Connection_T conn = <a class="code hl_function" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f">SocketPool_get</a>(pool, sock);</div>
<div class="line"><span class="keywordflow">if</span> (conn != NULL) {</div>
<div class="line">    <a class="code hl_typedef" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> inbuf = <a class="code hl_function" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf">Connection_inbuf</a>(conn);</div>
<div class="line">    <span class="keywordtype">size_t</span> avail = <a class="code hl_function" href="group__core__io.html#ga4f350e096708c438bc2002909325b143">SocketBuf_available</a>(inbuf);</div>
<div class="line">    <span class="keywordflow">if</span> (avail &gt; 0) {</div>
<div class="line">        <span class="comment">// Read data from buffer</span></div>
<div class="line">        <span class="keywordtype">char</span> buf[1024];</div>
<div class="line">        <span class="keywordtype">size_t</span> read_len = <a class="code hl_function" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42">SocketBuf_read</a>(inbuf, buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line">        <span class="comment">// Process data...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Update activity implicitly via get()</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Socket not managed by pool - handle directly or close</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga21b17f01e3036b53fed194c6b3c0b95f"><div class="ttname"><a href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f">SocketPool_get</a></div><div class="ttdeci">Connection_T SocketPool_get(SocketPool_T pool, Socket_T socket)</div><div class="ttdoc">Retrieve Connection_T wrapper for a socket in the pool.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga24170577512ce3a19fe195ab9c3576bf"><div class="ttname"><a href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf">Connection_inbuf</a></div><div class="ttdeci">SocketBuf_T Connection_inbuf(const Connection_T conn)</div><div class="ttdoc">Get connection's input buffer.</div></div>
<div class="ttc" id="agroup__core__io_html_ga4aacfb9008833f24abec18b1d65d0d42"><div class="ttname"><a href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42">SocketBuf_read</a></div><div class="ttdeci">size_t SocketBuf_read(SocketBuf_T buf, void *data, size_t len)</div><div class="ttdoc">Read and remove data from the buffer.</div></div>
<div class="ttc" id="agroup__core__io_html_ga4f350e096708c438bc2002909325b143"><div class="ttname"><a href="group__core__io.html#ga4f350e096708c438bc2002909325b143">SocketBuf_available</a></div><div class="ttdeci">size_t SocketBuf_available(const SocketBuf_T buf)</div><div class="ttdoc">Query the number of bytes available for reading.</div></div>
<div class="ttc" id="agroup__core__io_html_gad4b3ec10874282833e1b15760efa1b6c"><div class="ttname"><a href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></div><div class="ttdeci">struct SocketBuf_T * SocketBuf_T</div><div class="ttdoc">Opaque handle to a circular buffer instance.</div><div class="ttdef"><b>Definition</b> <a href="SocketBuf_8h_source.html#l00115">SocketBuf.h:115</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Automatically refreshes connection activity timestamp. </dd>
<dd>
Validation failures increment failure counters in pool stats. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returned Connection_T remains valid until <a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d" title="Remove socket from pool.">SocketPool_remove()</a> or pool free. </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average case - hash lookup; O(n) worst case - hash</dt><dd>collisions</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding connections to pool. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga11a46794f10d4d659cf75412e84cef31" title="Set connection validation callback.">SocketPool_set_validation_callback()</a> for custom validation before return. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5" title="Check health of a connection.">SocketPool_check_connection()</a> for manual health checks. </dd>
<dd>
Connection_T accessors like <a class="el" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652" title="Get connection&#39;s socket.">Connection_socket()</a>, <a class="el" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf" title="Get connection&#39;s input buffer.">Connection_inbuf()</a>. </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd()</a> for underlying hash function. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for full connection lifecycle. </dd></dl>

</div>
</div>
<a id="ga996b6e1e70230dec597386572109b873" name="ga996b6e1e70230dec597386572109b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996b6e1e70230dec597386572109b873">&#9670;&#160;</a></span>SocketPool_get_active_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_get_active_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get count of currently active connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of active connections in the pool. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1).</dt><dd></dd></dl>
<p>Convenience wrapper around <a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a>.current_active.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga19433078a67ca838968245b41644fe7c" title="Get count of currently idle connections.">SocketPool_get_idle_count()</a> for idle connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga618413d296dac8730047cf248273461e" title="Get active connection count.">SocketPool_count()</a> for same functionality (alias). </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a> for full statistics. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga86d406e9dc8b20a64731630a38b5f027" name="ga86d406e9dc8b20a64731630a38b5f027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d406e9dc8b20a64731630a38b5f027">&#9670;&#160;</a></span>SocketPool_get_hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SocketPool_get_hit_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection reuse rate (hit rate). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reuse rate as fraction (0.0 to 1.0), or 0.0 if no connections. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1).</dt><dd></dd></dl>
<p>Returns the ratio of reused connections to total connection acquisitions. Higher values indicate better pool efficiency. Calculated as: reused / (added + reused)</p>
<h2><a class="anchor" id="autotoc_md392"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> hit_rate = <a class="code hl_function" href="group__connection__mgmt.html#ga86d406e9dc8b20a64731630a38b5f027">SocketPool_get_hit_rate</a>(pool);</div>
<div class="line">printf(<span class="stringliteral">&quot;Connection reuse: %.1f%%\n&quot;</span>, hit_rate * 100.0);</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga86d406e9dc8b20a64731630a38b5f027"><div class="ttname"><a href="group__connection__mgmt.html#ga86d406e9dc8b20a64731630a38b5f027">SocketPool_get_hit_rate</a></div><div class="ttdeci">double SocketPool_get_hit_rate(SocketPool_T pool)</div><div class="ttdoc">Get connection reuse rate (hit rate).</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a> for full statistics. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2f8bfb464d9ab7068fefa9c0ba57c436" title="Reset pool statistics counters.">SocketPool_reset_stats()</a> to start fresh measurement window. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga19433078a67ca838968245b41644fe7c" name="ga19433078a67ca838968245b41644fe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19433078a67ca838968245b41644fe7c">&#9670;&#160;</a></span>SocketPool_get_idle_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_get_idle_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get count of currently idle connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of idle connections (active but not currently in use). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1).</dt><dd></dd></dl>
<p>Convenience wrapper around <a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a>.current_idle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga996b6e1e70230dec597386572109b873" title="Get count of currently active connections.">SocketPool_get_active_count()</a> for active connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a> for full statistics. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gaee19a772a9cf21b2c50fd1deec498b0b" name="gaee19a772a9cf21b2c50fd1deec498b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee19a772a9cf21b2c50fd1deec498b0b">&#9670;&#160;</a></span>SocketPool_get_idle_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t SocketPool_get_idle_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get idle connection timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current idle timeout in seconds (0 = disabled). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for setting the timeout. </dd></dl>

</div>
</div>
<a id="ga8289eac993efd5cac1c6147c06d6d645" name="ga8289eac993efd5cac1c6147c06d6d645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8289eac993efd5cac1c6147c06d6d645">&#9670;&#160;</a></span>SocketPool_get_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_get_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#structSocketPool__Stats">SocketPool_Stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pool statistics snapshot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stats</td><td>Output statistics structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Fills stats with current pool statistics. Calculated metrics (reuse_rate, avg_connection_age, churn_rate) are computed at call time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#structSocketPool__Stats" title="Pool statistics snapshot structure.">SocketPool_Stats</a> for statistics structure. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2f8bfb464d9ab7068fefa9c0ba57c436" title="Reset pool statistics counters.">SocketPool_reset_stats()</a> for resetting counters. </dd></dl>

</div>
</div>
<a id="ga9047fb0f2c05a4f208c023b5e81196e3" name="ga9047fb0f2c05a4f208c023b5e81196e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9047fb0f2c05a4f208c023b5e81196e3">&#9670;&#160;</a></span>SocketPool_get_syn_protection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__security.html#structSocketSYNProtect__T">SocketSYNProtect_T</a> SocketPool_get_syn_protection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current SYN protection module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current SYN protection instance, or NULL if disabled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga847e3ae8d165d8a999ef76a68d21ffa5" title="Enable SYN flood protection for pool.">SocketPool_set_syn_protection()</a> for setting protection. </dd></dl>

</div>
</div>
<a id="gadc0d9937eb377068134cab141b8bcfad" name="gadc0d9937eb377068134cab141b8bcfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0d9937eb377068134cab141b8bcfad">&#9670;&#160;</a></span>SocketPool_getconnrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_getconnrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection rate limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Connections per second limit (0 if disabled). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga204d43047f820499ae59b7984f00b148" title="Set connection rate limit.">SocketPool_setconnrate()</a> for setting the limit. </dd></dl>

</div>
</div>
<a id="ga952bad4a5d699878fef42407a1260cfe" name="ga952bad4a5d699878fef42407a1260cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952bad4a5d699878fef42407a1260cfe">&#9670;&#160;</a></span>SocketPool_getmaxperip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_getmaxperip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum connections per IP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum connections per IP (0 = unlimited). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b" title="Set maximum connections per IP.">SocketPool_setmaxperip()</a> for setting the limit. </dd></dl>

</div>
</div>
<a id="ga3eec83919427223173cdaae6f1b36b8a" name="ga3eec83919427223173cdaae6f1b36b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eec83919427223173cdaae6f1b36b8a">&#9670;&#160;</a></span>socketpool_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned socketpool_hash </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate temporary buffer for bulk cleanup operations from arena. </p>
<p>Allocates array of Socket_T pointers sized to match pool's maxconns. Used during <a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> to collect idle connections for batch processing. Arena-managed via CALLOC, zero-initialized (all NULL pointers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Arena_T for allocation (must not be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxconns</td><td>Pool's maximum connection count (determines buffer size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated and zeroed Socket_T* array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>if <a class="el" href="group__foundation.html#ga3b920b3eed0306dc5afb36934955f6a2" title="Allocate and zero-initialize a block of memory elements from the arena.">Arena_calloc()</a> fails (ENOMEM equivalent). </td></tr>
    <tr><td class="paramname">Arena_Failed</td><td>if insufficient arena space available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - relies on non-thread-safe arena allocation.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(maxconns) time and space - linear in pool capacity.</dt><dd></dd></dl>
<p>Internal Usage Pattern</p>
<div class="fragment"><div class="line"><span class="comment">// Called in allocate_pool_components() during pool creation</span></div>
<div class="line">pool-&gt;cleanup_buffer = SocketPool_cleanup_allocate_buffer(arena, maxconns);</div>
<div class="line"><span class="comment">// Later in SocketPool_cleanup():</span></div>
<div class="line"><span class="keywordtype">size_t</span> to_cleanup = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pool-&gt;maxconns; ++i) {</div>
<div class="line">  <span class="keywordflow">if</span> (is_idle(&amp;pool-&gt;connections[i])) {</div>
<div class="line">    pool-&gt;cleanup_buffer[to_cleanup++] = pool-&gt;connections[i].socket;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Batch process/close sockets in cleanup_buffer[0..to_cleanup-1]</span></div>
</div><!-- fragment --><p>Buffer Lifecycle</p>
<ul>
<li>Purpose: Avoid realloc() during runtime cleanup scans</li>
<li>Size: maxconns * sizeof(Socket_T*) (~8-64KB depending on arch)</li>
<li>Zero-init: Ensures safe iteration (no dangling pointers)</li>
<li>Arena-managed: Auto-freed on <a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> in <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Temporary work buffer - contents overwritten each cleanup cycle. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Oversized pools consume unnecessary memory; tune via <a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a>. </dd>
<dd>
Arena pressure: Large pools may cause frequent <a class="el" href="group__foundation.html#ga3b920b3eed0306dc5afb36934955f6a2" title="Allocate and zero-initialize a block of memory elements from the arena.">Arena_calloc()</a> reallocations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for buffer usage in idle connection eviction. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> / allocate_pool_components() for allocation context. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> for implicit cleanup via arena disposal. </dd>
<dd>
foundation::Arena_T::Arena_calloc() underlying mechanism (via <a class="el" href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934" title="Convenience macro for zero-initialized multi-element allocation with source tracking.">CALLOC</a>).</dd></dl>
<p>Compute hash for socket (internal).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket_T to hash (must not be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned hash value for hash table lookup.</dd></dl>
<p>Uses golden ratio hash function for optimal distribution and collision resistance. Hash is computed from socket file descriptor using multiplication method.</p>
<p>PERFORMANCE: O(1) constant time, optimized for cache performance. DISTRIBUTION: Designed for low collision rate with typical FD ranges.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4a354a257cb7d9a1f7cd2befa6d72d0f" title="Alias for the library&#39;s central hash table size configuration.">SOCKET_HASH_SIZE</a> for table size. </dd>
<dd>
<a class="el" href="group__foundation.html#ga62f7a03bb960ab153cb4b8dd0f114980" title="Hash file descriptor using golden ratio multiplicative.">socket_util_hash_fd</a> in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for implementation. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac073c8a892a77bae682cec8398d10518" title="Insert connection into hash table.">insert_into_hash_table()</a> for usage. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga344c2ab8a3e0b099bd74e65cc97cb66f" title="Find connection slot by socket (internal).">find_slot()</a> for lookup. </dd>
<dd>
<a class="el" href="group__foundation.html#gae5597cbeaa3012e797eb99aaf9570030" title="Golden ratio constant for multiplicative hashing.">HASH_GOLDEN_RATIO</a> in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for constants. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877" title="Get underlying file descriptor.">Socket_fd()</a> for getting file descriptor. </dd></dl>

</div>
</div>
<a id="gac801c2d9c4fd944334de2a551993bd89" name="gac801c2d9c4fd944334de2a551993bd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac801c2d9c4fd944334de2a551993bd89">&#9670;&#160;</a></span>SocketPool_health()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae">SocketPool_Health</a> SocketPool_health </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pool health status for load balancers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current SocketPool_Health. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1). Maps state to health: RUNNING -&gt; HEALTHY, DRAINING -&gt; DRAINING, STOPPED -&gt; STOPPED. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga97c30d41df98c69bb394f0a91c3759ae" title="Health status for load balancer integration.">SocketPool_Health</a> for health status definitions. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0a62267ba3008f826b6952624dbc6a29" title="Get current pool lifecycle state.">SocketPool_state()</a> for raw state. </dd></dl>

</div>
</div>
<a id="gab0d0f088107c8034fff0a9f87d056100" name="gab0d0f088107c8034fff0a9f87d056100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d0f088107c8034fff0a9f87d056100">&#9670;&#160;</a></span>SocketPool_idle_cleanup_due_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketPool_idle_cleanup_due_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get time until next idle cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until next cleanup, -1 if disabled. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Use as timeout hint for poll/select to ensure timely cleanup. Returns -1 if idle timeout is disabled (timeout_sec == 0).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for configuring cleanup. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8efd44a4a7089eea19819785b0e2de4b" title="Run idle connection cleanup if due.">SocketPool_run_idle_cleanup()</a> for manual cleanup. </dd></dl>

</div>
</div>
<a id="gace0da0754ae023a89aee4b96a4e50845" name="gace0da0754ae023a89aee4b96a4e50845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0da0754ae023a89aee4b96a4e50845">&#9670;&#160;</a></span>SocketPool_ip_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_ip_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get connection count for IP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ip</td><td>IP address to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of tracked connections from this IP. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9b0182834888e8b3136846f5fca1bc64" title="Manually track IP for per-IP limiting.">SocketPool_track_ip()</a> for tracking IPs. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4" title="Release tracked IP when connection closes.">SocketPool_release_ip()</a> for releasing tracked IPs. </dd></dl>

</div>
</div>
<a id="ga5245d1cd6578a86f1045529d07fe511c" name="ga5245d1cd6578a86f1045529d07fe511c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5245d1cd6578a86f1045529d07fe511c">&#9670;&#160;</a></span>SocketPool_is_draining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_is_draining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if pool is currently draining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if state is DRAINING. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga0a62267ba3008f826b6952624dbc6a29" title="Get current pool lifecycle state.">SocketPool_state()</a> for full state information. </dd></dl>

</div>
</div>
<a id="ga6ee3c9502d314b58f9eba33827dd28cf" name="ga6ee3c9502d314b58f9eba33827dd28cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee3c9502d314b58f9eba33827dd28cf">&#9670;&#160;</a></span>SocketPool_is_stopped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_is_stopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if pool is fully stopped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if state is STOPPED. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga0a62267ba3008f826b6952624dbc6a29" title="Get current pool lifecycle state.">SocketPool_state()</a> for full state information. </dd></dl>

</div>
</div>
<a id="ga2774ba952af4a9a218e33b492aed1a18" name="ga2774ba952af4a9a218e33b492aed1a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2774ba952af4a9a218e33b492aed1a18">&#9670;&#160;</a></span>SocketPool_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> SocketPool_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxconns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new connection pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Arena_T for memory allocation (NULL uses default arena). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxconns</td><td>Maximum number of connections (enforced to 1-SOCKET_MAX_CONNECTIONS). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Size of I/O buffers per connection (enforced to min-max bounds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New pool instance (never returns NULL on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on any allocation or initialization failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - pool operations are thread-safe after creation.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md386"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a>();</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> pool = <a class="code hl_function" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18">SocketPool_new</a>(arena, 1000, 8192);</div>
<div class="line">    <span class="comment">// Use pool for connections...</span></div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004">SocketPool_free</a>(&amp;pool);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a> (<a class="code hl_variable" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36">SocketPool_Failed</a>) {</div>
<div class="line">    <span class="comment">// Handle allocation failure</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;arena);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketPool-private_8h_html_structSocketPool__T"><div class="ttname"><a href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a></div><div class="ttdef"><b>Definition</b> <a href="SocketPool-private_8h_source.html#l00525">SocketPool-private.h:526</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga2774ba952af4a9a218e33b492aed1a18"><div class="ttname"><a href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18">SocketPool_new</a></div><div class="ttdeci">SocketPool_T SocketPool_new(Arena_T arena, size_t maxconns, size_t bufsize)</div><div class="ttdoc">Create a new connection pool.</div></div>
<div class="ttc" id="agroup__foundation_html_ga0e2a75478cd44f1666a6aca626c5c50b"><div class="ttname"><a href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a></div><div class="ttdeci">#define FINALLY</div><div class="ttdoc">Define cleanup code that executes regardless of exceptions.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01326">Except.h:1326</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga6842e66018614df08139e67826cf3e0d"><div class="ttname"><a href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a></div><div class="ttdeci">void Arena_dispose(Arena_T *ap)</div><div class="ttdoc">Dispose of an arena and all its allocations, freeing underlying memory chunks.</div></div>
<div class="ttc" id="agroup__foundation_html_ga6a6d6890eb6ed1248ae1a5f0c677c7a4"><div class="ttname"><a href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a></div><div class="ttdeci">Arena_T Arena_new(void)</div><div class="ttdoc">Create a new memory arena with initial capacity and thread-safe protection.</div></div>
<div class="ttc" id="agroup__foundation_html_gac1ed22b9df4eff7a3398cac608c090cc"><div class="ttname"><a href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></div><div class="ttdeci">struct Arena_T * Arena_T</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00080">Arena.h:80</a></div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(maxconns) - initializes hash table and pre-allocates buffers</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically pre-warms SOCKET_POOL_DEFAULT_PREWARM_PCT slots for performance. </dd>
<dd>
All connections share the same arena for memory management. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> for cleanup. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8363470d36d9cac714f087b8dcb1a048" title="Pre-allocate buffers for percentage of free slots.">SocketPool_prewarm()</a> for runtime pre-warming. </dd>
<dd>
<a class="el" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4" title="Create a new memory arena with initial capacity and thread-safe protection.">Arena_new()</a> for arena creation. </dd>
<dd>
<a class="el" href="group__foundation.html#ga72f1e9bc10cc82fb4ee1915335d60152" title="Maximum number of connections in pool.">SOCKET_MAX_CONNECTIONS</a> for global limits. </dd>
<dd>
<a class="el" href="group__foundation.html#ga8ae494bcc57f791a1f8cbcf48b96b9a8" title="Minimum buffer size per connection.">SOCKET_MIN_BUFFER_SIZE</a> and <a class="el" href="group__foundation.html#ga72443e4b95fbd8ef4d191b754b4324dc" title="Maximum buffer size per connection.">SOCKET_MAX_BUFFER_SIZE</a> for buffer limits. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gaef36179b23774c639bb9fd68a99001c7" name="gaef36179b23774c639bb9fd68a99001c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef36179b23774c639bb9fd68a99001c7">&#9670;&#160;</a></span>SocketPool_prepare_connection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_prepare_connection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T *&#160;</td>
          <td class="paramname"><em>out_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> *&#160;</td>
          <td class="paramname"><em>out_req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare async connection using DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Pool instance (used for configuration and cleanup). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">host</td><td>Remote hostname or IP address. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port</td><td>Remote port (1-65535). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_socket</td><td>New Socket_T instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_req</td><td>Pointer to Request_T (DNS request handle) for monitoring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (out_socket/out_req undefined). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Creates Socket_T with pool defaults, starts async DNS resolution. Monitor out_req, then complete with <a class="el" href="group__core__io.html#ga28271af8ebad671a64fd37ffb2d07e0c" title="Connect socket using resolved address.">Socket_connect_with_addrinfo()</a> and <a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a>. On error, <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> the socket.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabaca1689f64e0266f4b3366e99bcb766" title="Create async connection to remote host.">SocketPool_connect_async()</a> for higher-level async connection. </dd>
<dd>
<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> for DNS resolution details. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding completed connections. </dd>
<dd>
<a class="el" href="group__core__io.html#ga28271af8ebad671a64fd37ffb2d07e0c" title="Connect socket using resolved address.">Socket_connect_with_addrinfo()</a> for completing the connection. </dd>
<dd>
<a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> for cleanup on error. </dd></dl>

</div>
</div>
<a id="ga8363470d36d9cac714f087b8dcb1a048" name="ga8363470d36d9cac714f087b8dcb1a048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8363470d36d9cac714f087b8dcb1a048">&#9670;&#160;</a></span>SocketPool_prewarm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_prewarm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>percentage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-allocate buffers for percentage of free slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">percentage</td><td>Percentage of free slots to prewarm (0-100). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Reduces latency by pre-allocating buffers. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for initial prewarming. </dd></dl>

</div>
</div>
<a id="ga817b53044890ea7978afb73f51584bce" name="ga817b53044890ea7978afb73f51584bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817b53044890ea7978afb73f51584bce">&#9670;&#160;</a></span>SocketPool_process_reconnects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_process_reconnects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process reconnection state machines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Must be called periodically (e.g., in event loop) to process reconnection timers and state transitions for all connections with auto-reconnect enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4bfa04a134354dcebd077ea54dbb2d9e" title="Get time until next reconnection action.">SocketPool_reconnect_timeout_ms()</a> for timeout hints. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> for enabling reconnection. </dd></dl>

</div>
</div>
<a id="ga4bfa04a134354dcebd077ea54dbb2d9e" name="ga4bfa04a134354dcebd077ea54dbb2d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bfa04a134354dcebd077ea54dbb2d9e">&#9670;&#160;</a></span>SocketPool_reconnect_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_reconnect_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get time until next reconnection action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until next timeout, or -1 if none pending. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Use as timeout hint for poll/select when reconnections are active.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga817b53044890ea7978afb73f51584bce" title="Process reconnection state machines.">SocketPool_process_reconnects()</a> for processing reconnections. </dd></dl>

</div>
</div>
<a id="ga930ce5b0eddb884de4c8514e4d6068c4" name="ga930ce5b0eddb884de4c8514e4d6068c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga930ce5b0eddb884de4c8514e4d6068c4">&#9670;&#160;</a></span>SocketPool_release_ip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_release_ip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release tracked IP when connection closes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ip</td><td>IP address to release. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Decrements the connection count for the IP address. Safe to call with NULL or untracked IP.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9b0182834888e8b3136846f5fca1bc64" title="Manually track IP for per-IP limiting.">SocketPool_track_ip()</a> for tracking IPs. </dd></dl>

</div>
</div>
<a id="gacdffcf1802367df60db15c649fc7072d" name="gacdffcf1802367df60db15c649fc7072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdffcf1802367df60db15c649fc7072d">&#9670;&#160;</a></span>SocketPool_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove socket from pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">socket</td><td>Socket to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Clears buffers but does not close socket. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for adding connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab2a7df0479b8f9ac899672afdb488b94" title="Remove idle connections.">SocketPool_cleanup()</a> for bulk removal. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga2f8bfb464d9ab7068fefa9c0ba57c436" name="ga2f8bfb464d9ab7068fefa9c0ba57c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8bfb464d9ab7068fefa9c0ba57c436">&#9670;&#160;</a></span>SocketPool_reset_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_reset_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset pool statistics counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Resets all cumulative counters to zero and restarts the statistics window. Current state values (active, idle, max) are not affected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga8289eac993efd5cac1c6147c06d6d645" title="Get pool statistics snapshot.">SocketPool_get_stats()</a> for reading statistics. </dd></dl>

</div>
</div>
<a id="gae7d2acf643422a026241225f245f8d26" name="gae7d2acf643422a026241225f245f8d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d2acf643422a026241225f245f8d26">&#9670;&#160;</a></span>SocketPool_resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_maxconns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize pool capacity at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_maxconns</td><td>New maximum connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketPool_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Grows/shrinks pool; closes excess connections on shrink. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9c7cd8aa28512bb3e73885f5968a46cd" title="Register pool resize notification callback.">SocketPool_set_resize_callback()</a> for notifications. </dd></dl>

</div>
</div>
<a id="ga8efd44a4a7089eea19819785b0e2de4b" name="ga8efd44a4a7089eea19819785b0e2de4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8efd44a4a7089eea19819785b0e2de4b">&#9670;&#160;</a></span>SocketPool_run_idle_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_run_idle_cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run idle connection cleanup if due. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connections cleaned up. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Call periodically (e.g., after each poll iteration) to remove idle connections. Only performs cleanup if cleanup interval has passed. Does nothing if idle timeout is disabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for configuring cleanup. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab0d0f088107c8034fff0a9f87d056100" title="Get time until next idle cleanup.">SocketPool_idle_cleanup_due_ms()</a> for timing information. </dd></dl>

</div>
</div>
<a id="ga83ad1fb6ad736f4169297af3fd255410" name="ga83ad1fb6ad736f4169297af3fd255410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ad1fb6ad736f4169297af3fd255410">&#9670;&#160;</a></span>SocketPool_set_bufsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_bufsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set buffer size for future connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_bufsize</td><td>New buffer size for future connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Existing connections keep their current buffer size. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2774ba952af4a9a218e33b492aed1a18" title="Create a new connection pool.">SocketPool_new()</a> for initial buffer size. </dd>
<dd>
<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer operations. </dd></dl>

</div>
</div>
<a id="ga254e5c125de7413e1fa2a8809350d4e0" name="ga254e5c125de7413e1fa2a8809350d4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254e5c125de7413e1fa2a8809350d4e0">&#9670;&#160;</a></span>SocketPool_set_drain_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_drain_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#gad7679db7b1be62e465d9896944f3ad20">SocketPool_DrainCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register drain completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cb</td><td>Callback function (NULL to clear). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Callback is invoked exactly once when drain completes (transitions to STOPPED). Safe to call <a class="el" href="group__connection__mgmt.html#gafb57544a14c977302953fd36634bd004" title="Free a connection pool and release all resources.">SocketPool_free()</a> from callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gad7679db7b1be62e465d9896944f3ad20" title="Notification callback when drain completes.">SocketPool_DrainCallback</a> for callback signature. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for initiating drain. </dd></dl>

</div>
</div>
<a id="gaa0f0813679f7ffbff6ff75adb3678c8c" name="gaa0f0813679f7ffbff6ff75adb3678c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0f0813679f7ffbff6ff75adb3678c8c">&#9670;&#160;</a></span>SocketPool_set_idle_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_idle_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga18f3ff7614b9968e5cc27f2017a0f058">SocketPool_IdleCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register callback for when connections become idle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cb</td><td>Callback function (NULL to clear). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>The callback is invoked when a connection transitions to idle state. Useful for monitoring, logging, or cleaning up per-connection resources.</p>
<h2><a class="anchor" id="autotoc_md394"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> on_idle(Connection_T conn, <span class="keywordtype">void</span> *data) {</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__connection__mgmt.html#gaaeff7efb1109a312f56e35689b67c652">Connection_socket</a>(conn);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Connection from %s went idle\n&quot;</span>, <a class="code hl_function" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c">Socket_getpeeraddr</a>(sock));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gaa0f0813679f7ffbff6ff75adb3678c8c">SocketPool_set_idle_callback</a>(pool, on_idle, NULL);</div>
<div class="ttc" id="agroup__connection__mgmt_html_gaa0f0813679f7ffbff6ff75adb3678c8c"><div class="ttname"><a href="group__connection__mgmt.html#gaa0f0813679f7ffbff6ff75adb3678c8c">SocketPool_set_idle_callback</a></div><div class="ttdeci">void SocketPool_set_idle_callback(SocketPool_T pool, SocketPool_IdleCallback cb, void *data)</div><div class="ttdoc">Register callback for when connections become idle.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga18f3ff7614b9968e5cc27f2017a0f058" title="Callback invoked when a connection becomes idle.">SocketPool_IdleCallback</a> for callback requirements. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga76151bb579f44bdf79aeca57dbd8122e" title="Set idle connection timeout.">SocketPool_set_idle_timeout()</a> for automatic idle cleanup. </dd></dl>

</div>
</div>
<a id="ga76151bb579f44bdf79aeca57dbd8122e" name="ga76151bb579f44bdf79aeca57dbd8122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76151bb579f44bdf79aeca57dbd8122e">&#9670;&#160;</a></span>SocketPool_set_idle_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_idle_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set idle connection timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout_sec</td><td>Idle timeout in seconds (0 to disable automatic cleanup). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>When enabled, connections idle longer than timeout_sec will be removed during periodic cleanup. Use <a class="el" href="group__connection__mgmt.html#gab0d0f088107c8034fff0a9f87d056100" title="Get time until next idle cleanup.">SocketPool_idle_cleanup_due_ms()</a> to get the time until next cleanup for poll timeout integration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaee19a772a9cf21b2c50fd1deec498b0b" title="Get idle connection timeout.">SocketPool_get_idle_timeout()</a> for reading the timeout. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gab0d0f088107c8034fff0a9f87d056100" title="Get time until next idle cleanup.">SocketPool_idle_cleanup_due_ms()</a> for cleanup timing. </dd></dl>

</div>
</div>
<a id="gae4b6b07007da08326b53c069a4c1f2ea" name="gae4b6b07007da08326b53c069a4c1f2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b6b07007da08326b53c069a4c1f2ea">&#9670;&#160;</a></span>SocketPool_set_reconnect_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_reconnect_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set default reconnection policy for pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">policy</td><td>Reconnection policy (NULL to disable auto-reconnect). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Sets the default reconnection policy for connections in this pool. Does not affect existing connections - use <a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> for those.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> for policy configuration. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga94ef5658ee53e87337b931b549ff35f2" title="Enable auto-reconnect for a connection.">SocketPool_enable_reconnect()</a> for enabling on existing connections. </dd></dl>

</div>
</div>
<a id="ga9c7cd8aa28512bb3e73885f5968a46cd" name="ga9c7cd8aa28512bb3e73885f5968a46cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7cd8aa28512bb3e73885f5968a46cd">&#9670;&#160;</a></span>SocketPool_set_resize_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_resize_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga6ec7b7f0dae3b1366f32f93294dc8b4a">SocketPool_ResizeCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register pool resize notification callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cb</td><td>Callback function (NULL to clear). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Callback is invoked after successful pool resize operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga6ec7b7f0dae3b1366f32f93294dc8b4a" title="Callback invoked after pool resize.">SocketPool_ResizeCallback</a> for callback signature. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for resize operations. </dd></dl>

</div>
</div>
<a id="ga847e3ae8d165d8a999ef76a68d21ffa5" name="ga847e3ae8d165d8a999ef76a68d21ffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga847e3ae8d165d8a999ef76a68d21ffa5">&#9670;&#160;</a></span>SocketPool_set_syn_protection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_syn_protection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__security.html#structSocketSYNProtect__T">SocketSYNProtect_T</a>&#160;</td>
          <td class="paramname"><em>protect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable SYN flood protection for pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">protect</td><td>SYN protection instance (NULL to disable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>When enabled, <a class="el" href="group__connection__mgmt.html#ga899c660b21bf96befd2b5ea9f6937988" title="Accept with full SYN flood protection.">SocketPool_accept_protected()</a> will check with the protection module and apply appropriate actions (throttle, challenge, or block) before accepting connections.</p>
<p>The protection module is NOT owned by the pool - caller must ensure it remains valid and must free it after the pool is freed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga899c660b21bf96befd2b5ea9f6937988" title="Accept with full SYN flood protection.">SocketPool_accept_protected()</a> for protected accepting. </dd>
<dd>
security::SocketSYNProtect for SYN flood protection details. </dd></dl>

</div>
</div>
<a id="ga11a46794f10d4d659cf75412e84cef31" name="ga11a46794f10d4d659cf75412e84cef31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a46794f10d4d659cf75412e84cef31">&#9670;&#160;</a></span>SocketPool_set_validation_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_set_validation_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga9a848b27d2034b028ceb2febdc6471b5">SocketPool_ValidationCallback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connection validation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cb</td><td>Validation callback (NULL to disable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Callback invoked during <a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> to validate connections before reuse. Use for application-level health checks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga9a848b27d2034b028ceb2febdc6471b5" title="Callback to validate connection before reuse.">SocketPool_ValidationCallback</a> for callback signature. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3e6eccb3c5a10e8ac40b057a56e77ed5" title="Check health of a connection.">SocketPool_check_connection()</a> for built-in health checks. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for when validation occurs. </dd></dl>

</div>
</div>
<a id="ga204d43047f820499ae59b7984f00b148" name="ga204d43047f820499ae59b7984f00b148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204d43047f820499ae59b7984f00b148">&#9670;&#160;</a></span>SocketPool_setconnrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_setconnrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conns_per_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>burst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set connection rate limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conns_per_sec</td><td>Maximum new connections per second (0 to disable). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">burst</td><td>Burst capacity (0 for default = conns_per_sec). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Enables connection rate limiting using token bucket algorithm. New connections via <a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> or <a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> will be rejected if rate is exceeded.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for rate-limited accepting. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gadc0d9937eb377068134cab141b8bcfad" title="Get connection rate limit.">SocketPool_getconnrate()</a> to check current limit. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf8991c65cdec81d2a8db01a2f820a42b" title="Set maximum connections per IP.">SocketPool_setmaxperip()</a> for per-IP limits. </dd>
<dd>
utilities::SocketRateLimit_T for token bucket implementation. </dd></dl>

</div>
</div>
<a id="gaf8991c65cdec81d2a8db01a2f820a42b" name="gaf8991c65cdec81d2a8db01a2f820a42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8991c65cdec81d2a8db01a2f820a42b">&#9670;&#160;</a></span>SocketPool_setmaxperip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPool_setmaxperip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_conns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum connections per IP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">max_conns</td><td>Maximum connections per IP (0 = unlimited). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Enables per-IP connection limiting to prevent single-source attacks. New connections from IPs that exceed the limit will be rejected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga952bad4a5d699878fef42407a1260cfe" title="Get maximum connections per IP.">SocketPool_getmaxperip()</a> for reading the limit. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a> for rate-limited accepting. </dd></dl>

</div>
</div>
<a id="ga4cef8507b62e5092e9064800c84f296f" name="ga4cef8507b62e5092e9064800c84f296f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cef8507b62e5092e9064800c84f296f">&#9670;&#160;</a></span>SocketPool_shrink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketPool_shrink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release unused pool capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connection slots released. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Shrinks the pool by releasing unused (free) connection slots, reducing memory footprint. Only affects slots that have never been used or have been freed. Does not affect currently active connections.</p>
<h2><a class="anchor" id="autotoc_md393"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// After peak traffic subsides, reclaim unused memory</span></div>
<div class="line"><span class="keywordtype">size_t</span> released = <a class="code hl_function" href="group__connection__mgmt.html#ga4cef8507b62e5092e9064800c84f296f">SocketPool_shrink</a>(pool);</div>
<div class="line">printf(<span class="stringliteral">&quot;Released %zu unused slots\n&quot;</span>, released);</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga4cef8507b62e5092e9064800c84f296f"><div class="ttname"><a href="group__connection__mgmt.html#ga4cef8507b62e5092e9064800c84f296f">SocketPool_shrink</a></div><div class="ttdeci">size_t SocketPool_shrink(SocketPool_T pool)</div><div class="ttdoc">Release unused pool capacity.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Does not reduce maxconns - pool can still grow back to original size. </dd>
<dd>
Memory is not immediately returned to OS; managed by arena.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae7d2acf643422a026241225f245f8d26" title="Resize pool capacity at runtime.">SocketPool_resize()</a> for changing pool capacity. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8363470d36d9cac714f087b8dcb1a048" title="Pre-allocate buffers for percentage of free slots.">SocketPool_prewarm()</a> for pre-allocating capacity. </dd></dl>

</div>
</div>
<a id="ga0a62267ba3008f826b6952624dbc6a29" name="ga0a62267ba3008f826b6952624dbc6a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a62267ba3008f826b6952624dbc6a29">&#9670;&#160;</a></span>SocketPool_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056">SocketPool_State</a> SocketPool_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current pool lifecycle state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current SocketPool_State. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complexity: O(1). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae5f905ecace343c3b462dfadd5fa8056" title="Pool lifecycle states for graceful shutdown.">SocketPool_State</a> for state definitions. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga24cd4e2f757497906a5aef89b133b068" title="Initiate graceful shutdown.">SocketPool_drain()</a> for state transitions. </dd></dl>

</div>
</div>
<a id="ga9b0182834888e8b3136846f5fca1bc64" name="ga9b0182834888e8b3136846f5fca1bc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b0182834888e8b3136846f5fca1bc64">&#9670;&#160;</a></span>SocketPool_track_ip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketPool_track_ip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manually track IP for per-IP limiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Pool instance. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ip</td><td>IP address to track. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if under limit and tracked, 0 if limit reached. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Use when manually managing connections not via <a class="el" href="group__connection__mgmt.html#gabd8219ceff615ad4a4064cf389f137a6" title="Accept connection with rate limiting.">SocketPool_accept_limited()</a>. Call <a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4" title="Release tracked IP when connection closes.">SocketPool_release_ip()</a> when connection closes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga930ce5b0eddb884de4c8514e4d6068c4" title="Release tracked IP when connection closes.">SocketPool_release_ip()</a> for releasing tracked IPs. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gace0da0754ae023a89aee4b96a4e50845" title="Get connection count for IP.">SocketPool_ip_count()</a> for checking IP connection count. </dd></dl>

</div>
</div>
<a id="gae798b2ae7451bbc7247fe71481190ee6" name="gae798b2ae7451bbc7247fe71481190ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae798b2ae7451bbc7247fe71481190ee6">&#9670;&#160;</a></span>SocketReconnect_attempts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_attempts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of connection attempts since last success or reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of connection attempts since last success or reset </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>

</div>
</div>
<a id="ga2669844f3ad8a19649f2bc204eee8401" name="ga2669844f3ad8a19649f2bc204eee8401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2669844f3ad8a19649f2bc204eee8401">&#9670;&#160;</a></span>SocketReconnect_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate or queue a connection attempt according to current state and policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance to connect</td></tr>
  </table>
  </dd>
</dl>
<p>Triggers transition from DISCONNECTED to CONNECTING if possible. Behavior based on current state:</p><ul>
<li>DISCONNECTED: Starts non-blocking connect to resolved host/port</li>
<li>CONNECTING: No-op (already attempting)</li>
<li>CONNECTED: No-op (already connected)</li>
<li>BACKOFF: Queues retry after current backoff timer expires (via tick())</li>
<li>CIRCUIT_OPEN: Ignored until reset timeout elapses</li>
</ul>
<p>Success/failure detected via <a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538" title="Process I/O events from poll loop.">SocketReconnect_process()</a> on poll events or timeouts. Failed attempts increment statistics and may trigger backoff or circuit open.</p>
<h2><a class="anchor" id="autotoc_md557"></a>
State Transitions Triggered</h2>
<ul>
<li>DISCONNECTED -&gt; CONNECTING (immediate)</li>
<li>BACKOFF -&gt; CONNECTING (after delay)</li>
<li>CIRCUIT_OPEN -&gt; ignored</li>
</ul>
<h2><a class="anchor" id="autotoc_md558"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(<span class="stringliteral">&quot;example.com&quot;</span>, 80, NULL, NULL,</div>
<div class="line">NULL);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a>(conn);  <span class="comment">// Start first attempt</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In event loop:</span></div>
<div class="line"><span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8">SocketReconnect_pollfd</a>(conn);</div>
<div class="line"><span class="keywordflow">if</span> (event on fd ) { <span class="comment">// e.g., POLLOUT or POLLIN</span></div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538">SocketReconnect_process</a>(conn);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After failure, auto-retries per policy</span></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga4ca4375d521b1eddcc4cf3f75fe3b538"><div class="ttname"><a href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538">SocketReconnect_process</a></div><div class="ttdeci">void SocketReconnect_process(SocketReconnect_T conn)</div><div class="ttdoc">Process I/O events from poll loop.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gaa2db0dea41db5bb5a7efeec947323da8"><div class="ttname"><a href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8">SocketReconnect_pollfd</a></div><div class="ttdeci">int SocketReconnect_pollfd(SocketReconnect_T conn)</div><div class="ttdoc">Retrieve file descriptor for event loop integration (poll/epoll/kqueue/select).</div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n No - state mutation not safe across threads</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - defers actual connect to non-blocking socket call</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>getaddrinfo() cached from creation; no repeated DNS lookups </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling repeatedly in rapid succession wastes CPU; rely on auto-retry </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> Check if connect was accepted </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538" title="Process I/O events from poll loop.">SocketReconnect_process()</a> Handle connection completion events </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822" title="Advance timers and perform periodic maintenance for state transitions and checks.">SocketReconnect_tick()</a> Advance timers for queued retries </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaa3794b861d4dad021064bae97ea12e78" title="Gracefully disconnect without triggering reconnect.">SocketReconnect_disconnect()</a> Stop and reset without retry </dd></dl>

</div>
</div>
<a id="gae5943a7adc872f2a89da06c7cf19300d" name="gae5943a7adc872f2a89da06c7cf19300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5943a7adc872f2a89da06c7cf19300d">&#9670;&#160;</a></span>SocketReconnect_disable_tls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_disable_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable TLS for future connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context</td></tr>
  </table>
  </dd>
</dl>
<p>Clears TLS configuration. Future connections will be plain TCP. If currently connected with TLS, the connection remains encrypted until disconnect; the next reconnect will be unencrypted.</p>
<dl class="section note"><dt>Note</dt><dd>Does not affect current connection if active </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b" title="Configure TLS for reconnecting connections.">SocketReconnect_set_tls()</a> to enable TLS </dd></dl>

</div>
</div>
<a id="gaa3794b861d4dad021064bae97ea12e78" name="gaa3794b861d4dad021064bae97ea12e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3794b861d4dad021064bae97ea12e78">&#9670;&#160;</a></span>SocketReconnect_disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gracefully disconnect without triggering reconnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Disconnects without triggering reconnection logic. Resets attempt counter. </dd>
<dd>
Use this for intentional disconnection (e.g., shutdown). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> for starting connections. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> for complete cleanup. </dd></dl>

</div>
</div>
<a id="ga8bb049b5716726216dec25cd2dfa2380" name="ga8bb049b5716726216dec25cd2dfa2380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb049b5716726216dec25cd2dfa2380">&#9670;&#160;</a></span>socketreconnect_elapsed_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t socketreconnect_elapsed_ms </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute elapsed monotonic time since provided start timestamp. </p>
<p>Calculates duration between start_ms and current time, clamping to 0 if anomalous (e.g., clock adjustment). Essential for timeout checks and delay validation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_ms</td><td>Starting timestamp from socketreconnect_get_time_ms()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative int64_t milliseconds elapsed; 0 if start_ms &gt;= now</dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">int64_t start = socketreconnect_get_time_ms();</div>
<div class="line"><span class="comment">// ... some operation ...</span></div>
<div class="line">int64_t elapsed = <a class="code hl_function" href="group__connection__mgmt.html#ga8bb049b5716726216dec25cd2dfa2380">socketreconnect_elapsed_ms</a>(start);</div>
<div class="line"><span class="keywordflow">if</span> (elapsed &gt; policy.max_delay_ms) {</div>
<div class="line">    <span class="comment">// Timeout handling</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga8bb049b5716726216dec25cd2dfa2380"><div class="ttname"><a href="group__connection__mgmt.html#ga8bb049b5716726216dec25cd2dfa2380">socketreconnect_elapsed_ms</a></div><div class="ttdeci">static int64_t socketreconnect_elapsed_ms(int64_t start_ms)</div><div class="ttdoc">Compute elapsed monotonic time since provided start timestamp.</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect-private_8h_source.html#l00507">SocketReconnect-private.h:507</a></div></div>
</div><!-- fragment --><p>Guarantees non-negative result for safe comparisons.</p>
<dl class="section user"><dt>Complexity\n O(1) - arithmetic only (calls get_time_ms inline)</dt><dd></dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no side effects</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Clamps to 0 on underflow to handle rare clock issues </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Input must be valid monotonic timestamp; invalid values may yield large positives</dd></dl>
<dl class="section see"><dt>See also</dt><dd>socketreconnect_get_time_ms() to obtain start_ms </dd>
<dd>
<a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf" title="Socket_get_monotonic_ms - Get current monotonic time in milliseconds.">Socket_get_monotonic_ms()</a> underlying time source </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00507">507</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketReconnect-private_8h_source.html#l00464">socketreconnect_now_ms()</a>.</p>

</div>
</div>
<a id="ga9f80ff5ac565edacc7b5c08a263ec73d" name="ga9f80ff5ac565edacc7b5c08a263ec73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f80ff5ac565edacc7b5c08a263ec73d">&#9670;&#160;</a></span>SocketReconnect_failures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_failures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get count of consecutive connection failures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of consecutive failures (for circuit breaker) </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>

</div>
</div>
<a id="ga9d8b4dd4a693ba7acb20ff8e78defe91" name="ga9d8b4dd4a693ba7acb20ff8e78defe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d8b4dd4a693ba7acb20ff8e78defe91">&#9670;&#160;</a></span>SocketReconnect_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance and release all associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">conn</td><td>Pointer to the <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> handle (set to NULL on success)</td></tr>
  </table>
  </dd>
</dl>
<p>Performs immediate cleanup:</p><ul>
<li>If CONNECTED or CONNECTING: Calls underlying socket shutdown/close</li>
<li>Cancels any pending timers or health checks</li>
<li>Releases internal memory allocations</li>
<li>Invokes no callbacks (safe during destruction)</li>
<li>Sets *conn to NULL to prevent use-after-free</li>
</ul>
<h2><a class="anchor" id="autotoc_md555"></a>
Cleanup Guarantees</h2>
<ul>
<li>Graceful shutdown of socket if possible (SOCKET_SHUT_RDWR)</li>
<li>All resources returned to system (no leaks)</li>
<li>Underlying Socket_T freed internally</li>
<li>Statistics reset (not preserved)</li>
</ul>
<h2><a class="anchor" id="autotoc_md556"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(host, port, NULL, NULL, NULL);</div>
<div class="line"><span class="comment">// ... use connection ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gaa3794b861d4dad021064bae97ea12e78">SocketReconnect_disconnect</a>(conn);  <span class="comment">// Optional graceful close</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91">SocketReconnect_free</a>(&amp;conn);       <span class="comment">// Required cleanup</span></div>
<div class="line">assert(conn == NULL);</div>
<div class="ttc" id="agroup__connection__mgmt_html_gaa3794b861d4dad021064bae97ea12e78"><div class="ttname"><a href="group__connection__mgmt.html#gaa3794b861d4dad021064bae97ea12e78">SocketReconnect_disconnect</a></div><div class="ttdeci">void SocketReconnect_disconnect(SocketReconnect_T conn)</div><div class="ttdoc">Gracefully disconnect without triggering reconnect.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n No - must be called from the thread managing the instance</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - socket close is O(1), timers cancelled instantly</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always pair with <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a>; unpaired frees undefined </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling on NULL or already-freed pointer is safe (no-op) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> Creation counterpart </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaa3794b861d4dad021064bae97ea12e78" title="Gracefully disconnect without triggering reconnect.">SocketReconnect_disconnect()</a> Graceful disconnect without full cleanup </dd>
<dd>
<a class="el" href="group__socket__live__utils.html#gaa8cacd863c275e6e12f7c63b65708e1b" title="Query current number of active Socket_T instances (public for tests).">Socket_debug_live_count()</a> Verify no leaks in tests (should be 0 after free) </dd></dl>

</div>
</div>
<a id="ga322b43d2dfe9735da6cbd891af3527ad" name="ga322b43d2dfe9735da6cbd891af3527ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga322b43d2dfe9735da6cbd891af3527ad">&#9670;&#160;</a></span>SocketReconnect_get_tls_hostname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketReconnect_get_tls_hostname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the configured TLS hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SNI hostname or NULL if TLS not configured </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - returns internal pointer (valid until set_tls/free)</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b" title="Configure TLS for reconnecting connections.">SocketReconnect_set_tls()</a> to set hostname </dd></dl>

</div>
</div>
<a id="ga7ee1c4c9f76873db39c01f25563ef743" name="ga7ee1c4c9f76873db39c01f25563ef743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ee1c4c9f76873db39c01f25563ef743">&#9670;&#160;</a></span>SocketReconnect_is_session_reused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_is_session_reused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if last connection used session resumption. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if session was resumed (abbreviated handshake), 0 if full handshake was performed, -1 if not connected or TLS not enabled </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads only</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gab2c4eeb92b2367fd5dd731bcbea4acf2" title="Enable TLS session resumption for faster reconnects.">SocketReconnect_set_session_resumption()</a> to enable caching </dd></dl>

</div>
</div>
<a id="ga490043a4bfaba8214f5d10a3c7b956de" name="ga490043a4bfaba8214f5d10a3c7b956de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga490043a4bfaba8214f5d10a3c7b956de">&#9670;&#160;</a></span>SocketReconnect_isconnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_isconnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if reconnection is currently in connected state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if connected, 0 otherwise </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>

</div>
</div>
<a id="ga2064741bf60283ac3315823128fa2082" name="ga2064741bf60283ac3315823128fa2082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2064741bf60283ac3315823128fa2082">&#9670;&#160;</a></span>SocketReconnect_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> SocketReconnect_new </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220">SocketReconnect_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance configured for a specific host and port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Target hostname (e.g., "example.com") or IP address (IPv4/IPv6) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Target port (1-65535); 0 invalid and will raise exception </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Optional custom policy (NULL uses defaults from <a class="el" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212" title="Populate a SocketReconnect_Policy_T with safe, production-recommended default values.">SocketReconnect_policy_defaults()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Optional state transition callback (NULL to disable) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userdata</td><td>User data passed unchanged to callbacks (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New opaque <a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> handle in DISCONNECTED state </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketReconnect_Failed</td><td>On invalid parameters (null host, invalid port, bad policy values), Arena allocation failure, or internal init errors</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes a reconnection context with the specified endpoint. Hostname is resolved synchronously using getaddrinfo(); for async resolution integrate with SocketDNS externally. The instance starts in RECONNECT_DISCONNECTED state. No connection attempt is made until <a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> is called. Resources (timers, state) are allocated from internal Arena; freed on <a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a>.</p>
<h2><a class="anchor" id="autotoc_md552"></a>
Validation Rules</h2>
<ul>
<li>host must be non-null and valid (checked via getaddrinfo)</li>
<li>port 1-65535</li>
<li>policy values validated (positive delays, multiplier &gt;1, etc.)</li>
<li>callback may be NULL</li>
</ul>
<h2><a class="anchor" id="autotoc_md553"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Basic creation with defaults</span></div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(<span class="stringliteral">&quot;api.example.com&quot;</span>, 443,</div>
<div class="line">NULL, NULL, NULL); <a class="code hl_function" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a>(conn);</div>
<div class="line">    <span class="comment">// Now integrate with loop or use I/O wrappers</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__connection__mgmt.html#ga3dc308919d4ccef64b7674cae246d9c0">SocketReconnect_Failed</a>) {</div>
<div class="line">    <span class="comment">// Handle init failure (e.g., invalid host)</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga3dc308919d4ccef64b7674cae246d9c0"><div class="ttname"><a href="group__connection__mgmt.html#ga3dc308919d4ccef64b7674cae246d9c0">SocketReconnect_Failed</a></div><div class="ttdeci">const Except_T SocketReconnect_Failed</div><div class="ttdoc">Exception type for errors in the reconnection module.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md554"></a>
Advanced Configuration</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> policy;</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212">SocketReconnect_policy_defaults</a>(&amp;policy);</div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#abd49613f2c70d36afe1822ca33ec1a0e">max_attempts</a> = 0;  <span class="comment">// Unlimited retries</span></div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#aaa80956d1e58e84adfab7063e1936f95">health_check_interval_ms</a> = 10000;  <span class="comment">// Check every 10s</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> state_cb(<a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> c, <a class="code hl_enumeration" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> o,</div>
<div class="line"><a class="code hl_enumeration" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> n, <span class="keywordtype">void</span> *ud) {</div>
<div class="line">    <span class="comment">// Log transition</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(<span class="stringliteral">&quot;db.internal&quot;</span>, 5432, &amp;policy,</div>
<div class="line">state_cb, app_ctx);</div>
<div class="ttc" id="agroup__connection__mgmt_html_aaa80956d1e58e84adfab7063e1936f95"><div class="ttname"><a href="group__connection__mgmt.html#aaa80956d1e58e84adfab7063e1936f95">SocketReconnect_Policy_T::health_check_interval_ms</a></div><div class="ttdeci">int health_check_interval_ms</div><div class="ttdoc">Interval between health checks when CONNECTED (default: 30000ms / 30s). 0 disables health checks enti...</div><div class="ttdef"><b>Definition</b> <a href="SocketReconnect_8h_source.html#l00419">SocketReconnect.h:419</a></div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n Yes - each instance independent; safe from any thread but use</dt><dd>single-thread per instance thereafter </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) setup + O(n) getaddrinfo() where n=address families</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Host/port fixed at creation; for dynamic targets create new instances or use SocketProxy </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Synchronous DNS may block briefly; consider caching resolved addresses for performance </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212" title="Populate a SocketReconnect_Policy_T with safe, production-recommended default values.">SocketReconnect_policy_defaults()</a> Safe default policy </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> Start connection process </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga9d8b4dd4a693ba7acb20ff8e78defe91" title="Destroy a SocketReconnect_T instance and release all associated resources.">SocketReconnect_free()</a> Cleanup resources </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0" title="Register a custom health check callback for proactive connection validation.">SocketReconnect_set_health_check()</a> Post-creation health customization </dd></dl>

</div>
</div>
<a id="gaf5bf725fe34ae1de58a3ee05fbe270fd" name="gaf5bf725fe34ae1de58a3ee05fbe270fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5bf725fe34ae1de58a3ee05fbe270fd">&#9670;&#160;</a></span>SocketReconnect_next_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_next_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate milliseconds until next timer event or action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds until next timeout, or -1 if none pending </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<p>Returns the time until:</p><ul>
<li>Next backoff retry</li>
<li>Circuit breaker probe</li>
<li>Health check</li>
</ul>
<p>Use as timeout for poll/select. </p>

</div>
</div>
<a id="ga8e2e9cd2b8dd8294f175991957b1b37b" name="ga8e2e9cd2b8dd8294f175991957b1b37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e2e9cd2b8dd8294f175991957b1b37b">&#9670;&#160;</a></span>socketreconnect_now_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t socketreconnect_now_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve current monotonic time in milliseconds for internal timing. </p>
<p>Provides a consistent, non-decreasing timestamp resistant to system clock changes (e.g., NTP adjustments). Used for all backoff, timeout, and health check calculations.</p>
<dl class="section return"><dt>Returns</dt><dd>int64_t milliseconds since arbitrary fixed epoch (monotonic).</dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">int64_t now = socketreconnect_get_time_ms();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__connection__mgmt.html#ga8bb049b5716726216dec25cd2dfa2380">socketreconnect_elapsed_ms</a>(start) &gt; timeout_ms) {</div>
<div class="line">    <span class="comment">// Handle timeout</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Always prefer this over system time for scheduling to avoid jumps backward/forward.</p>
<dl class="section user"><dt>Complexity\n O(1) - thin wrapper over system clock query</dt><dd></dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reentrant with no shared mutable state</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Backed by CLOCK_MONOTONIC or platform equivalent </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Value wraps after ~292 years; handle int64_t overflow in long-running apps</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf" title="Socket_get_monotonic_ms - Get current monotonic time in milliseconds.">Socket_get_monotonic_ms()</a> core implementation </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8bb049b5716726216dec25cd2dfa2380" title="Compute elapsed monotonic time since provided start timestamp.">socketreconnect_elapsed_ms()</a> for computing durations </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketReconnect-private_8h_source.html#l00464">464</a> of file <a class="el" href="SocketReconnect-private_8h_source.html">SocketReconnect-private.h</a>.</p>

<p class="reference">References <a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketReconnect-private_8h_source.html#l00507">socketreconnect_elapsed_ms()</a>.</p>

</div>
</div>
<a id="ga4bc781f13408c70bfe9d28148ac87212" name="ga4bc781f13408c70bfe9d28148ac87212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc781f13408c70bfe9d28148ac87212">&#9670;&#160;</a></span>SocketReconnect_policy_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_policy_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> *&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a <a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> with safe, production-recommended default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">policy</td><td>Pointer to structure to initialize (overwritten)</td></tr>
  </table>
  </dd>
</dl>
<p>Sets balanced defaults suitable for most TCP services:</p><ul>
<li>Conservative backoff to avoid overload</li>
<li>Circuit breaker to prevent storms</li>
<li>Health checks for proactive failure detection</li>
</ul>
<h2><a class="anchor" id="autotoc_md566"></a>
Defaults Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Setting   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Rationale    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_delay_ms   </td><td class="markdownTableBodyNone">100   </td><td class="markdownTableBodyNone">Quick first retry without overwhelming    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_delay_ms   </td><td class="markdownTableBodyNone">30000   </td><td class="markdownTableBodyNone">30s cap prevents long hangs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">multiplier   </td><td class="markdownTableBodyNone">2.0   </td><td class="markdownTableBodyNone">Standard exponential growth    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">jitter   </td><td class="markdownTableBodyNone">0.25   </td><td class="markdownTableBodyNone">25% randomization avoids herd    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_attempts   </td><td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">Limit retries to prevent infinite loops    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">circuit_failure_threshold   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Quick detection of outages    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">circuit_reset_timeout_ms   </td><td class="markdownTableBodyNone">60000   </td><td class="markdownTableBodyNone">1min cooldown before probe    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">health_check_interval_ms   </td><td class="markdownTableBodyNone">30000   </td><td class="markdownTableBodyNone">Check every 30s, low overhead    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">health_check_timeout_ms   </td><td class="markdownTableBodyNone">5000   </td><td class="markdownTableBodyNone">5s max to avoid blocking   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md567"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__connection__mgmt.html#structSocketReconnect__Policy__T">SocketReconnect_Policy_T</a> policy;</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga4bc781f13408c70bfe9d28148ac87212">SocketReconnect_policy_defaults</a>(&amp;policy);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Optional tweaks</span></div>
<div class="line">policy.<a class="code hl_variable" href="group__connection__mgmt.html#abf740738ffd922747329556ebd6052ca">initial_delay_ms</a> = 200;  <span class="comment">// Slower start for busy servers</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(host, port, &amp;policy, NULL,</div>
<div class="line">NULL);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>void (populates policy in place) </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no side effects</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - simple assignment</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always use this before custom modifications to ensure valid base </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Modifying after <a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> requires new instance </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#structSocketReconnect__Policy__T" title="Configuration structure defining backoff policy, circuit breaker thresholds, and health check paramet...">SocketReconnect_Policy_T</a> Full field documentation </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> Apply initialized policy </dd></dl>

</div>
</div>
<a id="gaa2db0dea41db5bb5a7efeec947323da8" name="gaa2db0dea41db5bb5a7efeec947323da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2db0dea41db5bb5a7efeec947323da8">&#9670;&#160;</a></span>SocketReconnect_pollfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_pollfd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve file descriptor for event loop integration (poll/epoll/kqueue/select). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid FD (&gt;=0) during CONNECTING/CONNECTED states for polling read/write events, -1 otherwise (no polling needed)</dd></dl>
<p>Provides the underlying socket file descriptor for multiplexing with other FDs in event loops. Usage:</p><ul>
<li>During CONNECTING: Poll for write (connect completion) or error</li>
<li>During CONNECTED: Poll for read (data available) or write (send buffer ready)</li>
<li>Other states: -1 (no FD to poll; use next_timeout_ms() for timers)</li>
</ul>
<p>Always pair with <a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538" title="Process I/O events from poll loop.">SocketReconnect_process()</a> when events occur on this FD. FD changes on reconnect (new socket created); re-add to epoll etc. after state change callbacks.</p>
<h2><a class="anchor" id="autotoc_md560"></a>
Event Loop Integration Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Single instance loop example</span></div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(...);</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a>(conn);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    <span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8">SocketReconnect_pollfd</a>(conn);</div>
<div class="line">    <span class="keywordtype">int</span> timeout = <a class="code hl_function" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd">SocketReconnect_next_timeout_ms</a>(conn);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Poll setup (pseudocode)</span></div>
<div class="line">    <span class="keywordflow">if</span> (fd &gt;= 0) poll_add(fd, POLLIN | POLLOUT | POLLERR | POLLHUP);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> ready = poll_events(timeout);  <span class="comment">// Implement poll loop</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (fd &gt;= 0 &amp;&amp; event_on_fd(ready)) {</div>
<div class="line">        <a class="code hl_function" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538">SocketReconnect_process</a>(conn);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a>(conn);  <span class="comment">// Advance timers</span></div>
<div class="line">}</div>
<div class="ttc" id="aconnection__pool_8c_html_af1f449cc09f8d36befcce07bc38c29c0"><div class="ttname"><a href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a></div><div class="ttdeci">static volatile int running</div><div class="ttdef"><b>Definition</b> <a href="connection__pool_8c_source.html#l00029">connection_pool.c:29</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga8dd2c1fe7147188da2be29f7623d2822"><div class="ttname"><a href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a></div><div class="ttdeci">void SocketReconnect_tick(SocketReconnect_T conn)</div><div class="ttdoc">Advance timers and perform periodic maintenance for state transitions and checks.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gaf5bf725fe34ae1de58a3ee05fbe270fd"><div class="ttname"><a href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd">SocketReconnect_next_timeout_ms</a></div><div class="ttdeci">int SocketReconnect_next_timeout_ms(SocketReconnect_T conn)</div><div class="ttdoc">Calculate milliseconds until next timer event or action.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n No - FD may change concurrently if multi-threaded (avoid)</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1)</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>FD valid only while returned &gt;=0; do not close or modify directly </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In epoll/kqueue, use edge-triggered mode carefully; level-triggered safer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538" title="Process I/O events from poll loop.">SocketReconnect_process()</a> Process events on this FD </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd" title="Calculate milliseconds until next timer event or action.">SocketReconnect_next_timeout_ms()</a> Timer integration </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822" title="Advance timers and perform periodic maintenance for state transitions and checks.">SocketReconnect_tick()</a> Periodic timer advancement </dd>
<dd>
<a class="el" href="SocketPoll_8h.html" title="Cross-platform high-level interface for monitoring multiple sockets for I/O events.">poll/SocketPoll.h</a> For high-performance multiplexing </dd></dl>

</div>
</div>
<a id="ga4ca4375d521b1eddcc4cf3f75fe3b538" name="ga4ca4375d521b1eddcc4cf3f75fe3b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca4375d521b1eddcc4cf3f75fe3b538">&#9670;&#160;</a></span>SocketReconnect_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process I/O events from poll loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<p>Call when <a class="el" href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8" title="Retrieve file descriptor for event loop integration (poll/epoll/kqueue/select).">SocketReconnect_pollfd()</a> becomes readable/writable. Handles connection completion, detects disconnection, etc. </p>

</div>
</div>
<a id="ga92485113993efb3a1302bbcb8f57a908" name="ga92485113993efb3a1302bbcb8f57a908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92485113993efb3a1302bbcb8f57a908">&#9670;&#160;</a></span>SocketReconnect_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketReconnect_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data from the reconnection-managed connection, auto-reconnecting on close or errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to receive data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum bytes to receive into buf (must &gt;0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes received (&gt;0), 0 on EOF/disconnect (triggers reconnect), -1 on error</dd></dl>
<p>Symmetric to <a class="el" href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee" title="Send data over the reconnection-managed connection with automatic retry on transient errors.">SocketReconnect_send()</a>: Provides transparent recv with auto-recovery. Behavior:</p><ul>
<li>If CONNECTED: Delegates to <a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> on underlying socket</li>
<li>If not connected: Returns 0 immediately (would block)</li>
<li>On recv error, EOF (0 bytes), or disconnect: Triggers reconnection, returns 0</li>
<li>Partial receives possible; loop until 0 for full messages</li>
</ul>
<p>TCP ensures ordered delivery when connected; 0 indicates clean close or abrupt disconnect.</p>
<h2><a class="anchor" id="autotoc_md571"></a>
Error Handling</h2>
<ul>
<li>Return 0: EOF or error triggering reconnect (check state after)</li>
<li>errno=EAGAIN: Would block (non-blocking mode); try again later</li>
<li>Other errnos from underlying recv propagated</li>
</ul>
<h2><a class="anchor" id="autotoc_md572"></a>
Usage Example - Transparent Recv Loop</h2>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a> &amp;&amp; <a class="code hl_function" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de">SocketReconnect_isconnected</a>(conn)) {</div>
<div class="line">    ssize_t rcvd = <a class="code hl_function" href="group__connection__mgmt.html#ga92485113993efb3a1302bbcb8f57a908">SocketReconnect_recv</a>(conn, buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line">    <span class="keywordflow">if</span> (rcvd &gt; 0) {</div>
<div class="line">        <span class="comment">// Process data</span></div>
<div class="line">        process_data(buf, rcvd);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rcvd == 0) {</div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Connection closed, reconnecting...&quot;</span>);</div>
<div class="line">        <span class="comment">// Auto-reconnect happens</span></div>
<div class="line">        <span class="keywordflow">break</span>;  <span class="comment">// Or continue to wait</span></div>
<div class="line">    } <span class="keywordflow">else</span> {  <span class="comment">// -1</span></div>
<div class="line">        <span class="keywordflow">if</span> (errno != EAGAIN) {</div>
<div class="line">            <span class="comment">// Handle error</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__connection__mgmt_html_ga92485113993efb3a1302bbcb8f57a908"><div class="ttname"><a href="group__connection__mgmt.html#ga92485113993efb3a1302bbcb8f57a908">SocketReconnect_recv</a></div><div class="ttdeci">ssize_t SocketReconnect_recv(SocketReconnect_T conn, void *buf, size_t len)</div><div class="ttdoc">Receive data from the reconnection-managed connection, auto-reconnecting on close or errors.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md573"></a>
Performance Notes</h2>
<ul>
<li>For high-throughput: Use recvv() variants via direct socket access</li>
<li>Buffering: No internal queue; data lost on disconnect before recv</li>
<li>Non-blocking: Safe in event loops; returns EAGAIN if no data</li>
</ul>
<dl class="section user"><dt>Thread Safety\n No - may trigger state changes</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(len) - underlying recv syscall</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles partial reads; application must loop for complete messages </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Recv in non-connected state wastes CPU; check isconnected() first </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee" title="Send data over the reconnection-managed connection with automatic retry on transient errors.">SocketReconnect_send()</a> Send counterpart </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5" title="Get the underlying Socket_T when connected.">SocketReconnect_socket()</a> For recvv, peek, etc. </dd>
<dd>
<a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> Underlying primitive </dd></dl>

</div>
</div>
<a id="gace6fc797f7fe9c6cd3319f540db4b672" name="gace6fc797f7fe9c6cd3319f540db4b672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace6fc797f7fe9c6cd3319f540db4b672">&#9670;&#160;</a></span>SocketReconnect_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset reconnection statistics and state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Clears attempt counter, consecutive failures, and circuit breaker state. </dd>
<dd>
Does not disconnect if connected. Use after external recovery. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> for initiating reconnection. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> for current state. </dd></dl>

</div>
</div>
<a id="gae1f6cbe69ac37f9bae1efccfe98538ee" name="gae1f6cbe69ac37f9bae1efccfe98538ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f6cbe69ac37f9bae1efccfe98538ee">&#9670;&#160;</a></span>SocketReconnect_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketReconnect_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data over the reconnection-managed connection with automatic retry on transient errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes from buf to send (0 valid, no-op)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (&gt;0 success), 0 if not connected (DISCONNECTED/BACKOFF/CIRCUIT_OPEN), -1 on error</dd></dl>
<p>Convenience wrapper providing transparent I/O over the managed connection. Behavior:</p><ul>
<li>If CONNECTED: Delegates to <a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> on underlying socket</li>
<li>If not connected: Returns 0 immediately (no blocking)</li>
<li>On send error or disconnection: Triggers reconnect logic, sets errno to ENOTCONN, returns -1</li>
<li>Partial sends possible (like Socket_send); caller must handle retries if needed</li>
</ul>
<p>Does not buffer unsent data; for reliability use higher-level protocols (TCP ensures delivery if connected).</p>
<h2><a class="anchor" id="autotoc_md568"></a>
Error Handling</h2>
<ul>
<li>errno=ENOTCONN: Not connected or lost connection (reconnect queued)</li>
<li>errno=ECONNRESET/EPIPE: Peer closed, triggers reconnect</li>
<li>Other errnos propagated from underlying socket</li>
</ul>
<h2><a class="anchor" id="autotoc_md569"></a>
Usage Example - Transparent Send</h2>
<div class="fragment"><div class="line"><span class="comment">// Assume conn connected</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="stringliteral">&quot;Hello Server&quot;</span>;</div>
<div class="line">ssize_t sent = <a class="code hl_function" href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee">SocketReconnect_send</a>(conn, msg, strlen(msg));</div>
<div class="line"><span class="keywordflow">if</span> (sent &lt; 0) {</div>
<div class="line">    <span class="keywordflow">if</span> (errno == ENOTCONN) {</div>
<div class="line">        <span class="comment">// Reconnect will happen automatically</span></div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;Send failed, reconnecting...&quot;</span>);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Handle other errors</span></div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// sent bytes transmitted or queued in TCP</span></div>
<div class="line">}</div>
<div class="ttc" id="aSocketUtil_8h_html_ae560ccd4aef66d44e8ecbd256844059c"><div class="ttname"><a href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_WARN_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00544">SocketUtil.h:544</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gae1f6cbe69ac37f9bae1efccfe98538ee"><div class="ttname"><a href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee">SocketReconnect_send</a></div><div class="ttdeci">ssize_t SocketReconnect_send(SocketReconnect_T conn, const void *buf, size_t len)</div><div class="ttdoc">Send data over the reconnection-managed connection with automatic retry on transient errors.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md570"></a>
When to Use vs Direct Socket</h2>
<ul>
<li>Use this for simple apps wanting auto-reconnect without event loop</li>
<li>For performance/control: Get socket with <a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5" title="Get the underlying Socket_T when connected.">SocketReconnect_socket()</a> and use <a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a" title="Scatter/gather send (writev wrapper).">Socket_sendv()</a> etc.</li>
<li>Buffering? Use SocketPool or application-level queues</li>
</ul>
<dl class="section user"><dt>Thread Safety\n No - modifies internal state</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(len) - underlying send syscall</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>SIGPIPE handled internally (no signal sent) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not for large data; consider <a class="el" href="group__core__io.html#gad1003c289820587894dbfcad9b567c43" title="Zero-copy file-to-socket transfer.">Socket_sendfile()</a> or chunking for big transfers </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga92485113993efb3a1302bbcb8f57a908" title="Receive data from the reconnection-managed connection, auto-reconnecting on close or errors.">SocketReconnect_recv()</a> Counterpart receive wrapper </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga4c91b5c376059d9c35d2623cbc6bd7b5" title="Get the underlying Socket_T when connected.">SocketReconnect_socket()</a> Direct access for advanced I/O </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> Underlying primitive </dd></dl>

</div>
</div>
<a id="gacf257c08816a36a97c02b32e034c0ea0" name="gacf257c08816a36a97c02b32e034c0ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf257c08816a36a97c02b32e034c0ea0">&#9670;&#160;</a></span>SocketReconnect_set_health_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_set_health_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3">SocketReconnect_HealthCheck</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a custom health check callback for proactive connection validation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> to configure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>Custom health check function (NULL to revert to default)</td></tr>
  </table>
  </dd>
</dl>
<p>Overrides the default health check behavior used during CONNECTED state. The default check simply polls the socket for readability within the configured timeout to detect dead peers. Custom checks can perform application-specific validation (e.g., send ping, check latency).</p>
<p>Changes take effect on next health check interval (no immediate invocation). If health checks disabled (interval=0), this has no effect.</p>
<h2><a class="anchor" id="autotoc_md564"></a>
Default vs Custom</h2>
<ul>
<li><b>Default</b>: Socket_poll for POLLIN within timeout_ms (lightweight, detects closes)</li>
<li><b>Custom</b>: Caller-defined; must return 1=healthy, 0=unhealthy quickly</li>
</ul>
<h2><a class="anchor" id="autotoc_md565"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Set custom check after creation</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0">SocketReconnect_set_health_check</a>(conn, my_app_ping_check);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or revert to default</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gacf257c08816a36a97c02b32e034c0ea0">SocketReconnect_set_health_check</a>(conn, NULL);</div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n No - modifies instance configuration</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - simple assignment</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callback userdata is from creation (not set here); for per-check data use conn context </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Custom checks blocking &gt; timeout_ms will hang tick()/process(); always respect limit </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3" title="Custom health check callback to verify connection liveness beyond basic connectivity.">SocketReconnect_HealthCheck</a> Callback type definition and requirements </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#aaa80956d1e58e84adfab7063e1936f95" title="Interval between health checks when CONNECTED (default: 30000ms / 30s). 0 disables health checks enti...">SocketReconnect_Policy_T::health_check_interval_ms</a> Enable/disable checks </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ade4054b2276dfc3c6b06a4b759241208" title="Maximum time a health check may block (default: 5000ms / 5s). Custom health callbacks must respect th...">SocketReconnect_Policy_T::health_check_timeout_ms</a> Set timeout limit </dd></dl>

</div>
</div>
<a id="gab2c4eeb92b2367fd5dd731bcbea4acf2" name="gab2c4eeb92b2367fd5dd731bcbea4acf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c4eeb92b2367fd5dd731bcbea4acf2">&#9670;&#160;</a></span>SocketReconnect_set_session_resumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_set_session_resumption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable TLS session resumption for faster reconnects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>1 to enable session caching, 0 to disable</td></tr>
  </table>
  </dd>
</dl>
<p>When enabled, successful TLS sessions are saved and restored on reconnect attempts, enabling abbreviated handshakes (0-RTT for TLS 1.3). This significantly reduces reconnection latency.</p>
<dl class="section note"><dt>Note</dt><dd>Enabled by default when TLS is configured </dd>
<dd>
Session data stored internally; cleared on disable_tls or free </dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__security.html#ga315ccceb9cb5b74d8b90f1439ce57344" title="Check if TLS session was resumed.">SocketTLS_is_session_reused()</a> to check if resumption worked </dd></dl>

</div>
</div>
<a id="gaba120af42ef94401078aacf5b258145b" name="gaba120af42ef94401078aacf5b258145b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba120af42ef94401078aacf5b258145b">&#9670;&#160;</a></span>SocketReconnect_set_tls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_set_tls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure TLS for reconnecting connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>TLS context (caller retains ownership; must outlive conn) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hostname</td><td>SNI hostname for certificate verification (copied)</td></tr>
  </table>
  </dd>
</dl>
<p>Enables TLS on all future connections made by this reconnection instance. The TLS context is NOT owned by SocketReconnect - caller must ensure it remains valid for the lifetime of the reconnection instance.</p>
<p>After TCP connect completes, TLS handshake is performed automatically. The hostname is used for:</p><ul>
<li>SNI (Server Name Indication) extension per RFC 6066</li>
<li>Certificate hostname verification via X509_check_host()</li>
</ul>
<h2><a class="anchor" id="autotoc_md574"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a> ctx = <a class="code hl_function" href="group__security.html#ga7fe51da14439d768bdf72f4ed8fbb022">SocketTLSContext_new_client</a>(NULL);</div>
<div class="line"><a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(<span class="stringliteral">&quot;api.example.com&quot;</span>, 443,</div>
<div class="line">                                              NULL, NULL, NULL);</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b">SocketReconnect_set_tls</a>(conn, ctx, <span class="stringliteral">&quot;api.example.com&quot;</span>);</div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401">SocketReconnect_connect</a>(conn);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// TLS handshake happens automatically after TCP connect</span></div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de">SocketReconnect_isconnected</a>(conn)) {</div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a>(conn);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now using encrypted connection</span></div>
<div class="line"><a class="code hl_function" href="group__connection__mgmt.html#gae1f6cbe69ac37f9bae1efccfe98538ee">SocketReconnect_send</a>(conn, data, len);  <span class="comment">// Uses SocketTLS_send internally</span></div>
<div class="ttc" id="agroup__connection__mgmt_html_gaba120af42ef94401078aacf5b258145b"><div class="ttname"><a href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b">SocketReconnect_set_tls</a></div><div class="ttdeci">void SocketReconnect_set_tls(SocketReconnect_T conn, SocketTLSContext_T ctx, const char *hostname)</div><div class="ttdoc">Configure TLS for reconnecting connections.</div></div>
<div class="ttc" id="agroup__security_html_ga7fe51da14439d768bdf72f4ed8fbb022"><div class="ttname"><a href="group__security.html#ga7fe51da14439d768bdf72f4ed8fbb022">SocketTLSContext_new_client</a></div><div class="ttdeci">SocketTLSContext_T SocketTLSContext_new_client(const char *ca_file)</div><div class="ttdoc">Create client TLS context.</div></div>
<div class="ttc" id="agroup__security_html_structSocketTLSContext__T"><div class="ttname"><a href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a></div><div class="ttdoc">TLS context structure for managing OpenSSL SSL_CTX with secure defaults, certificates,...</div><div class="ttdef"><b>Definition</b> <a href="SocketTLS-private_8h_source.html#l00619">SocketTLS-private.h:620</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Call before <a class="el" href="group__connection__mgmt.html#ga2669844f3ad8a19649f2bc204eee8401" title="Initiate or queue a connection attempt according to current state and policy.">SocketReconnect_connect()</a> for first connection </dd>
<dd>
Can be called while disconnected to change TLS settings </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling while connected has no effect until next reconnect </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - must be called from same thread as other operations</dt><dd></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketReconnect_Failed</td><td>if hostname is NULL or too long</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gae5943a7adc872f2a89da06c7cf19300d" title="Disable TLS for future connections.">SocketReconnect_disable_tls()</a> to remove TLS configuration </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga3b2487b042967310b7df99ebab41e105" title="Check if TLS is configured for this connection.">SocketReconnect_tls_enabled()</a> to query TLS state </dd>
<dd>
<a class="el" href="group__security.html#ga7fe51da14439d768bdf72f4ed8fbb022" title="Create client TLS context.">SocketTLSContext_new_client()</a> for context creation </dd></dl>

</div>
</div>
<a id="ga4c91b5c376059d9c35d2623cbc6bd7b5" name="ga4c91b5c376059d9c35d2623cbc6bd7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c91b5c376059d9c35d2623cbc6bd7b5">&#9670;&#160;</a></span>SocketReconnect_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketReconnect_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying Socket_T when connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Reconnection context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Connected socket, or NULL if not connected. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns the underlying socket only when in RECONNECT_CONNECTED state. </dd>
<dd>
Do not close or free the returned socket directly. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14" title="Query the current state of the reconnection instance.">SocketReconnect_state()</a> for connection state. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de" title="Check if reconnection is currently in connected state.">SocketReconnect_isconnected()</a> for boolean check. </dd></dl>

</div>
</div>
<a id="gac2a144f4c67fde49d88d0a53aa528c14" name="gac2a144f4c67fde49d88d0a53aa528c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a144f4c67fde49d88d0a53aa528c14">&#9670;&#160;</a></span>SocketReconnect_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> SocketReconnect_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current state of the reconnection instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current SocketReconnect_State (e.g., RECONNECT_CONNECTED) </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - but read-only, safe if no concurrent mutations</dt><dd></dd></dl>
<p>Provides snapshot of internal state machine for decision making or logging. States reflect connection status, backoff timers, and circuit breaker. Use in conditionals to gate operations (e.g., only send when CONNECTED).</p>
<h2><a class="anchor" id="autotoc_md559"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a> st = <a class="code hl_function" href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14">SocketReconnect_state</a>(conn);</div>
<div class="line"><span class="keywordflow">switch</span> (st) {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548adb2277c5ef340a4d2f2e3ed98525ebe1">RECONNECT_CONNECTED</a>:</div>
<div class="line">        <span class="comment">// Safe to send/recv</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="group__connection__mgmt.html#ggab0f7f9254ebc5d681f058d6b2c26f548a2bf78e833dbbbf5bc17e6098ba8d55db">RECONNECT_CIRCUIT_OPEN</a>:</div>
<div class="line">        <span class="comment">// Outage detected, alert</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// Wait or retry</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Log with name</span></div>
<div class="line"><a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;State: %s&quot;</span>, <a class="code hl_function" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4">SocketReconnect_state_name</a>(st));</div>
<div class="ttc" id="aSocketUtil_8h_html_a7853a630bcaead9d41536ccbfd598f6d"><div class="ttname"><a href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_DEBUG_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00536">SocketUtil.h:536</a></div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gac2a144f4c67fde49d88d0a53aa528c14"><div class="ttname"><a href="group__connection__mgmt.html#gac2a144f4c67fde49d88d0a53aa528c14">SocketReconnect_state</a></div><div class="ttdeci">SocketReconnect_State SocketReconnect_state(SocketReconnect_T conn)</div><div class="ttdoc">Query the current state of the reconnection instance.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(1)</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>State may change immediately after call due to async nature; check in event handlers </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga490043a4bfaba8214f5d10a3c7b956de" title="Check if reconnection is currently in connected state.">SocketReconnect_isconnected()</a> Convenience for CONNECTED check </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0678924e4ecd0f43e1385d2e0b5354d4" title="Get human-readable name for a reconnection state.">SocketReconnect_state_name()</a> String representation for logs </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga0d4cc030dc9989344d20a170b6410220" title="Callback invoked on reconnection state transitions for monitoring and custom logic.">SocketReconnect_Callback()</a> Asynchronous state notifications </dd></dl>

</div>
</div>
<a id="ga0678924e4ecd0f43e1385d2e0b5354d4" name="ga0678924e4ecd0f43e1385d2e0b5354d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0678924e4ecd0f43e1385d2e0b5354d4">&#9670;&#160;</a></span>SocketReconnect_state_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketReconnect_state_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__connection__mgmt.html#gab0f7f9254ebc5d681f058d6b2c26f548">SocketReconnect_State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get human-readable name for a reconnection state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Reconnection state enum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Static string with state name </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>

</div>
</div>
<a id="ga8dd2c1fe7147188da2be29f7623d2822" name="ga8dd2c1fe7147188da2be29f7623d2822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd2c1fe7147188da2be29f7623d2822">&#9670;&#160;</a></span>SocketReconnect_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketReconnect_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance timers and perform periodic maintenance for state transitions and checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td><a class="el" href="group__reconnect__private.html#structSocketReconnect__T" title="Opaque internal context for reconnecting socket management.">SocketReconnect_T</a> to tick</td></tr>
  </table>
  </dd>
</dl>
<p>Essential function for timer-driven operations:</p><ul>
<li>Advances backoff timers (may trigger CONNECTING from BACKOFF)</li>
<li>Checks circuit reset timeout (may allow new attempts)</li>
<li>Performs health checks if interval elapsed (in CONNECTED)</li>
<li>Detects timeouts for ongoing connects</li>
<li>No-op if no timers pending</li>
</ul>
<p>Call this:</p><ul>
<li>Periodically in main loop (e.g., every 100ms or after poll timeout)</li>
<li>Immediately after <a class="el" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd" title="Calculate milliseconds until next timer event or action.">SocketReconnect_next_timeout_ms()</a> returns &lt;=0</li>
<li>Does not block; quick execution unless health check active</li>
</ul>
<h2><a class="anchor" id="autotoc_md561"></a>
Integration Patterns</h2>
<h3><a class="anchor" id="autotoc_md562"></a>
With Event Loop</h3>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    <span class="keywordtype">int</span> timeout = <a class="code hl_function" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd">SocketReconnect_next_timeout_ms</a>(conn);</div>
<div class="line">    timeout = MIN(timeout, 100);  <span class="comment">// Cap for responsiveness</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Poll with timeout</span></div>
<div class="line">    poll_wait(timeout);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a>(conn);  <span class="comment">// Handle expired timers</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__connection__mgmt.html#gaa2db0dea41db5bb5a7efeec947323da8">SocketReconnect_pollfd</a>(conn);</div>
<div class="line">    <span class="keywordflow">if</span> (event_on_fd(fd)) {</div>
<div class="line">        <a class="code hl_function" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538">SocketReconnect_process</a>(conn);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md563"></a>
Standalone Periodic Call</h3>
<div class="fragment"><div class="line"><span class="comment">// In timer thread or main loop</span></div>
<div class="line"><span class="keyword">static</span> int64_t last_tick = 0;</div>
<div class="line">int64_t now = <a class="code hl_function" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms</a>();</div>
<div class="line"><span class="keywordflow">if</span> (now - last_tick &gt;= 50) {  <span class="comment">// 50ms granularity</span></div>
<div class="line">    <a class="code hl_function" href="group__connection__mgmt.html#ga8dd2c1fe7147188da2be29f7623d2822">SocketReconnect_tick</a>(conn);</div>
<div class="line">    last_tick = now;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__foundation_html_ga264bfa9d1cf07aa22446a4df6c4936bf"><div class="ttname"><a href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms</a></div><div class="ttdeci">int64_t Socket_get_monotonic_ms(void)</div><div class="ttdoc">Socket_get_monotonic_ms - Get current monotonic time in milliseconds.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n No - modifies timers and may change state</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average; O(health check time) if check runs</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf" title="Socket_get_monotonic_ms - Get current monotonic time in milliseconds.">Socket_get_monotonic_ms()</a> internally for precision </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Infrequent calls (&gt; policy intervals) may delay detections; call regularly </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaf5bf725fe34ae1de58a3ee05fbe270fd" title="Calculate milliseconds until next timer event or action.">SocketReconnect_next_timeout_ms()</a> Determine optimal call frequency </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#ga4ca4375d521b1eddcc4cf3f75fe3b538" title="Process I/O events from poll loop.">SocketReconnect_process()</a> Handle FD events (complement) </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gae24b576ed367f734f434ef30ad8386c3" title="Custom health check callback to verify connection liveness beyond basic connectivity.">SocketReconnect_HealthCheck</a> Custom check during tick </dd></dl>

</div>
</div>
<a id="ga3b2487b042967310b7df99ebab41e105" name="ga3b2487b042967310b7df99ebab41e105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2487b042967310b7df99ebab41e105">&#9670;&#160;</a></span>SocketReconnect_tls_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketReconnect_tls_enabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if TLS is configured for this connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if TLS is configured (context set), 0 otherwise </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads only</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaba120af42ef94401078aacf5b258145b" title="Configure TLS for reconnecting connections.">SocketReconnect_set_tls()</a> to configure TLS </dd></dl>

</div>
</div>
<a id="ga8b84be023c19dc3f870a4c14250aceb9" name="ga8b84be023c19dc3f870a4c14250aceb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b84be023c19dc3f870a4c14250aceb9">&#9670;&#160;</a></span>SocketReconnect_tls_handshake_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__security.html#gad092160c037d01929df1bb8d5b75b43c">TLSHandshakeState</a> SocketReconnect_tls_handshake_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current TLS handshake state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn</td><td>Reconnection context</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the current TLS handshake progress. Useful for debugging and advanced event loop integration.</p>
<dl class="section return"><dt>Returns</dt><dd>Current TLSHandshakeState, or TLS_HANDSHAKE_NOT_STARTED if TLS not enabled or no handshake in progress </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads only</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__security.html#gad092160c037d01929df1bb8d5b75b43c" title="TLS handshake progress states for non-blocking and event-driven operations.">TLSHandshakeState</a> for state descriptions </dd></dl>

</div>
</div>
<a id="gae1541da7f1233af52ca75bb932074851" name="gae1541da7f1233af52ca75bb932074851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1541da7f1233af52ca75bb932074851">&#9670;&#160;</a></span>update_existing_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void update_existing_slot </td>
          <td>(</td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update existing connection slot activity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> slot to update. </td></tr>
    <tr><td class="paramname">now</td><td>Current timestamp.</td></tr>
  </table>
  </dd>
</dl>
<p>Updates last activity timestamp for idle timeout tracking.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga21b17f01e3036b53fed194c6b3c0b95f" title="Retrieve Connection_T wrapper for a socket in the pool.">SocketPool_get()</a> for automatic updates. </dd></dl>

</div>
</div>
<a id="ga93e4d3464b3def2864e59849788aaf11" name="ga93e4d3464b3def2864e59849788aaf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e4d3464b3def2864e59849788aaf11">&#9670;&#160;</a></span>validate_saved_session()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void validate_saved_session </td>
          <td>(</td>
          <td class="paramtype">Connection_T&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate TLS session for reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> with potential saved session. </td></tr>
    <tr><td class="paramname">now</td><td>Current timestamp.</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if saved TLS session is still valid for reuse.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494" title="Add a connected socket to the pool, creating a Connection_T wrapper.">SocketPool_add()</a> for session saving. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaeea0045572d9693e0579e265d0e00981" name="gaeea0045572d9693e0579e265d0e00981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeea0045572d9693e0579e265d0e00981">&#9670;&#160;</a></span>SocketPool_DetailedException</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketPool_DetailedException</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread-local exception for detailed error messages. </p>
<p>Extern declaration - actual definition in SocketPool-core.c. Uses shared socket_error_buf for consistent error formatting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gaf1430b907c84491b37ab7b18f7fd75a4" title="Raise exception with detailed error message.">RAISE_POOL_ERROR</a> macro. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#aad11dd8cef83792df92437f8d7ae3991">socket_error_buf</a> in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a>. </dd>
<dd>
<a class="el" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36" title="Pool operation failure.">SocketPool_Failed</a> exception type. </dd></dl>

</div>
</div>
<a id="gadba094d10381f1646de6a3e1e2bd0c36" name="gadba094d10381f1646de6a3e1e2bd0c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba094d10381f1646de6a3e1e2bd0c36">&#9670;&#160;</a></span>SocketPool_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketPool_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pool operation failure. </p>
<p>Category: RESOURCE or APPLICATION Retryable: Depends on specific operation</p>
<p>Raised for:</p><ul>
<li>Pool capacity exhaustion (RESOURCE, retryable after drain)</li>
<li>Invalid parameters (APPLICATION, not retryable)</li>
<li>Memory allocation failures (RESOURCE, not retryable)</li>
<li><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> validation failures (NETWORK, retryable)</li>
<li>Socket operation failures (NETWORK, retryable)</li>
<li>DNS resolution failures (NETWORK, retryable)</li>
</ul>
<p>Check errno or context for specific failure reason. Thread-safe: Uses thread-local error buffers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#gadba094d10381f1646de6a3e1e2bd0c36" title="Pool operation failure.">SocketPool_Failed</a> exception type. </dd>
<dd>
error-handling for exception handling patterns. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#aad11dd8cef83792df92437f8d7ae3991">socket_error_buf</a> in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> for error message formatting. </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga3dc308919d4ccef64b7674cae246d9c0" name="ga3dc308919d4ccef64b7674cae246d9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dc308919d4ccef64b7674cae246d9c0">&#9670;&#160;</a></span>SocketReconnect_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketReconnect_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception type for errors in the reconnection module. </p>
<p>This exception is raised for configuration errors, resource allocation failures, or internal state inconsistencies. Common triggers include:</p><ul>
<li>Invalid policy values (negative delays, multiplier &lt;=1.0, jitter &lt;0 or &gt;1)</li>
<li>Arena allocation failure during initialization</li>
<li>Invalid host/port parameters</li>
<li>Unrecoverable state machine errors (rare)</li>
</ul>
<h2><a class="anchor" id="autotoc_md541"></a>
Handling Pattern</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="group__reconnect__private.html#structSocketReconnect__T">SocketReconnect_T</a> conn = <a class="code hl_function" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082">SocketReconnect_new</a>(host, port, &amp;policy, NULL,</div>
<div class="line">NULL);</div>
<div class="line">    <span class="comment">// Use conn...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__connection__mgmt.html#ga3dc308919d4ccef64b7674cae246d9c0">SocketReconnect_Failed</a>) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Reconnect failed: %s\n&quot;</span>,</div>
<div class="line">Except_message(&amp;<a class="code hl_variable" href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a>));</div>
<div class="line">    <span class="comment">// Log or retry with different params</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga3d38c6361ecf1c4873bbcb2de8a50874"><div class="ttname"><a href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a></div><div class="ttdeci">Except_Frame * Except_stack</div><div class="ttdoc">Thread-local exception stack for TRY/EXCEPT/FINALLY blocks.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Always check <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a> or Except_message() for detailed error information </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__connection__mgmt.html#ga2064741bf60283ac3315823128fa2082" title="Create a new SocketReconnect_T instance configured for a specific host and port.">SocketReconnect_new()</a> Primary raise point </dd>
<dd>
<a class="el" href="Except_8h.html" title="Structured exception handling for C with TRY/EXCEPT/FINALLY blocks.">core/Except.h</a> Base exception handling framework </dd>
<dd>
<a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a> For system error details if applicable </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Custom footer for Tetsuo Pulse -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="footer" style="text-align: center; width: 100%;">
       <a href="https://tetsuocorp.com" target="_blank" rel="noopener">Tetsuo Corp</a>
    </li>
  </ul>
</div>
</body>
</html>
