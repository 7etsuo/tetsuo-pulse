<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Socket Library: SocketDNS.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('SocketDNS_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SocketDNS.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Except_8h_source.html">core/Except.h</a>&quot;</code><br />
<code>#include &lt;netdb.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
</div>
<p><a href="SocketDNS_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0acb682b8260ab1c60b918599864e2e5" id="r_a0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;SocketDNS_T</td></tr>
<tr class="memdesc:a0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async DNS Resolution.  <br /></td></tr>
<tr class="separator:a0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ba864e1a3353563283aa17b57abd88" id="r_aa9ba864e1a3353563283aa17b57abd88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#aa9ba864e1a3353563283aa17b57abd88">Request_T</a>&#160;&#160;&#160;SocketDNS_Request_T</td></tr>
<tr class="separator:aa9ba864e1a3353563283aa17b57abd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24514489b0962fafe8414bfae95aa268" id="r_a24514489b0962fafe8414bfae95aa268"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structT.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a24514489b0962fafe8414bfae95aa268">T</a></td></tr>
<tr class="separator:a24514489b0962fafe8414bfae95aa268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9b1a79ca074827284111e500f8b22" id="r_abed9b1a79ca074827284111e500f8b22"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a></td></tr>
<tr class="separator:abed9b1a79ca074827284111e500f8b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b5779cfd95203ac45b76e5fccbfe20" id="r_af6b5779cfd95203ac45b76e5fccbfe20"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#af6b5779cfd95203ac45b76e5fccbfe20">SocketDNS_Callback</a>) (<a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req, struct addrinfo *result, int error, void *data)</td></tr>
<tr class="memdesc:af6b5779cfd95203ac45b76e5fccbfe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_Callback - Callback function for async DNS resolution @req: Request handle for this resolution.  <br /></td></tr>
<tr class="separator:af6b5779cfd95203ac45b76e5fccbfe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b71ee0fa3c022f0342dd1bf9d2d9c14" id="r_a2b71ee0fa3c022f0342dd1bf9d2d9c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structT.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a2b71ee0fa3c022f0342dd1bf9d2d9c14">SocketDNS_new</a> (void)</td></tr>
<tr class="memdesc:a2b71ee0fa3c022f0342dd1bf9d2d9c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_new - Create a new async DNS resolver Returns: New DNS resolver instance Raises: SocketDNS_Failed on initialization failure Thread-safe: Yes - returns new instance Creates a thread pool for DNS resolution.  <br /></td></tr>
<tr class="separator:a2b71ee0fa3c022f0342dd1bf9d2d9c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa225e09d741aebee12bf0b5ab61e3c" id="r_a5aa225e09d741aebee12bf0b5ab61e3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a5aa225e09d741aebee12bf0b5ab61e3c">SocketDNS_free</a> (<a class="el" href="structT.html">T</a> *dns)</td></tr>
<tr class="memdesc:a5aa225e09d741aebee12bf0b5ab61e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_free - Free a DNS resolver @dns: Pointer to resolver (will be set to NULL) Drains pending requests, signals worker threads to stop, and joins threads.  <br /></td></tr>
<tr class="separator:a5aa225e09d741aebee12bf0b5ab61e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da13a84fbce512f59c75d3cdf53a3f9" id="r_a3da13a84fbce512f59c75d3cdf53a3f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a3da13a84fbce512f59c75d3cdf53a3f9">SocketDNS_resolve</a> (<a class="el" href="structT.html">T</a> dns, const char *host, int port, <a class="el" href="SocketDNS_8h.html#af6b5779cfd95203ac45b76e5fccbfe20">SocketDNS_Callback</a> callback, void *data)</td></tr>
<tr class="memdesc:a3da13a84fbce512f59c75d3cdf53a3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_resolve - Start async DNS resolution @dns: DNS resolver instance @host: Hostname or IP address to resolve (NULL for wildcard bind with AI_PASSIVE) @port: Port number (0 if not needed) @callback: Completion callback (NULL for SocketPoll integration) @data: User data passed to callback Returns: Request handle (never NULL) Raises: SocketDNS_Failed on queue full or invalid parameters Thread-safe: Yes - protected by internal mutex Starts asynchronous DNS resolution.  <br /></td></tr>
<tr class="separator:a3da13a84fbce512f59c75d3cdf53a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a9f6d43d9a9044391e3d91a050e7bf" id="r_ab8a9f6d43d9a9044391e3d91a050e7bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#ab8a9f6d43d9a9044391e3d91a050e7bf">SocketDNS_cancel</a> (<a class="el" href="structT.html">T</a> dns, <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req)</td></tr>
<tr class="memdesc:ab8a9f6d43d9a9044391e3d91a050e7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_cancel - Cancel a pending DNS resolution @dns: DNS resolver instance @req: Request handle to cancel Thread-safe: Yes - protected by internal mutex Cancels a pending request.  <br /></td></tr>
<tr class="separator:ab8a9f6d43d9a9044391e3d91a050e7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc9c864dd199a69a6a3d186439219a0" id="r_a3dc9c864dd199a69a6a3d186439219a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a3dc9c864dd199a69a6a3d186439219a0">SocketDNS_getmaxpending</a> (<a class="el" href="structT.html">T</a> dns)</td></tr>
<tr class="memdesc:a3dc9c864dd199a69a6a3d186439219a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_getmaxpending - Get maximum pending request capacity @dns: DNS resolver instance Returns: Current pending request limit Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:a3dc9c864dd199a69a6a3d186439219a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb55dea32906adadb740f9bc554768c" id="r_aedb55dea32906adadb740f9bc554768c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#aedb55dea32906adadb740f9bc554768c">SocketDNS_setmaxpending</a> (<a class="el" href="structT.html">T</a> dns, size_t max_pending)</td></tr>
<tr class="memdesc:aedb55dea32906adadb740f9bc554768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_setmaxpending - Set maximum pending request capacity @dns: DNS resolver instance @max_pending: New pending request limit (0 allows no pending requests) Raises: SocketDNS_Failed if max_pending &lt; current queue depth Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:aedb55dea32906adadb740f9bc554768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138bb4cdede6de597d17450f19f4530c" id="r_a138bb4cdede6de597d17450f19f4530c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a138bb4cdede6de597d17450f19f4530c">SocketDNS_gettimeout</a> (<a class="el" href="structT.html">T</a> dns)</td></tr>
<tr class="memdesc:a138bb4cdede6de597d17450f19f4530c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_gettimeout - Get resolver request timeout in milliseconds @dns: DNS resolver instance Returns: Timeout in milliseconds (0 disables timeout) Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:a138bb4cdede6de597d17450f19f4530c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7742ae0f0a34ecc0188df415e88a3c79" id="r_a7742ae0f0a34ecc0188df415e88a3c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a7742ae0f0a34ecc0188df415e88a3c79">SocketDNS_settimeout</a> (<a class="el" href="structT.html">T</a> dns, int timeout_ms)</td></tr>
<tr class="memdesc:a7742ae0f0a34ecc0188df415e88a3c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_settimeout - Set resolver request timeout in milliseconds @dns: DNS resolver instance @timeout_ms: Timeout in milliseconds (0 disables timeout) Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:a7742ae0f0a34ecc0188df415e88a3c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bad005b6f546b3014c95735b5503020" id="r_a5bad005b6f546b3014c95735b5503020"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a5bad005b6f546b3014c95735b5503020">SocketDNS_pollfd</a> (<a class="el" href="structT.html">T</a> dns)</td></tr>
<tr class="memdesc:a5bad005b6f546b3014c95735b5503020"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_pollfd - Get pollable file descriptor for SocketPoll integration @dns: DNS resolver instance Returns: File descriptor ready for reading when requests complete Thread-safe: Yes - returns stable file descriptor Returns a file descriptor (pipe or eventfd) that becomes readable when DNS resolution requests complete.  <br /></td></tr>
<tr class="separator:a5bad005b6f546b3014c95735b5503020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6710a0d5f406255e39a6ab44fa7603" id="r_abd6710a0d5f406255e39a6ab44fa7603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#abd6710a0d5f406255e39a6ab44fa7603">SocketDNS_check</a> (<a class="el" href="structT.html">T</a> dns)</td></tr>
<tr class="memdesc:abd6710a0d5f406255e39a6ab44fa7603"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_check - Check for completed requests (non-blocking) @dns: DNS resolver instance Returns: Number of completed requests processed Thread-safe: Yes - safe to call from any thread Processes completed DNS resolution requests.  <br /></td></tr>
<tr class="separator:abd6710a0d5f406255e39a6ab44fa7603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf4ce3f4cc95b946d7a3418a74da3df" id="r_a9bf4ce3f4cc95b946d7a3418a74da3df"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a9bf4ce3f4cc95b946d7a3418a74da3df">SocketDNS_getresult</a> (<a class="el" href="structT.html">T</a> dns, <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req)</td></tr>
<tr class="memdesc:a9bf4ce3f4cc95b946d7a3418a74da3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handle Returns: Completed addrinfo result or NULL if pending/error/cancelled Thread-safe: Yes - protected by internal mutex Retrieves the result of a completed DNS resolution.  <br /></td></tr>
<tr class="separator:a9bf4ce3f4cc95b946d7a3418a74da3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e368f3eae045faa5d591d9279c9ce2e" id="r_a2e368f3eae045faa5d591d9279c9ce2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a2e368f3eae045faa5d591d9279c9ce2e">SocketDNS_geterror</a> (<a class="el" href="structT.html">T</a> dns, <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req)</td></tr>
<tr class="memdesc:a2e368f3eae045faa5d591d9279c9ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_geterror - Get error code for completed request @dns: DNS resolver instance @req: Request handle Returns: getaddrinfo() error code or 0 on success Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:a2e368f3eae045faa5d591d9279c9ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f34d74dafd3ea4c4c05dbd1844fa50" id="r_a28f34d74dafd3ea4c4c05dbd1844fa50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a28f34d74dafd3ea4c4c05dbd1844fa50">SocketDNS_request_settimeout</a> (<a class="el" href="structT.html">T</a> dns, <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req, int timeout_ms)</td></tr>
<tr class="memdesc:a28f34d74dafd3ea4c4c05dbd1844fa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_request_settimeout - Override timeout for specific request @dns: DNS resolver instance @req: Request handle @timeout_ms: Timeout in milliseconds (0 disables timeout for this request) Thread-safe: Yes.  <br /></td></tr>
<tr class="separator:a28f34d74dafd3ea4c4c05dbd1844fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5cb57084527d92a827b62b4adfcd94" id="r_a9b5cb57084527d92a827b62b4adfcd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a9b5cb57084527d92a827b62b4adfcd94">SocketDNS_create_completed_request</a> (<a class="el" href="structT.html">T</a> dns, struct addrinfo *result, int port)</td></tr>
<tr class="memdesc:a9b5cb57084527d92a827b62b4adfcd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketDNS_create_completed_request - Create a completed request from pre-resolved addrinfo @dns: DNS resolver instance.  <br /></td></tr>
<tr class="separator:a9b5cb57084527d92a827b62b4adfcd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a152c227261ddef33b34fb3a3578d8a5e" id="r_a152c227261ddef33b34fb3a3578d8a5e"><td class="memItemLeft" align="right" valign="top">Except_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html#a152c227261ddef33b34fb3a3578d8a5e">SocketDNS_Failed</a></td></tr>
<tr class="memdesc:a152c227261ddef33b34fb3a3578d8a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution operation failure.  <br /></td></tr>
<tr class="separator:a152c227261ddef33b34fb3a3578d8a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa9ba864e1a3353563283aa17b57abd88" name="aa9ba864e1a3353563283aa17b57abd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ba864e1a3353563283aa17b57abd88">&#9670;&#160;</a></span>Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;&#160;&#160;SocketDNS_Request_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00049">49</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<a id="a0acb682b8260ab1c60b918599864e2e5" name="a0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="structT.html">T</a>&#160;&#160;&#160;SocketDNS_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Async DNS Resolution. </p>
<p>Provides asynchronous DNS resolution using a thread pool to eliminate blocking getaddrinfo() calls that can take 30+ seconds during DNS failures. This addresses DoS vulnerabilities and enables truly non-blocking socket operations.</p>
<p>PLATFORM REQUIREMENTS:</p><ul>
<li>POSIX-compliant system (Linux, BSD, macOS, etc.)</li>
<li>POSIX threads (pthread) for thread pool</li>
<li>getaddrinfo() for DNS resolution (POSIX.1-2001)</li>
<li>NOT portable to Windows without Winsock adaptation</li>
</ul>
<p>Features:</p><ul>
<li>Thread pool-based async DNS resolution</li>
<li>Callback-based completion notification</li>
<li>SocketPoll integration for event-driven completion</li>
<li>Request cancellation support with explicit error reporting</li>
<li>Configurable per-resolver and per-request timeouts</li>
<li>Thread-safe implementation</li>
<li>Automatic request lifecycle management Usage Pattern (Callback-based): SocketDNS_T dns = <a class="el" href="SocketDNS_8h.html#a2b71ee0fa3c022f0342dd1bf9d2d9c14" title="SocketDNS_new - Create a new async DNS resolver Returns: New DNS resolver instance Raises: SocketDNS_...">SocketDNS_new()</a>; SocketDNS_resolve(dns, "example.com", 80, callback, user_data); // callback invoked when resolution completes Usage Pattern (SocketPoll integration): SocketDNS_T dns = <a class="el" href="SocketDNS_8h.html#a2b71ee0fa3c022f0342dd1bf9d2d9c14" title="SocketDNS_new - Create a new async DNS resolver Returns: New DNS resolver instance Raises: SocketDNS_...">SocketDNS_new()</a>; SocketPoll_T poll = SocketPoll_new(100); int dns_fd = SocketDNS_pollfd(dns); SocketPoll_add(poll, dns_fd, POLL_READ, dns); // In event loop: SocketDNS_check(dns) processes completed requests Error Handling:</li>
<li>SocketDNS_Failed: DNS resolution errors</li>
<li>Request handles remain valid until result retrieved or cancelled </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00046">46</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abed9b1a79ca074827284111e500f8b22" name="abed9b1a79ca074827284111e500f8b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed9b1a79ca074827284111e500f8b22">&#9670;&#160;</a></span>Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>* <a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00050">50</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<a id="af6b5779cfd95203ac45b76e5fccbfe20" name="af6b5779cfd95203ac45b76e5fccbfe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b5779cfd95203ac45b76e5fccbfe20">&#9670;&#160;</a></span>SocketDNS_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketDNS_Callback) (<a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> req, struct addrinfo *result, int error, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SocketDNS_Callback - Callback function for async DNS resolution @req: Request handle for this resolution. </p>
<dl class="section return"><dt>Returns</dt><dd>: Completed addrinfo result (NULL on error) @error: Error code from getaddrinfo() (0 on success) @data: User data passed to <a class="el" href="SocketDNS_8h.html#a3da13a84fbce512f59c75d3cdf53a3f9" title="SocketDNS_resolve - Start async DNS resolution @dns: DNS resolver instance @host: Hostname or IP addr...">SocketDNS_resolve()</a> Called when DNS resolution completes. If result is NULL, error contains the getaddrinfo() error code. The caller owns the result addrinfo structure and must call freeaddrinfo() when done. Thread-safe: Called from DNS worker thread, not application thread </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00066">66</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<a id="a24514489b0962fafe8414bfae95aa268" name="a24514489b0962fafe8414bfae95aa268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514489b0962fafe8414bfae95aa268">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structT.html">T</a>* <a class="el" href="structT.html">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00047">47</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab8a9f6d43d9a9044391e3d91a050e7bf" name="ab8a9f6d43d9a9044391e3d91a050e7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a9f6d43d9a9044391e3d91a050e7bf">&#9670;&#160;</a></span>SocketDNS_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_cancel - Cancel a pending DNS resolution @dns: DNS resolver instance @req: Request handle to cancel Thread-safe: Yes - protected by internal mutex Cancels a pending request. </p>
<p>If resolution has already completed, this has no effect. The request handle becomes invalid after cancellation. Callbacks will not be invoked for cancelled requests. </p>

</div>
</div>
<a id="abd6710a0d5f406255e39a6ab44fa7603" name="abd6710a0d5f406255e39a6ab44fa7603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6710a0d5f406255e39a6ab44fa7603">&#9670;&#160;</a></span>SocketDNS_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_check - Check for completed requests (non-blocking) @dns: DNS resolver instance Returns: Number of completed requests processed Thread-safe: Yes - safe to call from any thread Processes completed DNS resolution requests. </p>
<p>For requests submitted without callbacks, the caller must poll for completion and call this function to retrieve results via <a class="el" href="SocketDNS_8h.html#a9bf4ce3f4cc95b946d7a3418a74da3df" title="SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handl...">SocketDNS_getresult()</a>. Should be called when <a class="el" href="SocketDNS_8h.html#a5bad005b6f546b3014c95735b5503020" title="SocketDNS_pollfd - Get pollable file descriptor for SocketPoll integration @dns: DNS resolver instanc...">SocketDNS_pollfd()</a> becomes readable. </p>

</div>
</div>
<a id="a9b5cb57084527d92a827b62b4adfcd94" name="a9b5cb57084527d92a827b62b4adfcd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5cb57084527d92a827b62b4adfcd94">&#9670;&#160;</a></span>SocketDNS_create_completed_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> SocketDNS_create_completed_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_create_completed_request - Create a completed request from pre-resolved addrinfo @dns: DNS resolver instance. </p>
<dl class="section return"><dt>Returns</dt><dd>: Pre-resolved addrinfo result (caller transfers ownership) @port: Port number Returns: Request handle for completed request Raises: SocketDNS_Failed on allocation failure Thread-safe: Yes - protected by internal mutex Creates a request that is already marked as complete with the provided result. Useful for synchronous resolution (e.g., wildcard bind) that doesn't need async DNS. The caller transfers ownership of the addrinfo result to the request. </dd></dl>

</div>
</div>
<a id="a5aa225e09d741aebee12bf0b5ab61e3c" name="a5aa225e09d741aebee12bf0b5ab61e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa225e09d741aebee12bf0b5ab61e3c">&#9670;&#160;</a></span>SocketDNS_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_free - Free a DNS resolver @dns: Pointer to resolver (will be set to NULL) Drains pending requests, signals worker threads to stop, and joins threads. </p>
<p>Any pending requests that have not been retrieved are cancelled. Thread-safe: Yes - safely shuts down thread pool </p>

</div>
</div>
<a id="a2e368f3eae045faa5d591d9279c9ce2e" name="a2e368f3eae045faa5d591d9279c9ce2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e368f3eae045faa5d591d9279c9ce2e">&#9670;&#160;</a></span>SocketDNS_geterror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_geterror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_geterror - Get error code for completed request @dns: DNS resolver instance @req: Request handle Returns: getaddrinfo() error code or 0 on success Thread-safe: Yes. </p>

</div>
</div>
<a id="a3dc9c864dd199a69a6a3d186439219a0" name="a3dc9c864dd199a69a6a3d186439219a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc9c864dd199a69a6a3d186439219a0">&#9670;&#160;</a></span>SocketDNS_getmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketDNS_getmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_getmaxpending - Get maximum pending request capacity @dns: DNS resolver instance Returns: Current pending request limit Thread-safe: Yes. </p>

</div>
</div>
<a id="a9bf4ce3f4cc95b946d7a3418a74da3df" name="a9bf4ce3f4cc95b946d7a3418a74da3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf4ce3f4cc95b946d7a3418a74da3df">&#9670;&#160;</a></span>SocketDNS_getresult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketDNS_getresult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handle Returns: Completed addrinfo result or NULL if pending/error/cancelled Thread-safe: Yes - protected by internal mutex Retrieves the result of a completed DNS resolution. </p>
<p>Returns NULL if:</p><ul>
<li>Request is still pending</li>
<li>Request was cancelled</li>
<li>Resolution failed (check error via <a class="el" href="SocketDNS_8h.html#a2e368f3eae045faa5d591d9279c9ce2e" title="SocketDNS_geterror - Get error code for completed request @dns: DNS resolver instance @req: Request h...">SocketDNS_geterror()</a>) The caller owns the returned addrinfo structure and must call freeaddrinfo() when done. The request handle becomes invalid after the result is retrieved. Performance: O(1) hash table lookup </li>
</ul>

</div>
</div>
<a id="a138bb4cdede6de597d17450f19f4530c" name="a138bb4cdede6de597d17450f19f4530c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138bb4cdede6de597d17450f19f4530c">&#9670;&#160;</a></span>SocketDNS_gettimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_gettimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_gettimeout - Get resolver request timeout in milliseconds @dns: DNS resolver instance Returns: Timeout in milliseconds (0 disables timeout) Thread-safe: Yes. </p>

</div>
</div>
<a id="a2b71ee0fa3c022f0342dd1bf9d2d9c14" name="a2b71ee0fa3c022f0342dd1bf9d2d9c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b71ee0fa3c022f0342dd1bf9d2d9c14">&#9670;&#160;</a></span>SocketDNS_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structT.html">T</a> SocketDNS_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_new - Create a new async DNS resolver Returns: New DNS resolver instance Raises: SocketDNS_Failed on initialization failure Thread-safe: Yes - returns new instance Creates a thread pool for DNS resolution. </p>
<p>Default thread count is SOCKET_DNS_THREAD_COUNT (configurable via <a class="el" href="SocketConfig_8h.html">SocketConfig.h</a>). </p>

</div>
</div>
<a id="a5bad005b6f546b3014c95735b5503020" name="a5bad005b6f546b3014c95735b5503020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bad005b6f546b3014c95735b5503020">&#9670;&#160;</a></span>SocketDNS_pollfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_pollfd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_pollfd - Get pollable file descriptor for SocketPoll integration @dns: DNS resolver instance Returns: File descriptor ready for reading when requests complete Thread-safe: Yes - returns stable file descriptor Returns a file descriptor (pipe or eventfd) that becomes readable when DNS resolution requests complete. </p>
<p>Add this to SocketPoll with POLL_READ and call <a class="el" href="SocketDNS_8h.html#abd6710a0d5f406255e39a6ab44fa7603" title="SocketDNS_check - Check for completed requests (non-blocking) @dns: DNS resolver instance Returns: Nu...">SocketDNS_check()</a> when events occur. The file descriptor remains valid for the lifetime of the resolver. </p>

</div>
</div>
<a id="a28f34d74dafd3ea4c4c05dbd1844fa50" name="a28f34d74dafd3ea4c4c05dbd1844fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f34d74dafd3ea4c4c05dbd1844fa50">&#9670;&#160;</a></span>SocketDNS_request_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_request_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_request_settimeout - Override timeout for specific request @dns: DNS resolver instance @req: Request handle @timeout_ms: Timeout in milliseconds (0 disables timeout for this request) Thread-safe: Yes. </p>

</div>
</div>
<a id="a3da13a84fbce512f59c75d3cdf53a3f9" name="a3da13a84fbce512f59c75d3cdf53a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da13a84fbce512f59c75d3cdf53a3f9">&#9670;&#160;</a></span>SocketDNS_resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SocketDNS_8h.html#abed9b1a79ca074827284111e500f8b22">Request_T</a> SocketDNS_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketDNS_8h.html#af6b5779cfd95203ac45b76e5fccbfe20">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_resolve - Start async DNS resolution @dns: DNS resolver instance @host: Hostname or IP address to resolve (NULL for wildcard bind with AI_PASSIVE) @port: Port number (0 if not needed) @callback: Completion callback (NULL for SocketPoll integration) @data: User data passed to callback Returns: Request handle (never NULL) Raises: SocketDNS_Failed on queue full or invalid parameters Thread-safe: Yes - protected by internal mutex Starts asynchronous DNS resolution. </p>
<p>If callback is NULL, use SocketPoll integration: add <a class="el" href="SocketDNS_8h.html#a5bad005b6f546b3014c95735b5503020" title="SocketDNS_pollfd - Get pollable file descriptor for SocketPoll integration @dns: DNS resolver instanc...">SocketDNS_pollfd()</a> to SocketPoll and call <a class="el" href="SocketDNS_8h.html#abd6710a0d5f406255e39a6ab44fa7603" title="SocketDNS_check - Check for completed requests (non-blocking) @dns: DNS resolver instance Returns: Nu...">SocketDNS_check()</a> on events. If callback is provided, it will be called from a worker thread when resolution completes. When host is NULL, AI_PASSIVE flag is automatically set for wildcard bind operations. The request handle remains valid until:</p><ul>
<li>Result retrieved via <a class="el" href="SocketDNS_8h.html#a9bf4ce3f4cc95b946d7a3418a74da3df" title="SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handl...">SocketDNS_getresult()</a> (callback mode)</li>
<li>Request cancelled via <a class="el" href="SocketDNS_8h.html#ab8a9f6d43d9a9044391e3d91a050e7bf" title="SocketDNS_cancel - Cancel a pending DNS resolution @dns: DNS resolver instance @req: Request handle t...">SocketDNS_cancel()</a></li>
<li>Resolver freed via <a class="el" href="SocketDNS_8h.html#a5aa225e09d741aebee12bf0b5ab61e3c" title="SocketDNS_free - Free a DNS resolver @dns: Pointer to resolver (will be set to NULL) Drains pending r...">SocketDNS_free()</a> Performance: O(1) queue insertion </li>
</ul>

</div>
</div>
<a id="aedb55dea32906adadb740f9bc554768c" name="aedb55dea32906adadb740f9bc554768c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb55dea32906adadb740f9bc554768c">&#9670;&#160;</a></span>SocketDNS_setmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_setmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_setmaxpending - Set maximum pending request capacity @dns: DNS resolver instance @max_pending: New pending request limit (0 allows no pending requests) Raises: SocketDNS_Failed if max_pending &lt; current queue depth Thread-safe: Yes. </p>

</div>
</div>
<a id="a7742ae0f0a34ecc0188df415e88a3c79" name="a7742ae0f0a34ecc0188df415e88a3c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7742ae0f0a34ecc0188df415e88a3c79">&#9670;&#160;</a></span>SocketDNS_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketDNS_settimeout - Set resolver request timeout in milliseconds @dns: DNS resolver instance @timeout_ms: Timeout in milliseconds (0 disables timeout) Thread-safe: Yes. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a152c227261ddef33b34fb3a3578d8a5e" name="a152c227261ddef33b34fb3a3578d8a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152c227261ddef33b34fb3a3578d8a5e">&#9670;&#160;</a></span>SocketDNS_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Except_T SocketDNS_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DNS resolution operation failure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_9c1a8fda6212d92d4df2de0cb3e2b810.html">dns</a></li><li class="navelem"><a class="el" href="SocketDNS_8h.html">SocketDNS.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
