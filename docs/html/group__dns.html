<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="High-performance, exception-driven socket toolkit for POSIX systems">
<meta name="keywords" content="socket, networking, C, POSIX, TCP, UDP, TLS, async, high-performance, library">
<meta name="author" content="Tetsuo Corporation">
<meta name="theme-color" content="#3b82f6">
<title>Asynchronous DNS Resolution</title>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' stop-color='%233b82f6'/><stop offset='100%25' stop-color='%238b5cf6'/></linearGradient></defs><rect width='100' height='100' rx='20' fill='url(%23g)'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='bold'>S</text></svg>">
</head>
<body>
<div id="top">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">1.0.0</span></div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
  <td style="text-align: right; padding: 20px; vertical-align: middle;">
    <div style="display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; align-items: center;">
      <a href="index.html" class="quick-link">Home</a>
      <a href="annotated.html" class="quick-link">Structures</a>
      <a href="files.html" class="quick-link">Files</a>
      <a href="globals.html" class="quick-link">API</a>
    </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__dns.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Asynchronous DNS Resolution<div class="ingroups"><a class="el" href="group__core__io.html">Core I/O Modules</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Thread pool-based DNS resolution with guaranteed timeouts and SocketPoll integration.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Asynchronous DNS Resolution:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__dns.svg" width="388" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketDNS-private_8h" id="r_SocketDNS-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS-private_8h.html">SocketDNS-private.h</a></td></tr>
<tr class="memdesc:SocketDNS-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structures, enums, and prototypes for asynchronous DNS resolver implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketDNS_8h" id="r_SocketDNS_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html">SocketDNS.h</a></td></tr>
<tr class="memdesc:SocketDNS_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous DNS resolution API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketDNS__Request__T" id="r_structSocketDNS__Request__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a></td></tr>
<tr class="memdesc:structSocketDNS__Request__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution request structure.  <a href="group__dns.html#structSocketDNS__Request__T">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__Request__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketDNS__T" id="r_structSocketDNS__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td></tr>
<tr class="memdesc:structSocketDNS__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async DNS resolver structure.  <a href="group__dns.html#structSocketDNS__T">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6aa3910745c244fe5ce4c66b7e31ce58" id="r_ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6aa3910745c244fe5ce4c66b7e31ce58">SIGNAL_DNS_COMPLETION</a>(dns)</td></tr>
<tr class="memdesc:ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal completion and wake waiters.  <br /></td></tr>
<tr class="separator:ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa42bc1aa6036f871ffed2e5274c8b4d" id="r_gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gafa42bc1aa6036f871ffed2e5274c8b4d">SANITIZE_TIMEOUT_MS</a>(timeout_ms)&#160;&#160;&#160;((timeout_ms) &lt; 0 ? 0 : (timeout_ms))</td></tr>
<tr class="memdesc:gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize timeout value (negative -&gt; 0).  <br /></td></tr>
<tr class="separator:gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga47df31a4c5b1861e6bc33bf91effa388" id="r_ga47df31a4c5b1861e6bc33bf91effa388"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *, struct addrinfo *, int, void *)</td></tr>
<tr class="memdesc:ga47df31a4c5b1861e6bc33bf91effa388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback type invoked when DNS resolution finishes.  <br /></td></tr>
<tr class="separator:ga47df31a4c5b1861e6bc33bf91effa388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7a4f82232cde2b125b4b1e1df03b1f" id="r_gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a></td></tr>
<tr class="memdesc:gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to DNS resolution request structure.  <br /></td></tr>
<tr class="separator:gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88905fdf7322b96426e000683280445d" id="r_ga88905fdf7322b96426e000683280445d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga88905fdf7322b96426e000683280445d">SocketDNS_Callback</a>) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error, void *data)</td></tr>
<tr class="memdesc:ga88905fdf7322b96426e000683280445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for async DNS resolution.  <br /></td></tr>
<tr class="separator:ga88905fdf7322b96426e000683280445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabbf149223655194c14baa78907cb2dab" id="r_gabbf149223655194c14baa78907cb2dab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a> { <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634">REQ_PENDING</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec">REQ_PROCESSING</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016">REQ_COMPLETE</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111">REQ_CANCELLED</a>
<br />
 }</td></tr>
<tr class="memdesc:gabbf149223655194c14baa78907cb2dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of DNS request processing states.  <a href="group__dns.html#gabbf149223655194c14baa78907cb2dab">More...</a><br /></td></tr>
<tr class="separator:gabbf149223655194c14baa78907cb2dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba752f803497a475aa1b96ed2351dd99" id="r_gaba752f803497a475aa1b96ed2351dd99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a> { <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941">DNS_CLEAN_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25">DNS_CLEAN_MUTEX</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc">DNS_CLEAN_CONDS</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca">DNS_CLEAN_PIPE</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb">DNS_CLEAN_ARENA</a>
<br />
 }</td></tr>
<tr class="memdesc:gaba752f803497a475aa1b96ed2351dd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Levels for partial cleanup during initialization failures.  <a href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">More...</a><br /></td></tr>
<tr class="separator:gaba752f803497a475aa1b96ed2351dd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0c5a84436f8b4c2c2159a9ae95ec6e6f" id="r_ga0c5a84436f8b4c2c2159a9ae95ec6e6f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a> (void)</td></tr>
<tr class="memdesc:ga0c5a84436f8b4c2c2159a9ae95ec6e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and zero-initialize DNS resolver structure from heap memory.  <br /></td></tr>
<tr class="separator:ga0c5a84436f8b4c2c2159a9ae95ec6e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7a4f5e6d71025f70a9ce5815567d19" id="r_ga6c7a4f5e6d71025f70a9ce5815567d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6c7a4f5e6d71025f70a9ce5815567d19">initialize_dns_fields</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga6c7a4f5e6d71025f70a9ce5815567d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize basic DNS resolver fields to default values.  <br /></td></tr>
<tr class="separator:ga6c7a4f5e6d71025f70a9ce5815567d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558e7ea40aee65f859eef6c434f750e0" id="r_ga558e7ea40aee65f859eef6c434f750e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga558e7ea40aee65f859eef6c434f750e0">initialize_dns_components</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga558e7ea40aee65f859eef6c434f750e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads.  <br /></td></tr>
<tr class="separator:ga558e7ea40aee65f859eef6c434f750e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b1aab7c7e7de783b56183c7a62863d" id="r_ga62b1aab7c7e7de783b56183c7a62863d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga62b1aab7c7e7de783b56183c7a62863d">setup_thread_attributes</a> (pthread_attr_t *attr)</td></tr>
<tr class="memdesc:ga62b1aab7c7e7de783b56183c7a62863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure thread attributes for worker thread creation.  <br /></td></tr>
<tr class="separator:ga62b1aab7c7e7de783b56183c7a62863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f5a6033fa425d4586553885a1dea47" id="r_ga94f5a6033fa425d4586553885a1dea47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga94f5a6033fa425d4586553885a1dea47">create_single_worker_thread</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, int thread_index)</td></tr>
<tr class="memdesc:ga94f5a6033fa425d4586553885a1dea47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a single worker thread.  <br /></td></tr>
<tr class="separator:ga94f5a6033fa425d4586553885a1dea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9424b326264ca67ebcd3b425836fd3e" id="r_gaa9424b326264ca67ebcd3b425836fd3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e">create_worker_threads</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaa9424b326264ca67ebcd3b425836fd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn the configured number of DNS worker threads.  <br /></td></tr>
<tr class="separator:gaa9424b326264ca67ebcd3b425836fd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966920bebbea908c25400af44930fe59" id="r_ga966920bebbea908c25400af44930fe59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga966920bebbea908c25400af44930fe59">start_dns_workers</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga966920bebbea908c25400af44930fe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start DNS worker threads (transition from initialization to running).  <br /></td></tr>
<tr class="separator:ga966920bebbea908c25400af44930fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a54f32c13c556fda9cb00e58078075" id="r_ga93a54f32c13c556fda9cb00e58078075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga93a54f32c13c556fda9cb00e58078075">initialize_mutex</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga93a54f32c13c556fda9cb00e58078075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the main mutex protecting DNS resolver state.  <br /></td></tr>
<tr class="separator:ga93a54f32c13c556fda9cb00e58078075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06edd21b5cb02e131393e908502c2563" id="r_ga06edd21b5cb02e131393e908502c2563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga06edd21b5cb02e131393e908502c2563">initialize_queue_condition</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga06edd21b5cb02e131393e908502c2563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable for queue empty/full signaling.  <br /></td></tr>
<tr class="separator:ga06edd21b5cb02e131393e908502c2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b07ff9ca818c6179416243aa5be0e3" id="r_ga08b07ff9ca818c6179416243aa5be0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga08b07ff9ca818c6179416243aa5be0e3">initialize_result_condition</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga08b07ff9ca818c6179416243aa5be0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable for result availability signaling.  <br /></td></tr>
<tr class="separator:ga08b07ff9ca818c6179416243aa5be0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf875bcba3b535a0981600de2c0aa5720" id="r_gaf875bcba3b535a0981600de2c0aa5720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf875bcba3b535a0981600de2c0aa5720">initialize_synchronization</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf875bcba3b535a0981600de2c0aa5720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all synchronization primitives (mutex + conditions).  <br /></td></tr>
<tr class="separator:gaf875bcba3b535a0981600de2c0aa5720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2db132989e70ce194d307157648be2" id="r_gafd2db132989e70ce194d307157648be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gafd2db132989e70ce194d307157648be2">create_completion_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gafd2db132989e70ce194d307157648be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create pipe for completion signaling to event loops.  <br /></td></tr>
<tr class="separator:gafd2db132989e70ce194d307157648be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4a337f44614e431316266926e989ed" id="r_ga1a4a337f44614e431316266926e989ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1a4a337f44614e431316266926e989ed">set_pipe_nonblocking</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga1a4a337f44614e431316266926e989ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set completion pipe to non-blocking mode.  <br /></td></tr>
<tr class="separator:ga1a4a337f44614e431316266926e989ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5821b121187c8fe5bdf8e5af7b76d7" id="r_ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga4e5821b121187c8fe5bdf8e5af7b76d7">initialize_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize completion pipe (create + configure).  <br /></td></tr>
<tr class="separator:ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350ef25d04ab2c551f69473a94faaee5" id="r_ga350ef25d04ab2c551f69473a94faaee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga350ef25d04ab2c551f69473a94faaee5">cleanup_mutex_cond</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga350ef25d04ab2c551f69473a94faaee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up mutex and condition variables.  <br /></td></tr>
<tr class="separator:ga350ef25d04ab2c551f69473a94faaee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26b2a24da54162a2a3aa842252aba6c" id="r_gad26b2a24da54162a2a3aa842252aba6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad26b2a24da54162a2a3aa842252aba6c">cleanup_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gad26b2a24da54162a2a3aa842252aba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up completion pipe.  <br /></td></tr>
<tr class="separator:gad26b2a24da54162a2a3aa842252aba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7611dac05257caaebe03fad6b799a65e" id="r_ga7611dac05257caaebe03fad6b799a65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e">cleanup_on_init_failure</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a> cleanup_level)</td></tr>
<tr class="memdesc:ga7611dac05257caaebe03fad6b799a65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up resources based on initialization failure level.  <br /></td></tr>
<tr class="separator:ga7611dac05257caaebe03fad6b799a65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b30e5d8a0c4c61b78414c87fc2e6ad6" id="r_ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6b30e5d8a0c4c61b78414c87fc2e6ad6">shutdown_workers</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal worker threads to shut down.  <br /></td></tr>
<tr class="separator:ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898228e143549696bc2d4e5d00f8965f" id="r_ga898228e143549696bc2d4e5d00f8965f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga898228e143549696bc2d4e5d00f8965f">drain_completion_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga898228e143549696bc2d4e5d00f8965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drain all pending completion signals from pipe.  <br /></td></tr>
<tr class="separator:ga898228e143549696bc2d4e5d00f8965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab8535e6f7b9cd7213be1f35babf70" id="r_ga1fab8535e6f7b9cd7213be1f35babf70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1fab8535e6f7b9cd7213be1f35babf70">reset_dns_state</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga1fab8535e6f7b9cd7213be1f35babf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset DNS resolver state to uninitialized values.  <br /></td></tr>
<tr class="separator:ga1fab8535e6f7b9cd7213be1f35babf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a861e18294d856d7424ed8d7430d642" id="r_ga3a861e18294d856d7424ed8d7430d642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga3a861e18294d856d7424ed8d7430d642">destroy_dns_resources</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga3a861e18294d856d7424ed8d7430d642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all DNS resolver resources.  <br /></td></tr>
<tr class="separator:ga3a861e18294d856d7424ed8d7430d642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ee93c269a62b9aa6c34c965b5d116a" id="r_gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa5ee93c269a62b9aa6c34c965b5d116a">free_request_list</a> (struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *head, int use_hash_next)</td></tr>
<tr class="memdesc:gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a linked list of DNS requests.  <br /></td></tr>
<tr class="separator:gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d1b0f6a9b6fa146ef00d6ca9211684" id="r_gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa0d1b0f6a9b6fa146ef00d6ca9211684">free_queued_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all requests currently in the processing queue.  <br /></td></tr>
<tr class="separator:gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2b657e4e48e6748189193c13195348" id="r_ga4d2b657e4e48e6748189193c13195348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga4d2b657e4e48e6748189193c13195348">free_hash_table_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga4d2b657e4e48e6748189193c13195348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all requests currently in the hash table.  <br /></td></tr>
<tr class="separator:ga4d2b657e4e48e6748189193c13195348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a2fbf12055d3bcc4abb72a9f8cdea8" id="r_gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf6a2fbf12055d3bcc4abb72a9f8cdea8">free_all_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all pending and completed DNS requests.  <br /></td></tr>
<tr class="separator:gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79ec1f8c6638d30d082e8af45420837" id="r_gae79ec1f8c6638d30d082e8af45420837"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gae79ec1f8c6638d30d082e8af45420837">request_hash_function</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gae79ec1f8c6638d30d082e8af45420837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hash value for request pointer.  <br /></td></tr>
<tr class="separator:gae79ec1f8c6638d30d082e8af45420837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021646b59321cc2b5ab7ca06895f7ed" id="r_ga5021646b59321cc2b5ab7ca06895f7ed"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5021646b59321cc2b5ab7ca06895f7ed">allocate_request_structure</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga5021646b59321cc2b5ab7ca06895f7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized request structure from resolver arena.  <br /></td></tr>
<tr class="separator:ga5021646b59321cc2b5ab7ca06895f7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae541ca39283e052d84495e5201a6fd" id="r_gacae541ca39283e052d84495e5201a6fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gacae541ca39283e052d84495e5201a6fd">allocate_request_hostname</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const char *host, size_t host_len)</td></tr>
<tr class="memdesc:gacae541ca39283e052d84495e5201a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and copy hostname string for request.  <br /></td></tr>
<tr class="separator:gacae541ca39283e052d84495e5201a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dda38ff120421fec3f5f32adf367bc" id="r_gad1dda38ff120421fec3f5f32adf367bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad1dda38ff120421fec3f5f32adf367bc">initialize_request_fields</a> (struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> callback, void *data)</td></tr>
<tr class="memdesc:gad1dda38ff120421fec3f5f32adf367bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize request fields after allocation.  <br /></td></tr>
<tr class="separator:gad1dda38ff120421fec3f5f32adf367bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bac854631773fa0c56cd5e965cef525" id="r_ga5bac854631773fa0c56cd5e965cef525"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5bac854631773fa0c56cd5e965cef525">allocate_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const char *host, size_t host_len, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> cb, void *data)</td></tr>
<tr class="memdesc:ga5bac854631773fa0c56cd5e965cef525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize complete DNS request.  <br /></td></tr>
<tr class="separator:ga5bac854631773fa0c56cd5e965cef525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17573e4e80145c4c8dcd3e4dbef28b1" id="r_gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gac17573e4e80145c4c8dcd3e4dbef28b1">hash_table_insert</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert request into hash table for O(1) lookup.  <br /></td></tr>
<tr class="separator:gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfe83ac3fd8daf74a5189130d35eb54" id="r_gadbfe83ac3fd8daf74a5189130d35eb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadbfe83ac3fd8daf74a5189130d35eb54">hash_table_remove</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gadbfe83ac3fd8daf74a5189130d35eb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from hash table.  <br /></td></tr>
<tr class="separator:gadbfe83ac3fd8daf74a5189130d35eb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae886927eaa45cdd51372735713b90058" id="r_gae886927eaa45cdd51372735713b90058"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gae886927eaa45cdd51372735713b90058">queue_append</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gae886927eaa45cdd51372735713b90058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append request to processing queue.  <br /></td></tr>
<tr class="separator:gae886927eaa45cdd51372735713b90058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf136ad6b2c162ef7251dc25b2e1a7200" id="r_gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf136ad6b2c162ef7251dc25b2e1a7200">remove_from_queue_head</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from queue head position.  <br /></td></tr>
<tr class="separator:gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57962854d57cd4bad03222b31bf5036" id="r_gaa57962854d57cd4bad03222b31bf5036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa57962854d57cd4bad03222b31bf5036">remove_from_queue_middle</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gaa57962854d57cd4bad03222b31bf5036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from middle of queue.  <br /></td></tr>
<tr class="separator:gaa57962854d57cd4bad03222b31bf5036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c14a21d40420acc4820fa2ff503ca20" id="r_ga6c14a21d40420acc4820fa2ff503ca20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6c14a21d40420acc4820fa2ff503ca20">queue_remove</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga6c14a21d40420acc4820fa2ff503ca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from processing queue.  <br /></td></tr>
<tr class="separator:ga6c14a21d40420acc4820fa2ff503ca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39628720afa0f701ab8d3e9bcceeb21c" id="r_ga39628720afa0f701ab8d3e9bcceeb21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga39628720afa0f701ab8d3e9bcceeb21c">check_queue_limit</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga39628720afa0f701ab8d3e9bcceeb21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if queue has reached capacity limit.  <br /></td></tr>
<tr class="separator:ga39628720afa0f701ab8d3e9bcceeb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd7ab93512c5ab94d32415eac07e69e" id="r_gadfd7ab93512c5ab94d32415eac07e69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadfd7ab93512c5ab94d32415eac07e69e">submit_dns_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gadfd7ab93512c5ab94d32415eac07e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit request for processing by worker threads.  <br /></td></tr>
<tr class="separator:gadfd7ab93512c5ab94d32415eac07e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e2afb20697e782942fa9ed48084a90" id="r_ga78e2afb20697e782942fa9ed48084a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga78e2afb20697e782942fa9ed48084a90">cancel_pending_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga78e2afb20697e782942fa9ed48084a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending request before it starts processing.  <br /></td></tr>
<tr class="separator:ga78e2afb20697e782942fa9ed48084a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fdc34348f496c17c968499f90ef36c" id="r_ga33fdc34348f496c17c968499f90ef36c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga33fdc34348f496c17c968499f90ef36c">request_effective_timeout_ms</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga33fdc34348f496c17c968499f90ef36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get effective timeout for request (with fallback to default).  <br /></td></tr>
<tr class="separator:ga33fdc34348f496c17c968499f90ef36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535554eb81b22d80ff8e72060293345b" id="r_ga535554eb81b22d80ff8e72060293345b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga535554eb81b22d80ff8e72060293345b">request_timed_out</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga535554eb81b22d80ff8e72060293345b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if request has exceeded its timeout.  <br /></td></tr>
<tr class="separator:ga535554eb81b22d80ff8e72060293345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5067399f8c9930eb42f1e625899a3f7" id="r_gad5067399f8c9930eb42f1e625899a3f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad5067399f8c9930eb42f1e625899a3f7">mark_request_timeout</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gad5067399f8c9930eb42f1e625899a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark request as timed out with appropriate error code.  <br /></td></tr>
<tr class="separator:gad5067399f8c9930eb42f1e625899a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e26345eeede858bb5922a6109160037" id="r_ga0e26345eeede858bb5922a6109160037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga0e26345eeede858bb5922a6109160037">handle_request_timeout</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga0e26345eeede858bb5922a6109160037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle timeout for a specific request.  <br /></td></tr>
<tr class="separator:ga0e26345eeede858bb5922a6109160037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9801b10626b586b24b9f9c76b89fbb" id="r_ga1e9801b10626b586b24b9f9c76b89fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1e9801b10626b586b24b9f9c76b89fbb">initialize_addrinfo_hints</a> (struct addrinfo *hints)</td></tr>
<tr class="memdesc:ga1e9801b10626b586b24b9f9c76b89fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize addrinfo hints structure with defaults.  <br /></td></tr>
<tr class="separator:ga1e9801b10626b586b24b9f9c76b89fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f292c19cdf04ce4fb9f9a890b656cf0" id="r_ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0">worker_thread</a> (void *arg)</td></tr>
<tr class="memdesc:ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main worker thread function for DNS resolution.  <br /></td></tr>
<tr class="separator:ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b432e1a64990d148474aab42fec110" id="r_ga84b432e1a64990d148474aab42fec110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga84b432e1a64990d148474aab42fec110">prepare_local_hints</a> (struct addrinfo *local_hints, const struct addrinfo *base_hints, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga84b432e1a64990d148474aab42fec110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare addrinfo hints for specific request.  <br /></td></tr>
<tr class="separator:ga84b432e1a64990d148474aab42fec110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7570715dd7fcb113790e60bedd3139fb" id="r_ga7570715dd7fcb113790e60bedd3139fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7570715dd7fcb113790e60bedd3139fb">handle_resolution_result</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int res)</td></tr>
<tr class="memdesc:ga7570715dd7fcb113790e60bedd3139fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle result of DNS resolution attempt.  <br /></td></tr>
<tr class="separator:ga7570715dd7fcb113790e60bedd3139fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cf4dd4591c2d36325e9478b8f81901" id="r_gaf1cf4dd4591c2d36325e9478b8f81901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf1cf4dd4591c2d36325e9478b8f81901">process_single_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const struct addrinfo *base_hints)</td></tr>
<tr class="memdesc:gaf1cf4dd4591c2d36325e9478b8f81901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a single DNS request from the queue.  <br /></td></tr>
<tr class="separator:gaf1cf4dd4591c2d36325e9478b8f81901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd94190827e14a98bab9b52b3cd7d" id="r_gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf2ecd94190827e14a98bab9b52b3cd7d">dequeue_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return next request from processing queue.  <br /></td></tr>
<tr class="separator:gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516cbcd949e90804306ac10ec02af7cd" id="r_ga516cbcd949e90804306ac10ec02af7cd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga516cbcd949e90804306ac10ec02af7cd">wait_for_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga516cbcd949e90804306ac10ec02af7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a request to become available in the queue.  <br /></td></tr>
<tr class="separator:ga516cbcd949e90804306ac10ec02af7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e5cc089ceff56a8558e455b94c8254" id="r_ga01e5cc089ceff56a8558e455b94c8254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga01e5cc089ceff56a8558e455b94c8254">signal_completion</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga01e5cc089ceff56a8558e455b94c8254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal completion of DNS request to waiting threads/polls.  <br /></td></tr>
<tr class="separator:ga01e5cc089ceff56a8558e455b94c8254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc14c60ccd56fe1f73c7d52b04d0664" id="r_gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadbc14c60ccd56fe1f73c7d52b04d0664">store_resolution_result</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error)</td></tr>
<tr class="memdesc:gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store DNS resolution result in request structure.  <br /></td></tr>
<tr class="separator:gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d853b1c769338c43c424a51f071876" id="r_ga08d853b1c769338c43c424a51f071876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga08d853b1c769338c43c424a51f071876">dns_cancellation_error</a> (void)</td></tr>
<tr class="memdesc:ga08d853b1c769338c43c424a51f071876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error code indicating request was cancelled.  <br /></td></tr>
<tr class="separator:ga08d853b1c769338c43c424a51f071876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4cb4a632aba382e70ef8fcf90e942c3" id="r_gac4cb4a632aba382e70ef8fcf90e942c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gac4cb4a632aba382e70ef8fcf90e942c3">perform_dns_resolution</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const struct addrinfo *hints, struct addrinfo **result)</td></tr>
<tr class="memdesc:gac4cb4a632aba382e70ef8fcf90e942c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform actual DNS resolution using getaddrinfo().  <br /></td></tr>
<tr class="separator:gac4cb4a632aba382e70ef8fcf90e942c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5049b49f719f1be126b489957a62c7d8" id="r_ga5049b49f719f1be126b489957a62c7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5049b49f719f1be126b489957a62c7d8">invoke_callback</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga5049b49f719f1be126b489957a62c7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke user callback for completed request.  <br /></td></tr>
<tr class="separator:ga5049b49f719f1be126b489957a62c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac4f41fc92ef0aec184eb3c8e6e10cb" id="r_gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabac4f41fc92ef0aec184eb3c8e6e10cb">validate_resolve_params</a> (const char *host, int port)</td></tr>
<tr class="memdesc:gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate hostname and port parameters for DNS resolution.  <br /></td></tr>
<tr class="separator:gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799f4d96c77eef54ecb9be5523b591fd" id="r_ga799f4d96c77eef54ecb9be5523b591fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a> (void)</td></tr>
<tr class="memdesc:ga799f4d96c77eef54ecb9be5523b591fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new asynchronous DNS resolver.  <br /></td></tr>
<tr class="separator:ga799f4d96c77eef54ecb9be5523b591fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc83f21f67b5b8557f35d7ffa4c839c" id="r_gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a DNS resolver.  <br /></td></tr>
<tr class="separator:gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380629d9c1650963341d1fe1dacd3253" id="r_ga380629d9c1650963341d1fe1dacd3253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *host, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> callback, void *data)</td></tr>
<tr class="memdesc:ga380629d9c1650963341d1fe1dacd3253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous DNS resolution.  <br /></td></tr>
<tr class="separator:ga380629d9c1650963341d1fe1dacd3253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca6cf65c0823f0a23aa2c0c5cbe2223" id="r_ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">SocketDNS_cancel</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending DNS resolution.  <br /></td></tr>
<tr class="separator:ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f007d40e50ed2894c962ee91509fcc" id="r_ga68f007d40e50ed2894c962ee91509fcc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga68f007d40e50ed2894c962ee91509fcc">SocketDNS_getmaxpending</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga68f007d40e50ed2894c962ee91509fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum pending request capacity.  <br /></td></tr>
<tr class="separator:ga68f007d40e50ed2894c962ee91509fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b33b7c9a44dc087be0f74b259d54f7" id="r_ga55b33b7c9a44dc087be0f74b259d54f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7">SocketDNS_setmaxpending</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, size_t max_pending)</td></tr>
<tr class="memdesc:ga55b33b7c9a44dc087be0f74b259d54f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum pending request capacity.  <br /></td></tr>
<tr class="separator:ga55b33b7c9a44dc087be0f74b259d54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4c54acbc79bbb31a4ce3ec75928ee8" id="r_ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga2f4c54acbc79bbb31a4ce3ec75928ee8">SocketDNS_gettimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get resolver request timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390b733f1a522dcaccede3adf56fece0" id="r_ga390b733f1a522dcaccede3adf56fece0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0">SocketDNS_settimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, int timeout_ms)</td></tr>
<tr class="memdesc:ga390b733f1a522dcaccede3adf56fece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set resolver request timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga390b733f1a522dcaccede3adf56fece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9228880ada42145db04298282b5f0c80" id="r_ga9228880ada42145db04298282b5f0c80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80">SocketDNS_pollfd</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga9228880ada42145db04298282b5f0c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pollable file descriptor for SocketPoll integration.  <br /></td></tr>
<tr class="separator:ga9228880ada42145db04298282b5f0c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f2fa5ee464e84f44b4b6059b4813e5" id="r_gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for completed requests (non-blocking).  <br /></td></tr>
<tr class="separator:gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7c4c4455c9158ccd272fe8c15235b5" id="r_ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get result of completed request.  <br /></td></tr>
<tr class="separator:ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d8d4c9f020bf781d541df7ecaf5acf" id="r_ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error code for completed request.  <br /></td></tr>
<tr class="separator:ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b27f46a350b3cfaf9a1092d94f81dd9" id="r_ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga9b27f46a350b3cfaf9a1092d94f81dd9">SocketDNS_request_settimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req, int timeout_ms)</td></tr>
<tr class="memdesc:ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override timeout for specific request.  <br /></td></tr>
<tr class="separator:ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494e7ef72d567b90e5fdcb1df6501ea5" id="r_ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga494e7ef72d567b90e5fdcb1df6501ea5">SocketDNS_create_completed_request</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, struct addrinfo *result, int port)</td></tr>
<tr class="memdesc:ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a completed request from pre-resolved addrinfo.  <br /></td></tr>
<tr class="separator:ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab988727825887d34e87d144d30c30c2f" id="r_gab988727825887d34e87d144d30c30c2f"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f">SocketDNS_resolve_sync</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *host, int port, const struct addrinfo *hints, int timeout_ms)</td></tr>
<tr class="memdesc:gab988727825887d34e87d144d30c30c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous DNS resolution with timeout guarantee.  <br /></td></tr>
<tr class="separator:gab988727825887d34e87d144d30c30c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga329324a0e4a1450a6b968b375bb9b333" id="r_ga329324a0e4a1450a6b968b375bb9b333"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a></td></tr>
<tr class="memdesc:ga329324a0e4a1450a6b968b375bb9b333"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution operation failure exception.  <br /></td></tr>
<tr class="separator:ga329324a0e4a1450a6b968b375bb9b333"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Thread pool-based DNS resolution with guaranteed timeouts and SocketPoll integration. </p>
<p>Provides asynchronous DNS resolution using a thread pool to eliminate blocking getaddrinfo() calls that can take 30+ seconds during DNS failures. This addresses DoS vulnerabilities and enables truly non-blocking socket operations.</p>
<p>Key components:</p><ul>
<li><a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a>: Main resolver with thread pool and queue management</li>
<li><a class="el" href="group__dns.html#structSocketDNS__Request__T" title="DNS resolution request structure.">SocketDNS_Request_T</a>: Individual DNS resolution request structure</li>
<li>Thread pool for concurrent resolution with O(1) hash table lookup</li>
<li>Completion pipe for SocketPoll integration</li>
<li>Guaranteed timeouts to prevent DoS attacks</li>
</ul>
<p>Requires <a class="el" href="group__foundation.html">Core Foundation Modules</a> (Arena_T, <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a>) Used by <a class="el" href="group__core__io.html">Core I/O Modules</a> (Socket_T for hostname resolution), <a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> (SocketPool, SocketReconnect)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html">Event System Modules</a> for SocketPoll integration. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for resolver creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for async resolution. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> for event loop integration. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callbacks execute in worker threads, not main thread! </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketDNS__Request__T" id="structSocketDNS__Request__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__Request__T">&#9670;&#160;</a></span>SocketDNS_Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_Request_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DNS resolution request structure. </p>
<p>Opaque type for DNS resolution requests.</p>
<p>Opaque handle for a single DNS resolution request.</p>
<p>Represents a single DNS resolution request with all associated state. Allocated from the resolver's arena and lives until result is retrieved or request is cancelled.</p>
<p>Created by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>, used to retrieve results, cancel, or via callback. Lifetime managed by resolver; invalid after completion or cancellation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00172">172</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketDNS_Request_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketDNS__Request__T__coll__graph.svg" width="266" height="172"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac737e6e0a2823df1c6a562ed9094ef68" name="ac737e6e0a2823df1c6a562ed9094ef68"></a><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a></td>
<td class="fieldname">
callback</td>
<td class="fielddoc">
<p>Completion callback (NULL for polling) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abb8217588f38c05ae1ef9c52ec58975f" name="abb8217588f38c05ae1ef9c52ec58975f"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">void</a> *</td>
<td class="fieldname">
callback_data</td>
<td class="fielddoc">
<p>User data passed to callback </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afb60ae86fa4e34c68f4b19248c0a6224" name="afb60ae86fa4e34c68f4b19248c0a6224"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *</td>
<td class="fieldname">
dns_resolver</td>
<td class="fielddoc">
<p>Back-pointer to owning resolver </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3d233326169857dc18531189fe9c6b73" name="a3d233326169857dc18531189fe9c6b73"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">int</a></td>
<td class="fieldname">
error</td>
<td class="fielddoc">
<p><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">getaddrinfo()</a> error code (0 on success) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac8e64bed401754d3f9edde727173d215" name="ac8e64bed401754d3f9edde727173d215"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
hash_next</td>
<td class="fielddoc">
<p>Hash table chain pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4cd29363bd5fa627cf69f0b049396aa5" name="a4cd29363bd5fa627cf69f0b049396aa5"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">unsigned</a></td>
<td class="fieldname">
hash_value</td>
<td class="fielddoc">
<p>Cached hash for <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">O(1)</a> removal </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9f3fa1aca3eb39a39d6e3777fc49273" name="ac9f3fa1aca3eb39a39d6e3777fc49273"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">char</a> *</td>
<td class="fieldname">
host</td>
<td class="fielddoc">
<p>Hostname to resolve (arena-allocated) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7868d9891ef8b5565dfa9ed0c26d6444" name="a7868d9891ef8b5565dfa9ed0c26d6444"></a>int</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
<p>Port number for service lookup </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeddfbe59d08f55af648954a09ce13e1c" name="aeddfbe59d08f55af648954a09ce13e1c"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_next</td>
<td class="fielddoc">
<p>Queue linked list pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a66c651eeca12f843f19f01518b8ae931" name="a66c651eeca12f843f19f01518b8ae931"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">addrinfo</a> *</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>Resolution result (owned until retrieved) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a98bce03b9f775ac1d728d1f26b0b547b" name="a98bce03b9f775ac1d728d1f26b0b547b"></a><a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Current request lifecycle state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aaac0c7c61c58409bc34fb10f8f1319b9" name="aaac0c7c61c58409bc34fb10f8f1319b9"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">timespec</a></td>
<td class="fieldname">
submit_time</td>
<td class="fielddoc">
<p>CLOCK_MONOTONIC submission timestamp </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a62225dfe2f1c26e94b46ceb012d52517" name="a62225dfe2f1c26e94b46ceb012d52517"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">int</a></td>
<td class="fieldname">
timeout_override_ms</td>
<td class="fielddoc">
<p>Per-request timeout (-1 = use default) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketDNS__T" id="structSocketDNS__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__T">&#9670;&#160;</a></span>SocketDNS_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Async DNS resolver structure. </p>
<p>Opaque handle for asynchronous DNS resolver.</p>
<p>Opaque type for DNS resolver instances.</p>
<p>Thread pool-based DNS resolver with queue management, hash table lookup, and pipe-based completion signaling for integration with SocketPoll.</p>
<p>SECURITY NOTE: The request hash table uses deterministic pointer-based hashing via <a class="el" href="group__foundation.html#ga0c1ed7481fd58c8cbb7e47b8a614b556" title="Hash pointer using golden ratio multiplicative.">socket_util_hash_ptr()</a>. While attackers cannot typically control memory allocation addresses, a large number of concurrent requests could theoretically cause hash collisions. This is mitigated by:</p><ul>
<li>max_pending limit (default SOCKET_DNS_MAX_PENDING = 1000)</li>
<li>Hash table size is prime (SOCKET_DNS_REQUEST_HASH_SIZE = 1021)</li>
<li>Worst case is O(n) lookup per bucket, not a security vulnerability</li>
</ul>
<p>Used by global DNS configuration functions for timeout guarantees in socket operations like bind() and connect().</p>
<p>Full API documentation in <a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API.">SocketDNS.h</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API.">SocketDNS.h</a> for complete DNS resolution API. </dd>
<dd>
<a class="el" href="group__core__io.html#ga70954c6e125769d15ffd6c3e31c89b75" title="Get global DNS resolver instance.">SocketCommon_get_dns_resolver()</a> for accessing the global instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00204">204</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketDNS_T:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketDNS__T__coll__graph.svg" width="266" height="172"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adb82c384f91b26001b159b838dc2d153" name="adb82c384f91b26001b159b838dc2d153"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Arena for request/hostname allocation </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1bc6ad584684b38b8e086a9f41aa9f66" name="a1bc6ad584684b38b8e086a9f41aa9f66"></a>size_t</td>
<td class="fieldname">
max_pending</td>
<td class="fielddoc">
<p>Queue capacity limit </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2aaaddbe895c6d917cfbbd0aa0a61951" name="a2aaaddbe895c6d917cfbbd0aa0a61951"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
<p>Protects all mutable state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae5aa58d8c9a029fff13619993cdb8c3e" name="ae5aa58d8c9a029fff13619993cdb8c3e"></a>int</td>
<td class="fieldname">
num_workers</td>
<td class="fielddoc">
<p>Number of worker threads </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a04a850256d01d59de5d86b389b5afdc8" name="a04a850256d01d59de5d86b389b5afdc8"></a>int</td>
<td class="fieldname">
pipefd[2]</td>
<td class="fielddoc">
<p>Completion pipe [0]=read, [1]=write </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad13012e13d0e2f6a9a2a18917249f45c" name="ad13012e13d0e2f6a9a2a18917249f45c"></a>pthread_cond_t</td>
<td class="fieldname">
queue_cond</td>
<td class="fielddoc">
<p>Signals workers when work available </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa4656138af397c9d59c119fdeb97a9a8" name="aa4656138af397c9d59c119fdeb97a9a8"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_head</td>
<td class="fielddoc">
<p>Request queue FIFO head </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a250c9a8eb40649ce94b504b229a8051c" name="a250c9a8eb40649ce94b504b229a8051c"></a>size_t</td>
<td class="fieldname">
queue_size</td>
<td class="fielddoc">
<p>Current pending request count </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1cb2f8d034a886ec86036844183004a1" name="a1cb2f8d034a886ec86036844183004a1"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_tail</td>
<td class="fielddoc">
<p>Request queue FIFO tail </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4c961cf7ec05d782ed03f09cf3a0b699" name="a4c961cf7ec05d782ed03f09cf3a0b699"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
request_hash[1021]</td>
<td class="fielddoc">
<p>Hash table for O(1) request lookup </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a529eb3ddf6ec19b9eb13c9ee3d50267c" name="a529eb3ddf6ec19b9eb13c9ee3d50267c"></a>int</td>
<td class="fieldname">
request_timeout_ms</td>
<td class="fielddoc">
<p>Default timeout (0 = no timeout) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6b84353355d27005721631d66237fb89" name="a6b84353355d27005721631d66237fb89"></a>pthread_cond_t</td>
<td class="fieldname">
result_cond</td>
<td class="fielddoc">
<p>Signals waiters when result ready </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a026541a405efc2f27fff1a59e8d29add" name="a026541a405efc2f27fff1a59e8d29add"></a>int</td>
<td class="fieldname">
shutdown</td>
<td class="fielddoc">
<p>Shutdown flag (1 = shutting down) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9ac775dac4641b59cab189333cbcb63d" name="a9ac775dac4641b59cab189333cbcb63d"></a>pthread_t *</td>
<td class="fieldname">
workers</td>
<td class="fielddoc">
<p>Worker thread array (arena-allocated) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafa42bc1aa6036f871ffed2e5274c8b4d" name="gafa42bc1aa6036f871ffed2e5274c8b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa42bc1aa6036f871ffed2e5274c8b4d">&#9670;&#160;</a></span>SANITIZE_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SANITIZE_TIMEOUT_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout_ms</td><td>)</td>
          <td>&#160;&#160;&#160;((timeout_ms) &lt; 0 ? 0 : (timeout_ms))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sanitize timeout value (negative -&gt; 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if negative, otherwise original value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00247">247</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga6aa3910745c244fe5ce4c66b7e31ce58" name="ga6aa3910745c244fe5ce4c66b7e31ce58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa3910745c244fe5ce4c66b7e31ce58">&#9670;&#160;</a></span>SIGNAL_DNS_COMPLETION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNAL_DNS_COMPLETION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dns</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      signal_completion (dns);                                                \</div>
<div class="line">      pthread_cond_broadcast (&amp;(dns)-&gt;result_cond);                           \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Signal completion and wake waiters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Consolidates repeated signal_completion + pthread_cond_broadcast pattern. </p>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00233">233</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00042">42</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaec7a4f82232cde2b125b4b1e1df03b1f" name="gaec7a4f82232cde2b125b4b1e1df03b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7a4f82232cde2b125b4b1e1df03b1f">&#9670;&#160;</a></span>Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a>* <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to DNS resolution request structure. </p>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00058">58</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<a id="ga47df31a4c5b1861e6bc33bf91effa388" name="ga47df31a4c5b1861e6bc33bf91effa388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47df31a4c5b1861e6bc33bf91effa388">&#9670;&#160;</a></span>SocketDNS_Callback <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketDNS_Callback) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *, struct addrinfo *, int, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion callback type invoked when DNS resolution finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The original request handle (for identification). </td></tr>
    <tr><td class="paramname">result</td><td>Resolution results as addrinfo linked list, or NULL on error. </td></tr>
    <tr><td class="paramname">error</td><td>getaddrinfo() error code (0=success, see &lt;netdb.h&gt; for others). </td></tr>
    <tr><td class="paramname">data</td><td>User data passed to <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called from worker thread context upon completion (success, error, or timeout). </p><dl class="section note"><dt>Note</dt><dd>Executed in a dedicated DNS worker thread - NOT the thread that submitted the request. </dd>
<dd>
Must complete quickly; blocking stalls the worker pool. </dd>
<dd>
Takes ownership of 'result'; free with freeaddrinfo() after use. </dd>
<dd>
Do NOT call SocketDNS_free(dns) from callback (deadlock risk). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No automatic synchronization; user must protect shared data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> to submit request with callback. </dd>
<dd>
<a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388" title="Completion callback type invoked when DNS resolution finishes.">SocketDNS_Callback</a> safety notes in <a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API.">SocketDNS.h</a> documentation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00095">95</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga88905fdf7322b96426e000683280445d" name="ga88905fdf7322b96426e000683280445d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88905fdf7322b96426e000683280445d">&#9670;&#160;</a></span>SocketDNS_Callback <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketDNS_Callback) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for async DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request handle for this resolution. </td></tr>
    <tr><td class="paramname">result</td><td>Completed addrinfo result (NULL on error). </td></tr>
    <tr><td class="paramname">error</td><td>Error code from getaddrinfo() (0 on success). </td></tr>
    <tr><td class="paramname">data</td><td>User data passed to <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called when DNS resolution completes. If result is NULL, error contains the getaddrinfo() error code.</p>
<p>OWNERSHIP: The callback receives ownership of the result addrinfo structure and MUST call freeaddrinfo() when done with it.</p>
<p>THREAD SAFETY WARNING: Callbacks are invoked from DNS WORKER THREADS, NOT from the application thread. The callback implementation MUST:</p>
<ul>
<li>Be thread-safe if accessing shared application data structures</li>
<li>Use proper synchronization (mutexes) when modifying shared state</li>
<li>NOT store the @req pointer (it becomes invalid after callback returns)</li>
<li>NOT call <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Free a DNS resolver.">SocketDNS_free()</a> from within the callback (deadlock)</li>
<li>NOT perform long-running or blocking operations (blocks DNS workers)</li>
<li>Take ownership of <dl class="section return"><dt>Returns</dt><dd>immediately (copy if needed for later use)</dd></dl>
For applications that cannot safely handle worker-thread callbacks, use the SocketPoll integration pattern instead (pass NULL callback to SocketDNS_resolve and use SocketDNS_check/SocketDNS_getresult). </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00118">118</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaba752f803497a475aa1b96ed2351dd99" name="gaba752f803497a475aa1b96ed2351dd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba752f803497a475aa1b96ed2351dd99">&#9670;&#160;</a></span>DnsCleanupLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Levels for partial cleanup during initialization failures. </p>
<p>Defines cleanup scope for <a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> based on init progress. Values correspond to initialization order to enable reverse-order resource release. Used in TRY/EXCEPT blocks during <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> to ensure no leaks on failure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga558e7ea40aee65f859eef6c434f750e0" title="Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads.">initialize_dns_components()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> constructor exception handling.</dd></dl>
<p>Enum for DNS cleanup levels during partial failure recovery.</p>
<p>Defines levels corresponding to initialization stages, enabling precise resource cleanup on partial failure in <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a>. Values match order: mutex -&gt; conds -&gt; pipe -&gt; arena. Used in TRY/EXCEPT for exception-safe initialization.</p>
<dl class="section note"><dt>Note</dt><dd>Higher levels include cleanup for lower levels (reverse order). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for usage in constructor. </dd>
<dd>
<a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> for cleanup logic. </dd>
<dd>
<a class="el" href="group__dns.html#ga558e7ea40aee65f859eef6c434f750e0" title="Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads.">initialize_dns_components()</a> for init sequence. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941" name="ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941"></a>DNS_CLEAN_NONE&#160;</td><td class="fielddoc"><p>No cleanup needed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25" name="ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25"></a>DNS_CLEAN_MUTEX&#160;</td><td class="fielddoc"><p>Cleanup mutex only </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc" name="ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc"></a>DNS_CLEAN_CONDS&#160;</td><td class="fielddoc"><p>Cleanup condition variables and mutex </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca" name="ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca"></a>DNS_CLEAN_PIPE&#160;</td><td class="fielddoc"><p>Cleanup pipe, conditions, and mutex </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb" name="ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb"></a>DNS_CLEAN_ARENA&#160;</td><td class="fielddoc"><p>Cleanup arena and all above </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00149">149</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="gabbf149223655194c14baa78907cb2dab" name="gabbf149223655194c14baa78907cb2dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf149223655194c14baa78907cb2dab">&#9670;&#160;</a></span>RequestState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of DNS request processing states. </p>
<p>Tracks the lifecycle of individual resolution requests through the async pipeline:</p><ul>
<li>Submitted requests transition PENDING -&gt; PROCESSING -&gt; COMPLETE/CANCELLED</li>
<li>State used for synchronization, timeout checks, and result availability</li>
<li>Atomic updates under mutex protection</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#a98bce03b9f775ac1d728d1f26b0b547b">SocketDNS_Request_T::state</a> field. </dd>
<dd>
<a class="el" href="group__dns.html#gae886927eaa45cdd51372735713b90058" title="Append request to processing queue.">queue_append()</a>, <a class="el" href="group__dns.html#gaf1cf4dd4591c2d36325e9478b8f81901" title="Process a single DNS request from the queue.">process_single_request()</a>, <a class="el" href="group__dns.html#ga78e2afb20697e782942fa9ed48084a90" title="Cancel a pending request before it starts processing.">cancel_pending_request()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634" name="ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634"></a>REQ_PENDING&#160;</td><td class="fielddoc"><p>Request queued, awaiting worker assignment </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec" name="ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec"></a>REQ_PROCESSING&#160;</td><td class="fielddoc"><p>Worker actively calling getaddrinfo() </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016" name="ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016"></a>REQ_COMPLETE&#160;</td><td class="fielddoc"><p>Resolution finished; result/error ready </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111" name="ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111"></a>REQ_CANCELLED&#160;</td><td class="fielddoc"><p>User cancelled before processing complete </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00115">115</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0c5a84436f8b4c2c2159a9ae95ec6e6f" name="ga0c5a84436f8b4c2c2159a9ae95ec6e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c5a84436f8b4c2c2159a9ae95ec6e6f">&#9670;&#160;</a></span>allocate_dns_resolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> * allocate_dns_resolver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and zero-initialize DNS resolver structure from heap memory. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated and zeroed <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on memory allocation failure (calloc failure).</td></tr>
  </table>
  </dd>
</dl>
<p>Performs calloc(1, sizeof(struct SocketDNS_T)) for zero-initialization of all fields. Used during <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> bootstrap before arena allocation. Caller must subsequently call <a class="el" href="group__dns.html#ga6c7a4f5e6d71025f70a9ce5815567d19" title="Initialize basic DNS resolver fields to default values.">initialize_dns_fields()</a> and other init functions.</p>
<dl class="section note"><dt>Note</dt><dd>Heap allocation (not arena); arena is initialized later for requests. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga6c7a4f5e6d71025f70a9ce5815567d19" title="Initialize basic DNS resolver fields to default values.">initialize_dns_fields()</a> to set default values. </dd>
<dd>
<a class="el" href="group__dns.html#ga558e7ea40aee65f859eef6c434f750e0" title="Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads.">initialize_dns_components()</a> for full setup including threads and sync. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> public entry point that orchestrates allocation + init. </dd></dl>

</div>
</div>
<a id="ga5bac854631773fa0c56cd5e965cef525" name="ga5bac854631773fa0c56cd5e965cef525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bac854631773fa0c56cd5e965cef525">&#9670;&#160;</a></span>allocate_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * allocate_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>host_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and initialize complete DNS request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">host_len</td><td>Length of hostname. </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
    <tr><td class="paramname">cb</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">data</td><td>User callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fully initialized request structure.</dd></dl>
<p>Combines allocation, hostname copying, and field initialization. </p>

</div>
</div>
<a id="gacae541ca39283e052d84495e5201a6fd" name="gacae541ca39283e052d84495e5201a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacae541ca39283e052d84495e5201a6fd">&#9670;&#160;</a></span>allocate_request_hostname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void allocate_request_hostname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>host_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and copy hostname string for request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to store hostname in. </td></tr>
    <tr><td class="paramname">host</td><td>Hostname string to copy. </td></tr>
    <tr><td class="paramname">host_len</td><td>Length of hostname string.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates hostname buffer from arena and copies host string. </p>

</div>
</div>
<a id="ga5021646b59321cc2b5ab7ca06895f7ed" name="ga5021646b59321cc2b5ab7ca06895f7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5021646b59321cc2b5ab7ca06895f7ed">&#9670;&#160;</a></span>allocate_request_structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * allocate_request_structure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate uninitialized request structure from resolver arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated request structure.</dd></dl>
<p>Allocates memory for request structure. Fields must be initialized before use. </p>

</div>
</div>
<a id="ga78e2afb20697e782942fa9ed48084a90" name="ga78e2afb20697e782942fa9ed48084a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e2afb20697e782942fa9ed48084a90">&#9670;&#160;</a></span>cancel_pending_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cancel_pending_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending request before it starts processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes from queue and hash table, marks as cancelled. </p>

</div>
</div>
<a id="ga39628720afa0f701ab8d3e9bcceeb21c" name="ga39628720afa0f701ab8d3e9bcceeb21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39628720afa0f701ab8d3e9bcceeb21c">&#9670;&#160;</a></span>check_queue_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int check_queue_limit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if queue has reached capacity limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if at limit, 0 if can accept more requests.</dd></dl>
<p>Compares current queue size against max_pending limit. </p>

</div>
</div>
<a id="ga350ef25d04ab2c551f69473a94faaee5" name="ga350ef25d04ab2c551f69473a94faaee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350ef25d04ab2c551f69473a94faaee5">&#9670;&#160;</a></span>cleanup_mutex_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_mutex_cond </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up mutex and condition variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroys mutex and condition variables. Safe to call multiple times. </p>

</div>
</div>
<a id="ga7611dac05257caaebe03fad6b799a65e" name="ga7611dac05257caaebe03fad6b799a65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7611dac05257caaebe03fad6b799a65e">&#9670;&#160;</a></span>cleanup_on_init_failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_on_init_failure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a>&#160;</td>
          <td class="paramname"><em>cleanup_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up resources based on initialization failure level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">cleanup_level</td><td>How much has been initialized (cleanup level).</td></tr>
  </table>
  </dd>
</dl>
<p>Used during initialization failure to clean up partially initialized state. Cleans up resources in reverse order of initialization. </p>

</div>
</div>
<a id="gad26b2a24da54162a2a3aa842252aba6c" name="gad26b2a24da54162a2a3aa842252aba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26b2a24da54162a2a3aa842252aba6c">&#9670;&#160;</a></span>cleanup_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up completion pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Closes pipe file descriptors and drains any pending data. </p>

</div>
</div>
<a id="gafd2db132989e70ce194d307157648be2" name="gafd2db132989e70ce194d307157648be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2db132989e70ce194d307157648be2">&#9670;&#160;</a></span>create_completion_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void create_completion_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create pipe for completion signaling to event loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a pipe that can be polled for DNS completion events. Used for integration with SocketPoll.</p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll for event multiplexing. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> for public API access to this pipe. </dd></dl>

</div>
</div>
<a id="ga94f5a6033fa425d4586553885a1dea47" name="ga94f5a6033fa425d4586553885a1dea47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f5a6033fa425d4586553885a1dea47">&#9670;&#160;</a></span>create_single_worker_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int create_single_worker_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a single worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">thread_index</td><td>Index of thread to create (0-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, errno on failure.</dd></dl>
<p>Creates one worker thread with proper attributes and error handling. </p>

</div>
</div>
<a id="gaa9424b326264ca67ebcd3b425836fd3e" name="gaa9424b326264ca67ebcd3b425836fd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9424b326264ca67ebcd3b425836fd3e">&#9670;&#160;</a></span>create_worker_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void create_worker_threads </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawn the configured number of DNS worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance (with num_workers set). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>if pthread_create() fails for any thread (ENOMEM, etc.).</td></tr>
  </table>
  </dd>
</dl>
<p>Creates dns-&gt;num_workers (default SOCKET_DNS_THREAD_COUNT) detached worker threads. Each thread runs <a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0" title="Main worker thread function for DNS resolution.">worker_thread()</a> loop until shutdown. Threads are stored in dns-&gt;workers array (arena-allocated).</p>
<dl class="section note"><dt>Note</dt><dd>Threads are created detached with default scheduling attributes. </dd>
<dd>
Partial success: some threads may start before failure; cleanup handles join. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - must be called under single thread during init.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga62b1aab7c7e7de783b56183c7a62863d" title="Configure thread attributes for worker thread creation.">setup_thread_attributes()</a> for thread config. </dd>
<dd>
<a class="el" href="group__dns.html#ga94f5a6033fa425d4586553885a1dea47" title="Create a single worker thread.">create_single_worker_thread()</a> low-level single thread creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0" title="Main worker thread function for DNS resolution.">worker_thread()</a> entry point for each thread. </dd>
<dd>
<a class="el" href="group__dns.html#ga6b30e5d8a0c4c61b78414c87fc2e6ad6" title="Signal worker threads to shut down.">shutdown_workers()</a> to stop all threads. </dd></dl>

</div>
</div>
<a id="gaf2ecd94190827e14a98bab9b52b3cd7d" name="gaf2ecd94190827e14a98bab9b52b3cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ecd94190827e14a98bab9b52b3cd7d">&#9670;&#160;</a></span>dequeue_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * dequeue_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return next request from processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next request to process, or NULL if queue empty.</dd></dl>
<p>Removes from queue head and updates queue_size counter. </p>

</div>
</div>
<a id="ga3a861e18294d856d7424ed8d7430d642" name="ga3a861e18294d856d7424ed8d7430d642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a861e18294d856d7424ed8d7430d642">&#9670;&#160;</a></span>destroy_dns_resources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_dns_resources </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all DNS resolver resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls all cleanup functions in proper order. Safe to call on partially initialized instances. </p>

</div>
</div>
<a id="ga08d853b1c769338c43c424a51f071876" name="ga08d853b1c769338c43c424a51f071876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d853b1c769338c43c424a51f071876">&#9670;&#160;</a></span>dns_cancellation_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dns_cancellation_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get error code indicating request was cancelled. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code for cancelled requests.</dd></dl>
<p>Returns EAI_NONAME as cancellation indicator. </p>

</div>
</div>
<a id="ga898228e143549696bc2d4e5d00f8965f" name="ga898228e143549696bc2d4e5d00f8965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898228e143549696bc2d4e5d00f8965f">&#9670;&#160;</a></span>drain_completion_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drain_completion_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drain all pending completion signals from pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads all available bytes from completion pipe to clear pending signals. </p>

</div>
</div>
<a id="gaf6a2fbf12055d3bcc4abb72a9f8cdea8" name="gaf6a2fbf12055d3bcc4abb72a9f8cdea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a2fbf12055d3bcc4abb72a9f8cdea8">&#9670;&#160;</a></span>free_all_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_all_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all pending and completed DNS requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gaa0d1b0f6a9b6fa146ef00d6ca9211684" title="Free all requests currently in the processing queue.">free_queued_requests()</a> and <a class="el" href="group__dns.html#ga4d2b657e4e48e6748189193c13195348" title="Free all requests currently in the hash table.">free_hash_table_requests()</a>. </p>

</div>
</div>
<a id="ga4d2b657e4e48e6748189193c13195348" name="ga4d2b657e4e48e6748189193c13195348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2b657e4e48e6748189193c13195348">&#9670;&#160;</a></span>free_hash_table_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_hash_table_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all requests currently in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees requests from all hash table buckets. </p>

</div>
</div>
<a id="gaa0d1b0f6a9b6fa146ef00d6ca9211684" name="gaa0d1b0f6a9b6fa146ef00d6ca9211684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d1b0f6a9b6fa146ef00d6ca9211684">&#9670;&#160;</a></span>free_queued_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_queued_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all requests currently in the processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees requests from queue_head/queue_tail linked list. </p>

</div>
</div>
<a id="gaa5ee93c269a62b9aa6c34c965b5d116a" name="gaa5ee93c269a62b9aa6c34c965b5d116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ee93c269a62b9aa6c34c965b5d116a">&#9670;&#160;</a></span>free_request_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_request_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_hash_next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a linked list of DNS requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Head of request list to free. </td></tr>
    <tr><td class="paramname">use_hash_next</td><td>Whether to use hash_next (1) or queue_next (0) for traversal.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees all requests in the list and their associated memory. </p>

</div>
</div>
<a id="ga0e26345eeede858bb5922a6109160037" name="ga0e26345eeede858bb5922a6109160037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e26345eeede858bb5922a6109160037">&#9670;&#160;</a></span>handle_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handle_request_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle timeout for a specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request that has timed out.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gad5067399f8c9930eb42f1e625899a3f7" title="Mark request as timed out with appropriate error code.">mark_request_timeout()</a> and signals completion. </p>

</div>
</div>
<a id="ga7570715dd7fcb113790e60bedd3139fb" name="ga7570715dd7fcb113790e60bedd3139fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7570715dd7fcb113790e60bedd3139fb">&#9670;&#160;</a></span>handle_resolution_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handle_resolution_result </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle result of DNS resolution attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request that was resolved. </td></tr>
    <tr><td class="paramname">result</td><td>Resolution result (NULL on error). </td></tr>
    <tr><td class="paramname">res</td><td>Error code from getaddrinfo().</td></tr>
  </table>
  </dd>
</dl>
<p>Updates request state, stores result, and signals completion. </p>

</div>
</div>
<a id="gac17573e4e80145c4c8dcd3e4dbef28b1" name="gac17573e4e80145c4c8dcd3e4dbef28b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17573e4e80145c4c8dcd3e4dbef28b1">&#9670;&#160;</a></span>hash_table_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_table_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert request into hash table for O(1) lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>Inserts request into hash table using pre-computed hash value. </p>

</div>
</div>
<a id="gadbfe83ac3fd8daf74a5189130d35eb54" name="gadbfe83ac3fd8daf74a5189130d35eb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbfe83ac3fd8daf74a5189130d35eb54">&#9670;&#160;</a></span>hash_table_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_table_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes request from hash table bucket chain. </p>

</div>
</div>
<a id="ga1e9801b10626b586b24b9f9c76b89fbb" name="ga1e9801b10626b586b24b9f9c76b89fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e9801b10626b586b24b9f9c76b89fbb">&#9670;&#160;</a></span>initialize_addrinfo_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_addrinfo_hints </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize addrinfo hints structure with defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hints</td><td>Hints structure to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets AF_UNSPEC, SOCK_STREAM, and AI_NUMERICSERV flags. </p>

</div>
</div>
<a id="ga558e7ea40aee65f859eef6c434f750e0" name="ga558e7ea40aee65f859eef6c434f750e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga558e7ea40aee65f859eef6c434f750e0">&#9670;&#160;</a></span>initialize_dns_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_dns_components </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>Pre-allocated DNS resolver structure (from <a class="el" href="group__dns.html#ga0c5a84436f8b4c2c2159a9ae95ec6e6f" title="Allocate and zero-initialize DNS resolver structure from heap memory.">allocate_dns_resolver()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on allocation failure (arena), synchronization init failure (pthread), pipe creation failure, or thread creation failure.</td></tr>
  </table>
  </dd>
</dl>
<p>Orchestrates full resolver setup:</p><ul>
<li>Arena allocation for requests/hostnames</li>
<li>Mutex and condition variables for queue/result signaling</li>
<li>Completion pipe for SocketPoll integration</li>
<li>Worker thread pool startup</li>
</ul>
<p>Must be called after <a class="el" href="group__dns.html#ga0c5a84436f8b4c2c2159a9ae95ec6e6f" title="Allocate and zero-initialize DNS resolver structure from heap memory.">allocate_dns_resolver()</a> and <a class="el" href="group__dns.html#ga6c7a4f5e6d71025f70a9ce5815567d19" title="Initialize basic DNS resolver fields to default values.">initialize_dns_fields()</a>. Handles partial failure cleanup via <a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a>. </p><dl class="section pre"><dt>Precondition</dt><dd>dns is allocated and fields initialized to defaults. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All internal state protected by mutex post-init. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - single-threaded initialization.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga0c5a84436f8b4c2c2159a9ae95ec6e6f" title="Allocate and zero-initialize DNS resolver structure from heap memory.">allocate_dns_resolver()</a> for structure allocation. </dd>
<dd>
<a class="el" href="group__dns.html#ga966920bebbea908c25400af44930fe59" title="Start DNS worker threads (transition from initialization to running).">start_dns_workers()</a> to signal workers active. </dd>
<dd>
<a class="el" href="group__dns.html#ga3a861e18294d856d7424ed8d7430d642" title="Destroy all DNS resolver resources.">destroy_dns_resources()</a> for symmetric cleanup. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> public wrapper. </dd></dl>

</div>
</div>
<a id="ga6c7a4f5e6d71025f70a9ce5815567d19" name="ga6c7a4f5e6d71025f70a9ce5815567d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c7a4f5e6d71025f70a9ce5815567d19">&#9670;&#160;</a></span>initialize_dns_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_dns_fields </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize basic DNS resolver fields to default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets all fields to safe defaults (NULL pointers, zero values). Called before <a class="el" href="group__dns.html#ga558e7ea40aee65f859eef6c434f750e0" title="Initialize core DNS resolver components: arena, synchronization primitives, pipe, and worker threads.">initialize_dns_components()</a>. </p>

</div>
</div>
<a id="ga93a54f32c13c556fda9cb00e58078075" name="ga93a54f32c13c556fda9cb00e58078075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a54f32c13c556fda9cb00e58078075">&#9670;&#160;</a></span>initialize_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_mutex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the main mutex protecting DNS resolver state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a recursive mutex for protecting all mutable resolver state. </p>

</div>
</div>
<a id="ga4e5821b121187c8fe5bdf8e5af7b76d7" name="ga4e5821b121187c8fe5bdf8e5af7b76d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5821b121187c8fe5bdf8e5af7b76d7">&#9670;&#160;</a></span>initialize_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize completion pipe (create + configure). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gafd2db132989e70ce194d307157648be2" title="Create pipe for completion signaling to event loops.">create_completion_pipe()</a> and <a class="el" href="group__dns.html#ga1a4a337f44614e431316266926e989ed" title="Set completion pipe to non-blocking mode.">set_pipe_nonblocking()</a>. </p>

</div>
</div>
<a id="ga06edd21b5cb02e131393e908502c2563" name="ga06edd21b5cb02e131393e908502c2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06edd21b5cb02e131393e908502c2563">&#9670;&#160;</a></span>initialize_queue_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_queue_condition </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize condition variable for queue empty/full signaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates condition variable used to wake worker threads when requests arrive. </p>

</div>
</div>
<a id="gad1dda38ff120421fec3f5f32adf367bc" name="gad1dda38ff120421fec3f5f32adf367bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1dda38ff120421fec3f5f32adf367bc">&#9670;&#160;</a></span>initialize_request_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_request_fields </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize request fields after allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request to initialize. </td></tr>
    <tr><td class="paramname">port</td><td>Port number for resolution. </td></tr>
    <tr><td class="paramname">callback</td><td>Completion callback (NULL for polling). </td></tr>
    <tr><td class="paramname">data</td><td>User data for callback.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets all request fields except host (which is set separately). </p>

</div>
</div>
<a id="ga08b07ff9ca818c6179416243aa5be0e3" name="ga08b07ff9ca818c6179416243aa5be0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b07ff9ca818c6179416243aa5be0e3">&#9670;&#160;</a></span>initialize_result_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_result_condition </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize condition variable for result availability signaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates condition variable used to wake polling threads when results complete. </p>

</div>
</div>
<a id="gaf875bcba3b535a0981600de2c0aa5720" name="gaf875bcba3b535a0981600de2c0aa5720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf875bcba3b535a0981600de2c0aa5720">&#9670;&#160;</a></span>initialize_synchronization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_synchronization </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all synchronization primitives (mutex + conditions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#ga93a54f32c13c556fda9cb00e58078075" title="Initialize the main mutex protecting DNS resolver state.">initialize_mutex()</a>, <a class="el" href="group__dns.html#ga06edd21b5cb02e131393e908502c2563" title="Initialize condition variable for queue empty/full signaling.">initialize_queue_condition()</a>, and <a class="el" href="group__dns.html#ga08b07ff9ca818c6179416243aa5be0e3" title="Initialize condition variable for result availability signaling.">initialize_result_condition()</a>. </p>

</div>
</div>
<a id="ga5049b49f719f1be126b489957a62c7d8" name="ga5049b49f719f1be126b489957a62c7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5049b49f719f1be126b489957a62c7d8">&#9670;&#160;</a></span>invoke_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void invoke_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke user callback for completed request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Completed request with result.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls req-&gt;callback with request, result, error, and user data. Callback executes in worker thread context. </p>

</div>
</div>
<a id="gad5067399f8c9930eb42f1e625899a3f7" name="gad5067399f8c9930eb42f1e625899a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5067399f8c9930eb42f1e625899a3f7">&#9670;&#160;</a></span>mark_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mark_request_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark request as timed out with appropriate error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to mark as timed out.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets state to REQ_COMPLETE, error to EAI_NONAME, and clears result. </p>

</div>
</div>
<a id="gac4cb4a632aba382e70ef8fcf90e942c3" name="gac4cb4a632aba382e70ef8fcf90e942c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4cb4a632aba382e70ef8fcf90e942c3">&#9670;&#160;</a></span>perform_dns_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int perform_dns_resolution </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform actual DNS resolution using getaddrinfo(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request containing hostname and port. </td></tr>
    <tr><td class="paramname">hints</td><td>addrinfo hints for resolution. </td></tr>
    <tr><td class="paramname">result</td><td>Output parameter for result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, getaddrinfo error code on failure.</dd></dl>
<p>Calls getaddrinfo() with hostname and service from request. </p>

</div>
</div>
<a id="ga84b432e1a64990d148474aab42fec110" name="ga84b432e1a64990d148474aab42fec110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b432e1a64990d148474aab42fec110">&#9670;&#160;</a></span>prepare_local_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prepare_local_hints </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>local_hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>base_hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare addrinfo hints for specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_hints</td><td>Output hints structure. </td></tr>
    <tr><td class="paramname">base_hints</td><td>Base hints to copy from. </td></tr>
    <tr><td class="paramname">req</td><td>Request providing port/service information.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies base hints and sets port from request. </p>

</div>
</div>
<a id="gaf1cf4dd4591c2d36325e9478b8f81901" name="gaf1cf4dd4591c2d36325e9478b8f81901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1cf4dd4591c2d36325e9478b8f81901">&#9670;&#160;</a></span>process_single_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process_single_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>base_hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a single DNS request from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to process. </td></tr>
    <tr><td class="paramname">base_hints</td><td>Base addrinfo hints for resolution.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs DNS resolution using getaddrinfo() with timeout checking. Updates request state and signals completion on finish. </p>

</div>
</div>
<a id="gae886927eaa45cdd51372735713b90058" name="gae886927eaa45cdd51372735713b90058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae886927eaa45cdd51372735713b90058">&#9670;&#160;</a></span>queue_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void queue_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append request to processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to queue.</td></tr>
  </table>
  </dd>
</dl>
<p>Adds request to end of FIFO queue and updates queue size. </p>

</div>
</div>
<a id="ga6c14a21d40420acc4820fa2ff503ca20" name="ga6c14a21d40420acc4820fa2ff503ca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c14a21d40420acc4820fa2ff503ca20">&#9670;&#160;</a></span>queue_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void queue_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatches to head or middle removal based on position. </p>

</div>
</div>
<a id="gaf136ad6b2c162ef7251dc25b2e1a7200" name="gaf136ad6b2c162ef7251dc25b2e1a7200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf136ad6b2c162ef7251dc25b2e1a7200">&#9670;&#160;</a></span>remove_from_queue_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_queue_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from queue head position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove (must be at queue head).</td></tr>
  </table>
  </dd>
</dl>
<p>Optimized removal when request is at queue head. </p>

</div>
</div>
<a id="gaa57962854d57cd4bad03222b31bf5036" name="gaa57962854d57cd4bad03222b31bf5036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57962854d57cd4bad03222b31bf5036">&#9670;&#160;</a></span>remove_from_queue_middle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_queue_middle </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from middle of queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove (not at head).</td></tr>
  </table>
  </dd>
</dl>
<p>Traverses queue to find and remove request from middle. </p>

</div>
</div>
<a id="ga33fdc34348f496c17c968499f90ef36c" name="ga33fdc34348f496c17c968499f90ef36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33fdc34348f496c17c968499f90ef36c">&#9670;&#160;</a></span>request_effective_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int request_effective_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get effective timeout for request (with fallback to default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Effective timeout in milliseconds.</dd></dl>
<p>Returns req-&gt;timeout_override_ms if &gt;= 0, otherwise dns-&gt;request_timeout_ms. </p>

</div>
</div>
<a id="gae79ec1f8c6638d30d082e8af45420837" name="gae79ec1f8c6638d30d082e8af45420837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79ec1f8c6638d30d082e8af45420837">&#9670;&#160;</a></span>request_hash_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned request_hash_function </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute hash value for request pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value for hash table lookup.</dd></dl>
<p>Uses <a class="el" href="group__foundation.html#ga0c1ed7481fd58c8cbb7e47b8a614b556" title="Hash pointer using golden ratio multiplicative.">socket_util_hash_ptr()</a> for deterministic hashing of request pointers.</p>
<dl class="section see"><dt>See also</dt><dd>SocketUtil for hash function <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utility Modules</a>. </dd></dl>

</div>
</div>
<a id="ga535554eb81b22d80ff8e72060293345b" name="ga535554eb81b22d80ff8e72060293345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535554eb81b22d80ff8e72060293345b">&#9670;&#160;</a></span>request_timed_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int request_timed_out </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if request has exceeded its timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if timed out, 0 if still within timeout.</dd></dl>
<p>Compares elapsed time since submission against effective timeout.</p>
<dl class="section see"><dt>See also</dt><dd>SocketTimer for timer management <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utility Modules</a>. </dd></dl>

</div>
</div>
<a id="ga1fab8535e6f7b9cd7213be1f35babf70" name="ga1fab8535e6f7b9cd7213be1f35babf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fab8535e6f7b9cd7213be1f35babf70">&#9670;&#160;</a></span>reset_dns_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset_dns_state </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset DNS resolver state to uninitialized values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears all pointers and resets counters. Called during destruction. </p>

</div>
</div>
<a id="ga1a4a337f44614e431316266926e989ed" name="ga1a4a337f44614e431316266926e989ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4a337f44614e431316266926e989ed">&#9670;&#160;</a></span>set_pipe_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_pipe_nonblocking </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set completion pipe to non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Ensures pipe reads/writes don't block, preventing deadlocks. </p>

</div>
</div>
<a id="ga62b1aab7c7e7de783b56183c7a62863d" name="ga62b1aab7c7e7de783b56183c7a62863d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b1aab7c7e7de783b56183c7a62863d">&#9670;&#160;</a></span>setup_thread_attributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setup_thread_attributes </td>
          <td>(</td>
          <td class="paramtype">pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure thread attributes for worker thread creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>Thread attributes structure to configure.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets thread attributes for detached, default-priority worker threads. </p>

</div>
</div>
<a id="ga6b30e5d8a0c4c61b78414c87fc2e6ad6" name="ga6b30e5d8a0c4c61b78414c87fc2e6ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b30e5d8a0c4c61b78414c87fc2e6ad6">&#9670;&#160;</a></span>shutdown_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shutdown_workers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal worker threads to shut down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets shutdown flag and broadcasts to wake all waiting threads. </p>

</div>
</div>
<a id="ga01e5cc089ceff56a8558e455b94c8254" name="ga01e5cc089ceff56a8558e455b94c8254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e5cc089ceff56a8558e455b94c8254">&#9670;&#160;</a></span>signal_completion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void signal_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal completion of DNS request to waiting threads/polls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes completion byte to pipe for SocketPoll integration. </p>

</div>
</div>
<a id="ga7ca6cf65c0823f0a23aa2c0c5cbe2223" name="ga7ca6cf65c0823f0a23aa2c0c5cbe2223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">&#9670;&#160;</a></span>SocketDNS_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Cancels a pending request. If resolution has already completed, this has no effect. The request handle becomes invalid after cancellation. Callbacks will not be invoked for cancelled requests.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> for retrieving completed results. </dd></dl>

</div>
</div>
<a id="gad8f2fa5ee464e84f44b4b6059b4813e5" name="gad8f2fa5ee464e84f44b4b6059b4813e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f2fa5ee464e84f44b4b6059b4813e5">&#9670;&#160;</a></span>SocketDNS_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for completed requests (non-blocking). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of completion signals drained (1 byte per completed/cancelled/timeout request). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - safe to call from any thread.</dt><dd></dd></dl>
<p>Drains the signal pipe for completed DNS events. Does not automatically retrieve results. For poll-mode requests (no callback), track your Request_T handles and call <a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> after draining to fetch completed results. Call when <a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> is readable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> for the file descriptor to monitor. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> for retrieving completed results. </dd></dl>

</div>
</div>
<a id="ga494e7ef72d567b90e5fdcb1df6501ea5" name="ga494e7ef72d567b90e5fdcb1df6501ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494e7ef72d567b90e5fdcb1df6501ea5">&#9670;&#160;</a></span>SocketDNS_create_completed_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> SocketDNS_create_completed_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a completed request from pre-resolved addrinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">result</td><td>Pre-resolved addrinfo result (caller transfers ownership). </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Request handle for completed request. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Creates a request that is already marked as complete with the provided result. Useful for synchronous resolution (e.g., wildcard bind) that doesn't need async DNS. The caller transfers ownership of the addrinfo result to the request.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> for retrieving the result. </dd>
<dd>
<a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with timeout guarantee.">SocketDNS_resolve_sync()</a> for synchronous resolution. </dd></dl>

</div>
</div>
<a id="gabdc83f21f67b5b8557f35d7ffa4c839c" name="gabdc83f21f67b5b8557f35d7ffa4c839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc83f21f67b5b8557f35d7ffa4c839c">&#9670;&#160;</a></span>SocketDNS_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a DNS resolver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>Pointer to resolver (will be set to NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Drains pending requests, signals worker threads to stop, and joins threads. Any pending requests that have not been retrieved are cancelled.</p>
<dl class="section user"><dt>Thread Safety\n Yes - safely shuts down thread pool.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> for cancelling individual requests. </dd></dl>

</div>
</div>
<a id="ga69d8d4c9f020bf781d541df7ecaf5acf" name="ga69d8d4c9f020bf781d541df7ecaf5acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d8d4c9f020bf781d541df7ecaf5acf">&#9670;&#160;</a></span>SocketDNS_geterror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_geterror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get error code for completed request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle (must have been returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> on this same resolver instance). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>getaddrinfo() error code, or 0 on success, or 0 if request does not belong to this resolver (invalid handle). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>IMPORTANT: Only use request handles returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> or <a class="el" href="group__dns.html#ga494e7ef72d567b90e5fdcb1df6501ea5" title="Create a completed request from pre-resolved addrinfo.">SocketDNS_create_completed_request()</a> on the SAME resolver instance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> for retrieving successful results. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd></dl>

</div>
</div>
<a id="ga68f007d40e50ed2894c962ee91509fcc" name="ga68f007d40e50ed2894c962ee91509fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f007d40e50ed2894c962ee91509fcc">&#9670;&#160;</a></span>SocketDNS_getmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketDNS_getmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum pending request capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current pending request limit. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7" title="Set maximum pending request capacity.">SocketDNS_setmaxpending()</a> for setting the limit. </dd></dl>

</div>
</div>
<a id="ga8f7c4c4455c9158ccd272fe8c15235b5" name="ga8f7c4c4455c9158ccd272fe8c15235b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7c4c4455c9158ccd272fe8c15235b5">&#9670;&#160;</a></span>SocketDNS_getresult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketDNS_getresult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get result of completed request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle (must have been returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> on this same resolver instance). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Completed addrinfo result or NULL if pending/error/cancelled/invalid. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Retrieves the result of a completed DNS resolution. Returns NULL if:</p><ul>
<li>Request is still pending</li>
<li>Request was cancelled</li>
<li>Resolution failed (check error via <a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a>)</li>
<li>Request does not belong to this resolver (invalid handle)</li>
<li>Callback was provided (callback already consumed the result)</li>
</ul>
<p>The caller owns the returned addrinfo structure and must call freeaddrinfo() when done. The request handle becomes invalid after the result is retrieved.</p>
<p>IMPORTANT: Only use request handles returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> or <a class="el" href="group__dns.html#ga494e7ef72d567b90e5fdcb1df6501ea5" title="Create a completed request from pre-resolved addrinfo.">SocketDNS_create_completed_request()</a> on the SAME resolver instance. Passing request handles from a different resolver is undefined behavior.</p>
<p>Performance: O(1) hash table lookup.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd>
<dd>
<a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a> for checking error status. </dd>
<dd>
<a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for poll-mode completion detection. </dd></dl>

</div>
</div>
<a id="ga2f4c54acbc79bbb31a4ce3ec75928ee8" name="ga2f4c54acbc79bbb31a4ce3ec75928ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4c54acbc79bbb31a4ce3ec75928ee8">&#9670;&#160;</a></span>SocketDNS_gettimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_gettimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get resolver request timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout in milliseconds (0 disables timeout). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0" title="Set resolver request timeout in milliseconds.">SocketDNS_settimeout()</a> for setting the timeout. </dd></dl>

</div>
</div>
<a id="ga799f4d96c77eef54ecb9be5523b591fd" name="ga799f4d96c77eef54ecb9be5523b591fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799f4d96c77eef54ecb9be5523b591fd">&#9670;&#160;</a></span>SocketDNS_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> SocketDNS_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new asynchronous DNS resolver. </p>
<dl class="section return"><dt>Returns</dt><dd>New DNS resolver instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on initialization failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - returns new instance.</dt><dd></dd></dl>
<p>Creates a thread pool for DNS resolution. Default thread count is SOCKET_DNS_THREAD_COUNT (configurable via <a class="el" href="SocketConfig_8h.html" title="Compile-time configuration and platform detection for the socket library.">SocketConfig.h</a>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Free a DNS resolver.">SocketDNS_free()</a> for cleanup. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for starting resolution requests. </dd>
<dd>
<a class="el" href="group__dns.html">Asynchronous DNS Resolution</a> for module overview and usage patterns. </dd></dl>

</div>
</div>
<a id="ga9228880ada42145db04298282b5f0c80" name="ga9228880ada42145db04298282b5f0c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9228880ada42145db04298282b5f0c80">&#9670;&#160;</a></span>SocketDNS_pollfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_pollfd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pollable file descriptor for SocketPoll integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File descriptor ready for reading when requests complete. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - returns stable file descriptor.</dt><dd></dd></dl>
<p>Returns a file descriptor (pipe or eventfd) that becomes readable when DNS resolution requests complete. Add this to SocketPoll with POLL_READ and call <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> when events occur. The file descriptor remains valid for the lifetime of the resolver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#structSocketPoll__T" title="Complete internal state for SocketPoll instance.">SocketPoll_T</a> for event polling. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System Modules</a> for SocketPoll integration patterns. </dd>
<dd>
<a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for processing completion events. </dd></dl>

</div>
</div>
<a id="ga9b27f46a350b3cfaf9a1092d94f81dd9" name="ga9b27f46a350b3cfaf9a1092d94f81dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b27f46a350b3cfaf9a1092d94f81dd9">&#9670;&#160;</a></span>SocketDNS_request_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_request_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override timeout for specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 disables timeout for this request). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0" title="Set resolver request timeout in milliseconds.">SocketDNS_settimeout()</a> for setting the default timeout. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd></dl>

</div>
</div>
<a id="ga380629d9c1650963341d1fe1dacd3253" name="ga380629d9c1650963341d1fe1dacd3253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga380629d9c1650963341d1fe1dacd3253">&#9670;&#160;</a></span>SocketDNS_resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> SocketDNS_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start asynchronous DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">host</td><td>Hostname or IP address to resolve (NULL for wildcard bind with AI_PASSIVE). </td></tr>
    <tr><td class="paramname">port</td><td>Port number (0 = no service/port in resolution, 1-65535 for specific port). </td></tr>
    <tr><td class="paramname">callback</td><td>Completion callback (NULL for SocketPoll integration). </td></tr>
    <tr><td class="paramname">data</td><td>User data passed to callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Request handle (never NULL). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on queue full or invalid parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Starts asynchronous DNS resolution. If callback is NULL, use SocketPoll integration: add <a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> to SocketPoll and call <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> on events. If callback is provided, it will be called from a worker thread when resolution completes (see SocketDNS_Callback documentation for safety).</p>
<p>When host is NULL, AI_PASSIVE flag is automatically set for wildcard bind operations. The request handle remains valid until:</p><ul>
<li>Result retrieved via <a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> (poll mode)</li>
<li>Callback invoked (callback mode - req invalid after callback returns)</li>
<li>Request cancelled via <a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a></li>
<li>Resolver freed via <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Free a DNS resolver.">SocketDNS_free()</a></li>
</ul>
<p>Performance: O(1) queue insertion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga88905fdf7322b96426e000683280445d" title="Callback function for async DNS resolution.">SocketDNS_Callback</a> for callback safety requirements. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get pollable file descriptor for SocketPoll integration.">SocketDNS_pollfd()</a> for event loop integration. </dd>
<dd>
<a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for polling completion. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Get result of completed request.">SocketDNS_getresult()</a> for retrieving results. </dd></dl>

</div>
</div>
<a id="gab988727825887d34e87d144d30c30c2f" name="gab988727825887d34e87d144d30c30c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab988727825887d34e87d144d30c30c2f">&#9670;&#160;</a></span>SocketDNS_resolve_sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketDNS_resolve_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronous DNS resolution with timeout guarantee. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance (NULL uses global default - not yet implemented). </td></tr>
    <tr><td class="paramname">host</td><td>Hostname to resolve (NULL for wildcard bind). </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
    <tr><td class="paramname">hints</td><td>Address hints (may be NULL for defaults). </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = use resolver default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>addrinfo result (caller must call freeaddrinfo()). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on error or timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses internal synchronization.</dt><dd></dd></dl>
<p>This function provides synchronous DNS resolution with GUARANTEED timeout. Unlike raw getaddrinfo() which can block for 30+ seconds, this function uses the async DNS worker thread pool internally and enforces the specified timeout using condition variable wait.</p>
<p>Use this function when you need blocking DNS resolution but cannot afford unbounded blocking time (e.g., in network servers handling untrusted input).</p>
<p>For IP addresses, resolution is instant (no DNS lookup needed).</p>
<p>Usage: struct addrinfo *res = SocketDNS_resolve_sync(dns, "example.com", 80, NULL, 5000); // Use res... freeaddrinfo(res);</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for asynchronous resolution. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for arena allocation patterns. </dd>
<dd>
<a class="el" href="group__dns.html">Asynchronous DNS Resolution</a> for asynchronous DNS resolution overview. </dd></dl>

</div>
</div>
<a id="ga55b33b7c9a44dc087be0f74b259d54f7" name="ga55b33b7c9a44dc087be0f74b259d54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b33b7c9a44dc087be0f74b259d54f7">&#9670;&#160;</a></span>SocketDNS_setmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_setmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum pending request capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">max_pending</td><td>New pending request limit (0 allows no pending requests). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>if max_pending &lt; current queue depth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga68f007d40e50ed2894c962ee91509fcc" title="Get maximum pending request capacity.">SocketDNS_getmaxpending()</a> for retrieving the current limit. </dd></dl>

</div>
</div>
<a id="ga390b733f1a522dcaccede3adf56fece0" name="ga390b733f1a522dcaccede3adf56fece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390b733f1a522dcaccede3adf56fece0">&#9670;&#160;</a></span>SocketDNS_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set resolver request timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 disables timeout). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga2f4c54acbc79bbb31a4ce3ec75928ee8" title="Get resolver request timeout in milliseconds.">SocketDNS_gettimeout()</a> for retrieving the current timeout. </dd></dl>

</div>
</div>
<a id="ga966920bebbea908c25400af44930fe59" name="ga966920bebbea908c25400af44930fe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966920bebbea908c25400af44930fe59">&#9670;&#160;</a></span>start_dns_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start_dns_workers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start DNS worker threads (transition from initialization to running). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Signals workers to begin processing requests from the queue. </p>

</div>
</div>
<a id="gadbc14c60ccd56fe1f73c7d52b04d0664" name="gadbc14c60ccd56fe1f73c7d52b04d0664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc14c60ccd56fe1f73c7d52b04d0664">&#9670;&#160;</a></span>store_resolution_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store_resolution_result </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store DNS resolution result in request structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to update. </td></tr>
    <tr><td class="paramname">result</td><td>Resolution result (NULL on error). </td></tr>
    <tr><td class="paramname">error</td><td>Error code (0 on success).</td></tr>
  </table>
  </dd>
</dl>
<p>Updates request state to REQ_COMPLETE and stores result/error. </p>

</div>
</div>
<a id="gadfd7ab93512c5ab94d32415eac07e69e" name="gadfd7ab93512c5ab94d32415eac07e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd7ab93512c5ab94d32415eac07e69e">&#9670;&#160;</a></span>submit_dns_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void submit_dns_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit request for processing by worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to submit.</td></tr>
  </table>
  </dd>
</dl>
<p>Inserts into hash table and queue, then signals workers. </p>

</div>
</div>
<a id="gabac4f41fc92ef0aec184eb3c8e6e10cb" name="gabac4f41fc92ef0aec184eb3c8e6e10cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac4f41fc92ef0aec184eb3c8e6e10cb">&#9670;&#160;</a></span>validate_resolve_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void validate_resolve_params </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate hostname and port parameters for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname string to validate. </td></tr>
    <tr><td class="paramname">port</td><td>Port number to validate.</td></tr>
  </table>
  </dd>
</dl>
<p>Validates that host is non-NULL, non-empty, and port is in valid range (1-65535). Raises SocketDNS_Failed exception on invalid parameters. </p>

</div>
</div>
<a id="ga516cbcd949e90804306ac10ec02af7cd" name="ga516cbcd949e90804306ac10ec02af7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516cbcd949e90804306ac10ec02af7cd">&#9670;&#160;</a></span>wait_for_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * wait_for_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a request to become available in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next request to process.</dd></dl>
<p>Blocks until request available or shutdown signaled. </p>

</div>
</div>
<a id="ga7f292c19cdf04ce4fb9f9a890b656cf0" name="ga7f292c19cdf04ce4fb9f9a890b656cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f292c19cdf04ce4fb9f9a890b656cf0">&#9670;&#160;</a></span>worker_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * worker_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main worker thread function for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Pointer to <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL (threads run until shutdown).</dd></dl>
<p>Worker thread main loop: wait for requests, process them, repeat. Handles shutdown signaling gracefully. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga329324a0e4a1450a6b968b375bb9b333" name="ga329324a0e4a1450a6b968b375bb9b333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329324a0e4a1450a6b968b375bb9b333">&#9670;&#160;</a></span>SocketDNS_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketDNS_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DNS resolution operation failure exception. </p>
<p>Category: NETWORK Retryable: YES - DNS servers may recover, cache may refresh</p>
<p>Raised when DNS resolution fails:</p><ul>
<li>Server unreachable (transient)</li>
<li>Query timeout (transient)</li>
<li>Invalid hostname (permanent)</li>
<li>NXDOMAIN (permanent)</li>
<li>Resource allocation failure</li>
<li>Thread pool initialization failure</li>
</ul>
<p>Check the error code from callback for specific failure reason. Transient failures (EAI_AGAIN, EAI_NODATA) are worth retrying. Permanent failures (EAI_NONAME, EAI_FAIL) should not be retried.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for resolution operations. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for initialization operations. </dd>
<dd>
foundation::Except_T for exception base type. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/>
<footer class="footer">
  <div style="max-width: 960px; margin: 0 auto; padding: 40px 24px;">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 40px;">
      <!-- Brand -->
      <div style="flex: 1; min-width: 200px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); border-radius: 6px;"></div>
          <span style="font-size: 1rem; font-weight: 600; color: #f7f9fa;">Socket Library</span>
        </div>
        <p style="color: #8b98a5; font-size: 0.8125rem; line-height: 1.6; margin: 0;">
          High-performance socket toolkit for POSIX systems with exception-based error handling and TLS 1.3 support.
        </p>
      </div>
      <!-- Links -->
      <div style="display: flex; gap: 48px; flex-wrap: wrap;">
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Documentation</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="index.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Getting Started</a></li>
            <li style="margin: 6px 0;"><a href="annotated.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Data Structures</a></li>
            <li style="margin: 6px 0;"><a href="globals.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">API Reference</a></li>
          </ul>
        </div>
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Resources</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="files.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Header Files</a></li>
            <li style="margin: 6px 0;"><a href="https://x.com/tetsuocorp" target="_blank" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Twitter/X</a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Bottom -->
    <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 0.75rem; font-weight: 500; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 4px 8px; border-radius: 4px;">C11</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 4px 8px; border-radius: 4px;">POSIX</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #8b5cf6; background: rgba(139, 92, 246, 0.1); padding: 4px 8px; border-radius: 4px;">TLS 1.3</span>
      </div>
      <div style="color: #6e7681; font-size: 0.75rem; display: flex; align-items: center; gap: 8px;">
        <span> 2025 Tetsuo Corporation</span>
        <span style="color: #30363d;"></span>
        <a href="https://opensource.org/licenses/MIT" target="_blank" style="color: #8b98a5; text-decoration: none;">MIT License</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
