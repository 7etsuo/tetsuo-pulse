<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="High-performance, exception-driven socket toolkit for POSIX systems">
<meta name="keywords" content="socket, networking, C, POSIX, TCP, UDP, TLS, async, high-performance, library">
<meta name="author" content="Tetsuo Corporation">
<meta name="theme-color" content="#3b82f6">
<title>Asynchronous DNS Resolution</title>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link href="socket-theme.css" rel="stylesheet" type="text/css"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' stop-color='%233b82f6'/><stop offset='100%25' stop-color='%238b5cf6'/></linearGradient></defs><rect width='100' height='100' rx='20' fill='url(%23g)'/><text x='50' y='68' font-size='50' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='bold'>S</text></svg>">
</head>
<body>
<div id="top">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">1.0.0</span></div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
  <td style="text-align: right; padding: 20px; vertical-align: middle;">
    <div style="display: flex; gap: 8px; justify-content: flex-end; flex-wrap: wrap; align-items: center;">
      <a href="index.html" class="quick-link">Home</a>
      <a href="annotated.html" class="quick-link">Structures</a>
      <a href="files.html" class="quick-link">Files</a>
      <a href="globals.html" class="quick-link">API</a>
    </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__dns.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Asynchronous DNS Resolution<div class="ingroups"><a class="el" href="group__core__io.html">Core I/O Modules</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Thread pool-based DNS resolution with guaranteed timeouts and SocketPoll integration.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Asynchronous DNS Resolution:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__dns.svg" width="388" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketDNS-private_8h" id="r_SocketDNS-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS-private_8h.html">SocketDNS-private.h</a></td></tr>
<tr class="memdesc:SocketDNS-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structures, enums, and prototypes for asynchronous DNS resolver implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketDNS_8h" id="r_SocketDNS_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDNS_8h.html">SocketDNS.h</a></td></tr>
<tr class="memdesc:SocketDNS_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous DNS resolution API for non-blocking network applications. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketDNS__Request__T" id="r_structSocketDNS__Request__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a></td></tr>
<tr class="memdesc:structSocketDNS__Request__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution request structure.  <a href="group__dns.html#structSocketDNS__Request__T">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__Request__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketDNS__CacheEntry" id="r_structSocketDNS__CacheEntry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a></td></tr>
<tr class="memdesc:structSocketDNS__CacheEntry"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS cache entry structure.  <a href="group__dns.html#structSocketDNS__CacheEntry">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__CacheEntry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketDNS__T" id="r_structSocketDNS__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td></tr>
<tr class="memdesc:structSocketDNS__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async DNS resolver structure.  <a href="group__dns.html#structSocketDNS__T">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketDNS__CacheStats" id="r_structSocketDNS__CacheStats"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#structSocketDNS__CacheStats">SocketDNS_CacheStats</a></td></tr>
<tr class="memdesc:structSocketDNS__CacheStats"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache statistics structure.  <a href="group__dns.html#structSocketDNS__CacheStats">More...</a><br /></td></tr>
<tr class="separator:structSocketDNS__CacheStats"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6aa3910745c244fe5ce4c66b7e31ce58" id="r_ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6aa3910745c244fe5ce4c66b7e31ce58">SIGNAL_DNS_COMPLETION</a>(dns)</td></tr>
<tr class="memdesc:ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal completion and wake waiters.  <br /></td></tr>
<tr class="separator:ga6aa3910745c244fe5ce4c66b7e31ce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa42bc1aa6036f871ffed2e5274c8b4d" id="r_gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gafa42bc1aa6036f871ffed2e5274c8b4d">SANITIZE_TIMEOUT_MS</a>(timeout_ms)&#160;&#160;&#160;((timeout_ms) &lt; 0 ? 0 : (timeout_ms))</td></tr>
<tr class="memdesc:gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize timeout value (negative -&gt; 0).  <br /></td></tr>
<tr class="separator:gafa42bc1aa6036f871ffed2e5274c8b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga47df31a4c5b1861e6bc33bf91effa388" id="r_ga47df31a4c5b1861e6bc33bf91effa388"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *, struct addrinfo *, int, void *)</td></tr>
<tr class="memdesc:ga47df31a4c5b1861e6bc33bf91effa388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback type invoked when DNS resolution finishes.  <br /></td></tr>
<tr class="separator:ga47df31a4c5b1861e6bc33bf91effa388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7a4f82232cde2b125b4b1e1df03b1f" id="r_gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a></td></tr>
<tr class="memdesc:gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to DNS resolution request structure.  <br /></td></tr>
<tr class="separator:gaec7a4f82232cde2b125b4b1e1df03b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88905fdf7322b96426e000683280445d" id="r_ga88905fdf7322b96426e000683280445d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga88905fdf7322b96426e000683280445d">SocketDNS_Callback</a>) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error, void *data)</td></tr>
<tr class="memdesc:ga88905fdf7322b96426e000683280445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for async DNS resolution.  <br /></td></tr>
<tr class="separator:ga88905fdf7322b96426e000683280445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabbf149223655194c14baa78907cb2dab" id="r_gabbf149223655194c14baa78907cb2dab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a> { <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634">REQ_PENDING</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec">REQ_PROCESSING</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016">REQ_COMPLETE</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111">REQ_CANCELLED</a>
<br />
 }</td></tr>
<tr class="memdesc:gabbf149223655194c14baa78907cb2dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of DNS request lifecycle states.  <a href="group__dns.html#gabbf149223655194c14baa78907cb2dab">More...</a><br /></td></tr>
<tr class="separator:gabbf149223655194c14baa78907cb2dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba752f803497a475aa1b96ed2351dd99" id="r_gaba752f803497a475aa1b96ed2351dd99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a> { <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941">DNS_CLEAN_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25">DNS_CLEAN_MUTEX</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc">DNS_CLEAN_CONDS</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca">DNS_CLEAN_PIPE</a>
, <br />
&#160;&#160;<a class="el" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb">DNS_CLEAN_ARENA</a>
<br />
 }</td></tr>
<tr class="memdesc:gaba752f803497a475aa1b96ed2351dd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Levels for partial cleanup during initialization failures.  <a href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">More...</a><br /></td></tr>
<tr class="separator:gaba752f803497a475aa1b96ed2351dd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga94f5a6033fa425d4586553885a1dea47" id="r_ga94f5a6033fa425d4586553885a1dea47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga94f5a6033fa425d4586553885a1dea47">create_single_worker_thread</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, int thread_index)</td></tr>
<tr class="memdesc:ga94f5a6033fa425d4586553885a1dea47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and zero-initialize DNS resolver structure from heap memory.  <br /></td></tr>
<tr class="separator:ga94f5a6033fa425d4586553885a1dea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9424b326264ca67ebcd3b425836fd3e" id="r_gaa9424b326264ca67ebcd3b425836fd3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e">create_worker_threads</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaa9424b326264ca67ebcd3b425836fd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn the configured number of DNS worker threads.  <br /></td></tr>
<tr class="separator:gaa9424b326264ca67ebcd3b425836fd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966920bebbea908c25400af44930fe59" id="r_ga966920bebbea908c25400af44930fe59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga966920bebbea908c25400af44930fe59">start_dns_workers</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga966920bebbea908c25400af44930fe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start DNS worker threads (transition from initialization to running).  <br /></td></tr>
<tr class="separator:ga966920bebbea908c25400af44930fe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a54f32c13c556fda9cb00e58078075" id="r_ga93a54f32c13c556fda9cb00e58078075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga93a54f32c13c556fda9cb00e58078075">initialize_mutex</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga93a54f32c13c556fda9cb00e58078075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the main mutex protecting DNS resolver state.  <br /></td></tr>
<tr class="separator:ga93a54f32c13c556fda9cb00e58078075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06edd21b5cb02e131393e908502c2563" id="r_ga06edd21b5cb02e131393e908502c2563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga06edd21b5cb02e131393e908502c2563">initialize_queue_condition</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga06edd21b5cb02e131393e908502c2563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable for queue empty/full signaling.  <br /></td></tr>
<tr class="separator:ga06edd21b5cb02e131393e908502c2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b07ff9ca818c6179416243aa5be0e3" id="r_ga08b07ff9ca818c6179416243aa5be0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga08b07ff9ca818c6179416243aa5be0e3">initialize_result_condition</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga08b07ff9ca818c6179416243aa5be0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable for result availability signaling.  <br /></td></tr>
<tr class="separator:ga08b07ff9ca818c6179416243aa5be0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf875bcba3b535a0981600de2c0aa5720" id="r_gaf875bcba3b535a0981600de2c0aa5720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf875bcba3b535a0981600de2c0aa5720">initialize_synchronization</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf875bcba3b535a0981600de2c0aa5720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all synchronization primitives (mutex + conditions).  <br /></td></tr>
<tr class="separator:gaf875bcba3b535a0981600de2c0aa5720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2db132989e70ce194d307157648be2" id="r_gafd2db132989e70ce194d307157648be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gafd2db132989e70ce194d307157648be2">create_completion_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gafd2db132989e70ce194d307157648be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create pipe for completion signaling to event loops.  <br /></td></tr>
<tr class="separator:gafd2db132989e70ce194d307157648be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4a337f44614e431316266926e989ed" id="r_ga1a4a337f44614e431316266926e989ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1a4a337f44614e431316266926e989ed">set_pipe_nonblocking</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga1a4a337f44614e431316266926e989ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set completion pipe to non-blocking mode.  <br /></td></tr>
<tr class="separator:ga1a4a337f44614e431316266926e989ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5821b121187c8fe5bdf8e5af7b76d7" id="r_ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga4e5821b121187c8fe5bdf8e5af7b76d7">initialize_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize completion pipe (create + configure).  <br /></td></tr>
<tr class="separator:ga4e5821b121187c8fe5bdf8e5af7b76d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350ef25d04ab2c551f69473a94faaee5" id="r_ga350ef25d04ab2c551f69473a94faaee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga350ef25d04ab2c551f69473a94faaee5">cleanup_mutex_cond</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga350ef25d04ab2c551f69473a94faaee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up mutex and condition variables.  <br /></td></tr>
<tr class="separator:ga350ef25d04ab2c551f69473a94faaee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26b2a24da54162a2a3aa842252aba6c" id="r_gad26b2a24da54162a2a3aa842252aba6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad26b2a24da54162a2a3aa842252aba6c">cleanup_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gad26b2a24da54162a2a3aa842252aba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up completion pipe.  <br /></td></tr>
<tr class="separator:gad26b2a24da54162a2a3aa842252aba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7611dac05257caaebe03fad6b799a65e" id="r_ga7611dac05257caaebe03fad6b799a65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e">cleanup_on_init_failure</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a> cleanup_level)</td></tr>
<tr class="memdesc:ga7611dac05257caaebe03fad6b799a65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up resources based on initialization failure level.  <br /></td></tr>
<tr class="separator:ga7611dac05257caaebe03fad6b799a65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b30e5d8a0c4c61b78414c87fc2e6ad6" id="r_ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6b30e5d8a0c4c61b78414c87fc2e6ad6">shutdown_workers</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal worker threads to shut down.  <br /></td></tr>
<tr class="separator:ga6b30e5d8a0c4c61b78414c87fc2e6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898228e143549696bc2d4e5d00f8965f" id="r_ga898228e143549696bc2d4e5d00f8965f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga898228e143549696bc2d4e5d00f8965f">drain_completion_pipe</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga898228e143549696bc2d4e5d00f8965f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drain all pending completion signals from pipe.  <br /></td></tr>
<tr class="separator:ga898228e143549696bc2d4e5d00f8965f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab8535e6f7b9cd7213be1f35babf70" id="r_ga1fab8535e6f7b9cd7213be1f35babf70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1fab8535e6f7b9cd7213be1f35babf70">reset_dns_state</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga1fab8535e6f7b9cd7213be1f35babf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset DNS resolver state to uninitialized values.  <br /></td></tr>
<tr class="separator:ga1fab8535e6f7b9cd7213be1f35babf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a861e18294d856d7424ed8d7430d642" id="r_ga3a861e18294d856d7424ed8d7430d642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga3a861e18294d856d7424ed8d7430d642">destroy_dns_resources</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga3a861e18294d856d7424ed8d7430d642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all DNS resolver resources.  <br /></td></tr>
<tr class="separator:ga3a861e18294d856d7424ed8d7430d642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ee93c269a62b9aa6c34c965b5d116a" id="r_gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa5ee93c269a62b9aa6c34c965b5d116a">free_request_list</a> (struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *head, int use_hash_next)</td></tr>
<tr class="memdesc:gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a linked list of DNS requests.  <br /></td></tr>
<tr class="separator:gaa5ee93c269a62b9aa6c34c965b5d116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d1b0f6a9b6fa146ef00d6ca9211684" id="r_gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa0d1b0f6a9b6fa146ef00d6ca9211684">free_queued_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all requests currently in the processing queue.  <br /></td></tr>
<tr class="separator:gaa0d1b0f6a9b6fa146ef00d6ca9211684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2b657e4e48e6748189193c13195348" id="r_ga4d2b657e4e48e6748189193c13195348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga4d2b657e4e48e6748189193c13195348">free_hash_table_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga4d2b657e4e48e6748189193c13195348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all requests currently in the hash table.  <br /></td></tr>
<tr class="separator:ga4d2b657e4e48e6748189193c13195348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a2fbf12055d3bcc4abb72a9f8cdea8" id="r_gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf6a2fbf12055d3bcc4abb72a9f8cdea8">free_all_requests</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all pending and completed DNS requests.  <br /></td></tr>
<tr class="separator:gaf6a2fbf12055d3bcc4abb72a9f8cdea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79ec1f8c6638d30d082e8af45420837" id="r_gae79ec1f8c6638d30d082e8af45420837"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gae79ec1f8c6638d30d082e8af45420837">request_hash_function</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gae79ec1f8c6638d30d082e8af45420837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hash value for request pointer.  <br /></td></tr>
<tr class="separator:gae79ec1f8c6638d30d082e8af45420837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021646b59321cc2b5ab7ca06895f7ed" id="r_ga5021646b59321cc2b5ab7ca06895f7ed"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5021646b59321cc2b5ab7ca06895f7ed">allocate_request_structure</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga5021646b59321cc2b5ab7ca06895f7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized request structure from resolver arena.  <br /></td></tr>
<tr class="separator:ga5021646b59321cc2b5ab7ca06895f7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae541ca39283e052d84495e5201a6fd" id="r_gacae541ca39283e052d84495e5201a6fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gacae541ca39283e052d84495e5201a6fd">allocate_request_hostname</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const char *host, size_t host_len)</td></tr>
<tr class="memdesc:gacae541ca39283e052d84495e5201a6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and copy hostname string for request.  <br /></td></tr>
<tr class="separator:gacae541ca39283e052d84495e5201a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dda38ff120421fec3f5f32adf367bc" id="r_gad1dda38ff120421fec3f5f32adf367bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad1dda38ff120421fec3f5f32adf367bc">initialize_request_fields</a> (struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> callback, void *data)</td></tr>
<tr class="memdesc:gad1dda38ff120421fec3f5f32adf367bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize request fields after allocation.  <br /></td></tr>
<tr class="separator:gad1dda38ff120421fec3f5f32adf367bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bac854631773fa0c56cd5e965cef525" id="r_ga5bac854631773fa0c56cd5e965cef525"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5bac854631773fa0c56cd5e965cef525">allocate_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const char *host, size_t host_len, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> cb, void *data)</td></tr>
<tr class="memdesc:ga5bac854631773fa0c56cd5e965cef525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize complete DNS request.  <br /></td></tr>
<tr class="separator:ga5bac854631773fa0c56cd5e965cef525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17573e4e80145c4c8dcd3e4dbef28b1" id="r_gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gac17573e4e80145c4c8dcd3e4dbef28b1">hash_table_insert</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert request into hash table for O(1) lookup.  <br /></td></tr>
<tr class="separator:gac17573e4e80145c4c8dcd3e4dbef28b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfe83ac3fd8daf74a5189130d35eb54" id="r_gadbfe83ac3fd8daf74a5189130d35eb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadbfe83ac3fd8daf74a5189130d35eb54">hash_table_remove</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gadbfe83ac3fd8daf74a5189130d35eb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from hash table.  <br /></td></tr>
<tr class="separator:gadbfe83ac3fd8daf74a5189130d35eb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf136ad6b2c162ef7251dc25b2e1a7200" id="r_gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf136ad6b2c162ef7251dc25b2e1a7200">remove_from_queue_head</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a DNS request to the end of the FIFO processing queue.  <br /></td></tr>
<tr class="separator:gaf136ad6b2c162ef7251dc25b2e1a7200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57962854d57cd4bad03222b31bf5036" id="r_gaa57962854d57cd4bad03222b31bf5036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaa57962854d57cd4bad03222b31bf5036">remove_from_queue_middle</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gaa57962854d57cd4bad03222b31bf5036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from middle of queue.  <br /></td></tr>
<tr class="separator:gaa57962854d57cd4bad03222b31bf5036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c14a21d40420acc4820fa2ff503ca20" id="r_ga6c14a21d40420acc4820fa2ff503ca20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga6c14a21d40420acc4820fa2ff503ca20">queue_remove</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga6c14a21d40420acc4820fa2ff503ca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove request from processing queue.  <br /></td></tr>
<tr class="separator:ga6c14a21d40420acc4820fa2ff503ca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39628720afa0f701ab8d3e9bcceeb21c" id="r_ga39628720afa0f701ab8d3e9bcceeb21c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga39628720afa0f701ab8d3e9bcceeb21c">check_queue_limit</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga39628720afa0f701ab8d3e9bcceeb21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if queue has reached capacity limit.  <br /></td></tr>
<tr class="separator:ga39628720afa0f701ab8d3e9bcceeb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd7ab93512c5ab94d32415eac07e69e" id="r_gadfd7ab93512c5ab94d32415eac07e69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadfd7ab93512c5ab94d32415eac07e69e">submit_dns_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gadfd7ab93512c5ab94d32415eac07e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit request for processing by worker threads.  <br /></td></tr>
<tr class="separator:gadfd7ab93512c5ab94d32415eac07e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e2afb20697e782942fa9ed48084a90" id="r_ga78e2afb20697e782942fa9ed48084a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga78e2afb20697e782942fa9ed48084a90">cancel_pending_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga78e2afb20697e782942fa9ed48084a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending request before it starts processing.  <br /></td></tr>
<tr class="separator:ga78e2afb20697e782942fa9ed48084a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fdc34348f496c17c968499f90ef36c" id="r_ga33fdc34348f496c17c968499f90ef36c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga33fdc34348f496c17c968499f90ef36c">request_effective_timeout_ms</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga33fdc34348f496c17c968499f90ef36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get effective timeout for request (with fallback to default).  <br /></td></tr>
<tr class="separator:ga33fdc34348f496c17c968499f90ef36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535554eb81b22d80ff8e72060293345b" id="r_ga535554eb81b22d80ff8e72060293345b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga535554eb81b22d80ff8e72060293345b">request_timed_out</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga535554eb81b22d80ff8e72060293345b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if request has exceeded its timeout.  <br /></td></tr>
<tr class="separator:ga535554eb81b22d80ff8e72060293345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5067399f8c9930eb42f1e625899a3f7" id="r_gad5067399f8c9930eb42f1e625899a3f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad5067399f8c9930eb42f1e625899a3f7">mark_request_timeout</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:gad5067399f8c9930eb42f1e625899a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark request as timed out with appropriate error code.  <br /></td></tr>
<tr class="separator:gad5067399f8c9930eb42f1e625899a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e26345eeede858bb5922a6109160037" id="r_ga0e26345eeede858bb5922a6109160037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga0e26345eeede858bb5922a6109160037">handle_request_timeout</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga0e26345eeede858bb5922a6109160037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle timeout for a specific request.  <br /></td></tr>
<tr class="separator:ga0e26345eeede858bb5922a6109160037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9801b10626b586b24b9f9c76b89fbb" id="r_ga1e9801b10626b586b24b9f9c76b89fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga1e9801b10626b586b24b9f9c76b89fbb">initialize_addrinfo_hints</a> (struct addrinfo *hints)</td></tr>
<tr class="memdesc:ga1e9801b10626b586b24b9f9c76b89fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize addrinfo hints structure with defaults.  <br /></td></tr>
<tr class="separator:ga1e9801b10626b586b24b9f9c76b89fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f292c19cdf04ce4fb9f9a890b656cf0" id="r_ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0">worker_thread</a> (void *arg)</td></tr>
<tr class="memdesc:ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main worker thread function for DNS resolution.  <br /></td></tr>
<tr class="separator:ga7f292c19cdf04ce4fb9f9a890b656cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b432e1a64990d148474aab42fec110" id="r_ga84b432e1a64990d148474aab42fec110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga84b432e1a64990d148474aab42fec110">prepare_local_hints</a> (struct addrinfo *local_hints, const struct addrinfo *base_hints, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga84b432e1a64990d148474aab42fec110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare addrinfo hints for specific request.  <br /></td></tr>
<tr class="separator:ga84b432e1a64990d148474aab42fec110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7570715dd7fcb113790e60bedd3139fb" id="r_ga7570715dd7fcb113790e60bedd3139fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7570715dd7fcb113790e60bedd3139fb">handle_resolution_result</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int res)</td></tr>
<tr class="memdesc:ga7570715dd7fcb113790e60bedd3139fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle result of DNS resolution attempt.  <br /></td></tr>
<tr class="separator:ga7570715dd7fcb113790e60bedd3139fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cf4dd4591c2d36325e9478b8f81901" id="r_gaf1cf4dd4591c2d36325e9478b8f81901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf1cf4dd4591c2d36325e9478b8f81901">process_single_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const struct addrinfo *base_hints)</td></tr>
<tr class="memdesc:gaf1cf4dd4591c2d36325e9478b8f81901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a single DNS request from the queue.  <br /></td></tr>
<tr class="separator:gaf1cf4dd4591c2d36325e9478b8f81901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd94190827e14a98bab9b52b3cd7d" id="r_gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaf2ecd94190827e14a98bab9b52b3cd7d">dequeue_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return next request from processing queue.  <br /></td></tr>
<tr class="separator:gaf2ecd94190827e14a98bab9b52b3cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516cbcd949e90804306ac10ec02af7cd" id="r_ga516cbcd949e90804306ac10ec02af7cd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga516cbcd949e90804306ac10ec02af7cd">wait_for_request</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga516cbcd949e90804306ac10ec02af7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a request to become available in the queue.  <br /></td></tr>
<tr class="separator:ga516cbcd949e90804306ac10ec02af7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e5cc089ceff56a8558e455b94c8254" id="r_ga01e5cc089ceff56a8558e455b94c8254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga01e5cc089ceff56a8558e455b94c8254">signal_completion</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:ga01e5cc089ceff56a8558e455b94c8254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal completion of DNS request to waiting threads/polls.  <br /></td></tr>
<tr class="separator:ga01e5cc089ceff56a8558e455b94c8254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc14c60ccd56fe1f73c7d52b04d0664" id="r_gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gadbc14c60ccd56fe1f73c7d52b04d0664">store_resolution_result</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error)</td></tr>
<tr class="memdesc:gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store DNS resolution result in request structure.  <br /></td></tr>
<tr class="separator:gadbc14c60ccd56fe1f73c7d52b04d0664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d853b1c769338c43c424a51f071876" id="r_ga08d853b1c769338c43c424a51f071876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga08d853b1c769338c43c424a51f071876">dns_cancellation_error</a> (void)</td></tr>
<tr class="memdesc:ga08d853b1c769338c43c424a51f071876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error code indicating request was cancelled.  <br /></td></tr>
<tr class="separator:ga08d853b1c769338c43c424a51f071876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4cb4a632aba382e70ef8fcf90e942c3" id="r_gac4cb4a632aba382e70ef8fcf90e942c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gac4cb4a632aba382e70ef8fcf90e942c3">perform_dns_resolution</a> (const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, const struct addrinfo *hints, struct addrinfo **result)</td></tr>
<tr class="memdesc:gac4cb4a632aba382e70ef8fcf90e942c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform actual DNS resolution using getaddrinfo().  <br /></td></tr>
<tr class="separator:gac4cb4a632aba382e70ef8fcf90e942c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5049b49f719f1be126b489957a62c7d8" id="r_ga5049b49f719f1be126b489957a62c7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga5049b49f719f1be126b489957a62c7d8">invoke_callback</a> (struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns, struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga5049b49f719f1be126b489957a62c7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke user callback for completed request.  <br /></td></tr>
<tr class="separator:ga5049b49f719f1be126b489957a62c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac4f41fc92ef0aec184eb3c8e6e10cb" id="r_gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabac4f41fc92ef0aec184eb3c8e6e10cb">validate_resolve_params</a> (const char *host, int port)</td></tr>
<tr class="memdesc:gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate hostname and port parameters for DNS resolution.  <br /></td></tr>
<tr class="separator:gabac4f41fc92ef0aec184eb3c8e6e10cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799f4d96c77eef54ecb9be5523b591fd" id="r_ga799f4d96c77eef54ecb9be5523b591fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a> (void)</td></tr>
<tr class="memdesc:ga799f4d96c77eef54ecb9be5523b591fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new asynchronous DNS resolver.  <br /></td></tr>
<tr class="separator:ga799f4d96c77eef54ecb9be5523b591fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc83f21f67b5b8557f35d7ffa4c839c" id="r_gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns)</td></tr>
<tr class="memdesc:gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of DNS resolver and release all resources.  <br /></td></tr>
<tr class="separator:gabdc83f21f67b5b8557f35d7ffa4c839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380629d9c1650963341d1fe1dacd3253" id="r_ga380629d9c1650963341d1fe1dacd3253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *host, int port, <a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a> callback, void *data)</td></tr>
<tr class="memdesc:ga380629d9c1650963341d1fe1dacd3253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous DNS resolution.  <br /></td></tr>
<tr class="separator:ga380629d9c1650963341d1fe1dacd3253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca6cf65c0823f0a23aa2c0c5cbe2223" id="r_ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">SocketDNS_cancel</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a pending DNS resolution.  <br /></td></tr>
<tr class="separator:ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f007d40e50ed2894c962ee91509fcc" id="r_ga68f007d40e50ed2894c962ee91509fcc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga68f007d40e50ed2894c962ee91509fcc">SocketDNS_getmaxpending</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga68f007d40e50ed2894c962ee91509fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum pending request capacity.  <br /></td></tr>
<tr class="separator:ga68f007d40e50ed2894c962ee91509fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b33b7c9a44dc087be0f74b259d54f7" id="r_ga55b33b7c9a44dc087be0f74b259d54f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7">SocketDNS_setmaxpending</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, size_t max_pending)</td></tr>
<tr class="memdesc:ga55b33b7c9a44dc087be0f74b259d54f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum pending request capacity.  <br /></td></tr>
<tr class="separator:ga55b33b7c9a44dc087be0f74b259d54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4c54acbc79bbb31a4ce3ec75928ee8" id="r_ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga2f4c54acbc79bbb31a4ce3ec75928ee8">SocketDNS_gettimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get resolver request timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga2f4c54acbc79bbb31a4ce3ec75928ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390b733f1a522dcaccede3adf56fece0" id="r_ga390b733f1a522dcaccede3adf56fece0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0">SocketDNS_settimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, int timeout_ms)</td></tr>
<tr class="memdesc:ga390b733f1a522dcaccede3adf56fece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set resolver request timeout in milliseconds.  <br /></td></tr>
<tr class="separator:ga390b733f1a522dcaccede3adf56fece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9228880ada42145db04298282b5f0c80" id="r_ga9228880ada42145db04298282b5f0c80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80">SocketDNS_pollfd</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga9228880ada42145db04298282b5f0c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file descriptor for integration with SocketPoll (completion notifications).  <br /></td></tr>
<tr class="separator:ga9228880ada42145db04298282b5f0c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f2fa5ee464e84f44b4b6059b4813e5" id="r_gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for completed requests (non-blocking).  <br /></td></tr>
<tr class="separator:gad8f2fa5ee464e84f44b4b6059b4813e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7c4c4455c9158ccd272fe8c15235b5" id="r_ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve completed DNS resolution result, transferring ownership to caller.  <br /></td></tr>
<tr class="separator:ga8f7c4c4455c9158ccd272fe8c15235b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d8d4c9f020bf781d541df7ecaf5acf" id="r_ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req)</td></tr>
<tr class="memdesc:ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get error code for completed request.  <br /></td></tr>
<tr class="separator:ga69d8d4c9f020bf781d541df7ecaf5acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b27f46a350b3cfaf9a1092d94f81dd9" id="r_ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga9b27f46a350b3cfaf9a1092d94f81dd9">SocketDNS_request_settimeout</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req, int timeout_ms)</td></tr>
<tr class="memdesc:ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override timeout for specific request.  <br /></td></tr>
<tr class="separator:ga9b27f46a350b3cfaf9a1092d94f81dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494e7ef72d567b90e5fdcb1df6501ea5" id="r_ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga494e7ef72d567b90e5fdcb1df6501ea5">SocketDNS_create_completed_request</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, struct addrinfo *result, int port)</td></tr>
<tr class="memdesc:ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a completed request from pre-resolved addrinfo.  <br /></td></tr>
<tr class="separator:ga494e7ef72d567b90e5fdcb1df6501ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab988727825887d34e87d144d30c30c2f" id="r_gab988727825887d34e87d144d30c30c2f"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f">SocketDNS_resolve_sync</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *host, int port, const struct addrinfo *hints, int timeout_ms)</td></tr>
<tr class="memdesc:gab988727825887d34e87d144d30c30c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous DNS resolution with optional timeout guarantee.  <br /></td></tr>
<tr class="separator:gab988727825887d34e87d144d30c30c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8642d0527ed406099dd2ca81cbcbc53" id="r_gac8642d0527ed406099dd2ca81cbcbc53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53">SocketDNS_cache_clear</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:gac8642d0527ed406099dd2ca81cbcbc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire DNS result cache.  <br /></td></tr>
<tr class="separator:gac8642d0527ed406099dd2ca81cbcbc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d75a5fca44d0543bcc7fccab2f3ebc0" id="r_ga8d75a5fca44d0543bcc7fccab2f3ebc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga8d75a5fca44d0543bcc7fccab2f3ebc0">SocketDNS_cache_remove</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char *hostname)</td></tr>
<tr class="memdesc:ga8d75a5fca44d0543bcc7fccab2f3ebc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specific hostname from the DNS cache.  <br /></td></tr>
<tr class="separator:ga8d75a5fca44d0543bcc7fccab2f3ebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf578d18322c0da146bfc52e236ae91d" id="r_gaaf578d18322c0da146bfc52e236ae91d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d">SocketDNS_cache_set_ttl</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, int ttl_seconds)</td></tr>
<tr class="memdesc:gaaf578d18322c0da146bfc52e236ae91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TTL (time-to-live) for cached DNS results.  <br /></td></tr>
<tr class="separator:gaaf578d18322c0da146bfc52e236ae91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358ec74cbdfba760e98798bb0269ec70" id="r_ga358ec74cbdfba760e98798bb0269ec70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga358ec74cbdfba760e98798bb0269ec70">SocketDNS_cache_set_max_entries</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, size_t max_entries)</td></tr>
<tr class="memdesc:ga358ec74cbdfba760e98798bb0269ec70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of entries in the DNS cache.  <br /></td></tr>
<tr class="separator:ga358ec74cbdfba760e98798bb0269ec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552e6fce7e0aabe57e4bdaa18bbc4dcd" id="r_ga552e6fce7e0aabe57e4bdaa18bbc4dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd">SocketDNS_cache_stats</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#structSocketDNS__CacheStats">SocketDNS_CacheStats</a> *stats)</td></tr>
<tr class="memdesc:ga552e6fce7e0aabe57e4bdaa18bbc4dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DNS cache statistics.  <br /></td></tr>
<tr class="separator:ga552e6fce7e0aabe57e4bdaa18bbc4dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd162147cc335b1d66ea31a6e70dba91" id="r_gafd162147cc335b1d66ea31a6e70dba91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gafd162147cc335b1d66ea31a6e70dba91">SocketDNS_prefer_ipv6</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, int prefer_ipv6)</td></tr>
<tr class="memdesc:gafd162147cc335b1d66ea31a6e70dba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IPv6 preference for DNS resolution.  <br /></td></tr>
<tr class="separator:gafd162147cc335b1d66ea31a6e70dba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13ffd5fe0baab4e755abb0c45bc78410" id="r_ga13ffd5fe0baab4e755abb0c45bc78410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga13ffd5fe0baab4e755abb0c45bc78410">SocketDNS_get_prefer_ipv6</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns)</td></tr>
<tr class="memdesc:ga13ffd5fe0baab4e755abb0c45bc78410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current IPv6 preference setting.  <br /></td></tr>
<tr class="separator:ga13ffd5fe0baab4e755abb0c45bc78410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686f6e19ce68debbdbb9638b1a60b573" id="r_ga686f6e19ce68debbdbb9638b1a60b573"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga686f6e19ce68debbdbb9638b1a60b573">SocketDNS_set_nameservers</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char **servers, size_t count)</td></tr>
<tr class="memdesc:ga686f6e19ce68debbdbb9638b1a60b573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom nameservers for DNS resolution.  <br /></td></tr>
<tr class="separator:ga686f6e19ce68debbdbb9638b1a60b573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01bb71c26d598319a2fdfe043bf455e" id="r_gae01bb71c26d598319a2fdfe043bf455e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#gae01bb71c26d598319a2fdfe043bf455e">SocketDNS_set_search_domains</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, const char **domains, size_t count)</td></tr>
<tr class="memdesc:gae01bb71c26d598319a2fdfe043bf455e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DNS search domains for hostname resolution.  <br /></td></tr>
<tr class="separator:gae01bb71c26d598319a2fdfe043bf455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga329324a0e4a1450a6b968b375bb9b333" id="r_ga329324a0e4a1450a6b968b375bb9b333"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html#ga329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a></td></tr>
<tr class="memdesc:ga329324a0e4a1450a6b968b375bb9b333"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS resolution operation failure exception.  <br /></td></tr>
<tr class="separator:ga329324a0e4a1450a6b968b375bb9b333"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Thread pool-based DNS resolution with guaranteed timeouts and SocketPoll integration. </p>
<p>Provides asynchronous DNS resolution using a thread pool to eliminate blocking getaddrinfo() calls that can take 30+ seconds during DNS failures. This addresses DoS vulnerabilities and enables truly non-blocking socket operations.</p>
<h2><a class="anchor" id="autotoc_md241"></a>
Architecture Overview</h2>
<div class="fragment"><div class="line"></div>
<div class="line">     Application Thread      </div>
<div class="line"> <a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>() calls   </div>
<div class="line"></div>
<div class="line">           queue request</div>
<div class="line"></div>
<div class="line">   <a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> (Main)        </div>
<div class="line">  - Mutex-protected queue    </div>
<div class="line">  - Hash table (requests)    </div>
<div class="line">  - Completion pipe FD       </div>
<div class="line">  - Condition vars (sync)    </div>
<div class="line"></div>
<div class="line">           signal workers</div>
<div class="line">   </div>
<div class="line">   Worker Threads Pool        getaddrinfo()   </div>
<div class="line">  - Process queue items          - System call   </div>
<div class="line">  - Perform getaddrinfo()        - Timeout check </div>
<div class="line">  - Signal completion           </div>
<div class="line"></div>
<div class="line">           write pipe</div>
<div class="line"></div>
<div class="line"> Completion Pipe (pollfd)      SocketPoll integration</div>
<div class="line"></div>
<div class="ttc" id="agroup__dns_html_ga380629d9c1650963341d1fe1dacd3253"><div class="ttname"><a href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a></div><div class="ttdeci">Request_T SocketDNS_resolve(SocketDNS_T dns, const char *host, int port, SocketDNS_Callback callback, void *data)</div><div class="ttdoc">Start asynchronous DNS resolution.</div></div>
<div class="ttc" id="agroup__dns_html_structSocketDNS__T"><div class="ttname"><a href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></div><div class="ttdoc">Async DNS resolver structure.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00260">SocketDNS-private.h:261</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md242"></a>
Key Features</h2>
<ul>
<li><b>Non-blocking</b>: No main-thread blocking; workers handle slow DNS.</li>
<li><b>Thread-safe</b>: Mutex protects shared state; callbacks in workers.</li>
<li><b>DoS Protection</b>: Bounded queue, timeouts prevent resource exhaustion.</li>
<li><b>Flexible</b>: Callback or poll mode for completion handling.</li>
<li><b>Sync Wrapper</b>: <a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with optional timeout guarantee.">SocketDNS_resolve_sync()</a> with guaranteed timeout.</li>
</ul>
<h2><a class="anchor" id="autotoc_md243"></a>
Module Relationships</h2>
<ul>
<li><b>Depends on</b>: <a class="el" href="group__foundation.html">Core Foundation Modules</a> (Arena_T, <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a>), core/SocketUtil (logging/metrics), socket/SocketCommon (address resolution utils).</li>
<li><b>Used by</b>: <a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> (SocketPool::prepare_connection, SocketReconnect), <a class="el" href="group__core__io.html">Core I/O Modules</a> (Socket::connect helpers).</li>
<li><b>Integrates with</b>: <a class="el" href="group__event__system.html">Event System Modules</a> (SocketPoll via completion pipe FD).</li>
</ul>
<h2><a class="anchor" id="autotoc_md244"></a>
Configuration Parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter   </th><th class="markdownTableHeadNone">Default   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_workers   </td><td class="markdownTableBodyNone">CPU cores   </td><td class="markdownTableBodyNone">Thread pool size   </td></tr>
</table>
<p>(SOCKET_DNS_DEFAULT_NUM_WORKERS) | | max_pending | 1000 | Queue capacity (SOCKET_DNS_MAX_PENDING) | | timeout_ms | 5000 | Default request timeout (SOCKET_DNS_DEFAULT_TIMEOUT_MS) |</p>
<h2><a class="anchor" id="autotoc_md245"></a>
Error Handling</h2>
<ul>
<li><b>Exceptions</b>: SocketDNS_Failed for init, queue full, invalid params.</li>
<li><b>getaddrinfo() Codes</b>: Passed via <a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a>; retryable: EAI_AGAIN.</li>
<li><b>Cancellation</b>: EAI_CANCELED for user-cancelled requests.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Callbacks execute in <b>worker threads</b>, NOT main thread! Ensure thread-safety; avoid shared mutable state without locks.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for async requests. </dd>
<dd>
<a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with optional timeout guarantee.">SocketDNS_resolve_sync()</a> for synchronous with timeout. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> and <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for event loop. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for detailed async patterns. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> for DoS protection details. </dd>
<dd>
docs/ERROR_HANDLING.md for exception and error codes.</dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> initialization. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> core async API. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> detailed async patterns. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> DoS protections. </dd>
<dd>
docs/ERROR_HANDLING.md error codes. </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketDNS__Request__T" id="structSocketDNS__Request__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__Request__T">&#9670;&#160;</a></span>SocketDNS_Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_Request_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DNS resolution request structure. </p>
<p>Opaque type for DNS resolution requests.</p>
<p>Opaque handle for a single DNS resolution request.</p>
<p>Represents a single DNS resolution request with all associated state. Allocated from the resolver's arena and lives until result is retrieved or request is cancelled.</p>
<p>Created by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>, used to retrieve results, cancel, or via callback. Lifetime managed by resolver; invalid after completion or cancellation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00211">211</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketDNS_Request_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketDNS__Request__T__coll__graph.svg" width="547" height="172"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac737e6e0a2823df1c6a562ed9094ef68" name="ac737e6e0a2823df1c6a562ed9094ef68"></a><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a></td>
<td class="fieldname">
callback</td>
<td class="fielddoc">
<p>Completion callback (NULL for polling) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abb8217588f38c05ae1ef9c52ec58975f" name="abb8217588f38c05ae1ef9c52ec58975f"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">void</a> *</td>
<td class="fieldname">
callback_data</td>
<td class="fielddoc">
<p>User data passed to callback </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afb60ae86fa4e34c68f4b19248c0a6224" name="afb60ae86fa4e34c68f4b19248c0a6224"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *</td>
<td class="fieldname">
dns_resolver</td>
<td class="fielddoc">
<p>Back-pointer to owning resolver </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3d233326169857dc18531189fe9c6b73" name="a3d233326169857dc18531189fe9c6b73"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">int</a></td>
<td class="fieldname">
error</td>
<td class="fielddoc">
<p><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">getaddrinfo()</a> error code (0 on success) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac8e64bed401754d3f9edde727173d215" name="ac8e64bed401754d3f9edde727173d215"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
hash_next</td>
<td class="fielddoc">
<p>Hash table chain pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4cd29363bd5fa627cf69f0b049396aa5" name="a4cd29363bd5fa627cf69f0b049396aa5"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">unsigned</a></td>
<td class="fieldname">
hash_value</td>
<td class="fielddoc">
<p>Cached hash for <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">O(1)</a> removal </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9f3fa1aca3eb39a39d6e3777fc49273" name="ac9f3fa1aca3eb39a39d6e3777fc49273"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">char</a> *</td>
<td class="fieldname">
host</td>
<td class="fielddoc">
<p>Hostname to resolve (arena-allocated) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7868d9891ef8b5565dfa9ed0c26d6444" name="a7868d9891ef8b5565dfa9ed0c26d6444"></a>int</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
<p>Port number for service lookup </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeddfbe59d08f55af648954a09ce13e1c" name="aeddfbe59d08f55af648954a09ce13e1c"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_next</td>
<td class="fielddoc">
<p>Queue linked list pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a66c651eeca12f843f19f01518b8ae931" name="a66c651eeca12f843f19f01518b8ae931"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">addrinfo</a> *</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>Resolution result (owned until retrieved) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a98bce03b9f775ac1d728d1f26b0b547b" name="a98bce03b9f775ac1d728d1f26b0b547b"></a><a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Current request lifecycle state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aaac0c7c61c58409bc34fb10f8f1319b9" name="aaac0c7c61c58409bc34fb10f8f1319b9"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">struct</a> <a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">timespec</a></td>
<td class="fieldname">
submit_time</td>
<td class="fielddoc">
<p>CLOCK_MONOTONIC submission timestamp </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a62225dfe2f1c26e94b46ceb012d52517" name="a62225dfe2f1c26e94b46ceb012d52517"></a><a class="el" href="group__dns.html#a7868d9891ef8b5565dfa9ed0c26d6444">int</a></td>
<td class="fieldname">
timeout_override_ms</td>
<td class="fielddoc">
<p>Per-request timeout (-1 = use default) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketDNS__CacheEntry" id="structSocketDNS__CacheEntry"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__CacheEntry">&#9670;&#160;</a></span>SocketDNS_CacheEntry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_CacheEntry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DNS cache entry structure. </p>
<p>Stores a cached DNS resolution result with TTL and LRU tracking. </p>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00234">234</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketDNS_CacheEntry:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketDNS__CacheEntry__coll__graph.svg" width="268" height="55"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a70aac2d4922733ec0d8695da28b3b576" name="a70aac2d4922733ec0d8695da28b3b576"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
hash_next</td>
<td class="fielddoc">
<p>Hash collision chain </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a255928a9675d7cf10546db358803aff9" name="a255928a9675d7cf10546db358803aff9"></a>char *</td>
<td class="fieldname">
hostname</td>
<td class="fielddoc">
<p>Cached hostname key </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acdc4f7c7982f99ed429b960d0136ef03" name="acdc4f7c7982f99ed429b960d0136ef03"></a>int64_t</td>
<td class="fieldname">
insert_time_ms</td>
<td class="fielddoc">
<p>Monotonic time of insertion </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a532f8a6cec51029299694060cc3e601f" name="a532f8a6cec51029299694060cc3e601f"></a>int64_t</td>
<td class="fieldname">
last_access_ms</td>
<td class="fielddoc">
<p>Monotonic time of last access (LRU) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afd50b3f49a48cb75f1701e077dbb6ba5" name="afd50b3f49a48cb75f1701e077dbb6ba5"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
lru_next</td>
<td class="fielddoc">
<p>LRU list next pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3fa811806204bac45715df62674e5058" name="a3fa811806204bac45715df62674e5058"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
lru_prev</td>
<td class="fielddoc">
<p>LRU list prev pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6a48c1dab59a852e8ff31dd5706171ad" name="a6a48c1dab59a852e8ff31dd5706171ad"></a>struct addrinfo *</td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>Cached addrinfo result (owned) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketDNS__T" id="structSocketDNS__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__T">&#9670;&#160;</a></span>SocketDNS_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Async DNS resolver structure. </p>
<p>Opaque handle for asynchronous DNS resolver.</p>
<p>Opaque type for DNS resolver instances.</p>
<p>Thread pool-based DNS resolver with queue management, hash table lookup, and pipe-based completion signaling for integration with SocketPoll.</p>
<p>SECURITY NOTE: The request hash table uses deterministic pointer-based hashing via <a class="el" href="group__foundation.html#ga0c1ed7481fd58c8cbb7e47b8a614b556" title="Hash pointer using golden ratio multiplicative.">socket_util_hash_ptr()</a>. While attackers cannot typically control memory allocation addresses, a large number of concurrent requests could theoretically cause hash collisions. This is mitigated by:</p><ul>
<li>max_pending limit (default SOCKET_DNS_MAX_PENDING = 1000)</li>
<li>Hash table size is prime (SOCKET_DNS_REQUEST_HASH_SIZE = 1021)</li>
<li>Worst case is O(n) lookup per bucket, not a security vulnerability</li>
</ul>
<p>Used by global DNS configuration functions for timeout guarantees in socket operations like bind() and connect().</p>
<p>Full API documentation in <a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API for non-blocking network applications.">SocketDNS.h</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API for non-blocking network applications.">SocketDNS.h</a> for complete DNS resolution API. </dd>
<dd>
<a class="el" href="group__core__io.html#ga70954c6e125769d15ffd6c3e31c89b75" title="Get global DNS resolver instance.">SocketCommon_get_dns_resolver()</a> for accessing the global instance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00260">260</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>
</div><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketDNS_T:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketDNS__T__coll__graph.svg" width="268" height="308"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adb82c384f91b26001b159b838dc2d153" name="adb82c384f91b26001b159b838dc2d153"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Arena for request/hostname allocation </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac0fa7dd0cc498c23a31a6f098b5722c3" name="ac0fa7dd0cc498c23a31a6f098b5722c3"></a>uint64_t</td>
<td class="fieldname">
cache_evictions</td>
<td class="fielddoc">
<p>Eviction counter </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a16f569bb317093051b79b32c1849e986" name="a16f569bb317093051b79b32c1849e986"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
cache_hash[1021]</td>
<td class="fielddoc">
<p>Cache hash table for O(1) lookup </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a95afde895cf101a50cb4a7d117272409" name="a95afde895cf101a50cb4a7d117272409"></a>uint64_t</td>
<td class="fieldname">
cache_hits</td>
<td class="fielddoc">
<p>Cache hit counter </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a93e8ba3f5a4605e1011252a7bd6fda05" name="a93e8ba3f5a4605e1011252a7bd6fda05"></a>uint64_t</td>
<td class="fieldname">
cache_insertions</td>
<td class="fielddoc">
<p>Insertion counter </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab293feab42fe174da5f435f83b674df5" name="ab293feab42fe174da5f435f83b674df5"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
cache_lru_head</td>
<td class="fielddoc">
<p>LRU list head (most recent) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a07d905f3bad8fcf64ca67c8403df16e0" name="a07d905f3bad8fcf64ca67c8403df16e0"></a>struct <a class="el" href="group__dns.html#structSocketDNS__CacheEntry">SocketDNS_CacheEntry</a> *</td>
<td class="fieldname">
cache_lru_tail</td>
<td class="fielddoc">
<p>LRU list tail (oldest) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a145218b12162a09a737407e6aacc63f5" name="a145218b12162a09a737407e6aacc63f5"></a>size_t</td>
<td class="fieldname">
cache_max_entries</td>
<td class="fielddoc">
<p>Maximum cache entries (0 = disabled) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae0a2004f91a93f8b0dc545f9218f1442" name="ae0a2004f91a93f8b0dc545f9218f1442"></a>uint64_t</td>
<td class="fieldname">
cache_misses</td>
<td class="fielddoc">
<p>Cache miss counter </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a48de60e4f89fdf4028b311c74af29dc5" name="a48de60e4f89fdf4028b311c74af29dc5"></a>size_t</td>
<td class="fieldname">
cache_size</td>
<td class="fielddoc">
<p>Current number of cached entries </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac7e264776c53a4d8d430e8904586540e" name="ac7e264776c53a4d8d430e8904586540e"></a>int</td>
<td class="fieldname">
cache_ttl_seconds</td>
<td class="fielddoc">
<p>TTL for cached entries (0 = disabled) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="affc9bb7fb07c068e65155ad2107ee947" name="affc9bb7fb07c068e65155ad2107ee947"></a>char **</td>
<td class="fieldname">
custom_nameservers</td>
<td class="fielddoc">
<p>Custom nameserver list (NULL = use system) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1bc6ad584684b38b8e086a9f41aa9f66" name="a1bc6ad584684b38b8e086a9f41aa9f66"></a>size_t</td>
<td class="fieldname">
max_pending</td>
<td class="fielddoc">
<p>Queue capacity limit </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2aaaddbe895c6d917cfbbd0aa0a61951" name="a2aaaddbe895c6d917cfbbd0aa0a61951"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
<p>Protects all mutable state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8c87e44fe98cb210e51d659ff95d1155" name="a8c87e44fe98cb210e51d659ff95d1155"></a>size_t</td>
<td class="fieldname">
nameserver_count</td>
<td class="fielddoc">
<p>Number of custom nameservers </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae5aa58d8c9a029fff13619993cdb8c3e" name="ae5aa58d8c9a029fff13619993cdb8c3e"></a>int</td>
<td class="fieldname">
num_workers</td>
<td class="fielddoc">
<p>Number of worker threads </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a04a850256d01d59de5d86b389b5afdc8" name="a04a850256d01d59de5d86b389b5afdc8"></a>int</td>
<td class="fieldname">
pipefd[2]</td>
<td class="fielddoc">
<p>Completion pipe [0]=read, [1]=write </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0b2b173de8cf17b724c383f24193ce1e" name="a0b2b173de8cf17b724c383f24193ce1e"></a>int</td>
<td class="fieldname">
prefer_ipv6</td>
<td class="fielddoc">
<p>1 = prefer IPv6, 0 = prefer IPv4 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad13012e13d0e2f6a9a2a18917249f45c" name="ad13012e13d0e2f6a9a2a18917249f45c"></a>pthread_cond_t</td>
<td class="fieldname">
queue_cond</td>
<td class="fielddoc">
<p>Signals workers when work available </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa4656138af397c9d59c119fdeb97a9a8" name="aa4656138af397c9d59c119fdeb97a9a8"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_head</td>
<td class="fielddoc">
<p>Request queue FIFO head </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a250c9a8eb40649ce94b504b229a8051c" name="a250c9a8eb40649ce94b504b229a8051c"></a>size_t</td>
<td class="fieldname">
queue_size</td>
<td class="fielddoc">
<p>Current pending request count </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1cb2f8d034a886ec86036844183004a1" name="a1cb2f8d034a886ec86036844183004a1"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
queue_tail</td>
<td class="fielddoc">
<p>Request queue FIFO tail </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4c961cf7ec05d782ed03f09cf3a0b699" name="a4c961cf7ec05d782ed03f09cf3a0b699"></a>struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *</td>
<td class="fieldname">
request_hash[1021]</td>
<td class="fielddoc">
<p>Hash table for O(1) request lookup </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a529eb3ddf6ec19b9eb13c9ee3d50267c" name="a529eb3ddf6ec19b9eb13c9ee3d50267c"></a>int</td>
<td class="fieldname">
request_timeout_ms</td>
<td class="fielddoc">
<p>Default timeout (0 = no timeout) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6b84353355d27005721631d66237fb89" name="a6b84353355d27005721631d66237fb89"></a>pthread_cond_t</td>
<td class="fieldname">
result_cond</td>
<td class="fielddoc">
<p>Signals waiters when result ready </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3ee59a2c0215806ac3af7cabeb61e7c3" name="a3ee59a2c0215806ac3af7cabeb61e7c3"></a>size_t</td>
<td class="fieldname">
search_domain_count</td>
<td class="fielddoc">
<p>Number of search domains </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6797750b5414b4ff70ae740e07d6dd1a" name="a6797750b5414b4ff70ae740e07d6dd1a"></a>char **</td>
<td class="fieldname">
search_domains</td>
<td class="fielddoc">
<p>Custom search domains (NULL = use system) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a026541a405efc2f27fff1a59e8d29add" name="a026541a405efc2f27fff1a59e8d29add"></a>int</td>
<td class="fieldname">
shutdown</td>
<td class="fielddoc">
<p>Shutdown flag (1 = shutting down) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9ac775dac4641b59cab189333cbcb63d" name="a9ac775dac4641b59cab189333cbcb63d"></a>pthread_t *</td>
<td class="fieldname">
workers</td>
<td class="fielddoc">
<p>Worker thread array (arena-allocated) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketDNS__CacheStats" id="structSocketDNS__CacheStats"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketDNS__CacheStats">&#9670;&#160;</a></span>SocketDNS_CacheStats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketDNS_CacheStats</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Cache statistics structure. </p>
<p>Statistics about DNS resolution cache performance. Used to monitor cache efficiency and tune TTL/size parameters.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd" title="Get DNS cache statistics.">SocketDNS_cache_stats()</a> to retrieve statistics. </dd>
<dd>
<a class="el" href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53" title="Clear the entire DNS result cache.">SocketDNS_cache_clear()</a> to reset cache. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00864">864</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae7b6f98198e752cc02f4e2bc650b5305" name="ae7b6f98198e752cc02f4e2bc650b5305"></a>size_t</td>
<td class="fieldname">
current_size</td>
<td class="fielddoc">
<p>Current number of cached entries </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab0a332ac89fb52b9f3d4bbe8d53e5c97" name="ab0a332ac89fb52b9f3d4bbe8d53e5c97"></a>uint64_t</td>
<td class="fieldname">
evictions</td>
<td class="fielddoc">
<p>Entries evicted due to TTL or size limits </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a40fdfc4bf0eaf4823e0fdb63ca381450" name="a40fdfc4bf0eaf4823e0fdb63ca381450"></a>double</td>
<td class="fieldname">
hit_rate</td>
<td class="fielddoc">
<p>Calculated hit rate (hits / (hits + misses)) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa2e8e3582926075d0695528e38ccad83" name="aa2e8e3582926075d0695528e38ccad83"></a>uint64_t</td>
<td class="fieldname">
hits</td>
<td class="fielddoc">
<p>Cache hits (result found in cache) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a908dc782db301d455dac01655b23df71" name="a908dc782db301d455dac01655b23df71"></a>uint64_t</td>
<td class="fieldname">
insertions</td>
<td class="fielddoc">
<p>Total entries inserted into cache </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6cb49fe4982b48272102d78ddf0b6846" name="a6cb49fe4982b48272102d78ddf0b6846"></a>size_t</td>
<td class="fieldname">
max_entries</td>
<td class="fielddoc">
<p>Maximum cache capacity </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acb32258f717bdb3a45390d2cced85bba" name="acb32258f717bdb3a45390d2cced85bba"></a>uint64_t</td>
<td class="fieldname">
misses</td>
<td class="fielddoc">
<p>Cache misses (resolution required) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8efca55d6c0863dd9c0067d7b89237ec" name="a8efca55d6c0863dd9c0067d7b89237ec"></a>int</td>
<td class="fieldname">
ttl_seconds</td>
<td class="fielddoc">
<p>Current TTL setting </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafa42bc1aa6036f871ffed2e5274c8b4d" name="gafa42bc1aa6036f871ffed2e5274c8b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa42bc1aa6036f871ffed2e5274c8b4d">&#9670;&#160;</a></span>SANITIZE_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SANITIZE_TIMEOUT_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout_ms</td><td>)</td>
          <td>&#160;&#160;&#160;((timeout_ms) &lt; 0 ? 0 : (timeout_ms))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sanitize timeout value (negative -&gt; 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if negative, otherwise original value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00324">324</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga6aa3910745c244fe5ce4c66b7e31ce58" name="ga6aa3910745c244fe5ce4c66b7e31ce58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa3910745c244fe5ce4c66b7e31ce58">&#9670;&#160;</a></span>SIGNAL_DNS_COMPLETION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNAL_DNS_COMPLETION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dns</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span>                                                                          \</div>
<div class="line">    {                                                                         \</div>
<div class="line">      signal_completion (dns);                                                \</div>
<div class="line">      pthread_cond_broadcast (&amp;(dns)-&gt;result_cond);                           \</div>
<div class="line">    }                                                                         \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Signal completion and wake waiters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Consolidates repeated signal_completion + pthread_cond_broadcast pattern. </p>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00310">310</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00149">149</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaec7a4f82232cde2b125b4b1e1df03b1f" name="gaec7a4f82232cde2b125b4b1e1df03b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7a4f82232cde2b125b4b1e1df03b1f">&#9670;&#160;</a></span>Request_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a>* <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to DNS resolution request structure. </p>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00165">165</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<a id="ga47df31a4c5b1861e6bc33bf91effa388" name="ga47df31a4c5b1861e6bc33bf91effa388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47df31a4c5b1861e6bc33bf91effa388">&#9670;&#160;</a></span>SocketDNS_Callback <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketDNS_Callback) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *, struct addrinfo *, int, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion callback type invoked when DNS resolution finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The original request handle (for identification). </td></tr>
    <tr><td class="paramname">result</td><td>Resolution results as addrinfo linked list, or NULL on error. </td></tr>
    <tr><td class="paramname">error</td><td>getaddrinfo() error code (0=success, see &lt;netdb.h&gt; for others). </td></tr>
    <tr><td class="paramname">data</td><td>User data passed to <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called from worker thread context upon completion (success, error, or timeout). </p><dl class="section note"><dt>Note</dt><dd>Executed in a dedicated DNS worker thread - NOT the thread that submitted the request. </dd>
<dd>
Must complete quickly; blocking stalls the worker pool. </dd>
<dd>
Takes ownership of 'result'; free with freeaddrinfo() after use. </dd>
<dd>
Do NOT call SocketDNS_free(dns) from callback (deadlock risk). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No automatic synchronization; user must protect shared data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> to submit request with callback. </dd>
<dd>
<a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388" title="Completion callback type invoked when DNS resolution finishes.">SocketDNS_Callback</a> safety notes in <a class="el" href="SocketDNS_8h.html" title="Asynchronous DNS resolution API for non-blocking network applications.">SocketDNS.h</a> documentation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00108">108</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="ga88905fdf7322b96426e000683280445d" name="ga88905fdf7322b96426e000683280445d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88905fdf7322b96426e000683280445d">&#9670;&#160;</a></span>SocketDNS_Callback <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketDNS_Callback) (<a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, struct addrinfo *result, int error, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for async DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request handle for this resolution. </td></tr>
    <tr><td class="paramname">result</td><td>Completed addrinfo result (NULL on error). </td></tr>
    <tr><td class="paramname">error</td><td>Error code from getaddrinfo() (0 on success). </td></tr>
    <tr><td class="paramname">data</td><td>User data passed to <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Called when DNS resolution completes. If result is NULL, error contains the getaddrinfo() error code.</p>
<p>OWNERSHIP: The callback receives ownership of the result addrinfo structure and MUST call freeaddrinfo() when done with it.</p>
<p>THREAD SAFETY WARNING: Callbacks are invoked from DNS WORKER THREADS, NOT from the application thread. The callback implementation MUST:</p>
<ul>
<li>Be thread-safe if accessing shared application data structures</li>
<li>Use proper synchronization (mutexes) when modifying shared state</li>
<li>NOT store the @req pointer (it becomes invalid after callback returns)</li>
<li>NOT call <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Dispose of DNS resolver and release all resources.">SocketDNS_free()</a> from within the callback (deadlock)</li>
<li>NOT perform long-running or blocking operations (blocks DNS workers)</li>
<li>Take ownership of <dl class="section return"><dt>Returns</dt><dd>immediately (copy if needed for later use)</dd></dl>
For applications that cannot safely handle worker-thread callbacks, use the SocketPoll integration pattern instead (pass NULL callback to SocketDNS_resolve and use SocketDNS_check/SocketDNS_getresult). </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SocketDNS_8h_source.html#l00225">225</a> of file <a class="el" href="SocketDNS_8h_source.html">SocketDNS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaba752f803497a475aa1b96ed2351dd99" name="gaba752f803497a475aa1b96ed2351dd99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba752f803497a475aa1b96ed2351dd99">&#9670;&#160;</a></span>DnsCleanupLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Levels for partial cleanup during initialization failures. </p>
<p>Defines cleanup scope for <a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> based on init progress. Values correspond to initialization order to enable reverse-order resource release. Used in TRY/EXCEPT blocks during <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> to ensure no leaks on failure.</p>
<dl class="section see"><dt>See also</dt><dd>initialize_dns_components() </dd>
<dd>
<a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> constructor exception handling.</dd></dl>
<p>Enum for DNS cleanup levels during partial failure recovery.</p>
<p>Defines levels corresponding to initialization stages, enabling precise resource cleanup on partial failure in <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a>. Values match order: mutex -&gt; conds -&gt; pipe -&gt; arena. Used in TRY/EXCEPT for exception-safe initialization.</p>
<dl class="section note"><dt>Note</dt><dd>Higher levels include cleanup for lower levels (reverse order). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for usage in constructor. </dd>
<dd>
<a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> for cleanup logic. </dd>
<dd>
initialize_dns_components() for init sequence. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941" name="ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941"></a>DNS_CLEAN_NONE&#160;</td><td class="fielddoc"><p>No cleanup needed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25" name="ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25"></a>DNS_CLEAN_MUTEX&#160;</td><td class="fielddoc"><p>Cleanup mutex only </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc" name="ggaba752f803497a475aa1b96ed2351dd99a2e24c3dd9e7450a52d40c9480eaccffc"></a>DNS_CLEAN_CONDS&#160;</td><td class="fielddoc"><p>Cleanup condition variables and mutex </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca" name="ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca"></a>DNS_CLEAN_PIPE&#160;</td><td class="fielddoc"><p>Cleanup pipe, conditions, and mutex </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb" name="ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb"></a>DNS_CLEAN_ARENA&#160;</td><td class="fielddoc"><p>Cleanup arena and all above </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00188">188</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<a id="gabbf149223655194c14baa78907cb2dab" name="gabbf149223655194c14baa78907cb2dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf149223655194c14baa78907cb2dab">&#9670;&#160;</a></span>RequestState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__dns.html#gabbf149223655194c14baa78907cb2dab">RequestState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of DNS request lifecycle states. </p>
<p>Defines the processing states for individual DNS resolution requests. Requests transition linearly: REQ_PENDING  REQ_PROCESSING  (REQ_COMPLETE | REQ_CANCELLED)</p>
<p>State transitions are atomic under mutex protection to ensure consistency across threads (submitters, workers, pollers). Used for:</p><ul>
<li>Queue management and worker assignment</li>
<li>Timeout detection and forced completion</li>
<li>Result availability checks</li>
<li><p class="startli">Cancellation safety</p>
<p class="startli">State Transition Table</p>
</li>
</ul>
<p>| State | Description | Transitions From | Actions Available | |----------&mdash;|-----------------------------------&mdash;|------------------------&mdash;|-------------------------&mdash;| | REQ_PENDING | Queued, waiting for worker | <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> | cancel, timeout check | | REQ_PROCESSING | Worker executing getaddrinfo() | Worker dequeues | no cancel (unsafe), timeout| | REQ_COMPLETE | Result ready, callback pending | getaddrinfo() success/error| getresult, invoke callback | | REQ_CANCELLED | User cancelled, no further action | <a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> | geterror (EAI_NONAME) |</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#a98bce03b9f775ac1d728d1f26b0b547b">SocketDNS_Request_T::state</a> field for storage. </dd>
<dd>
<a class="el" href="group__dns.html#gadfd7ab93512c5ab94d32415eac07e69e" title="Submit request for processing by worker threads.">submit_dns_request()</a> for PENDING insertion. </dd>
<dd>
<a class="el" href="group__dns.html#gaf1cf4dd4591c2d36325e9478b8f81901" title="Process a single DNS request from the queue.">process_single_request()</a> for PROCESSING  COMPLETE. </dd>
<dd>
<a class="el" href="group__dns.html#ga78e2afb20697e782942fa9ed48084a90" title="Cancel a pending request before it starts processing.">cancel_pending_request()</a> for CANCELLED transition. </dd>
<dd>
<a class="el" href="group__dns.html#ga535554eb81b22d80ff8e72060293345b" title="Check if request has exceeded its timeout.">request_timed_out()</a> for timeout handling. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634" name="ggabbf149223655194c14baa78907cb2daba7ead5ef092f0da5dc3697bef6e471634"></a>REQ_PENDING&#160;</td><td class="fielddoc"><p>Request enqueued, awaiting assignment to worker thread </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec" name="ggabbf149223655194c14baa78907cb2dabaee8f2ea0bc2ac29aebf50d119493c1ec"></a>REQ_PROCESSING&#160;</td><td class="fielddoc"><p>Dequeued and actively being resolved by worker (getaddrinfo active) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016" name="ggabbf149223655194c14baa78907cb2daba5018b6008cd3f54493a3eab0c3e29016"></a>REQ_COMPLETE&#160;</td><td class="fielddoc"><p>Resolution complete; result/error stored, ready for retrieval/callback </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111" name="ggabbf149223655194c14baa78907cb2daba8ee12f04250be78e34a7bdf0f08f2111"></a>REQ_CANCELLED&#160;</td><td class="fielddoc"><p>Cancelled by user before processing; no result produced </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketDNS-private_8h_source.html#l00151">151</a> of file <a class="el" href="SocketDNS-private_8h_source.html">SocketDNS-private.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5bac854631773fa0c56cd5e965cef525" name="ga5bac854631773fa0c56cd5e965cef525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bac854631773fa0c56cd5e965cef525">&#9670;&#160;</a></span>allocate_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * allocate_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>host_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and initialize complete DNS request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">host_len</td><td>Length of hostname. </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
    <tr><td class="paramname">cb</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">data</td><td>User callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Fully initialized request structure.</dd></dl>
<p>Combines allocation, hostname copying, and field initialization. </p>

</div>
</div>
<a id="gacae541ca39283e052d84495e5201a6fd" name="gacae541ca39283e052d84495e5201a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacae541ca39283e052d84495e5201a6fd">&#9670;&#160;</a></span>allocate_request_hostname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void allocate_request_hostname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>host_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and copy hostname string for request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to store hostname in. </td></tr>
    <tr><td class="paramname">host</td><td>Hostname string to copy. </td></tr>
    <tr><td class="paramname">host_len</td><td>Length of hostname string.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates hostname buffer from arena and copies host string. </p>

</div>
</div>
<a id="ga5021646b59321cc2b5ab7ca06895f7ed" name="ga5021646b59321cc2b5ab7ca06895f7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5021646b59321cc2b5ab7ca06895f7ed">&#9670;&#160;</a></span>allocate_request_structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * allocate_request_structure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate uninitialized request structure from resolver arena. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated request structure.</dd></dl>
<p>Allocates memory for request structure. Fields must be initialized before use. </p>

</div>
</div>
<a id="ga78e2afb20697e782942fa9ed48084a90" name="ga78e2afb20697e782942fa9ed48084a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e2afb20697e782942fa9ed48084a90">&#9670;&#160;</a></span>cancel_pending_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cancel_pending_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending request before it starts processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes from queue and hash table, marks as cancelled. </p>

</div>
</div>
<a id="ga39628720afa0f701ab8d3e9bcceeb21c" name="ga39628720afa0f701ab8d3e9bcceeb21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39628720afa0f701ab8d3e9bcceeb21c">&#9670;&#160;</a></span>check_queue_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int check_queue_limit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if queue has reached capacity limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if at limit, 0 if can accept more requests.</dd></dl>
<p>Compares current queue size against max_pending limit. </p>

</div>
</div>
<a id="ga350ef25d04ab2c551f69473a94faaee5" name="ga350ef25d04ab2c551f69473a94faaee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350ef25d04ab2c551f69473a94faaee5">&#9670;&#160;</a></span>cleanup_mutex_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_mutex_cond </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up mutex and condition variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroys mutex and condition variables. Safe to call multiple times. </p>

</div>
</div>
<a id="ga7611dac05257caaebe03fad6b799a65e" name="ga7611dac05257caaebe03fad6b799a65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7611dac05257caaebe03fad6b799a65e">&#9670;&#160;</a></span>cleanup_on_init_failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_on_init_failure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a>&#160;</td>
          <td class="paramname"><em>cleanup_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up resources based on initialization failure level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">cleanup_level</td><td>How much has been initialized (cleanup level).</td></tr>
  </table>
  </dd>
</dl>
<p>Used during initialization failure to clean up partially initialized state. Cleans up resources in reverse order of initialization. </p>

</div>
</div>
<a id="gad26b2a24da54162a2a3aa842252aba6c" name="gad26b2a24da54162a2a3aa842252aba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26b2a24da54162a2a3aa842252aba6c">&#9670;&#160;</a></span>cleanup_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up completion pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Closes pipe file descriptors and drains any pending data. </p>

</div>
</div>
<a id="gafd2db132989e70ce194d307157648be2" name="gafd2db132989e70ce194d307157648be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd2db132989e70ce194d307157648be2">&#9670;&#160;</a></span>create_completion_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void create_completion_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create pipe for completion signaling to event loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a pipe that can be polled for DNS completion events. Used for integration with SocketPoll.</p>
<dl class="section see"><dt>See also</dt><dd>SocketPoll for event multiplexing. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> for public API access to this pipe. </dd></dl>

</div>
</div>
<a id="ga94f5a6033fa425d4586553885a1dea47" name="ga94f5a6033fa425d4586553885a1dea47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f5a6033fa425d4586553885a1dea47">&#9670;&#160;</a></span>create_single_worker_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int create_single_worker_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and zero-initialize DNS resolver structure from heap memory. </p>
<p>Performs calloc(1, sizeof(struct SocketDNS_T)) for zero-initialization of all fields. Used during <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> bootstrap before arena allocation. Caller must subsequently call initialize_dns_fields() and other init functions.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated and zeroed <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on memory allocation failure (calloc failure).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - intended for single-threaded initialization in</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a>. <pre class="fragment">Usage Example
</pre> <div class="fragment"><div class="line">   <span class="keyword">struct </span><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns = <a class="code hl_function" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a>();</div>
<div class="line">   <span class="keywordflow">if</span> (dns == NULL) {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">struct </span><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> * <a class="code hl_function" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a> (<span class="keywordtype">void</span>);</div>
<div class="line">       <span class="comment">// Handle allocation failure (ENOMEM)</span></div>
<div class="line">       <a class="code hl_define" href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>);</div>
<div class="line">   }</div>
<div class="line">   <a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">       initialize_dns_fields(dns);</div>
<div class="line">       initialize_dns_components(dns);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> initialize_dns_components (<span class="keyword">struct</span> <a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns);</div>
<div class="line">       <span class="comment">// Success: dns ready for use</span></div>
<div class="line">   } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>) {</div>
<div class="line">       <a class="code hl_function" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e">cleanup_on_init_failure</a>(dns, <a class="code hl_enumvalue" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941">DNS_CLEAN_NONE</a>);  <span class="comment">// Or appropriate level</span></div>
<div class="line">       free(dns);</div>
<div class="line">       <a class="code hl_define" href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a>;</div>
<div class="line">   } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketDNS-private_8h_html_a0c5a84436f8b4c2c2159a9ae95ec6e6f"><div class="ttname"><a href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a></div><div class="ttdeci">struct SocketDNS_T * allocate_dns_resolver(void)</div></div>
<div class="ttc" id="aSocketDNS-private_8h_html_a329324a0e4a1450a6b968b375bb9b333"><div class="ttname"><a href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a></div><div class="ttdeci">const Except_T SocketDNS_Failed</div></div>
<div class="ttc" id="agroup__dns_html_ga7611dac05257caaebe03fad6b799a65e"><div class="ttname"><a href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e">cleanup_on_init_failure</a></div><div class="ttdeci">void cleanup_on_init_failure(struct SocketDNS_T *dns, enum DnsCleanupLevel cleanup_level)</div><div class="ttdoc">Clean up resources based on initialization failure level.</div></div>
<div class="ttc" id="agroup__dns_html_ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941"><div class="ttname"><a href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941">DNS_CLEAN_NONE</a></div><div class="ttdeci">@ DNS_CLEAN_NONE</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00190">SocketDNS-private.h:190</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga45e87c4d7dee50346b15c7761b0b340a"><div class="ttname"><a href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a></div><div class="ttdeci">#define RAISE(e)</div><div class="ttdoc">Raise an exception with current file and line information.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00636">Except.h:636</a></div></div>
<div class="ttc" id="agroup__foundation_html_gab5e72fc2bd41014c75e0ace4feabfe8e"><div class="ttname"><a href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a></div><div class="ttdeci">#define EXCEPT(e)</div><div class="ttdoc">Catch a specific exception type within a TRY block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01105">Except.h:1105</a></div></div>
<div class="ttc" id="agroup__foundation_html_gad2746371528bdf15c3910b7bf217dac0"><div class="ttname"><a href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a></div><div class="ttdeci">#define TRY</div><div class="ttdoc">Start a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00991">Except.h:991</a></div></div>
<div class="ttc" id="agroup__foundation_html_gae6628ac788ad213363b89dba9868420b"><div class="ttname"><a href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a></div><div class="ttdeci">#define END_TRY</div><div class="ttdoc">Complete a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01439">Except.h:1439</a></div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Heap allocation (not arena); arena is initialized later for requests. Caller owns the pointer until <a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> or <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Dispose of DNS resolver and release all resources.">SocketDNS_free()</a>.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single calloc() call.</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use directly; part of internal <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> implementation. Applications must use public <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>initialize_dns_fields() for field initialization. </dd>
<dd>
initialize_dns_components() for component setup (threads, sync primitives).</dd></dl>
<p>extern void initialize_dns_components (struct <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> *dns); </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> for error cleanup. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> public constructor that orchestrates this allocation.</dd></dl>
<p>Initialize basic DNS resolver fields to safe default values.</p>
<p>Sets all fields in the DNS resolver structure to safe defaults:</p><ul>
<li>NULL for pointers (arena, workers, queue pointers, hash table entries)</li>
<li>0/1 for counters and flags (num_workers, queue_size, shutdown, etc.)</li>
<li>Default values for configurable limits (max_pending, timeout)</li>
</ul>
<p>This ensures the structure is in a consistent state before component initialization (mutex, pipe, threads). Zero-initialization from calloc is supplemented with explicit defaults for clarity and future-proofing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dns</td><td>Pre-allocated DNS resolver structure (from <a class="el" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - called during single-threaded initialization.</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">   <span class="keyword">struct </span><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns = <a class="code hl_function" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a>();</div>
<div class="line">   <a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">       initialize_dns_fields(dns);  <span class="comment">// Set defaults</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> initialize_dns_fields (<span class="keyword">struct</span> <a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns);</div>
<div class="line">       <span class="comment">// Now safe to call initialize_dns_components(dns)</span></div>
<div class="line">   } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>) {</div>
<div class="line">       <span class="comment">// Minimal cleanup needed (already zeroed)</span></div>
<div class="line">   } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Explicitly sets defaults even after calloc() for code clarity and to handle future field additions without relying on zero-init.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct field assignments, no loops or allocations.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver()</a> for structure allocation. </dd>
<dd>
initialize_dns_components() next step after fields init. </dd>
<dd>
<a class="el" href="group__dns.html#ga1fab8535e6f7b9cd7213be1f35babf70" title="Reset DNS resolver state to uninitialized values.">reset_dns_state()</a> for symmetric reset during cleanup. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> orchestrating function.</dd></dl>
<p>Initialize core DNS resolver components including arena, sync primitives, pipe, and threads.</p>
<p>Orchestrates the complete setup of resolver internals:</p><ol type="1">
<li>Arena allocation for request structures and hostnames</li>
<li>Synchronization primitives (recursive mutex + 2 condition vars)</li>
<li>Non-blocking completion pipe for event loop integration</li>
<li>Worker thread pool creation (SOCKET_DNS_THREAD_COUNT threads)</li>
</ol>
<p>Uses TRY/EXCEPT blocks internally for exception-safe partial failure recovery. Cleanup levels track init progress for precise resource release on errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dns</td><td>Pre-allocated and field-initialized DNS resolver (from <a class="el" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver()</a> + initialize_dns_fields()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on:<ul>
<li><a class="el" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4" title="Create a new memory arena with initial capacity and thread-safe protection.">Arena_new()</a> failure (ENOMEM)</li>
<li>pthread_mutex_init() / pthread_cond_init() failure (EAGAIN, ENOMEM)</li>
<li>pipe() or socketpair() failure for completion signaling (EMFILE, EAFNOSUPPORT)</li>
<li>pthread_create() failure for workers (EAGAIN, EINVAL, EMFILE, EPERM)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - single-threaded initialization phase only.</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *dns = <a class="code hl_function" href="SocketDNS-private_8h.html#a0c5a84436f8b4c2c2159a9ae95ec6e6f">allocate_dns_resolver</a>();</div>
<div class="line"><span class="keyword">enum</span> <a class="code hl_enumeration" href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a> cleanup_level = <a class="code hl_enumvalue" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99aae3ddf1daeda71dca3b2cb763696b941">DNS_CLEAN_NONE</a>;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    initialize_dns_fields(dns);</div>
<div class="line">    cleanup_level = <a class="code hl_enumvalue" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25">DNS_CLEAN_MUTEX</a>;</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#gaf875bcba3b535a0981600de2c0aa5720">initialize_synchronization</a>(dns);  <span class="comment">// Or direct calls</span></div>
<div class="line">    cleanup_level = <a class="code hl_enumvalue" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca">DNS_CLEAN_PIPE</a>;</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#ga4e5821b121187c8fe5bdf8e5af7b76d7">initialize_pipe</a>(dns);</div>
<div class="line">    cleanup_level = <a class="code hl_enumvalue" href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb">DNS_CLEAN_ARENA</a>;</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e">create_worker_threads</a>(dns);</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#ga966920bebbea908c25400af44930fe59">start_dns_workers</a>(dns);</div>
<div class="line">    <span class="comment">// Full init complete - return dns to SocketDNS_new()</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>) {</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e">cleanup_on_init_failure</a>(dns, cleanup_level);</div>
<div class="line">    free(dns);</div>
<div class="line">    <a class="code hl_define" href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a>;</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__dns_html_ga4e5821b121187c8fe5bdf8e5af7b76d7"><div class="ttname"><a href="group__dns.html#ga4e5821b121187c8fe5bdf8e5af7b76d7">initialize_pipe</a></div><div class="ttdeci">void initialize_pipe(struct SocketDNS_T *dns)</div><div class="ttdoc">Initialize completion pipe (create + configure).</div></div>
<div class="ttc" id="agroup__dns_html_ga966920bebbea908c25400af44930fe59"><div class="ttname"><a href="group__dns.html#ga966920bebbea908c25400af44930fe59">start_dns_workers</a></div><div class="ttdeci">void start_dns_workers(struct SocketDNS_T *dns)</div><div class="ttdoc">Start DNS worker threads (transition from initialization to running).</div></div>
<div class="ttc" id="agroup__dns_html_gaa9424b326264ca67ebcd3b425836fd3e"><div class="ttname"><a href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e">create_worker_threads</a></div><div class="ttdeci">void create_worker_threads(struct SocketDNS_T *dns)</div><div class="ttdoc">Spawn the configured number of DNS worker threads.</div></div>
<div class="ttc" id="agroup__dns_html_gaba752f803497a475aa1b96ed2351dd99"><div class="ttname"><a href="group__dns.html#gaba752f803497a475aa1b96ed2351dd99">DnsCleanupLevel</a></div><div class="ttdeci">DnsCleanupLevel</div><div class="ttdoc">Levels for partial cleanup during initialization failures.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00188">SocketDNS-private.h:189</a></div></div>
<div class="ttc" id="agroup__dns_html_gaf875bcba3b535a0981600de2c0aa5720"><div class="ttname"><a href="group__dns.html#gaf875bcba3b535a0981600de2c0aa5720">initialize_synchronization</a></div><div class="ttdeci">void initialize_synchronization(struct SocketDNS_T *dns)</div><div class="ttdoc">Initialize all synchronization primitives (mutex + conditions).</div></div>
<div class="ttc" id="agroup__dns_html_ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca"><div class="ttname"><a href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a080e8c4f0bc500d949f6210704a156ca">DNS_CLEAN_PIPE</a></div><div class="ttdeci">@ DNS_CLEAN_PIPE</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00193">SocketDNS-private.h:193</a></div></div>
<div class="ttc" id="agroup__dns_html_ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25"><div class="ttname"><a href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99a615acce89a6c289fce7fd44bd35b0d25">DNS_CLEAN_MUTEX</a></div><div class="ttdeci">@ DNS_CLEAN_MUTEX</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00191">SocketDNS-private.h:191</a></div></div>
<div class="ttc" id="agroup__dns_html_ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb"><div class="ttname"><a href="group__dns.html#ggaba752f803497a475aa1b96ed2351dd99afbae8735e6a307a7f4eea386f3d5afbb">DNS_CLEAN_ARENA</a></div><div class="ttdeci">@ DNS_CLEAN_ARENA</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00195">SocketDNS-private.h:194</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Recursive mutex allows nested locking during init/cleanup. </dd>
<dd>
Pipe FD [0] is pollfd for reading completions; [1] for writing signals. </dd>
<dd>
Worker threads start in suspended state until <a class="el" href="group__dns.html#ga966920bebbea908c25400af44930fe59" title="Start DNS worker threads (transition from initialization to running).">start_dns_workers()</a>.</dd></dl>
<dl class="section user"><dt>Complexity\n O(n) where n = number of worker threads (typically small, ~4-8).</dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Partial failures cleaned up automatically; do not reuse partially init dns. </dd>
<dd>
Thread creation may fail under resource exhaustion (ulimit -u).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>dns-&gt;arena == NULL, dns-&gt;workers == NULL, dns-&gt;mutex uninitialized, etc. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga7611dac05257caaebe03fad6b799a65e" title="Clean up resources based on initialization failure level.">cleanup_on_init_failure()</a> for symmetric error handling. </dd>
<dd>
<a class="el" href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e" title="Spawn the configured number of DNS worker threads.">create_worker_threads()</a> for thread spawning details. </dd>
<dd>
<a class="el" href="group__dns.html#gaf875bcba3b535a0981600de2c0aa5720" title="Initialize all synchronization primitives (mutex + conditions).">initialize_synchronization()</a> / <a class="el" href="group__dns.html#ga4e5821b121187c8fe5bdf8e5af7b76d7" title="Initialize completion pipe (create + configure).">initialize_pipe()</a> sub-components. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> public API entry point. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for async integration patterns.</dd></dl>
<p>Configure pthread attributes for DNS worker threads.</p>
<p>Sets up thread attributes for detached operation with default stack size and scheduling policy. Ensures workers run independently without join requirements during shutdown.</p>
<p>Specific settings:</p><ul>
<li>Detached state: PTHREAD_CREATE_DETACHED (no pthread_join needed)</li>
<li>Inherit scheduler: PTHREAD_EXPLICIT_SCHED not set (inherits parent)</li>
<li>Default stack size and guards (platform defaults)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">attr</td><td>Pointer to pthread_attr_t structure to configure. Must be initialized (via pthread_attr_init) before call. Modified in place with worker-specific attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void - raises SocketDNS_Failed on pthread_attr_* failure (rare). Implementation uses TRY/EXCEPT internally.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>if pthread_attr_setdetachstate() or other attr calls fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - reentrant, modifies local attr structure only.</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">pthread_attr_t attr;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    pthread_attr_init(&amp;attr);</div>
<div class="line">    setup_thread_attributes(&amp;attr);</div>
<div class="line">    <span class="comment">// Now attr is ready for pthread_create()</span></div>
<div class="line">    <span class="keywordtype">int</span> ret = pthread_create(&amp;thread_id, &amp;attr, <a class="code hl_function" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0">worker_thread</a>, dns);</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0) RAISE_FMT(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>, <span class="stringliteral">&quot;pthread_create failed: %s&quot;</span>,</div>
<div class="line">strerror(ret)); } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    pthread_attr_destroy(&amp;attr);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__dns_html_ga7f292c19cdf04ce4fb9f9a890b656cf0"><div class="ttname"><a href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0">worker_thread</a></div><div class="ttdeci">void * worker_thread(void *arg)</div><div class="ttdoc">Main worker thread function for DNS resolution.</div></div>
<div class="ttc" id="agroup__foundation_html_ga0e2a75478cd44f1666a6aca626c5c50b"><div class="ttname"><a href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a></div><div class="ttdeci">#define FINALLY</div><div class="ttdoc">Define cleanup code that executes regardless of exceptions.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01326">Except.h:1326</a></div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(1) - fixed number of pthread_attr_* calls.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Detached threads simplify shutdown; no explicit joins required. </dd>
<dd>
Defaults to platform scheduler policy (SCHED_OTHER typically).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Caller must pthread_attr_destroy(&amp;attr) after use, even on failure. Caller must pthread_attr_init(&amp;attr) before calling this function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga94f5a6033fa425d4586553885a1dea47" title="Allocate and zero-initialize DNS resolver structure from heap memory.">create_single_worker_thread()</a> for using configured attributes. </dd>
<dd>
<a class="el" href="group__dns.html#gaa9424b326264ca67ebcd3b425836fd3e" title="Spawn the configured number of DNS worker threads.">create_worker_threads()</a> for multi-thread creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0" title="Main worker thread function for DNS resolution.">worker_thread()</a> thread entry point. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> high-level initialization.</dd></dl>
<p>Create a single worker thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">thread_index</td><td>Index of thread to create (0-based). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, errno on failure.</dd></dl>
<p>Creates one worker thread with proper attributes and error handling. </p>

</div>
</div>
<a id="gaa9424b326264ca67ebcd3b425836fd3e" name="gaa9424b326264ca67ebcd3b425836fd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9424b326264ca67ebcd3b425836fd3e">&#9670;&#160;</a></span>create_worker_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void create_worker_threads </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawn the configured number of DNS worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance (with num_workers set). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>if pthread_create() fails for any thread (ENOMEM, etc.).</td></tr>
  </table>
  </dd>
</dl>
<p>Creates dns-&gt;num_workers (default SOCKET_DNS_THREAD_COUNT) detached worker threads. Each thread runs <a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0" title="Main worker thread function for DNS resolution.">worker_thread()</a> loop until shutdown. Threads are stored in dns-&gt;workers array (arena-allocated).</p>
<dl class="section note"><dt>Note</dt><dd>Threads are created detached with default scheduling attributes. </dd>
<dd>
Partial success: some threads may start before failure; cleanup handles join. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - must be called under single thread during init.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>setup_thread_attributes() for thread config. </dd>
<dd>
<a class="el" href="group__dns.html#ga94f5a6033fa425d4586553885a1dea47" title="Allocate and zero-initialize DNS resolver structure from heap memory.">create_single_worker_thread()</a> low-level single thread creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga7f292c19cdf04ce4fb9f9a890b656cf0" title="Main worker thread function for DNS resolution.">worker_thread()</a> entry point for each thread. </dd>
<dd>
<a class="el" href="group__dns.html#ga6b30e5d8a0c4c61b78414c87fc2e6ad6" title="Signal worker threads to shut down.">shutdown_workers()</a> to stop all threads. </dd></dl>

</div>
</div>
<a id="gaf2ecd94190827e14a98bab9b52b3cd7d" name="gaf2ecd94190827e14a98bab9b52b3cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ecd94190827e14a98bab9b52b3cd7d">&#9670;&#160;</a></span>dequeue_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * dequeue_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return next request from processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next request to process, or NULL if queue empty.</dd></dl>
<p>Removes from queue head and updates queue_size counter. </p>

</div>
</div>
<a id="ga3a861e18294d856d7424ed8d7430d642" name="ga3a861e18294d856d7424ed8d7430d642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a861e18294d856d7424ed8d7430d642">&#9670;&#160;</a></span>destroy_dns_resources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_dns_resources </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all DNS resolver resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls all cleanup functions in proper order. Safe to call on partially initialized instances. </p>

</div>
</div>
<a id="ga08d853b1c769338c43c424a51f071876" name="ga08d853b1c769338c43c424a51f071876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d853b1c769338c43c424a51f071876">&#9670;&#160;</a></span>dns_cancellation_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dns_cancellation_error </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get error code indicating request was cancelled. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code for cancelled requests.</dd></dl>
<p>Returns EAI_NONAME as cancellation indicator. </p>

</div>
</div>
<a id="ga898228e143549696bc2d4e5d00f8965f" name="ga898228e143549696bc2d4e5d00f8965f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898228e143549696bc2d4e5d00f8965f">&#9670;&#160;</a></span>drain_completion_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drain_completion_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drain all pending completion signals from pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads all available bytes from completion pipe to clear pending signals. </p>

</div>
</div>
<a id="gaf6a2fbf12055d3bcc4abb72a9f8cdea8" name="gaf6a2fbf12055d3bcc4abb72a9f8cdea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a2fbf12055d3bcc4abb72a9f8cdea8">&#9670;&#160;</a></span>free_all_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_all_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all pending and completed DNS requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gaa0d1b0f6a9b6fa146ef00d6ca9211684" title="Free all requests currently in the processing queue.">free_queued_requests()</a> and <a class="el" href="group__dns.html#ga4d2b657e4e48e6748189193c13195348" title="Free all requests currently in the hash table.">free_hash_table_requests()</a>. </p>

</div>
</div>
<a id="ga4d2b657e4e48e6748189193c13195348" name="ga4d2b657e4e48e6748189193c13195348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2b657e4e48e6748189193c13195348">&#9670;&#160;</a></span>free_hash_table_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_hash_table_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all requests currently in the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees requests from all hash table buckets. </p>

</div>
</div>
<a id="gaa0d1b0f6a9b6fa146ef00d6ca9211684" name="gaa0d1b0f6a9b6fa146ef00d6ca9211684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d1b0f6a9b6fa146ef00d6ca9211684">&#9670;&#160;</a></span>free_queued_requests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_queued_requests </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all requests currently in the processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees requests from queue_head/queue_tail linked list. </p>

</div>
</div>
<a id="gaa5ee93c269a62b9aa6c34c965b5d116a" name="gaa5ee93c269a62b9aa6c34c965b5d116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ee93c269a62b9aa6c34c965b5d116a">&#9670;&#160;</a></span>free_request_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_request_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_hash_next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a linked list of DNS requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Head of request list to free. </td></tr>
    <tr><td class="paramname">use_hash_next</td><td>Whether to use hash_next (1) or queue_next (0) for traversal.</td></tr>
  </table>
  </dd>
</dl>
<p>Frees all requests in the list and their associated memory. </p>

</div>
</div>
<a id="ga0e26345eeede858bb5922a6109160037" name="ga0e26345eeede858bb5922a6109160037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e26345eeede858bb5922a6109160037">&#9670;&#160;</a></span>handle_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handle_request_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle timeout for a specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request that has timed out.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gad5067399f8c9930eb42f1e625899a3f7" title="Mark request as timed out with appropriate error code.">mark_request_timeout()</a> and signals completion. </p>

</div>
</div>
<a id="ga7570715dd7fcb113790e60bedd3139fb" name="ga7570715dd7fcb113790e60bedd3139fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7570715dd7fcb113790e60bedd3139fb">&#9670;&#160;</a></span>handle_resolution_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handle_resolution_result </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle result of DNS resolution attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request that was resolved. </td></tr>
    <tr><td class="paramname">result</td><td>Resolution result (NULL on error). </td></tr>
    <tr><td class="paramname">res</td><td>Error code from getaddrinfo().</td></tr>
  </table>
  </dd>
</dl>
<p>Updates request state, stores result, and signals completion. </p>

</div>
</div>
<a id="gac17573e4e80145c4c8dcd3e4dbef28b1" name="gac17573e4e80145c4c8dcd3e4dbef28b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17573e4e80145c4c8dcd3e4dbef28b1">&#9670;&#160;</a></span>hash_table_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_table_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert request into hash table for O(1) lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to insert.</td></tr>
  </table>
  </dd>
</dl>
<p>Inserts request into hash table using pre-computed hash value. </p>

</div>
</div>
<a id="gadbfe83ac3fd8daf74a5189130d35eb54" name="gadbfe83ac3fd8daf74a5189130d35eb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbfe83ac3fd8daf74a5189130d35eb54">&#9670;&#160;</a></span>hash_table_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_table_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes request from hash table bucket chain. </p>

</div>
</div>
<a id="ga1e9801b10626b586b24b9f9c76b89fbb" name="ga1e9801b10626b586b24b9f9c76b89fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e9801b10626b586b24b9f9c76b89fbb">&#9670;&#160;</a></span>initialize_addrinfo_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_addrinfo_hints </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize addrinfo hints structure with defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hints</td><td>Hints structure to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets AF_UNSPEC, SOCK_STREAM, and AI_NUMERICSERV flags. </p>

</div>
</div>
<a id="ga93a54f32c13c556fda9cb00e58078075" name="ga93a54f32c13c556fda9cb00e58078075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a54f32c13c556fda9cb00e58078075">&#9670;&#160;</a></span>initialize_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_mutex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the main mutex protecting DNS resolver state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a recursive mutex for protecting all mutable resolver state. </p>

</div>
</div>
<a id="ga4e5821b121187c8fe5bdf8e5af7b76d7" name="ga4e5821b121187c8fe5bdf8e5af7b76d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5821b121187c8fe5bdf8e5af7b76d7">&#9670;&#160;</a></span>initialize_pipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_pipe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize completion pipe (create + configure). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#gafd2db132989e70ce194d307157648be2" title="Create pipe for completion signaling to event loops.">create_completion_pipe()</a> and <a class="el" href="group__dns.html#ga1a4a337f44614e431316266926e989ed" title="Set completion pipe to non-blocking mode.">set_pipe_nonblocking()</a>. </p>

</div>
</div>
<a id="ga06edd21b5cb02e131393e908502c2563" name="ga06edd21b5cb02e131393e908502c2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06edd21b5cb02e131393e908502c2563">&#9670;&#160;</a></span>initialize_queue_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_queue_condition </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize condition variable for queue empty/full signaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates condition variable used to wake worker threads when requests arrive. </p>

</div>
</div>
<a id="gad1dda38ff120421fec3f5f32adf367bc" name="gad1dda38ff120421fec3f5f32adf367bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1dda38ff120421fec3f5f32adf367bc">&#9670;&#160;</a></span>initialize_request_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_request_fields </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize request fields after allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request to initialize. </td></tr>
    <tr><td class="paramname">port</td><td>Port number for resolution. </td></tr>
    <tr><td class="paramname">callback</td><td>Completion callback (NULL for polling). </td></tr>
    <tr><td class="paramname">data</td><td>User data for callback.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets all request fields except host (which is set separately). </p>

</div>
</div>
<a id="ga08b07ff9ca818c6179416243aa5be0e3" name="ga08b07ff9ca818c6179416243aa5be0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b07ff9ca818c6179416243aa5be0e3">&#9670;&#160;</a></span>initialize_result_condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_result_condition </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize condition variable for result availability signaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates condition variable used to wake polling threads when results complete. </p>

</div>
</div>
<a id="gaf875bcba3b535a0981600de2c0aa5720" name="gaf875bcba3b535a0981600de2c0aa5720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf875bcba3b535a0981600de2c0aa5720">&#9670;&#160;</a></span>initialize_synchronization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_synchronization </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all synchronization primitives (mutex + conditions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls <a class="el" href="group__dns.html#ga93a54f32c13c556fda9cb00e58078075" title="Initialize the main mutex protecting DNS resolver state.">initialize_mutex()</a>, <a class="el" href="group__dns.html#ga06edd21b5cb02e131393e908502c2563" title="Initialize condition variable for queue empty/full signaling.">initialize_queue_condition()</a>, and <a class="el" href="group__dns.html#ga08b07ff9ca818c6179416243aa5be0e3" title="Initialize condition variable for result availability signaling.">initialize_result_condition()</a>. </p>

</div>
</div>
<a id="ga5049b49f719f1be126b489957a62c7d8" name="ga5049b49f719f1be126b489957a62c7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5049b49f719f1be126b489957a62c7d8">&#9670;&#160;</a></span>invoke_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void invoke_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke user callback for completed request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Completed request with result.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls req-&gt;callback with request, result, error, and user data. Callback executes in worker thread context. </p>

</div>
</div>
<a id="gad5067399f8c9930eb42f1e625899a3f7" name="gad5067399f8c9930eb42f1e625899a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5067399f8c9930eb42f1e625899a3f7">&#9670;&#160;</a></span>mark_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mark_request_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark request as timed out with appropriate error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to mark as timed out.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets state to REQ_COMPLETE, error to EAI_NONAME, and clears result. </p>

</div>
</div>
<a id="gac4cb4a632aba382e70ef8fcf90e942c3" name="gac4cb4a632aba382e70ef8fcf90e942c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4cb4a632aba382e70ef8fcf90e942c3">&#9670;&#160;</a></span>perform_dns_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int perform_dns_resolution </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo **&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform actual DNS resolution using getaddrinfo(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request containing hostname and port. </td></tr>
    <tr><td class="paramname">hints</td><td>addrinfo hints for resolution. </td></tr>
    <tr><td class="paramname">result</td><td>Output parameter for result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, getaddrinfo error code on failure.</dd></dl>
<p>Calls getaddrinfo() with hostname and service from request. </p>

</div>
</div>
<a id="ga84b432e1a64990d148474aab42fec110" name="ga84b432e1a64990d148474aab42fec110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b432e1a64990d148474aab42fec110">&#9670;&#160;</a></span>prepare_local_hints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prepare_local_hints </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>local_hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>base_hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare addrinfo hints for specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_hints</td><td>Output hints structure. </td></tr>
    <tr><td class="paramname">base_hints</td><td>Base hints to copy from. </td></tr>
    <tr><td class="paramname">req</td><td>Request providing port/service information.</td></tr>
  </table>
  </dd>
</dl>
<p>Copies base hints and sets port from request. </p>

</div>
</div>
<a id="gaf1cf4dd4591c2d36325e9478b8f81901" name="gaf1cf4dd4591c2d36325e9478b8f81901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1cf4dd4591c2d36325e9478b8f81901">&#9670;&#160;</a></span>process_single_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void process_single_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>base_hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a single DNS request from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to process. </td></tr>
    <tr><td class="paramname">base_hints</td><td>Base addrinfo hints for resolution.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs DNS resolution using getaddrinfo() with timeout checking. Updates request state and signals completion on finish. </p>

</div>
</div>
<a id="ga6c14a21d40420acc4820fa2ff503ca20" name="ga6c14a21d40420acc4820fa2ff503ca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c14a21d40420acc4820fa2ff503ca20">&#9670;&#160;</a></span>queue_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void queue_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from processing queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Dispatches to head or middle removal based on position. </p>

</div>
</div>
<a id="gaf136ad6b2c162ef7251dc25b2e1a7200" name="gaf136ad6b2c162ef7251dc25b2e1a7200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf136ad6b2c162ef7251dc25b2e1a7200">&#9670;&#160;</a></span>remove_from_queue_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_queue_head </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a DNS request to the end of the FIFO processing queue. </p>
<p>Inserts the request into the tail of the queue (FIFO order) and increments the queue_size counter. Updates queue_tail pointer and sets req-&gt;queue_next = NULL. Must be called under mutex lock (internal invariant).</p>
<p>Queue is singly-linked via <a class="el" href="group__dns.html#aeddfbe59d08f55af648954a09ce13e1c">SocketDNS_Request_T::queue_next</a> field. Used during request submission after hash table insertion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dns</td><td>DNS resolver (queue_head/tail/size modified). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request to append (req-&gt;queue_next set to NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - requires exclusive access via dns-&gt;mutex.</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">pthread_mutex_lock(&amp;dns-&gt;mutex);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__dns.html#ga39628720afa0f701ab8d3e9bcceeb21c">check_queue_limit</a>(dns)) {</div>
<div class="line">    <span class="comment">// Reject or queue overflow handling</span></div>
<div class="line">    pthread_mutex_unlock(&amp;dns-&gt;mutex);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__dns.html#gac17573e4e80145c4c8dcd3e4dbef28b1">hash_table_insert</a>(dns, req);</div>
<div class="line">queue_append(dns, req);</div>
<div class="line">pthread_cond_broadcast(&amp;dns-&gt;queue_cond);  <span class="comment">// Wake workers</span></div>
<div class="line">pthread_mutex_unlock(&amp;dns-&gt;mutex);</div>
<div class="ttc" id="agroup__dns_html_ga39628720afa0f701ab8d3e9bcceeb21c"><div class="ttname"><a href="group__dns.html#ga39628720afa0f701ab8d3e9bcceeb21c">check_queue_limit</a></div><div class="ttdeci">int check_queue_limit(const struct SocketDNS_T *dns)</div><div class="ttdoc">Check if queue has reached capacity limit.</div></div>
<div class="ttc" id="agroup__dns_html_gac17573e4e80145c4c8dcd3e4dbef28b1"><div class="ttname"><a href="group__dns.html#gac17573e4e80145c4c8dcd3e4dbef28b1">hash_table_insert</a></div><div class="ttdeci">void hash_table_insert(struct SocketDNS_T *dns, struct SocketDNS_Request_T *req)</div><div class="ttdoc">Insert request into hash table for O(1) lookup.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(1) - direct pointer updates, no traversal.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>FIFO ensures fair processing order for submitted requests. </dd>
<dd>
Called only from <a class="el" href="group__dns.html#gadfd7ab93512c5ab94d32415eac07e69e" title="Submit request for processing by worker threads.">submit_dns_request()</a> under lock.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invalid if called without holding dns-&gt;mutex (race conditions). </dd>
<dd>
req must not already be in queue or hash table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga6c14a21d40420acc4820fa2ff503ca20" title="Remove request from processing queue.">queue_remove()</a> for removal operations. </dd>
<dd>
<a class="el" href="group__dns.html#ga39628720afa0f701ab8d3e9bcceeb21c" title="Check if queue has reached capacity limit.">check_queue_limit()</a> for capacity check before append. </dd>
<dd>
<a class="el" href="group__dns.html#gadfd7ab93512c5ab94d32415eac07e69e" title="Submit request for processing by worker threads.">submit_dns_request()</a> coordinating insert + append + signal. </dd>
<dd>
<a class="el" href="group__dns.html#gaf2ecd94190827e14a98bab9b52b3cd7d" title="Remove and return next request from processing queue.">dequeue_request()</a> for head removal by workers.</dd></dl>
<p>Remove request from queue head position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove (must be at queue head).</td></tr>
  </table>
  </dd>
</dl>
<p>Optimized removal when request is at queue head. </p>

</div>
</div>
<a id="gaa57962854d57cd4bad03222b31bf5036" name="gaa57962854d57cd4bad03222b31bf5036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57962854d57cd4bad03222b31bf5036">&#9670;&#160;</a></span>remove_from_queue_middle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_from_queue_middle </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove request from middle of queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to remove (not at head).</td></tr>
  </table>
  </dd>
</dl>
<p>Traverses queue to find and remove request from middle. </p>

</div>
</div>
<a id="ga33fdc34348f496c17c968499f90ef36c" name="ga33fdc34348f496c17c968499f90ef36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33fdc34348f496c17c968499f90ef36c">&#9670;&#160;</a></span>request_effective_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int request_effective_timeout_ms </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get effective timeout for request (with fallback to default). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Effective timeout in milliseconds.</dd></dl>
<p>Returns req-&gt;timeout_override_ms if &gt;= 0, otherwise dns-&gt;request_timeout_ms. </p>

</div>
</div>
<a id="gae79ec1f8c6638d30d082e8af45420837" name="gae79ec1f8c6638d30d082e8af45420837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79ec1f8c6638d30d082e8af45420837">&#9670;&#160;</a></span>request_hash_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned request_hash_function </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute hash value for request pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value for hash table lookup.</dd></dl>
<p>Uses <a class="el" href="group__foundation.html#ga0c1ed7481fd58c8cbb7e47b8a614b556" title="Hash pointer using golden ratio multiplicative.">socket_util_hash_ptr()</a> for deterministic hashing of request pointers.</p>
<dl class="section see"><dt>See also</dt><dd>SocketUtil for hash function <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utilities</a>. </dd></dl>

</div>
</div>
<a id="ga535554eb81b22d80ff8e72060293345b" name="ga535554eb81b22d80ff8e72060293345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535554eb81b22d80ff8e72060293345b">&#9670;&#160;</a></span>request_timed_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int request_timed_out </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if request has exceeded its timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if timed out, 0 if still within timeout.</dd></dl>
<p>Compares elapsed time since submission against effective timeout.</p>
<dl class="section see"><dt>See also</dt><dd>SocketTimer for timer management <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utilities</a>. </dd></dl>

</div>
</div>
<a id="ga1fab8535e6f7b9cd7213be1f35babf70" name="ga1fab8535e6f7b9cd7213be1f35babf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fab8535e6f7b9cd7213be1f35babf70">&#9670;&#160;</a></span>reset_dns_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset_dns_state </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset DNS resolver state to uninitialized values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Clears all pointers and resets counters. Called during destruction. </p>

</div>
</div>
<a id="ga1a4a337f44614e431316266926e989ed" name="ga1a4a337f44614e431316266926e989ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4a337f44614e431316266926e989ed">&#9670;&#160;</a></span>set_pipe_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_pipe_nonblocking </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set completion pipe to non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Ensures pipe reads/writes don't block, preventing deadlocks. </p>

</div>
</div>
<a id="ga6b30e5d8a0c4c61b78414c87fc2e6ad6" name="ga6b30e5d8a0c4c61b78414c87fc2e6ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b30e5d8a0c4c61b78414c87fc2e6ad6">&#9670;&#160;</a></span>shutdown_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shutdown_workers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal worker threads to shut down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets shutdown flag and broadcasts to wake all waiting threads. </p>

</div>
</div>
<a id="ga01e5cc089ceff56a8558e455b94c8254" name="ga01e5cc089ceff56a8558e455b94c8254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e5cc089ceff56a8558e455b94c8254">&#9670;&#160;</a></span>signal_completion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void signal_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal completion of DNS request to waiting threads/polls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes completion byte to pipe for SocketPoll integration. </p>

</div>
</div>
<a id="gac8642d0527ed406099dd2ca81cbcbc53" name="gac8642d0527ed406099dd2ca81cbcbc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8642d0527ed406099dd2ca81cbcbc53">&#9670;&#160;</a></span>SocketDNS_cache_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cache_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the entire DNS result cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Removes all cached DNS resolution results, forcing fresh lookups for subsequent requests. Useful when DNS records are known to have changed or when troubleshooting resolution issues.</p>
<h2><a class="anchor" id="autotoc_md265"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// DNS records changed, force fresh lookups</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53">SocketDNS_cache_clear</a>(dns);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now all resolutions will query DNS servers</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, <span class="stringliteral">&quot;example.com&quot;</span>, 443, callback, data);</div>
<div class="ttc" id="agroup__dns_html_gac8642d0527ed406099dd2ca81cbcbc53"><div class="ttname"><a href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53">SocketDNS_cache_clear</a></div><div class="ttdeci">void SocketDNS_cache_clear(SocketDNS_T dns)</div><div class="ttdoc">Clear the entire DNS result cache.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(n) where n is number of cached entries.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga8d75a5fca44d0543bcc7fccab2f3ebc0" title="Remove a specific hostname from the DNS cache.">SocketDNS_cache_remove()</a> to remove specific entries. </dd>
<dd>
<a class="el" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd" title="Get DNS cache statistics.">SocketDNS_cache_stats()</a> to check cache state. </dd></dl>

</div>
</div>
<a id="ga8d75a5fca44d0543bcc7fccab2f3ebc0" name="ga8d75a5fca44d0543bcc7fccab2f3ebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d75a5fca44d0543bcc7fccab2f3ebc0">&#9670;&#160;</a></span>SocketDNS_cache_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_cache_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a specific hostname from the DNS cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hostname</td><td>Hostname to remove from cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if entry was found and removed, 0 if not found. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Removes a specific hostname's cached result, forcing a fresh DNS lookup on the next resolution request for that hostname.</p>
<h2><a class="anchor" id="autotoc_md266"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Known DNS change for specific host</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__dns.html#ga8d75a5fca44d0543bcc7fccab2f3ebc0">SocketDNS_cache_remove</a>(dns, <span class="stringliteral">&quot;api.example.com&quot;</span>)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Removed stale cache entry\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__dns_html_ga8d75a5fca44d0543bcc7fccab2f3ebc0"><div class="ttname"><a href="group__dns.html#ga8d75a5fca44d0543bcc7fccab2f3ebc0">SocketDNS_cache_remove</a></div><div class="ttdeci">int SocketDNS_cache_remove(SocketDNS_T dns, const char *hostname)</div><div class="ttdoc">Remove a specific hostname from the DNS cache.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(1) average - hash table lookup.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53" title="Clear the entire DNS result cache.">SocketDNS_cache_clear()</a> to clear entire cache. </dd></dl>

</div>
</div>
<a id="ga358ec74cbdfba760e98798bb0269ec70" name="ga358ec74cbdfba760e98798bb0269ec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga358ec74cbdfba760e98798bb0269ec70">&#9670;&#160;</a></span>SocketDNS_cache_set_max_entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cache_set_max_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of entries in the DNS cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_entries</td><td>Maximum cache entries (0 disables caching). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Limits memory usage by capping the number of cached DNS results. When the limit is reached, oldest entries are evicted (LRU).</p>
<h2><a class="anchor" id="autotoc_md269"></a>
Default</h2>
<p>Default max is SOCKET_DNS_DEFAULT_CACHE_MAX_ENTRIES (1000).</p>
<h2><a class="anchor" id="autotoc_md270"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Limit cache for memory-constrained environments</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga358ec74cbdfba760e98798bb0269ec70">SocketDNS_cache_set_max_entries</a>(dns, 100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Large cache for high-traffic servers</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga358ec74cbdfba760e98798bb0269ec70">SocketDNS_cache_set_max_entries</a>(dns, 10000);</div>
<div class="ttc" id="agroup__dns_html_ga358ec74cbdfba760e98798bb0269ec70"><div class="ttname"><a href="group__dns.html#ga358ec74cbdfba760e98798bb0269ec70">SocketDNS_cache_set_max_entries</a></div><div class="ttdeci">void SocketDNS_cache_set_max_entries(SocketDNS_T dns, size_t max_entries)</div><div class="ttdoc">Set the maximum number of entries in the DNS cache.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If new limit is less than current size, excess entries are evicted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd" title="Get DNS cache statistics.">SocketDNS_cache_stats()</a> to check current size. </dd></dl>

</div>
</div>
<a id="gaaf578d18322c0da146bfc52e236ae91d" name="gaaf578d18322c0da146bfc52e236ae91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf578d18322c0da146bfc52e236ae91d">&#9670;&#160;</a></span>SocketDNS_cache_set_ttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cache_set_ttl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl_seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the TTL (time-to-live) for cached DNS results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl_seconds</td><td>TTL in seconds (0 disables caching). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Controls how long resolved DNS results are cached before being considered stale and requiring re-resolution. Setting to 0 effectively disables caching (all requests go to DNS servers).</p>
<h2><a class="anchor" id="autotoc_md267"></a>
Default</h2>
<p>Default TTL is SOCKET_DNS_DEFAULT_CACHE_TTL_SECONDS (300 = 5 minutes).</p>
<h2><a class="anchor" id="autotoc_md268"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Short TTL for frequently changing DNS</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d">SocketDNS_cache_set_ttl</a>(dns, 60);  <span class="comment">// 1 minute</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disable caching entirely</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d">SocketDNS_cache_set_ttl</a>(dns, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Long TTL for stable DNS</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d">SocketDNS_cache_set_ttl</a>(dns, 3600);  <span class="comment">// 1 hour</span></div>
<div class="ttc" id="agroup__dns_html_gaaf578d18322c0da146bfc52e236ae91d"><div class="ttname"><a href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d">SocketDNS_cache_set_ttl</a></div><div class="ttdeci">void SocketDNS_cache_set_ttl(SocketDNS_T dns, int ttl_seconds)</div><div class="ttdoc">Set the TTL (time-to-live) for cached DNS results.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Does not affect existing cached entries; only new insertions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd" title="Get DNS cache statistics.">SocketDNS_cache_stats()</a> to check current TTL. </dd></dl>

</div>
</div>
<a id="ga552e6fce7e0aabe57e4bdaa18bbc4dcd" name="ga552e6fce7e0aabe57e4bdaa18bbc4dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552e6fce7e0aabe57e4bdaa18bbc4dcd">&#9670;&#160;</a></span>SocketDNS_cache_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cache_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__CacheStats">SocketDNS_CacheStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get DNS cache statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>Output statistics structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic snapshot.</dt><dd></dd></dl>
<p>Retrieves current cache statistics including hit/miss rates, size, and configuration. Useful for monitoring and tuning cache parameters.</p>
<h2><a class="anchor" id="autotoc_md271"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__dns.html#structSocketDNS__CacheStats">SocketDNS_CacheStats</a> stats;</div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd">SocketDNS_cache_stats</a>(dns, &amp;stats);</div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;Cache hit rate: %.1f%% (%lu hits, %lu misses)\n&quot;</span>,</div>
<div class="line">       stats.<a class="code hl_variable" href="group__dns.html#a40fdfc4bf0eaf4823e0fdb63ca381450">hit_rate</a> * 100.0,</div>
<div class="line">       (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)stats.<a class="code hl_variable" href="group__dns.html#aa2e8e3582926075d0695528e38ccad83">hits</a>,</div>
<div class="line">       (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)stats.<a class="code hl_variable" href="group__dns.html#acb32258f717bdb3a45390d2cced85bba">misses</a>);</div>
<div class="line">printf(<span class="stringliteral">&quot;Cache size: %zu / %zu entries\n&quot;</span>,</div>
<div class="line">       stats.<a class="code hl_variable" href="group__dns.html#ae7b6f98198e752cc02f4e2bc650b5305">current_size</a>, stats.<a class="code hl_variable" href="group__dns.html#a6cb49fe4982b48272102d78ddf0b6846">max_entries</a>);</div>
<div class="line">printf(<span class="stringliteral">&quot;Evictions: %lu\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)stats.<a class="code hl_variable" href="group__dns.html#ab0a332ac89fb52b9f3d4bbe8d53e5c97">evictions</a>);</div>
<div class="ttc" id="agroup__dns_html_a40fdfc4bf0eaf4823e0fdb63ca381450"><div class="ttname"><a href="group__dns.html#a40fdfc4bf0eaf4823e0fdb63ca381450">SocketDNS_CacheStats::hit_rate</a></div><div class="ttdeci">double hit_rate</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00873">SocketDNS.h:873</a></div></div>
<div class="ttc" id="agroup__dns_html_a6cb49fe4982b48272102d78ddf0b6846"><div class="ttname"><a href="group__dns.html#a6cb49fe4982b48272102d78ddf0b6846">SocketDNS_CacheStats::max_entries</a></div><div class="ttdeci">size_t max_entries</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00871">SocketDNS.h:871</a></div></div>
<div class="ttc" id="agroup__dns_html_aa2e8e3582926075d0695528e38ccad83"><div class="ttname"><a href="group__dns.html#aa2e8e3582926075d0695528e38ccad83">SocketDNS_CacheStats::hits</a></div><div class="ttdeci">uint64_t hits</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00866">SocketDNS.h:866</a></div></div>
<div class="ttc" id="agroup__dns_html_ab0a332ac89fb52b9f3d4bbe8d53e5c97"><div class="ttname"><a href="group__dns.html#ab0a332ac89fb52b9f3d4bbe8d53e5c97">SocketDNS_CacheStats::evictions</a></div><div class="ttdeci">uint64_t evictions</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00868">SocketDNS.h:868</a></div></div>
<div class="ttc" id="agroup__dns_html_acb32258f717bdb3a45390d2cced85bba"><div class="ttname"><a href="group__dns.html#acb32258f717bdb3a45390d2cced85bba">SocketDNS_CacheStats::misses</a></div><div class="ttdeci">uint64_t misses</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00867">SocketDNS.h:867</a></div></div>
<div class="ttc" id="agroup__dns_html_ae7b6f98198e752cc02f4e2bc650b5305"><div class="ttname"><a href="group__dns.html#ae7b6f98198e752cc02f4e2bc650b5305">SocketDNS_CacheStats::current_size</a></div><div class="ttdeci">size_t current_size</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00870">SocketDNS.h:870</a></div></div>
<div class="ttc" id="agroup__dns_html_ga552e6fce7e0aabe57e4bdaa18bbc4dcd"><div class="ttname"><a href="group__dns.html#ga552e6fce7e0aabe57e4bdaa18bbc4dcd">SocketDNS_cache_stats</a></div><div class="ttdeci">void SocketDNS_cache_stats(SocketDNS_T dns, SocketDNS_CacheStats *stats)</div><div class="ttdoc">Get DNS cache statistics.</div></div>
<div class="ttc" id="agroup__dns_html_structSocketDNS__CacheStats"><div class="ttname"><a href="group__dns.html#structSocketDNS__CacheStats">SocketDNS_CacheStats</a></div><div class="ttdoc">Cache statistics structure.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS_8h_source.html#l00864">SocketDNS.h:865</a></div></div>
</div><!-- fragment --><dl class="section user"><dt>Complexity\n O(1).</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#structSocketDNS__CacheStats" title="Cache statistics structure.">SocketDNS_CacheStats</a> for field descriptions. </dd>
<dd>
<a class="el" href="group__dns.html#gac8642d0527ed406099dd2ca81cbcbc53" title="Clear the entire DNS result cache.">SocketDNS_cache_clear()</a> to reset cache. </dd></dl>

</div>
</div>
<a id="ga7ca6cf65c0823f0a23aa2c0c5cbe2223" name="ga7ca6cf65c0823f0a23aa2c0c5cbe2223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">&#9670;&#160;</a></span>SocketDNS_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel a pending DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Cancels a pending request. If resolution has already completed, this has no effect. The request handle becomes invalid after cancellation. Callbacks will not be invoked for cancelled requests.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> for retrieving completed results. </dd></dl>

</div>
</div>
<a id="gad8f2fa5ee464e84f44b4b6059b4813e5" name="gad8f2fa5ee464e84f44b4b6059b4813e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f2fa5ee464e84f44b4b6059b4813e5">&#9670;&#160;</a></span>SocketDNS_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for completed requests (non-blocking). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of completion signals drained (1 byte per completed/cancelled/timeout request). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - safe to call from any thread.</dt><dd></dd></dl>
<p>Drains the signal pipe for completed DNS events. Does not automatically retrieve results. For poll-mode requests (no callback), track your Request_T handles and call <a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> after draining to fetch completed results. Call when <a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> is readable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> for the file descriptor to monitor. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> for retrieving completed results. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga494e7ef72d567b90e5fdcb1df6501ea5" name="ga494e7ef72d567b90e5fdcb1df6501ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga494e7ef72d567b90e5fdcb1df6501ea5">&#9670;&#160;</a></span>SocketDNS_create_completed_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> SocketDNS_create_completed_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a completed request from pre-resolved addrinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">result</td><td>Pre-resolved addrinfo result (caller transfers ownership). </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Request handle for completed request. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Creates a request that is already marked as complete with the provided result. Useful for synchronous resolution (e.g., wildcard bind) that doesn't need async DNS. The caller transfers ownership of the addrinfo result to the request.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> for retrieving the result. </dd>
<dd>
<a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with optional timeout guarantee.">SocketDNS_resolve_sync()</a> for synchronous resolution. </dd></dl>

</div>
</div>
<a id="gabdc83f21f67b5b8557f35d7ffa4c839c" name="gabdc83f21f67b5b8557f35d7ffa4c839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc83f21f67b5b8557f35d7ffa4c839c">&#9670;&#160;</a></span>SocketDNS_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispose of DNS resolver and release all resources. </p>
<p>Gracefully shuts down the DNS resolver: signals workers to stop, cancels pending requests, drains the completion pipe, joins worker threads, and frees internal resources (arena, mutex, pipe, etc.). Ensures no resource leaks or zombie threads.</p>
<p>Pending requests receive EAI_CANCELED error and are removed. Completed but unretrieved results are discarded (potential leak if not fetched via getresult before free). In-progress requests complete or cancel based on state.</p>
<p>Safe to call on NULL pointer (no-op). Concurrent resolutions may race: some may complete post-free if not synchronized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dns</td><td>Pointer to resolver instance (set to NULL on success).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- fails silently on errors (logs warnings); already-freed or NULL handled gracefully.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if no concurrent</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>/getresult() calls; may leak unretrieved results under race conditions. Recommend drain pending before free.</dd></dl>
<h2><a class="anchor" id="autotoc_md256"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Basic cleanup</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a>(&amp;dns);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With pending drain</span></div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a>(dns) &gt; 0) { <span class="comment">// Drain completions</span></div>
<div class="line">    <span class="comment">// Optionally fetch results for tracked requests</span></div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a>(&amp;dns);</div>
<div class="ttc" id="agroup__dns_html_gabdc83f21f67b5b8557f35d7ffa4c839c"><div class="ttname"><a href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a></div><div class="ttdeci">void SocketDNS_free(SocketDNS_T *dns)</div><div class="ttdoc">Dispose of DNS resolver and release all resources.</div></div>
<div class="ttc" id="agroup__dns_html_gad8f2fa5ee464e84f44b4b6059b4813e5"><div class="ttname"><a href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a></div><div class="ttdeci">int SocketDNS_check(SocketDNS_T dns)</div><div class="ttdoc">Check for completed requests (non-blocking).</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md257"></a>
Safe Shutdown Pattern</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <span class="comment">// ... use dns ...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <span class="comment">// Cancel tracked requests</span></div>
<div class="line">    <span class="keywordflow">for each</span> pending req: <a class="code hl_function" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">SocketDNS_cancel</a>(dns, req);</div>
<div class="line">    <span class="comment">// Drain pipe</span></div>
<div class="line">    <a class="code hl_function" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a>(dns);</div>
<div class="line">    <a class="code hl_function" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a>(&amp;dns);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__dns_html_ga7ca6cf65c0823f0a23aa2c0c5cbe2223"><div class="ttname"><a href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223">SocketDNS_cancel</a></div><div class="ttdeci">void SocketDNS_cancel(SocketDNS_T dns, Request_T req)</div><div class="ttdoc">Cancel a pending DNS resolution.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Worker threads joined; completion pipe closed. All Request_T handles invalid post-free. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unretrieved completed results lost (memory leak). Always fetch or cancel before free. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Logs warnings on shutdown errors (e.g., pthread_join timeout); does not raise exceptions.</dd></dl>
<dl class="section user"><dt>Complexity\n O(pending + num_workers) - cancel/drain/join time</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for paired creation. </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> for explicit request cleanup. </dd>
<dd>
<a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for draining before shutdown. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> to retrieve pending results. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md for resource lifecycle. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for shutdown in event loops. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga13ffd5fe0baab4e755abb0c45bc78410" name="ga13ffd5fe0baab4e755abb0c45bc78410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13ffd5fe0baab4e755abb0c45bc78410">&#9670;&#160;</a></span>SocketDNS_get_prefer_ipv6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_get_prefer_ipv6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current IPv6 preference setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if IPv6 preferred, 0 if IPv4 preferred. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gafd162147cc335b1d66ea31a6e70dba91" title="Set IPv6 preference for DNS resolution.">SocketDNS_prefer_ipv6()</a> to set preference. </dd></dl>

</div>
</div>
<a id="ga69d8d4c9f020bf781d541df7ecaf5acf" name="ga69d8d4c9f020bf781d541df7ecaf5acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d8d4c9f020bf781d541df7ecaf5acf">&#9670;&#160;</a></span>SocketDNS_geterror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_geterror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get error code for completed request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle (must have been returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> on this same resolver instance). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>getaddrinfo() error code, or 0 on success, or 0 if request does not belong to this resolver (invalid handle). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>IMPORTANT: Only use request handles returned by <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> or <a class="el" href="group__dns.html#ga494e7ef72d567b90e5fdcb1df6501ea5" title="Create a completed request from pre-resolved addrinfo.">SocketDNS_create_completed_request()</a> on the SAME resolver instance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> for retrieving successful results. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd></dl>

</div>
</div>
<a id="ga68f007d40e50ed2894c962ee91509fcc" name="ga68f007d40e50ed2894c962ee91509fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f007d40e50ed2894c962ee91509fcc">&#9670;&#160;</a></span>SocketDNS_getmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketDNS_getmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum pending request capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current pending request limit. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7" title="Set maximum pending request capacity.">SocketDNS_setmaxpending()</a> for setting the limit. </dd></dl>

</div>
</div>
<a id="ga8f7c4c4455c9158ccd272fe8c15235b5" name="ga8f7c4c4455c9158ccd272fe8c15235b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f7c4c4455c9158ccd272fe8c15235b5">&#9670;&#160;</a></span>SocketDNS_getresult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketDNS_getresult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve completed DNS resolution result, transferring ownership to caller. </p>
<p>Fetches addrinfo for completed requests in polling mode (no callback). Performs ownership transfer: clears internal result pointer, removes request from hash table, invalidates handle. Callback mode returns NULL (result already transferred to callback).</p>
<p>NULL return conditions:</p><ul>
<li>Request pending/processing (call after <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> signals).</li>
<li>Cancelled (use <a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a> for EAI_CANCELED).</li>
<li>Failed resolution (error code via geterror()).</li>
<li>Invalid handle or ownership mismatch (cross-resolver).</li>
<li>Callback mode (result consumed by callback).</li>
</ul>
<p>Security: Validates ownership via back-pointer to prevent corruption from invalid handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>Resolver owning the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle from this resolver's <a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>addrinfo chain (caller owns; free with freeaddrinfo()) or NULL (see conditions).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- returns NULL on invalid/pending; logs debug warnings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - acquires mutex for hash lookup and transfer.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md263"></a>
Polling Completion Pattern</h2>
<div class="fragment"><div class="line"><span class="comment">// After SocketDNS_check(dns) &gt; 0</span></div>
<div class="line"><span class="keyword">struct </span>addrinfo *res = <a class="code hl_function" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a>(dns, tracked_req);</div>
<div class="line"><span class="keywordflow">if</span> (res) {</div>
<div class="line">    <span class="keywordtype">int</span> err = <a class="code hl_function" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a>(dns, tracked_req);</div>
<div class="line">    <span class="keywordflow">if</span> (err == 0) {</div>
<div class="line">        <span class="comment">// Success: use res for connect/bind/etc.</span></div>
<div class="line">        Socket_T sock = Socket_new_from_addrinfo(res); <span class="comment">// Example helper</span></div>
<div class="line">        <span class="comment">// ... connect or bind ...</span></div>
<div class="line">        freeaddrinfo(res);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Failure: err from getaddrinfo()</span></div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;DNS error %d: %s&quot;</span>, err, gai_strerror(err));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// req now invalid; remove from tracking</span></div>
<div class="line">} <span class="comment">// else still pending or invalid</span></div>
<div class="ttc" id="aSocketUtil_8h_html_a16642c35dec627aeb4976538671b1552"><div class="ttname"><a href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_ERROR_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00548">SocketUtil.h:548</a></div></div>
<div class="ttc" id="agroup__dns_html_ga69d8d4c9f020bf781d541df7ecaf5acf"><div class="ttname"><a href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a></div><div class="ttdeci">int SocketDNS_geterror(SocketDNS_T dns, const struct SocketDNS_Request_T *req)</div><div class="ttdoc">Get error code for completed request.</div></div>
<div class="ttc" id="agroup__dns_html_ga8f7c4c4455c9158ccd272fe8c15235b5"><div class="ttname"><a href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a></div><div class="ttdeci">struct addrinfo * SocketDNS_getresult(SocketDNS_T dns, Request_T req)</div><div class="ttdoc">Retrieve completed DNS resolution result, transferring ownership to caller.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md264"></a>
Error Check Always</h2>
<p>Always pair with <a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a> even on non-NULL res (paranoia):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>addrinfo *res = <a class="code hl_function" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a>(dns, req);</div>
<div class="line"><span class="keywordtype">int</span> err = <a class="code hl_function" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a>(dns, req);</div>
<div class="line"><span class="keywordflow">if</span> (res &amp;&amp; err == 0) {</div>
<div class="line">    <span class="comment">// Valid success</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Handle error or pending (NULL res)</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Ownership transfer semantics: Caller MUST freeaddrinfo() on success. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invalid req/dns mismatch: Silent NULL (no crash, but debug log). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Post-call: req invalid; do not reuse or pass to other functions. </dd>
<dd>
Callback mode: Always NULL; use callback for result.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average - hash lookup; O(n) worst collision chain.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>freeaddrinfo() required cleanup (or <a class="el" href="group__core__io.html#ga6c73595d93eeee7b21ad12b980770f5a" title="Free addrinfo chain created by copy_addrinfo.">SocketCommon_free_addrinfo()</a> wrapper). </dd>
<dd>
<a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a> mandatory error check. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> polling mode (NULL callback). </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> alternative for pending. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md addrinfo ownership. </dd>
<dd>
docs/ERROR_HANDLING.md getaddrinfo codes. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga2f4c54acbc79bbb31a4ce3ec75928ee8" name="ga2f4c54acbc79bbb31a4ce3ec75928ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4c54acbc79bbb31a4ce3ec75928ee8">&#9670;&#160;</a></span>SocketDNS_gettimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_gettimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get resolver request timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout in milliseconds (0 disables timeout). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0" title="Set resolver request timeout in milliseconds.">SocketDNS_settimeout()</a> for setting the timeout. </dd></dl>

</div>
</div>
<a id="ga799f4d96c77eef54ecb9be5523b591fd" name="ga799f4d96c77eef54ecb9be5523b591fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799f4d96c77eef54ecb9be5523b591fd">&#9670;&#160;</a></span>SocketDNS_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> SocketDNS_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new asynchronous DNS resolver. </p>
<p>Initializes a thread pool-based DNS resolver that offloads getaddrinfo() calls to worker threads, preventing blocking in the main application thread. Supports both callback and polling modes for completion notification, with built-in DoS protection via queue limits and timeouts.</p>
<p>The resolver allocates an internal Arena for memory management, creates synchronization primitives (mutex, condition variables, completion pipe), and spawns worker threads. Default configuration:</p>
<h2><a class="anchor" id="autotoc_md253"></a>
Default Configuration</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Setting   </th><th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_workers   </td><td class="markdownTableBodyNone">SOCKET_DNS_DEFAULT_NUM_WORKERS   </td><td class="markdownTableBodyNone">Typically # of CPU cores    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_pending   </td><td class="markdownTableBodyNone">SOCKET_DNS_MAX_PENDING   </td><td class="markdownTableBodyNone">Default 1000 queued requests    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">timeout_ms   </td><td class="markdownTableBodyNone">SOCKET_DNS_DEFAULT_TIMEOUT_MS   </td><td class="markdownTableBodyNone">Default 5000ms per request   </td></tr>
</table>
<p>Edge cases:</p><ul>
<li>Thread creation failure (e.g., system limits): raises SocketDNS_Failed</li>
<li>Pipe creation failure: raises SocketDNS_Failed</li>
<li>Arena allocation failure: raises SocketDNS_Failed</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>New DNS resolver instance or NULL on failure (check exception).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on memory allocation failure, mutex/pipe/thread initialization errors, or worker startup issues. Common causes: EMFILE (too many files), EAGAIN (resources exhausted).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent instance; safe from any thread.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md254"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns = <a class="code hl_function" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a>();</div>
<div class="line"><span class="keywordflow">if</span> (!dns) {</div>
<div class="line">    <span class="comment">// Handle failure (exception already raised via TRY/EXCEPT if used)</span></div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure optional settings</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0">SocketDNS_settimeout</a>(dns, 3000);  <span class="comment">// 3s timeout</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7">SocketDNS_setmaxpending</a>(dns, 500); <span class="comment">// Limit queue to 500</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit resolutions...</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, <span class="stringliteral">&quot;example.com&quot;</span>, 443, callback, userdata);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c">SocketDNS_free</a>(&amp;dns);</div>
<div class="ttc" id="agroup__dns_html_ga390b733f1a522dcaccede3adf56fece0"><div class="ttname"><a href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0">SocketDNS_settimeout</a></div><div class="ttdeci">void SocketDNS_settimeout(SocketDNS_T dns, int timeout_ms)</div><div class="ttdoc">Set resolver request timeout in milliseconds.</div></div>
<div class="ttc" id="agroup__dns_html_ga55b33b7c9a44dc087be0f74b259d54f7"><div class="ttname"><a href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7">SocketDNS_setmaxpending</a></div><div class="ttdeci">void SocketDNS_setmaxpending(SocketDNS_T dns, size_t max_pending)</div><div class="ttdoc">Set maximum pending request capacity.</div></div>
<div class="ttc" id="agroup__dns_html_ga799f4d96c77eef54ecb9be5523b591fd"><div class="ttname"><a href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a></div><div class="ttdeci">SocketDNS_T SocketDNS_new(void)</div><div class="ttdoc">Create a new asynchronous DNS resolver.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md255"></a>
With Exception Handling</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns = <a class="code hl_function" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a>();</div>
<div class="line">    <a class="code hl_struct" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> req = <a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, host, port, NULL,</div>
<div class="line">NULL); <span class="comment">// Polling mode</span></div>
<div class="line">    <span class="comment">// Wait or poll for completion...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="SocketDNS-private_8h.html#a329324a0e4a1450a6b968b375bb9b333">SocketDNS_Failed</a>) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;DNS init or resolve failed: %s&quot;</span>,</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>());</div>
<div class="line">    <span class="comment">// Cleanup resources...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__dns_html_structSocketDNS__Request__T"><div class="ttname"><a href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a></div><div class="ttdoc">DNS resolution request structure.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00211">SocketDNS-private.h:212</a></div></div>
<div class="ttc" id="agroup__foundation_html_gac71a25566cdc9e11eaecb16c966081db"><div class="ttname"><a href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a></div><div class="ttdeci">const char * Socket_GetLastError(void)</div><div class="ttdoc">Socket_GetLastError - Retrieve the most recent formatted error message.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Worker threads are created immediately and run indefinitely until <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Dispose of DNS resolver and release all resources.">SocketDNS_free()</a>. Use <a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7" title="Set maximum pending request capacity.">SocketDNS_setmaxpending()</a> to limit memory usage under high load. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> from signal handlers or non-async-signal-safe contexts.</dd></dl>
<dl class="section user"><dt>Complexity\n O(num_workers) - time for thread creation and startup; space</dt><dd>O(num_workers * stack_size)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Dispose of DNS resolver and release all resources.">SocketDNS_free()</a> for resource cleanup and shutdown. </dd>
<dd>
<a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0" title="Set resolver request timeout in milliseconds.">SocketDNS_settimeout()</a> for configuring timeouts. </dd>
<dd>
<a class="el" href="group__dns.html#ga55b33b7c9a44dc087be0f74b259d54f7" title="Set maximum pending request capacity.">SocketDNS_setmaxpending()</a> for queue limits. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for submitting requests. </dd>
<dd>
<a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with optional timeout guarantee.">SocketDNS_resolve_sync()</a> for synchronous alternative. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for thread pool details. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> for DoS protection via limits. </dd>
<dd>
docs/ERROR_HANDLING.md for failure diagnosis. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga9228880ada42145db04298282b5f0c80" name="ga9228880ada42145db04298282b5f0c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9228880ada42145db04298282b5f0c80">&#9670;&#160;</a></span>SocketDNS_pollfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_pollfd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get file descriptor for integration with SocketPoll (completion notifications). </p>
<p>Provides the read end of the internal completion pipe (or eventfd on some platforms). Becomes readable (POLL_READ/POLLIN) when one or more requests complete, cancel, or timeout. Designed for edge/level-triggered event loops; multiple events coalesced into one signal.</p>
<p>FD lifetime: Valid from <a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> to <a class="el" href="group__dns.html#gabdc83f21f67b5b8557f35d7ffa4c839c" title="Dispose of DNS resolver and release all resources.">SocketDNS_free()</a>; closed during shutdown. Post-free: Invalid; polling returns error or EOF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>Resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid FD (&gt;=0) or -1 (NULL dns or shutdown state).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read of stable FD value; no mutex needed.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md261"></a>
Event Loop Integration</h2>
<div class="fragment"><div class="line"><span class="comment">// Setup</span></div>
<div class="line"><span class="keywordtype">int</span> dns_fd = <a class="code hl_function" href="group__dns.html#ga9228880ada42145db04298282b5f0c80">SocketDNS_pollfd</a>(dns);</div>
<div class="line"><span class="keywordflow">if</span> (dns_fd &gt;= 0) {</div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, dns_fd, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>, dns_userdata);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In poll loop</span></div>
<div class="line"><span class="keywordtype">int</span> n_events = <a class="code hl_function" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a>(poll, events, timeout);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n_events; i++) {</div>
<div class="line">    <span class="keywordflow">if</span> (events[i].socket == dns_fd &amp;&amp; (events[i].events &amp; <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>)) {</div>
<div class="line">        <span class="keywordtype">int</span> drained = <a class="code hl_function" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a>(dns);</div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a>(<span class="stringliteral">&quot;DNS: drained %d completions&quot;</span>, drained);</div>
<div class="line">        <span class="comment">// Now check tracked requests for results</span></div>
<div class="line">        process_dns_completions(dns, tracked_requests);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aSocketUtil_8h_html_a7853a630bcaead9d41536ccbfd598f6d"><div class="ttname"><a href="SocketUtil_8h.html#a7853a630bcaead9d41536ccbfd598f6d">SOCKET_LOG_DEBUG_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_DEBUG_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00536">SocketUtil.h:536</a></div></div>
<div class="ttc" id="agroup__dns_html_ga9228880ada42145db04298282b5f0c80"><div class="ttname"><a href="group__dns.html#ga9228880ada42145db04298282b5f0c80">SocketDNS_pollfd</a></div><div class="ttdeci">int SocketDNS_pollfd(SocketDNS_T dns)</div><div class="ttdoc">Get file descriptor for integration with SocketPoll (completion notifications).</div></div>
<div class="ttc" id="agroup__event__system_html_ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><div class="ttname"><a href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a></div><div class="ttdeci">void SocketPoll_add(SocketPoll_T poll, Socket_T socket, unsigned events, void *data)</div><div class="ttdoc">Register a socket for I/O event monitoring within the poll instance.</div></div>
<div class="ttc" id="agroup__event__system_html_gaa3d47365dd18329d50ee636284839738"><div class="ttname"><a href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a></div><div class="ttdeci">int SocketPoll_wait(SocketPoll_T poll, SocketEvent_T **events, int timeout)</div><div class="ttdoc">Block and wait for I/O events or timeout on registered sockets.</div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a></div><div class="ttdeci">@ POLL_READ</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00181">SocketPoll.h:181</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md262"></a>
Best Practices</h2>
<ul>
<li><b>Drain Fully</b>: Call <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> in loop until EAGAIN to handle coalesced signals.</li>
<li><b>Edge-Triggered</b>: Safe; but level-triggered requires full drain to clear POLL_READ.</li>
<li><b>Error Handling</b>: On POLLERR/POLLHUP: check resolver state; likely shutdown.</li>
<li><b>High Load</b>: Buffer pipe reads prevent overflow (internal buffering limited).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Not a socket FD; do not close() or use socket ops; only poll/read via check(). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not block on read(); <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> is non-blocking. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Multiple resolvers: separate FD per instance; aggregate in one poll.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - simple FD return.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registering the FD. </dd>
<dd>
<a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for draining signals post-event. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketEvent__T" title="Event notification structure returned by polling operations.">SocketEvent_T</a> for poll events structure. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> event loop patterns with pipes. </dd>
<dd>
docs/POLL.md cross-platform polling notes. </dd></dl>

</div>
</div>
<a id="gafd162147cc335b1d66ea31a6e70dba91" name="gafd162147cc335b1d66ea31a6e70dba91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd162147cc335b1d66ea31a6e70dba91">&#9670;&#160;</a></span>SocketDNS_prefer_ipv6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_prefer_ipv6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefer_ipv6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set IPv6 preference for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefer_ipv6</td><td>1 to prefer IPv6, 0 to prefer IPv4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Controls whether IPv6 (AAAA records) or IPv4 (A records) addresses are preferred when both are available. Affects the ordering of addresses in resolution results.</p>
<h2><a class="anchor" id="autotoc_md272"></a>
Default</h2>
<p>Default is 1 (prefer IPv6) per RFC 6724 recommendations.</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Prefer IPv4 (legacy compatibility)</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gafd162147cc335b1d66ea31a6e70dba91">SocketDNS_prefer_ipv6</a>(dns, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prefer IPv6 (modern default)</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#gafd162147cc335b1d66ea31a6e70dba91">SocketDNS_prefer_ipv6</a>(dns, 1);</div>
<div class="ttc" id="agroup__dns_html_gafd162147cc335b1d66ea31a6e70dba91"><div class="ttname"><a href="group__dns.html#gafd162147cc335b1d66ea31a6e70dba91">SocketDNS_prefer_ipv6</a></div><div class="ttdeci">void SocketDNS_prefer_ipv6(SocketDNS_T dns, int prefer_ipv6)</div><div class="ttdoc">Set IPv6 preference for DNS resolution.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This sets AI_ADDRCONFIG hints appropriately. System resolver may still return both address families.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketHappyEyeballs for RFC 8305 dual-stack connection racing. </dd></dl>

</div>
</div>
<a id="ga9b27f46a350b3cfaf9a1092d94f81dd9" name="ga9b27f46a350b3cfaf9a1092d94f81dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b27f46a350b3cfaf9a1092d94f81dd9">&#9670;&#160;</a></span>SocketDNS_request_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_request_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override timeout for specific request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 disables timeout for this request). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga390b733f1a522dcaccede3adf56fece0" title="Set resolver request timeout in milliseconds.">SocketDNS_settimeout()</a> for setting the default timeout. </dd>
<dd>
<a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for creating requests. </dd></dl>

</div>
</div>
<a id="ga380629d9c1650963341d1fe1dacd3253" name="ga380629d9c1650963341d1fe1dacd3253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga380629d9c1650963341d1fe1dacd3253">&#9670;&#160;</a></span>SocketDNS_resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> SocketDNS_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#ga47df31a4c5b1861e6bc33bf91effa388">SocketDNS_Callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start asynchronous DNS resolution. </p>
<p>Submits a DNS resolution request to the thread pool for non-blocking processing. Supports IP addresses (fast-path, no lookup), hostnames (async getaddrinfo()), and wildcard binds (AI_PASSIVE flag). Queue protected by mutex; workers process in FIFO order.</p>
<p>Two completion modes:</p><ul>
<li><b>Callback</b>: Provide callback; invoked from worker thread on completion/cancel/timeout.</li>
<li><b>Polling</b>: NULL callback; monitor <a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> via SocketPoll, drain with check().</li>
</ul>
<p>Validation: Hostname RFC 1123 compliant; port 0-65535 (0=no service lookup). IP addresses bypass workers for instant "resolution". Queue full raises exception (DoS protection).</p>
<p>Request lifecycle: Valid until result fetched, cancelled, or resolver freed. Per-request timeout override via <a class="el" href="group__dns.html#ga9b27f46a350b3cfaf9a1092d94f81dd9" title="Override timeout for specific request.">SocketDNS_request_settimeout()</a> post-submit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>Resolver instance (validated non-NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Hostname/IP or NULL (wildcard bind, sets AI_PASSIVE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port (0-65535; 0 omits service resolution in hints). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Completion callback or NULL (polling mode). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Opaque user data passed to callback (ignored if NULL callback).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid Request_T handle (never NULL on success).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on invalid params (bad host/port), queue full (max_pending exceeded), allocation failure, or resolver invalid. Use TRY/EXCEPT for handling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - internal mutex serializes queue/hash operations.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md258"></a>
Error Codes from getaddrinfo()</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Code   </th><th class="markdownTableHeadNone">Meaning   </th><th class="markdownTableHeadNone">Retryable    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Success   </td><td class="markdownTableBodyNone">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAI_AGAIN   </td><td class="markdownTableBodyNone">Temporary failure (server busy/DNS down)   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EAI_NONAME   </td><td class="markdownTableBodyNone">Host not found   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAI_FAIL   </td><td class="markdownTableBodyNone">Non-recoverable failure   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EAI_SYSTEM   </td><td class="markdownTableBodyNone">System error (errno details)   </td><td class="markdownTableBodyNone">Depends on errno    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAI_CANCELED   </td><td class="markdownTableBodyNone">User cancelled   </td><td class="markdownTableBodyNone">No (retry new request)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md259"></a>
Callback Mode Usage</h2>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> my_dns_callback(<a class="code hl_struct" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req, <span class="keyword">struct</span> addrinfo *res,</div>
<div class="line">                            <span class="keywordtype">int</span> err, <span class="keywordtype">void</span> *data) {</div>
<div class="line">    <span class="keywordflow">if</span> (err == 0 &amp;&amp; res) {</div>
<div class="line">        <span class="comment">// Use res (caller owns; freeaddrinfo(res))</span></div>
<div class="line">        connect_via_addrinfo((MyContext*)data, res);</div>
<div class="line">        freeaddrinfo(res);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Handle error (retry logic based on err)</span></div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;DNS failed for %s: %s&quot;</span>, req-&gt;<a class="code hl_variable" href="group__dns.html#ac9f3fa1aca3eb39a39d6e3777fc49273">host</a>,</div>
<div class="line">gai_strerror(err));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do NOT free req; owned by resolver</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit</span></div>
<div class="line"><a class="code hl_struct" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req = <a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, <span class="stringliteral">&quot;api.example.com&quot;</span>, 443,</div>
<div class="line">                                             my_dns_callback, ctx);</div>
<div class="ttc" id="aSocketUtil_8h_html_ae560ccd4aef66d44e8ecbd256844059c"><div class="ttname"><a href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_WARN_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00544">SocketUtil.h:544</a></div></div>
<div class="ttc" id="agroup__dns_html_ac9f3fa1aca3eb39a39d6e3777fc49273"><div class="ttname"><a href="group__dns.html#ac9f3fa1aca3eb39a39d6e3777fc49273">SocketDNS_Request_T::host</a></div><div class="ttdeci">char * host</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00213">SocketDNS-private.h:213</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md260"></a>
Polling Mode Usage (Event Loop)</h2>
<div class="fragment"><div class="line"><span class="comment">// Track requests in application state</span></div>
<div class="line"><span class="keyword">struct </span>PendingDNS { <a class="code hl_struct" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *req; <span class="keywordtype">void</span> *userdata; };</div>
<div class="line">PendingDNS pending[] = {...};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit</span></div>
<div class="line">pending[i].req = <a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, host, port, NULL, NULL);</div>
<div class="line">pending[i].userdata = ctx;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In event loop</span></div>
<div class="line"><span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__dns.html#ga9228880ada42145db04298282b5f0c80">SocketDNS_pollfd</a>(dns);</div>
<div class="line"><a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, fd, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6a19f5d65c083268df50040f34f306d1b8">POLL_READ</a>, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// On POLL_READ event</span></div>
<div class="line"><span class="keywordtype">int</span> drained = <a class="code hl_function" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5">SocketDNS_check</a>(dns);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; drained; j++) { <span class="comment">// But actually check specific reqs</span></div>
<div class="line">    <span class="keywordflow">for each</span> tracked req:</div>
<div class="line">        <span class="keyword">struct </span>addrinfo *res = <a class="code hl_function" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a>(dns, req);</div>
<div class="line">        <span class="keywordflow">if</span> (res) {</div>
<div class="line">            <span class="keywordtype">int</span> err = <a class="code hl_function" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf">SocketDNS_geterror</a>(dns, req);</div>
<div class="line">            <span class="keywordflow">if</span> (err == 0) {</div>
<div class="line">                <span class="comment">// Success: use res</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Error: handle</span></div>
<div class="line">            }</div>
<div class="line">            freeaddrinfo(res);</div>
<div class="line">            <span class="comment">// Remove from tracked</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Fast-path for IPs/NULL host: may complete synchronously before return. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callbacks run in workers: thread-safe impl required; no blocking ops; own res immediately. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Request handle invalid post-result/cancel/free; do not store long-term.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average - queue append + hash insert; O(n) worst hash</dt><dd>collision.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga88905fdf7322b96426e000683280445d" title="Callback function for async DNS resolution.">SocketDNS_Callback</a> detailed safety rules and ownership. </dd>
<dd>
<a class="el" href="group__dns.html#ga7ca6cf65c0823f0a23aa2c0c5cbe2223" title="Cancel a pending DNS resolution.">SocketDNS_cancel()</a> for aborting requests. </dd>
<dd>
<a class="el" href="group__dns.html#ga9b27f46a350b3cfaf9a1092d94f81dd9" title="Override timeout for specific request.">SocketDNS_request_settimeout()</a> per-request timeout override. </dd>
<dd>
<a class="el" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5" title="Retrieve completed DNS resolution result, transferring ownership to caller.">SocketDNS_getresult()</a> and <a class="el" href="group__dns.html#ga69d8d4c9f020bf781d541df7ecaf5acf" title="Get error code for completed request.">SocketDNS_geterror()</a> for polling retrieval. </dd>
<dd>
<a class="el" href="group__dns.html#ga9228880ada42145db04298282b5f0c80" title="Get file descriptor for integration with SocketPoll (completion notifications).">SocketDNS_pollfd()</a> and <a class="el" href="group__dns.html#gad8f2fa5ee464e84f44b4b6059b4813e5" title="Check for completed requests (non-blocking).">SocketDNS_check()</a> for event integration. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> worker threads and callback patterns. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> queue limits for DoS mitigation. </dd>
<dd>
docs/ERROR_HANDLING.md getaddrinfo error categorization. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gab988727825887d34e87d144d30c30c2f" name="gab988727825887d34e87d144d30c30c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab988727825887d34e87d144d30c30c2f">&#9670;&#160;</a></span>SocketDNS_resolve_sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketDNS_resolve_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronous DNS resolution with optional timeout guarantee. </p>
<p>Performs blocking DNS resolution with configurable timeout when using a resolver instance. For NULL dns, falls back to direct getaddrinfo() (no timeout protection - use with caution). Internal: Uses async machinery for timeout enforcement via worker + condvar wait.</p>
<p>Ideal for cases needing simple blocking call but with DoS protection (timeout). IP addresses resolve instantly. Handles hints for family/type/protocol prefs.</p>
<p>Timeout: 0 = resolver default or infinite (NULL dns). Negative sanitized. Throws on timeout (SocketDNS_Failed with timeout message) or resolution error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>Resolver for timeout/queue (NULL = direct getaddrinfo, no timeout). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Host/IP or NULL (AI_PASSIVE wildcard). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port (appended to hints.ai_addr if resolved). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hints</td><td>getaddrinfo hints or NULL (defaults: AF_UNSPEC, SOCK_STREAM, AI_ADDRCONFIG|AI_V4MAPPED). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Max wait ms (0=use dns default/infinite; ignored for NULL dns).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated addrinfo (free with freeaddrinfo()) or NULL + exception on failure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>on resolution failure, timeout, invalid params, or internal error. For NULL dns: Raw getaddrinfo errors wrapped as Failed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - mutex for shared state; condvar wait atomic.</dt><dd></dd></dl>
<p>This function provides synchronous DNS resolution with GUARANTEED timeout. Unlike raw getaddrinfo() which can block for 30+ seconds, this function uses the async DNS worker thread pool internally and enforces the specified timeout using condition variable wait.</p>
<p>Use this function when you need blocking DNS resolution but cannot afford unbounded blocking time (e.g., in network servers handling untrusted input).</p>
<p>For IP addresses, resolution is instant (no DNS lookup needed).</p>
<p>Usage: struct addrinfo *res = SocketDNS_resolve_sync(dns, "example.com", 80, NULL, 5000); // Use res... freeaddrinfo(res);</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for asynchronous resolution. </dd>
<dd>
<a class="el" href="group__foundation.html">Core Foundation Modules</a> for arena allocation patterns. </dd>
<dd>
<a class="el" href="group__dns.html">Asynchronous DNS Resolution</a> for asynchronous DNS resolution overview. </dd></dl>

<p class="reference">Referenced by <a class="el" href="dns__lookup_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga686f6e19ce68debbdbb9638b1a60b573" name="ga686f6e19ce68debbdbb9638b1a60b573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686f6e19ce68debbdbb9638b1a60b573">&#9670;&#160;</a></span>SocketDNS_set_nameservers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_set_nameservers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>servers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set custom nameservers for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">servers</td><td>Array of nameserver IP addresses (NULL-terminated). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of servers in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if custom nameservers not supported. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Configures custom DNS nameservers instead of using system resolv.conf. This is useful for applications that need to use specific DNS servers (e.g., DNS-over-HTTPS, private DNS, or fallback servers).</p>
<h2><a class="anchor" id="autotoc_md274"></a>
Platform Support</h2>
<p>This function requires platform-specific resolver configuration:</p><ul>
<li><b>Linux</b>: Uses res_init() with modified _res structure</li>
<li><b>macOS/BSD</b>: Limited support via dns_open()/dns_search()</li>
<li><b>Windows</b>: Requires different API (not supported)</li>
</ul>
<p>If custom nameservers are not supported on the platform, this function returns -1 and the system resolver continues to be used.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *servers[] = {<span class="stringliteral">&quot;8.8.8.8&quot;</span>, <span class="stringliteral">&quot;8.8.4.4&quot;</span>, NULL};</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__dns.html#ga686f6e19ce68debbdbb9638b1a60b573">SocketDNS_set_nameservers</a>(dns, servers, 2) &lt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Custom nameservers not supported, using system resolver\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__dns_html_ga686f6e19ce68debbdbb9638b1a60b573"><div class="ttname"><a href="group__dns.html#ga686f6e19ce68debbdbb9638b1a60b573">SocketDNS_set_nameservers</a></div><div class="ttdeci">int SocketDNS_set_nameservers(SocketDNS_T dns, const char **servers, size_t count)</div><div class="ttdoc">Set custom nameservers for DNS resolution.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Changes affect only this resolver instance, not system-wide. </dd>
<dd>
Pass NULL and count=0 to revert to system nameservers.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gae01bb71c26d598319a2fdfe043bf455e" title="Set DNS search domains for hostname resolution.">SocketDNS_set_search_domains()</a> for search path configuration. </dd></dl>

</div>
</div>
<a id="gae01bb71c26d598319a2fdfe043bf455e" name="gae01bb71c26d598319a2fdfe043bf455e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01bb71c26d598319a2fdfe043bf455e">&#9670;&#160;</a></span>SocketDNS_set_search_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDNS_set_search_domains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set DNS search domains for hostname resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domains</td><td>Array of search domain strings (NULL-terminated). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of domains in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if custom search domains not supported. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - protected by internal mutex.</dt><dd></dd></dl>
<p>Configures DNS search domains for resolving unqualified hostnames. When resolving a name like "myserver", the resolver will try "myserver.domain1", "myserver.domain2", etc.</p>
<h2><a class="anchor" id="autotoc_md276"></a>
Platform Support</h2>
<p>Similar to <a class="el" href="group__dns.html#ga686f6e19ce68debbdbb9638b1a60b573" title="Set custom nameservers for DNS resolution.">SocketDNS_set_nameservers()</a>, this requires platform support.</p>
<h2><a class="anchor" id="autotoc_md277"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *domains[] = {<span class="stringliteral">&quot;internal.company.com&quot;</span>, <span class="stringliteral">&quot;company.com&quot;</span>, NULL};</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__dns.html#gae01bb71c26d598319a2fdfe043bf455e">SocketDNS_set_search_domains</a>(dns, domains, 2) &lt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Custom search domains not supported\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now &quot;myserver&quot; resolves as &quot;myserver.internal.company.com&quot; first</span></div>
<div class="line"><a class="code hl_function" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253">SocketDNS_resolve</a>(dns, <span class="stringliteral">&quot;myserver&quot;</span>, 80, callback, data);</div>
<div class="ttc" id="agroup__dns_html_gae01bb71c26d598319a2fdfe043bf455e"><div class="ttname"><a href="group__dns.html#gae01bb71c26d598319a2fdfe043bf455e">SocketDNS_set_search_domains</a></div><div class="ttdeci">int SocketDNS_set_search_domains(SocketDNS_T dns, const char **domains, size_t count)</div><div class="ttdoc">Set DNS search domains for hostname resolution.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Pass NULL and count=0 to revert to system search domains.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga686f6e19ce68debbdbb9638b1a60b573" title="Set custom nameservers for DNS resolution.">SocketDNS_set_nameservers()</a> for nameserver configuration. </dd></dl>

</div>
</div>
<a id="ga55b33b7c9a44dc087be0f74b259d54f7" name="ga55b33b7c9a44dc087be0f74b259d54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b33b7c9a44dc087be0f74b259d54f7">&#9670;&#160;</a></span>SocketDNS_setmaxpending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_setmaxpending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_pending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set maximum pending request capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">max_pending</td><td>New pending request limit (0 allows no pending requests). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketDNS_Failed</td><td>if max_pending &lt; current queue depth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga68f007d40e50ed2894c962ee91509fcc" title="Get maximum pending request capacity.">SocketDNS_getmaxpending()</a> for retrieving the current limit. </dd></dl>

</div>
</div>
<a id="ga390b733f1a522dcaccede3adf56fece0" name="ga390b733f1a522dcaccede3adf56fece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390b733f1a522dcaccede3adf56fece0">&#9670;&#160;</a></span>SocketDNS_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketDNS_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set resolver request timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 disables timeout). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga2f4c54acbc79bbb31a4ce3ec75928ee8" title="Get resolver request timeout in milliseconds.">SocketDNS_gettimeout()</a> for retrieving the current timeout. </dd></dl>

</div>
</div>
<a id="ga966920bebbea908c25400af44930fe59" name="ga966920bebbea908c25400af44930fe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966920bebbea908c25400af44930fe59">&#9670;&#160;</a></span>start_dns_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start_dns_workers </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start DNS worker threads (transition from initialization to running). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Signals workers to begin processing requests from the queue. </p>

</div>
</div>
<a id="gadbc14c60ccd56fe1f73c7d52b04d0664" name="gadbc14c60ccd56fe1f73c7d52b04d0664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc14c60ccd56fe1f73c7d52b04d0664">&#9670;&#160;</a></span>store_resolution_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void store_resolution_result </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store DNS resolution result in request structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to update. </td></tr>
    <tr><td class="paramname">result</td><td>Resolution result (NULL on error). </td></tr>
    <tr><td class="paramname">error</td><td>Error code (0 on success).</td></tr>
  </table>
  </dd>
</dl>
<p>Updates request state to REQ_COMPLETE and stores result/error. </p>

</div>
</div>
<a id="gadfd7ab93512c5ab94d32415eac07e69e" name="gadfd7ab93512c5ab94d32415eac07e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd7ab93512c5ab94d32415eac07e69e">&#9670;&#160;</a></span>submit_dns_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void submit_dns_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit request for processing by worker threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request to submit.</td></tr>
  </table>
  </dd>
</dl>
<p>Inserts into hash table and queue, then signals workers. </p>

</div>
</div>
<a id="gabac4f41fc92ef0aec184eb3c8e6e10cb" name="gabac4f41fc92ef0aec184eb3c8e6e10cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac4f41fc92ef0aec184eb3c8e6e10cb">&#9670;&#160;</a></span>validate_resolve_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void validate_resolve_params </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate hostname and port parameters for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname string to validate. </td></tr>
    <tr><td class="paramname">port</td><td>Port number to validate.</td></tr>
  </table>
  </dd>
</dl>
<p>Validates that host is non-NULL, non-empty, and port is in valid range (1-65535). Raises SocketDNS_Failed exception on invalid parameters. </p>

</div>
</div>
<a id="ga516cbcd949e90804306ac10ec02af7cd" name="ga516cbcd949e90804306ac10ec02af7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516cbcd949e90804306ac10ec02af7cd">&#9670;&#160;</a></span>wait_for_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a> * wait_for_request </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> *&#160;</td>
          <td class="paramname"><em>dns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a request to become available in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next request to process.</dd></dl>
<p>Blocks until request available or shutdown signaled. </p>

</div>
</div>
<a id="ga7f292c19cdf04ce4fb9f9a890b656cf0" name="ga7f292c19cdf04ce4fb9f9a890b656cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f292c19cdf04ce4fb9f9a890b656cf0">&#9670;&#160;</a></span>worker_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * worker_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main worker thread function for DNS resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Pointer to <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL (threads run until shutdown).</dd></dl>
<p>Worker thread main loop: wait for requests, process them, repeat. Handles shutdown signaling gracefully. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga329324a0e4a1450a6b968b375bb9b333" name="ga329324a0e4a1450a6b968b375bb9b333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329324a0e4a1450a6b968b375bb9b333">&#9670;&#160;</a></span>SocketDNS_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketDNS_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DNS resolution operation failure exception. </p>
<p>Category: NETWORK Retryable: YES - DNS servers may recover, cache may refresh</p>
<p>Raised when DNS resolution fails:</p><ul>
<li>Server unreachable (transient)</li>
<li>Query timeout (transient)</li>
<li>Invalid hostname (permanent)</li>
<li>NXDOMAIN (permanent)</li>
<li>Resource allocation failure</li>
<li>Thread pool initialization failure</li>
</ul>
<p>Check the error code from callback for specific failure reason. Transient failures (EAI_AGAIN, EAI_NODATA) are worth retrying. Permanent failures (EAI_NONAME, EAI_FAIL) should not be retried.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga380629d9c1650963341d1fe1dacd3253" title="Start asynchronous DNS resolution.">SocketDNS_resolve()</a> for resolution operations. </dd>
<dd>
<a class="el" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd" title="Create a new asynchronous DNS resolver.">SocketDNS_new()</a> for initialization operations. </dd>
<dd>
foundation::Except_T for exception base type. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/>
<footer class="footer">
  <div style="max-width: 960px; margin: 0 auto; padding: 40px 24px;">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 40px;">
      <!-- Brand -->
      <div style="flex: 1; min-width: 200px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); border-radius: 6px;"></div>
          <span style="font-size: 1rem; font-weight: 600; color: #f7f9fa;">Socket Library</span>
        </div>
        <p style="color: #8b98a5; font-size: 0.8125rem; line-height: 1.6; margin: 0;">
          High-performance socket toolkit for POSIX systems with exception-based error handling and TLS 1.3 support.
        </p>
      </div>
      <!-- Links -->
      <div style="display: flex; gap: 48px; flex-wrap: wrap;">
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Documentation</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="index.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Getting Started</a></li>
            <li style="margin: 6px 0;"><a href="annotated.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Data Structures</a></li>
            <li style="margin: 6px 0;"><a href="globals.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">API Reference</a></li>
          </ul>
        </div>
        <div>
          <h4 style="font-size: 0.75rem; font-weight: 600; color: #f7f9fa; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 12px 0;">Resources</h4>
          <ul style="list-style: none; padding: 0; margin: 0;">
            <li style="margin: 6px 0;"><a href="files.html" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Header Files</a></li>
            <li style="margin: 6px 0;"><a href="https://x.com/tetsuocorp" target="_blank" style="color: #8b98a5; text-decoration: none; font-size: 0.8125rem;">Twitter/X</a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Bottom -->
    <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 16px;">
      <div style="display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 0.75rem; font-weight: 500; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 4px 8px; border-radius: 4px;">C11</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 4px 8px; border-radius: 4px;">POSIX</span>
        <span style="font-size: 0.75rem; font-weight: 500; color: #8b5cf6; background: rgba(139, 92, 246, 0.1); padding: 4px 8px; border-radius: 4px;">TLS 1.3</span>
      </div>
      <div style="color: #6e7681; font-size: 0.75rem; display: flex; align-items: center; gap: 8px;">
        <span> 2025 Tetsuo Corporation</span>
        <span style="color: #30363d;"></span>
        <a href="https://opensource.org/licenses/MIT" target="_blank" style="color: #8b98a5; text-decoration: none;">MIT License</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
