<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Socket Library: SocketAsync.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('SocketAsync_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SocketAsync.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Socket_8h_source.html">socket/Socket.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Except_8h_source.html">core/Except.h</a>&quot;</code><br />
</div>
<p><a href="SocketAsync_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0acb682b8260ab1c60b918599864e2e5" id="r_a0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="SocketPoll_8h.html#a733615fa159421d6c73d01f6bb34bac8">SocketAsync_T</a></td></tr>
<tr class="memdesc:a0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync - Asynchronous I/O Operations.  <br /></td></tr>
<tr class="separator:a0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24514489b0962fafe8414bfae95aa268" id="r_a24514489b0962fafe8414bfae95aa268"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structT.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a24514489b0962fafe8414bfae95aa268">T</a></td></tr>
<tr class="separator:a24514489b0962fafe8414bfae95aa268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6644a0c3153b65fa217ecbc45b5b8f9" id="r_ad6644a0c3153b65fa217ecbc45b5b8f9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#ad6644a0c3153b65fa217ecbc45b5b8f9">SocketAsync_Callback</a>) (<a class="el" href="structSocket__T.html">Socket_T</a> socket, ssize_t bytes, int err, void *user_data)</td></tr>
<tr class="memdesc:ad6644a0c3153b65fa217ecbc45b5b8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_Callback - Callback function for async operation completion @socket: Socket that completed the operation @bytes: Number of bytes transferred (negative on error) @err: Error code (0 on success, errno value on error) @user_data: User data passed to async function.  <br /></td></tr>
<tr class="separator:ad6644a0c3153b65fa217ecbc45b5b8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae66259c675b6f9658c95d34e1fbfefdf" id="r_ae66259c675b6f9658c95d34e1fbfefdf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a> { <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdfa3b607e56f470ff08783c2f3385c1041c">ASYNC_FLAG_NONE</a> = 0
, <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdfa5b1a5dc7d9ed8ace5643e4cef11cb50d">ASYNC_FLAG_ZERO_COPY</a> = 1 &lt;&lt; 0
, <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdfaf08a13c5b932be67e3f0ed7de0499ef8">ASYNC_FLAG_URGENT</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="memdesc:ae66259c675b6f9658c95d34e1fbfefdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async operation flags.  <a href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">More...</a><br /></td></tr>
<tr class="separator:ae66259c675b6f9658c95d34e1fbfefdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6001469d4be96f6f05d78d1c222784cc" id="r_a6001469d4be96f6f05d78d1c222784cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structT.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a6001469d4be96f6f05d78d1c222784cc">SocketAsync_new</a> (Arena_T arena)</td></tr>
<tr class="memdesc:a6001469d4be96f6f05d78d1c222784cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_new - Create a new async I/O context @arena: Arena for memory allocation Returns: New async context (never returns NULL) Raises: SocketAsync_Failed on initialization failure Thread-safe: Yes - returns new instance.  <br /></td></tr>
<tr class="separator:a6001469d4be96f6f05d78d1c222784cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee23e4535260946b632fc973ac4935a" id="r_a2ee23e4535260946b632fc973ac4935a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a2ee23e4535260946b632fc973ac4935a">SocketAsync_free</a> (<a class="el" href="structT.html">T</a> *async)</td></tr>
<tr class="memdesc:a2ee23e4535260946b632fc973ac4935a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_free - Free an async I/O context @async: Pointer to async context (will be set to NULL) Thread-safe: Yes - frees resources.  <br /></td></tr>
<tr class="separator:a2ee23e4535260946b632fc973ac4935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf11b6fec4537a1d25ed17038c2f2f7c" id="r_adf11b6fec4537a1d25ed17038c2f2f7c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#adf11b6fec4537a1d25ed17038c2f2f7c">SocketAsync_send</a> (<a class="el" href="structT.html">T</a> async, <a class="el" href="structSocket__T.html">Socket_T</a> socket, const void *buf, size_t len, <a class="el" href="SocketAsync_8h.html#ad6644a0c3153b65fa217ecbc45b5b8f9">SocketAsync_Callback</a> cb, void *user_data, <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a> flags)</td></tr>
<tr class="memdesc:adf11b6fec4537a1d25ed17038c2f2f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_send - Submit asynchronous send operation @async: Async context (from SocketPoll_get_async) @socket: Socket to send on (must be non-blocking) @buf: Data to send @len: Length of data to send @cb: Callback to call on completion @user_data: User data passed to callback @flags: Operation flags (ASYNC_FLAG_ZERO_COPY, etc.)  <br /></td></tr>
<tr class="separator:adf11b6fec4537a1d25ed17038c2f2f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966b7ae7c15262f4503a70f869a04ddb" id="r_a966b7ae7c15262f4503a70f869a04ddb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a966b7ae7c15262f4503a70f869a04ddb">SocketAsync_recv</a> (<a class="el" href="structT.html">T</a> async, <a class="el" href="structSocket__T.html">Socket_T</a> socket, void *buf, size_t len, <a class="el" href="SocketAsync_8h.html#ad6644a0c3153b65fa217ecbc45b5b8f9">SocketAsync_Callback</a> cb, void *user_data, <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a> flags)</td></tr>
<tr class="memdesc:a966b7ae7c15262f4503a70f869a04ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_recv - Submit asynchronous receive operation @async: Async context (from SocketPoll_get_async) @socket: Socket to receive on (must be non-blocking) @buf: Buffer to receive into (must remain valid until callback invoked) @len: Maximum length to receive @cb: Callback to call on completion @user_data: User data passed to callback @flags: Operation flags (currently unused)  <br /></td></tr>
<tr class="separator:a966b7ae7c15262f4503a70f869a04ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229345d46001f8c9e4a0df90339be910" id="r_a229345d46001f8c9e4a0df90339be910"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a229345d46001f8c9e4a0df90339be910">SocketAsync_cancel</a> (<a class="el" href="structT.html">T</a> async, unsigned request_id)</td></tr>
<tr class="memdesc:a229345d46001f8c9e4a0df90339be910"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_cancel - Cancel pending async operation @async: Async context @request_id: Request ID returned from send/recv.  <br /></td></tr>
<tr class="separator:a229345d46001f8c9e4a0df90339be910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af209d2124b5062b1f294501ea3ae79b2" id="r_af209d2124b5062b1f294501ea3ae79b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#af209d2124b5062b1f294501ea3ae79b2">SocketAsync_process_completions</a> (<a class="el" href="structT.html">T</a> async, int timeout_ms)</td></tr>
<tr class="memdesc:af209d2124b5062b1f294501ea3ae79b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_process_completions - Process pending async completions @async: Async context @timeout_ms: Timeout in milliseconds (0 = non-blocking)  <br /></td></tr>
<tr class="separator:af209d2124b5062b1f294501ea3ae79b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e10c5a59d6331ea46cb4458307424e" id="r_ab0e10c5a59d6331ea46cb4458307424e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#ab0e10c5a59d6331ea46cb4458307424e">SocketAsync_is_available</a> (<a class="el" href="structT.html">T</a> async)</td></tr>
<tr class="memdesc:ab0e10c5a59d6331ea46cb4458307424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_is_available - Check if async I/O is available on this platform @async: Async context.  <br /></td></tr>
<tr class="separator:ab0e10c5a59d6331ea46cb4458307424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f74b54be873b1ca3040b53cb15e99e" id="r_a21f74b54be873b1ca3040b53cb15e99e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a21f74b54be873b1ca3040b53cb15e99e">SocketAsync_backend_name</a> (<a class="el" href="structT.html">T</a> async)</td></tr>
<tr class="memdesc:a21f74b54be873b1ca3040b53cb15e99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketAsync_backend_name - Get name of async backend in use @async: Async context.  <br /></td></tr>
<tr class="separator:a21f74b54be873b1ca3040b53cb15e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a832db2f86b4c0d8a57dc3def7121d833" id="r_a832db2f86b4c0d8a57dc3def7121d833"><td class="memItemLeft" align="right" valign="top">Except_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketAsync_8h.html#a832db2f86b4c0d8a57dc3def7121d833">SocketAsync_Failed</a></td></tr>
<tr class="memdesc:a832db2f86b4c0d8a57dc3def7121d833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Async operation failure.  <br /></td></tr>
<tr class="separator:a832db2f86b4c0d8a57dc3def7121d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0acb682b8260ab1c60b918599864e2e5" name="a0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="structT.html">T</a>&#160;&#160;&#160;<a class="el" href="SocketPoll_8h.html#a733615fa159421d6c73d01f6bb34bac8">SocketAsync_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SocketAsync - Asynchronous I/O Operations. </p>
<p>Provides non-blocking I/O operations using platform-optimized async mechanisms:</p><ul>
<li>Linux: io_uring (kernel 5.1+)</li>
<li>macOS/BSD: kqueue AIO</li>
<li>Fallback: Edge-triggered polling (if async unavailable)</li>
</ul>
<p>Features:</p><ul>
<li>Zero-copy operations where supported</li>
<li>Callback-based completion handling</li>
<li>Integration with SocketPoll for event-driven completion</li>
<li>Thread-safe operation</li>
</ul>
<p>PLATFORM REQUIREMENTS:</p><ul>
<li>Linux: kernel 5.1+ for io_uring (falls back to edge-triggered if unavailable)</li>
<li>macOS/BSD: kqueue with AIO support</li>
<li>All platforms: Non-blocking sockets (automatically handled)</li>
</ul>
<p>Usage example: SocketPoll_T poll = SocketPoll_new(4096); SocketAsync_T async = SocketPoll_get_async(poll);</p>
<p>void send_callback(Socket_T sock, ssize_t bytes, int err, void *data) { if (err != 0) { // Handle error return; } // Process completion }</p>
<p>unsigned req_id = SocketAsync_send(sock, buf, len, send_callback, user_data, 0); </p>

<p class="definition">Definition at line <a class="el" href="SocketAsync_8h_source.html#l00041">41</a> of file <a class="el" href="SocketAsync_8h_source.html">SocketAsync.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad6644a0c3153b65fa217ecbc45b5b8f9" name="ad6644a0c3153b65fa217ecbc45b5b8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6644a0c3153b65fa217ecbc45b5b8f9">&#9670;&#160;</a></span>SocketAsync_Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SocketAsync_Callback) (<a class="el" href="structSocket__T.html">Socket_T</a> socket, ssize_t bytes, int err, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SocketAsync_Callback - Callback function for async operation completion @socket: Socket that completed the operation @bytes: Number of bytes transferred (negative on error) @err: Error code (0 on success, errno value on error) @user_data: User data passed to async function. </p>
<p>Returns: Nothing</p>
<p>Note: bytes &lt; 0 indicates error, check err for details. For send operations: bytes is total bytes sent (may be partial) For recv operations: bytes is total bytes received (0 = EOF) Callback is invoked from <a class="el" href="SocketPoll_8h.html#a838225b94dfd40f308c49482bca2e7fd" title="SocketPoll_wait - Wait for events @poll: Poll instance @events: Output - array of events that occurre...">SocketPoll_wait()</a> context - keep it fast! Thread-safe: Yes - invoked from single-threaded poll context </p>

<p class="definition">Definition at line <a class="el" href="SocketAsync_8h_source.html#l00062">62</a> of file <a class="el" href="SocketAsync_8h_source.html">SocketAsync.h</a>.</p>

</div>
</div>
<a id="a24514489b0962fafe8414bfae95aa268" name="a24514489b0962fafe8414bfae95aa268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514489b0962fafe8414bfae95aa268">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structT.html">T</a>* <a class="el" href="structT.html">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketAsync_8h_source.html#l00042">42</a> of file <a class="el" href="SocketAsync_8h_source.html">SocketAsync.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae66259c675b6f9658c95d34e1fbfefdf" name="ae66259c675b6f9658c95d34e1fbfefdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66259c675b6f9658c95d34e1fbfefdf">&#9670;&#160;</a></span>SocketAsync_Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Async operation flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae66259c675b6f9658c95d34e1fbfefdfa3b607e56f470ff08783c2f3385c1041c" name="ae66259c675b6f9658c95d34e1fbfefdfa3b607e56f470ff08783c2f3385c1041c"></a>ASYNC_FLAG_NONE&#160;</td><td class="fielddoc"><p>No special flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae66259c675b6f9658c95d34e1fbfefdfa5b1a5dc7d9ed8ace5643e4cef11cb50d" name="ae66259c675b6f9658c95d34e1fbfefdfa5b1a5dc7d9ed8ace5643e4cef11cb50d"></a>ASYNC_FLAG_ZERO_COPY&#160;</td><td class="fielddoc"><p>Use zero-copy (sendfile/splice) if available. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae66259c675b6f9658c95d34e1fbfefdfaf08a13c5b932be67e3f0ed7de0499ef8" name="ae66259c675b6f9658c95d34e1fbfefdfaf08a13c5b932be67e3f0ed7de0499ef8"></a>ASYNC_FLAG_URGENT&#160;</td><td class="fielddoc"><p>High-priority operation (io_uring IOSQE_IO_LINK) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketAsync_8h_source.html#l00067">67</a> of file <a class="el" href="SocketAsync_8h_source.html">SocketAsync.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a21f74b54be873b1ca3040b53cb15e99e" name="a21f74b54be873b1ca3040b53cb15e99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f74b54be873b1ca3040b53cb15e99e">&#9670;&#160;</a></span>SocketAsync_backend_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketAsync_backend_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_backend_name - Get name of async backend in use @async: Async context. </p>
<p>Returns: String describing backend ("io_uring", "kqueue", "edge-triggered")</p>
<p>Thread-safe: Yes </p>

</div>
</div>
<a id="a229345d46001f8c9e4a0df90339be910" name="a229345d46001f8c9e4a0df90339be910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229345d46001f8c9e4a0df90339be910">&#9670;&#160;</a></span>SocketAsync_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketAsync_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>request_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_cancel - Cancel pending async operation @async: Async context @request_id: Request ID returned from send/recv. </p>
<p>Returns: 0 on success, -1 if request not found or already completed</p>
<p>Thread-safe: Yes</p>
<p>Note: Cancellation is best-effort. Operation may complete before cancellation takes effect. </p>

</div>
</div>
<a id="a2ee23e4535260946b632fc973ac4935a" name="a2ee23e4535260946b632fc973ac4935a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee23e4535260946b632fc973ac4935a">&#9670;&#160;</a></span>SocketAsync_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketAsync_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>async</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_free - Free an async I/O context @async: Pointer to async context (will be set to NULL) Thread-safe: Yes - frees resources. </p>

</div>
</div>
<a id="ab0e10c5a59d6331ea46cb4458307424e" name="ab0e10c5a59d6331ea46cb4458307424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e10c5a59d6331ea46cb4458307424e">&#9670;&#160;</a></span>SocketAsync_is_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketAsync_is_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_is_available - Check if async I/O is available on this platform @async: Async context. </p>
<p>Returns: Non-zero if async I/O is available, 0 if fallback mode</p>
<p>Thread-safe: Yes </p>

</div>
</div>
<a id="a6001469d4be96f6f05d78d1c222784cc" name="a6001469d4be96f6f05d78d1c222784cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6001469d4be96f6f05d78d1c222784cc">&#9670;&#160;</a></span>SocketAsync_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structT.html">T</a> SocketAsync_new </td>
          <td>(</td>
          <td class="paramtype">Arena_T&#160;</td>
          <td class="paramname"><em>arena</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_new - Create a new async I/O context @arena: Arena for memory allocation Returns: New async context (never returns NULL) Raises: SocketAsync_Failed on initialization failure Thread-safe: Yes - returns new instance. </p>
<p>Creates an async context with platform-specific backend initialization. Falls back gracefully if async I/O is unavailable on this platform. </p>

</div>
</div>
<a id="af209d2124b5062b1f294501ea3ae79b2" name="af209d2124b5062b1f294501ea3ae79b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af209d2124b5062b1f294501ea3ae79b2">&#9670;&#160;</a></span>SocketAsync_process_completions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketAsync_process_completions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_process_completions - Process pending async completions @async: Async context @timeout_ms: Timeout in milliseconds (0 = non-blocking) </p>
<p>Returns: Number of completions processed</p>
<p>Thread-safe: Yes - uses internal mutex</p>
<p>Note: This is called automatically by <a class="el" href="SocketPoll_8h.html#a838225b94dfd40f308c49482bca2e7fd" title="SocketPoll_wait - Wait for events @poll: Poll instance @events: Output - array of events that occurre...">SocketPoll_wait()</a>. Applications typically don't need to call this directly. </p>

</div>
</div>
<a id="a966b7ae7c15262f4503a70f869a04ddb" name="a966b7ae7c15262f4503a70f869a04ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966b7ae7c15262f4503a70f869a04ddb">&#9670;&#160;</a></span>SocketAsync_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SocketAsync_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSocket__T.html">Socket_T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketAsync_8h.html#ad6644a0c3153b65fa217ecbc45b5b8f9">SocketAsync_Callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_recv - Submit asynchronous receive operation @async: Async context (from SocketPoll_get_async) @socket: Socket to receive on (must be non-blocking) @buf: Buffer to receive into (must remain valid until callback invoked) @len: Maximum length to receive @cb: Callback to call on completion @user_data: User data passed to callback @flags: Operation flags (currently unused) </p>
<p>Returns: Request ID (&gt; 0) on success, 0 on failure Raises: SocketAsync_Failed if submission fails</p>
<p>Thread-safe: Yes</p>
<p>Note: Callback receives bytes received (0 = EOF, &lt; 0 = error). Buffer must remain valid until callback is invoked. </p>

</div>
</div>
<a id="adf11b6fec4537a1d25ed17038c2f2f7c" name="adf11b6fec4537a1d25ed17038c2f2f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf11b6fec4537a1d25ed17038c2f2f7c">&#9670;&#160;</a></span>SocketAsync_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SocketAsync_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>async</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSocket__T.html">Socket_T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketAsync_8h.html#ad6644a0c3153b65fa217ecbc45b5b8f9">SocketAsync_Callback</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SocketAsync_8h.html#ae66259c675b6f9658c95d34e1fbfefdf">SocketAsync_Flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketAsync_send - Submit asynchronous send operation @async: Async context (from SocketPoll_get_async) @socket: Socket to send on (must be non-blocking) @buf: Data to send @len: Length of data to send @cb: Callback to call on completion @user_data: User data passed to callback @flags: Operation flags (ASYNC_FLAG_ZERO_COPY, etc.) </p>
<p>Returns: Request ID (&gt; 0) on success, 0 on failure Raises: SocketAsync_Failed if submission fails</p>
<p>Thread-safe: Yes - uses internal mutex for request tracking</p>
<p>Note: Operation is submitted immediately. Completion will be delivered via callback when data is sent (or error occurs). Callback is invoked from <a class="el" href="SocketPoll_8h.html#a838225b94dfd40f308c49482bca2e7fd" title="SocketPoll_wait - Wait for events @poll: Poll instance @events: Output - array of events that occurre...">SocketPoll_wait()</a> context - keep it fast!</p>
<p>Partial sends: If only part of data is sent, callback is called with partial byte count. Use SocketAsync_send_continue() to send remainder.</p>
<p>Fallback mode: If async I/O is unavailable (<a class="el" href="SocketAsync_8h.html#ab0e10c5a59d6331ea46cb4458307424e" title="SocketAsync_is_available - Check if async I/O is available on this platform @async: Async context.">SocketAsync_is_available()</a> == 0), the request is queued but not submitted to kernel. Application must complete the operation manually using regular <a class="el" href="Socket_8h.html#ab72bbc8824c7adf5aa55af88b784b9d0" title="Socket_send - Send data @socket: Connected socket @buf: Data to send @len: Length of data (&gt; 0) Retur...">Socket_send()</a>/Socket_recv() and then invoke the callback. Check <a class="el" href="SocketAsync_8h.html#ab0e10c5a59d6331ea46cb4458307424e" title="SocketAsync_is_available - Check if async I/O is available on this platform @async: Async context.">SocketAsync_is_available()</a> to determine mode. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a832db2f86b4c0d8a57dc3def7121d833" name="a832db2f86b4c0d8a57dc3def7121d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832db2f86b4c0d8a57dc3def7121d833">&#9670;&#160;</a></span>SocketAsync_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Except_T SocketAsync_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Async operation failure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_472464c21f3697a4351aeeea96351180.html">socket</a></li><li class="navelem"><a class="el" href="SocketAsync_8h.html">SocketAsync.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
