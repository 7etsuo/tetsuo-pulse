<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Socket Library: SocketBuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('SocketBuf_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SocketBuf.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Arena_8h_source.html">core/Arena.h</a>&quot;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="SocketBuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0acb682b8260ab1c60b918599864e2e5" id="r_a0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;SocketBuf_T</td></tr>
<tr class="memdesc:a0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular Buffer for Socket I/O Provides efficient buffering for network I/O operations using a circular buffer implementation.  <br /></td></tr>
<tr class="separator:a0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24514489b0962fafe8414bfae95aa268" id="r_a24514489b0962fafe8414bfae95aa268"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structT.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a24514489b0962fafe8414bfae95aa268">T</a></td></tr>
<tr class="separator:a24514489b0962fafe8414bfae95aa268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3bf21f035828a8427ab9190fcb864062" id="r_a3bf21f035828a8427ab9190fcb864062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structT.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a3bf21f035828a8427ab9190fcb864062">SocketBuf_new</a> (Arena_T arena, size_t capacity)</td></tr>
<tr class="memdesc:a3bf21f035828a8427ab9190fcb864062"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_new - Create a new circular buffer @arena: Arena for memory allocation @capacity: Buffer capacity in bytes Returns: New buffer instance.  <br /></td></tr>
<tr class="separator:a3bf21f035828a8427ab9190fcb864062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf958f842426764dc619f941b976c4a" id="r_adcf958f842426764dc619f941b976c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#adcf958f842426764dc619f941b976c4a">SocketBuf_release</a> (<a class="el" href="structT.html">T</a> *buf)</td></tr>
<tr class="memdesc:adcf958f842426764dc619f941b976c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_release - Release a buffer reference @buf: Pointer to buffer (will be set to NULL) Arena-based allocation means buffer memory persists until the arena is disposed - individual buffers cannot be freed separately.  <br /></td></tr>
<tr class="separator:adcf958f842426764dc619f941b976c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab0fc2f53dfd288874bc101611397a8" id="r_a2ab0fc2f53dfd288874bc101611397a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a2ab0fc2f53dfd288874bc101611397a8">SocketBuf_write</a> (<a class="el" href="structT.html">T</a> buf, const void *data, size_t len)</td></tr>
<tr class="memdesc:a2ab0fc2f53dfd288874bc101611397a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_write - Write data to buffer @buf: Buffer instance @data: Data to write @len: Length of data Returns: Bytes actually written (may be less if buffer fills) Performance: O(n) where n is bytes written.  <br /></td></tr>
<tr class="separator:a2ab0fc2f53dfd288874bc101611397a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bdacbb4bdbb33f791a3b42041d0978" id="r_a52bdacbb4bdbb33f791a3b42041d0978"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a52bdacbb4bdbb33f791a3b42041d0978">SocketBuf_read</a> (<a class="el" href="structT.html">T</a> buf, void *data, size_t len)</td></tr>
<tr class="memdesc:a52bdacbb4bdbb33f791a3b42041d0978"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_read - Read and remove data from buffer @buf: Buffer instance @data: Destination buffer @len: Maximum bytes to read Returns: Bytes actually read Performance: O(n) where n is bytes read.  <br /></td></tr>
<tr class="separator:a52bdacbb4bdbb33f791a3b42041d0978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de33b1ad02cd2b92da27de821e22eb1" id="r_a0de33b1ad02cd2b92da27de821e22eb1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a0de33b1ad02cd2b92da27de821e22eb1">SocketBuf_peek</a> (<a class="el" href="structT.html">T</a> buf, void *data, size_t len)</td></tr>
<tr class="memdesc:a0de33b1ad02cd2b92da27de821e22eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_peek - Read data without removing it @buf: Buffer instance @data: Destination buffer @len: Maximum bytes to peek Returns: Bytes actually read Performance: O(n) where n is bytes peeked.  <br /></td></tr>
<tr class="separator:a0de33b1ad02cd2b92da27de821e22eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f1f39925ead88382c8fa3a376ce1a" id="r_a2b0f1f39925ead88382c8fa3a376ce1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a2b0f1f39925ead88382c8fa3a376ce1a">SocketBuf_consume</a> (<a class="el" href="structT.html">T</a> buf, size_t len)</td></tr>
<tr class="memdesc:a2b0f1f39925ead88382c8fa3a376ce1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_consume - Remove data without reading @buf: Buffer instance @len: Bytes to remove Asserts if len &gt; available data Performance: O(1)  <br /></td></tr>
<tr class="separator:a2b0f1f39925ead88382c8fa3a376ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c24cb001b8719e744e7b23102cf9cbf" id="r_a1c24cb001b8719e744e7b23102cf9cbf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a1c24cb001b8719e744e7b23102cf9cbf">SocketBuf_available</a> (const <a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:a1c24cb001b8719e744e7b23102cf9cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_available - Get available data size @buf: Buffer instance Returns: Bytes available for reading Performance: O(1)  <br /></td></tr>
<tr class="separator:a1c24cb001b8719e744e7b23102cf9cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbe3e226b9ca23669dff9dc45ec1fec" id="r_a7fbe3e226b9ca23669dff9dc45ec1fec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a7fbe3e226b9ca23669dff9dc45ec1fec">SocketBuf_space</a> (const <a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:a7fbe3e226b9ca23669dff9dc45ec1fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_space - Get available space @buf: Buffer instance Returns: Bytes available for writing Performance: O(1)  <br /></td></tr>
<tr class="separator:a7fbe3e226b9ca23669dff9dc45ec1fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa095538b04982085714da1b0c8536ed5" id="r_aa095538b04982085714da1b0c8536ed5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#aa095538b04982085714da1b0c8536ed5">SocketBuf_empty</a> (const <a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:aa095538b04982085714da1b0c8536ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_empty - Check if buffer is empty @buf: Buffer instance Returns: Non-zero if empty.  <br /></td></tr>
<tr class="separator:aa095538b04982085714da1b0c8536ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaed887af908cf955504cd0258cf26a" id="r_afdaed887af908cf955504cd0258cf26a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#afdaed887af908cf955504cd0258cf26a">SocketBuf_full</a> (const <a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:afdaed887af908cf955504cd0258cf26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_full - Check if buffer is full @buf: Buffer instance Returns: Non-zero if full.  <br /></td></tr>
<tr class="separator:afdaed887af908cf955504cd0258cf26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1901d45150be93f028ceb17fae25a9a9" id="r_a1901d45150be93f028ceb17fae25a9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a1901d45150be93f028ceb17fae25a9a9">SocketBuf_clear</a> (<a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:a1901d45150be93f028ceb17fae25a9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_clear - Clear all data @buf: Buffer instance Resets buffer pointers without clearing memory contents.  <br /></td></tr>
<tr class="separator:a1901d45150be93f028ceb17fae25a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23c64b3d936f901d970330ec945f9e5" id="r_af23c64b3d936f901d970330ec945f9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#af23c64b3d936f901d970330ec945f9e5">SocketBuf_secureclear</a> (<a class="el" href="structT.html">T</a> buf)</td></tr>
<tr class="memdesc:af23c64b3d936f901d970330ec945f9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_secureclear - Securely clear all data @buf: Buffer instance Zeros memory contents before resetting buffer pointers.  <br /></td></tr>
<tr class="separator:af23c64b3d936f901d970330ec945f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af677e1247f6f8e3af0556dd9403afc3f" id="r_af677e1247f6f8e3af0556dd9403afc3f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#af677e1247f6f8e3af0556dd9403afc3f">SocketBuf_readptr</a> (<a class="el" href="structT.html">T</a> buf, size_t *len)</td></tr>
<tr class="memdesc:af677e1247f6f8e3af0556dd9403afc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_readptr - Get direct read pointer @buf: Buffer instance @len: Output - contiguous bytes available Returns: Pointer to data or NULL if empty Performance: O(1) For zero-copy reads.  <br /></td></tr>
<tr class="separator:af677e1247f6f8e3af0556dd9403afc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87441b4a7a435eba0aef8d0ba1617a5d" id="r_a87441b4a7a435eba0aef8d0ba1617a5d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#a87441b4a7a435eba0aef8d0ba1617a5d">SocketBuf_writeptr</a> (<a class="el" href="structT.html">T</a> buf, size_t *len)</td></tr>
<tr class="memdesc:a87441b4a7a435eba0aef8d0ba1617a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_writeptr - Get direct write pointer @buf: Buffer instance @len: Output - contiguous space available Returns: Pointer to write location or NULL if full Performance: O(1) For zero-copy writes.  <br /></td></tr>
<tr class="separator:a87441b4a7a435eba0aef8d0ba1617a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac317b47fb64444fbadc087018059ad5a" id="r_ac317b47fb64444fbadc087018059ad5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html#ac317b47fb64444fbadc087018059ad5a">SocketBuf_written</a> (<a class="el" href="structT.html">T</a> buf, size_t len)</td></tr>
<tr class="memdesc:ac317b47fb64444fbadc087018059ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketBuf_written - Commit written data @buf: Buffer instance @len: Bytes written to writeptr Asserts if len &gt; space available Performance: O(1)  <br /></td></tr>
<tr class="separator:ac317b47fb64444fbadc087018059ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0acb682b8260ab1c60b918599864e2e5" name="a0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="structT.html">T</a>&#160;&#160;&#160;SocketBuf_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular Buffer for Socket I/O Provides efficient buffering for network I/O operations using a circular buffer implementation. </p>
<p>This minimizes memory copies and provides O(1) operations for all buffer operations. Features:</p><ul>
<li>Zero-copy read/write operations where possible</li>
<li>Thread-safe design (when used with proper synchronization)</li>
<li>Automatic wraparound handling</li>
<li>Memory managed by Arena allocator The buffer automatically handles wraparound, so users don't need to worry about circular buffer complexities. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="SocketBuf_8h_source.html#l00021">21</a> of file <a class="el" href="SocketBuf_8h_source.html">SocketBuf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a24514489b0962fafe8414bfae95aa268" name="a24514489b0962fafe8414bfae95aa268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514489b0962fafe8414bfae95aa268">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structT.html">T</a>* <a class="el" href="structT.html">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketBuf_8h_source.html#l00022">22</a> of file <a class="el" href="SocketBuf_8h_source.html">SocketBuf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1c24cb001b8719e744e7b23102cf9cbf" name="a1c24cb001b8719e744e7b23102cf9cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c24cb001b8719e744e7b23102cf9cbf">&#9670;&#160;</a></span>SocketBuf_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_available - Get available data size @buf: Buffer instance Returns: Bytes available for reading Performance: O(1) </p>

</div>
</div>
<a id="a1901d45150be93f028ceb17fae25a9a9" name="a1901d45150be93f028ceb17fae25a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1901d45150be93f028ceb17fae25a9a9">&#9670;&#160;</a></span>SocketBuf_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_clear - Clear all data @buf: Buffer instance Resets buffer pointers without clearing memory contents. </p>
<p>Fast operation suitable for non-sensitive data. For security-sensitive data, use <a class="el" href="SocketBuf_8h.html#af23c64b3d936f901d970330ec945f9e5" title="SocketBuf_secureclear - Securely clear all data @buf: Buffer instance Zeros memory contents before re...">SocketBuf_secureclear()</a> instead. Performance: O(1) </p>

</div>
</div>
<a id="a2b0f1f39925ead88382c8fa3a376ce1a" name="a2b0f1f39925ead88382c8fa3a376ce1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0f1f39925ead88382c8fa3a376ce1a">&#9670;&#160;</a></span>SocketBuf_consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_consume - Remove data without reading @buf: Buffer instance @len: Bytes to remove Asserts if len &gt; available data Performance: O(1) </p>

</div>
</div>
<a id="aa095538b04982085714da1b0c8536ed5" name="aa095538b04982085714da1b0c8536ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa095538b04982085714da1b0c8536ed5">&#9670;&#160;</a></span>SocketBuf_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBuf_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_empty - Check if buffer is empty @buf: Buffer instance Returns: Non-zero if empty. </p>

</div>
</div>
<a id="afdaed887af908cf955504cd0258cf26a" name="afdaed887af908cf955504cd0258cf26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaed887af908cf955504cd0258cf26a">&#9670;&#160;</a></span>SocketBuf_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBuf_full </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_full - Check if buffer is full @buf: Buffer instance Returns: Non-zero if full. </p>

</div>
</div>
<a id="a3bf21f035828a8427ab9190fcb864062" name="a3bf21f035828a8427ab9190fcb864062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf21f035828a8427ab9190fcb864062">&#9670;&#160;</a></span>SocketBuf_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structT.html">T</a> SocketBuf_new </td>
          <td>(</td>
          <td class="paramtype">Arena_T&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_new - Create a new circular buffer @arena: Arena for memory allocation @capacity: Buffer capacity in bytes Returns: New buffer instance. </p>

</div>
</div>
<a id="a0de33b1ad02cd2b92da27de821e22eb1" name="a0de33b1ad02cd2b92da27de821e22eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de33b1ad02cd2b92da27de821e22eb1">&#9670;&#160;</a></span>SocketBuf_peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_peek - Read data without removing it @buf: Buffer instance @data: Destination buffer @len: Maximum bytes to peek Returns: Bytes actually read Performance: O(n) where n is bytes peeked. </p>

</div>
</div>
<a id="a52bdacbb4bdbb33f791a3b42041d0978" name="a52bdacbb4bdbb33f791a3b42041d0978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bdacbb4bdbb33f791a3b42041d0978">&#9670;&#160;</a></span>SocketBuf_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_read - Read and remove data from buffer @buf: Buffer instance @data: Destination buffer @len: Maximum bytes to read Returns: Bytes actually read Performance: O(n) where n is bytes read. </p>

</div>
</div>
<a id="af677e1247f6f8e3af0556dd9403afc3f" name="af677e1247f6f8e3af0556dd9403afc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af677e1247f6f8e3af0556dd9403afc3f">&#9670;&#160;</a></span>SocketBuf_readptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * SocketBuf_readptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_readptr - Get direct read pointer @buf: Buffer instance @len: Output - contiguous bytes available Returns: Pointer to data or NULL if empty Performance: O(1) For zero-copy reads. </p>
<p>Data remains in buffer until consumed. </p>

</div>
</div>
<a id="adcf958f842426764dc619f941b976c4a" name="adcf958f842426764dc619f941b976c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf958f842426764dc619f941b976c4a">&#9670;&#160;</a></span>SocketBuf_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_release - Release a buffer reference @buf: Pointer to buffer (will be set to NULL) Arena-based allocation means buffer memory persists until the arena is disposed - individual buffers cannot be freed separately. </p>
<p>This function invalidates the buffer pointer to prevent accidental access through stale pointers. The buffer memory will be automatically freed when the arena is disposed. This is the fundamental arena allocation pattern, not a limitation to work around. </p>

</div>
</div>
<a id="af23c64b3d936f901d970330ec945f9e5" name="af23c64b3d936f901d970330ec945f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23c64b3d936f901d970330ec945f9e5">&#9670;&#160;</a></span>SocketBuf_secureclear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_secureclear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_secureclear - Securely clear all data @buf: Buffer instance Zeros memory contents before resetting buffer pointers. </p>
<p>Use this for buffers containing sensitive data (passwords, keys, etc.) Performance: O(n) where n is buffer capacity Note: Always use secureclear when removing connections that may have handled sensitive data to prevent information disclosure. </p>

</div>
</div>
<a id="a7fbe3e226b9ca23669dff9dc45ec1fec" name="a7fbe3e226b9ca23669dff9dc45ec1fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbe3e226b9ca23669dff9dc45ec1fec">&#9670;&#160;</a></span>SocketBuf_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_space - Get available space @buf: Buffer instance Returns: Bytes available for writing Performance: O(1) </p>

</div>
</div>
<a id="a2ab0fc2f53dfd288874bc101611397a8" name="a2ab0fc2f53dfd288874bc101611397a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab0fc2f53dfd288874bc101611397a8">&#9670;&#160;</a></span>SocketBuf_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_write - Write data to buffer @buf: Buffer instance @data: Data to write @len: Length of data Returns: Bytes actually written (may be less if buffer fills) Performance: O(n) where n is bytes written. </p>

</div>
</div>
<a id="a87441b4a7a435eba0aef8d0ba1617a5d" name="a87441b4a7a435eba0aef8d0ba1617a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87441b4a7a435eba0aef8d0ba1617a5d">&#9670;&#160;</a></span>SocketBuf_writeptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SocketBuf_writeptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_writeptr - Get direct write pointer @buf: Buffer instance @len: Output - contiguous space available Returns: Pointer to write location or NULL if full Performance: O(1) For zero-copy writes. </p>
<p>Call <a class="el" href="SocketBuf_8h.html#ac317b47fb64444fbadc087018059ad5a" title="SocketBuf_written - Commit written data @buf: Buffer instance @len: Bytes written to writeptr Asserts...">SocketBuf_written()</a> after writing. </p>

</div>
</div>
<a id="ac317b47fb64444fbadc087018059ad5a" name="ac317b47fb64444fbadc087018059ad5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac317b47fb64444fbadc087018059ad5a">&#9670;&#160;</a></span>SocketBuf_written()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_written </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketBuf_written - Commit written data @buf: Buffer instance @len: Bytes written to writeptr Asserts if len &gt; space available Performance: O(1) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_472464c21f3697a4351aeeea96351180.html">socket</a></li><li class="navelem"><a class="el" href="SocketBuf_8h.html">SocketBuf.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
