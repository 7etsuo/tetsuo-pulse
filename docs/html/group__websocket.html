<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tetsuo Pulse: WebSocket Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="socket-brand.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Tetsuo Pulse<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance networking from Tetsuo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__websocket.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">WebSocket Modules</div></div>
</div><!--header-->
<div class="contents">

<p>WebSocket protocol support for client and server, with framing, compression, and integration.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:SocketWS-private_8h" id="r_SocketWS-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketWS-private_8h.html">SocketWS-private.h</a></td></tr>
<tr class="memdesc:SocketWS-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation details for WebSocket module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketWS_8h" id="r_SocketWS_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketWS_8h.html">SocketWS.h</a></td></tr>
<tr class="memdesc:SocketWS_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket Protocol (RFC 6455) implementation with compression support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketWS__FrameParse" id="r_structSocketWS__FrameParse"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a></td></tr>
<tr class="memdesc:structSocketWS__FrameParse"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for parsing incoming WebSocket frames.  <a href="group__websocket.html#structSocketWS__FrameParse">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__FrameParse"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__MessageAssembly" id="r_structSocketWS__MessageAssembly"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__MessageAssembly">SocketWS_MessageAssembly</a></td></tr>
<tr class="memdesc:structSocketWS__MessageAssembly"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for reassembling fragmented WebSocket messages.  <a href="group__websocket.html#structSocketWS__MessageAssembly">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__MessageAssembly"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__Handshake" id="r_structSocketWS__Handshake"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__Handshake">SocketWS_Handshake</a></td></tr>
<tr class="memdesc:structSocketWS__Handshake"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for WebSocket HTTP upgrade handshake.  <a href="group__websocket.html#structSocketWS__Handshake">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__Handshake"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS" id="r_structSocketWS"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS">SocketWS_T</a></td></tr>
<tr class="memdesc:structSocketWS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque WebSocket connection context holding all protocol state.  <a href="group__websocket.html#structSocketWS">More...</a><br /></td></tr>
<tr class="separator:structSocketWS"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__Config" id="r_structSocketWS__Config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a></td></tr>
<tr class="memdesc:structSocketWS__Config"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration parameters for WebSocket instances.  <a href="group__websocket.html#structSocketWS__Config">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__Config"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__Frame" id="r_structSocketWS__Frame"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__Frame">SocketWS_Frame</a></td></tr>
<tr class="memdesc:structSocketWS__Frame"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a parsed WebSocket frame.  <a href="group__websocket.html#structSocketWS__Frame">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__Frame"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__Message" id="r_structSocketWS__Message"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__Message">SocketWS_Message</a></td></tr>
<tr class="memdesc:structSocketWS__Message"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete reassembled WebSocket message from recv_message().  <a href="group__websocket.html#structSocketWS__Message">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__Message"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketWS__CompressionOptions" id="r_structSocketWS__CompressionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a></td></tr>
<tr class="memdesc:structSocketWS__CompressionOptions"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket compression options.  <a href="group__websocket.html#structSocketWS__CompressionOptions">More...</a><br /></td></tr>
<tr class="separator:structSocketWS__CompressionOptions"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9819e96f9d91fe108c80c7513bf1d4af" id="r_ga9819e96f9d91fe108c80c7513bf1d4af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9819e96f9d91fe108c80c7513bf1d4af">SOCKETWS_MAX_FRAME_SIZE</a>&#160;&#160;&#160;(16 * 1024 * 1024)</td></tr>
<tr class="separator:ga9819e96f9d91fe108c80c7513bf1d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f84e7a4e066091e7a75f51507d3391" id="r_gad2f84e7a4e066091e7a75f51507d3391"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gad2f84e7a4e066091e7a75f51507d3391">SOCKETWS_PROTOCOL_VERSION</a>&#160;&#160;&#160;&quot;13&quot;</td></tr>
<tr class="separator:gad2f84e7a4e066091e7a75f51507d3391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21b49963e774f217dd5558e8ce0fbc6" id="r_gaf21b49963e774f217dd5558e8ce0fbc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaf21b49963e774f217dd5558e8ce0fbc6">SOCKETWS_XOR_ALIGN_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gaf21b49963e774f217dd5558e8ce0fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be4ad7326c3c8e0480ae9ca4170bc79" id="r_ga9be4ad7326c3c8e0480ae9ca4170bc79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9be4ad7326c3c8e0480ae9ca4170bc79">SOCKETWS_BASE_HEADER_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga9be4ad7326c3c8e0480ae9ca4170bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9cdb003a53aa826efee47bcfbd59b6" id="r_ga9b9cdb003a53aa826efee47bcfbd59b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9b9cdb003a53aa826efee47bcfbd59b6">SOCKETWS_FIN_BIT</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:ga9b9cdb003a53aa826efee47bcfbd59b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012fa1b5257d1188d71ec84b86513bda" id="r_ga012fa1b5257d1188d71ec84b86513bda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga012fa1b5257d1188d71ec84b86513bda">SOCKETWS_SEND_CHUNK_SIZE</a>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:ga012fa1b5257d1188d71ec84b86513bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47afcd717fda7a921345994a4e5f4a5" id="r_gad47afcd717fda7a921345994a4e5f4a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gad47afcd717fda7a921345994a4e5f4a5">RAISE_WS_ERROR</a>(e)&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (<a class="el" href="group__websocket.html#structSocketWS">SocketWS</a>, e)</td></tr>
<tr class="memdesc:gad47afcd717fda7a921345994a4e5f4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local exception declarations for <a class="el" href="group__websocket.html#structSocketWS" title="Opaque WebSocket connection context holding all protocol state.">SocketWS</a> module.  <br /></td></tr>
<tr class="separator:gad47afcd717fda7a921345994a4e5f4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;SocketWS_T</td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacba3d485716ab762c1ecd90312174721" id="r_gacba3d485716ab762c1ecd90312174721"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gacba3d485716ab762c1ecd90312174721">SocketWS_FrameState</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec">WS_FRAME_STATE_HEADER</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721af660d590efb4ea061786e8482299f185">WS_FRAME_STATE_EXTENDED_LEN</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721ac2be9581030ed942d7ac8a599522a991">WS_FRAME_STATE_MASK_KEY</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721afe6b85e3f7bb21768bd711b5c788defe">WS_FRAME_STATE_PAYLOAD</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721a03af376c7e0d083cafca2056a7a1913c">WS_FRAME_STATE_COMPLETE</a>
<br />
 }</td></tr>
<tr class="memdesc:gacba3d485716ab762c1ecd90312174721"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for the frame parsing state machine.  <a href="group__websocket.html#gacba3d485716ab762c1ecd90312174721">More...</a><br /></td></tr>
<tr class="separator:gacba3d485716ab762c1ecd90312174721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2bca991ca02e642b76a7ecc166943c" id="r_gafb2bca991ca02e642b76a7ecc166943c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gafb2bca991ca02e642b76a7ecc166943c">SocketWS_HandshakeState</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggafb2bca991ca02e642b76a7ecc166943cafe125c7c26a9431e7e7f5a71e35d47bc">WS_HANDSHAKE_INIT</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggafb2bca991ca02e642b76a7ecc166943cad8f0ee2a2480a3cde670e3e87265bbc3">WS_HANDSHAKE_SENDING_REQUEST</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggafb2bca991ca02e642b76a7ecc166943ca25652911320a61aa0f678b7b369a222d">WS_HANDSHAKE_READING_RESPONSE</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggafb2bca991ca02e642b76a7ecc166943ca1819c5beb0d322efdacf6438eb3c3c32">WS_HANDSHAKE_COMPLETE</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggafb2bca991ca02e642b76a7ecc166943ca0fb5763d6e764dbe2fbf97169c1a2b1b">WS_HANDSHAKE_FAILED</a>
<br />
 }</td></tr>
<tr class="memdesc:gafb2bca991ca02e642b76a7ecc166943c"><td class="mdescLeft">&#160;</td><td class="mdescRight">States for WebSocket HTTP upgrade handshake.  <a href="group__websocket.html#gafb2bca991ca02e642b76a7ecc166943c">More...</a><br /></td></tr>
<tr class="separator:gafb2bca991ca02e642b76a7ecc166943c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174740343c7f920060f8640f23600c7b" id="r_ga174740343c7f920060f8640f23600c7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba414ed52e10fc98a59c9fbadc896b3ea3">WS_OPCODE_CONTINUATION</a> = 0x0
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7bab290478c848bb099a2fefe6c7b633558">WS_OPCODE_TEXT</a> = 0x1
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba01f825533b31920937ba5ddb2315a361">WS_OPCODE_BINARY</a> = 0x2
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5">WS_OPCODE_CLOSE</a> = 0x8
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539">WS_OPCODE_PING</a> = 0x9
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c">WS_OPCODE_PONG</a> = 0xA
<br />
 }</td></tr>
<tr class="memdesc:ga174740343c7f920060f8640f23600c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket frame opcodes as defined in RFC 6455 section 5.2.  <a href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">More...</a><br /></td></tr>
<tr class="separator:ga174740343c7f920060f8640f23600c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386c437e966aeaeb091d1d81c0e77b13" id="r_ga386c437e966aeaeb091d1d81c0e77b13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">SocketWS_CloseCode</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30">WS_CLOSE_NORMAL</a> = 1000
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a9bb565620ebf9a5c79afa6281a253b6d">WS_CLOSE_GOING_AWAY</a> = 1001
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13aaf641b4eedfe849aeed35a84f61709bf">WS_CLOSE_PROTOCOL_ERROR</a> = 1002
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a2852358b8d5151feda017ab29972f16e">WS_CLOSE_UNSUPPORTED_DATA</a> = 1003
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a859b46a0f5a7a29e664a22a1c1c86919">WS_CLOSE_NO_STATUS</a> = 1005
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13aa5b58d4bfbfbeb754edc424760ff4b04">WS_CLOSE_ABNORMAL</a> = 1006
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a5fcad814a12fede092794145c328fb9f">WS_CLOSE_INVALID_PAYLOAD</a> = 1007
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a35ac58f4457834de3faeb1fa7792366d">WS_CLOSE_POLICY_VIOLATION</a> = 1008
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13adbdae48a85dc5e937a163e01508001c6">WS_CLOSE_MESSAGE_TOO_BIG</a> = 1009
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a1f6f581ca2b8fc652c8ffb993fb8194a">WS_CLOSE_MANDATORY_EXT</a> = 1010
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a5724188e50f92c13d3673f08ce69412a">WS_CLOSE_INTERNAL_ERROR</a> = 1011
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a9af38cc3ecad679dcf15e666000dfa4b">WS_CLOSE_SERVICE_RESTART</a> = 1012
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13ae899716cd2fc4d8f76d4dad9889129e2">WS_CLOSE_TRY_AGAIN_LATER</a> = 1013
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13ac0935030c6af954b99019692f8757b1b">WS_CLOSE_BAD_GATEWAY</a> = 1014
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13aceffd9fee405e4dee36e9596939ba5ec">WS_CLOSE_TLS_HANDSHAKE</a> = 1015
<br />
 }</td></tr>
<tr class="memdesc:ga386c437e966aeaeb091d1d81c0e77b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes for WebSocket CLOSE frames (RFC 6455 section 7.4).  <a href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">More...</a><br /></td></tr>
<tr class="separator:ga386c437e966aeaeb091d1d81c0e77b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b49607a661224d66bb264b1e597e2d" id="r_gab8b49607a661224d66bb264b1e597e2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">SocketWS_State</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2da782bbde9b515882abdd6b712c127af31">WS_STATE_CONNECTING</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c">WS_STATE_OPEN</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2daa3bafc31c6e8514011174ffeb2dd1eac">WS_STATE_CLOSING</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2da4356293e46722d1fa27ca8624f62b296">WS_STATE_CLOSED</a>
<br />
 }</td></tr>
<tr class="memdesc:gab8b49607a661224d66bb264b1e597e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket connection lifecycle states.  <a href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">More...</a><br /></td></tr>
<tr class="separator:gab8b49607a661224d66bb264b1e597e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d14d3d0f1b05e44fcd74782107cbd94" id="r_ga9d14d3d0f1b05e44fcd74782107cbd94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9d14d3d0f1b05e44fcd74782107cbd94">SocketWS_Role</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga9d14d3d0f1b05e44fcd74782107cbd94adb564f62107e65c4ba508183929404d1">WS_ROLE_CLIENT</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#gga9d14d3d0f1b05e44fcd74782107cbd94afa4a0c78e19b98cca7f556560ca4061b">WS_ROLE_SERVER</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9d14d3d0f1b05e44fcd74782107cbd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket endpoint roles per RFC 6455.  <a href="group__websocket.html#ga9d14d3d0f1b05e44fcd74782107cbd94">More...</a><br /></td></tr>
<tr class="separator:ga9d14d3d0f1b05e44fcd74782107cbd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd79199a60ad91cf785166f24f41101f" id="r_gabd79199a60ad91cf785166f24f41101f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> { <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb">WS_OK</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101faa41b8e2f5c20dd621e69746820e10ecd">WS_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa326cba4dbca2cd3fc40aa705e3c8c43c">WS_ERROR_HANDSHAKE</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fac3b45ed8d1cffbe97ae99ad9368edfec">WS_ERROR_PROTOCOL</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fad67cba0f02674ecdb494d3c897945304">WS_ERROR_FRAME_TOO_LARGE</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa202edc337483e9a546142eeadae60afa">WS_ERROR_MESSAGE_TOO_LARGE</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa276c19a5f29e2a5d3032eeebf7d54a8e">WS_ERROR_INVALID_UTF8</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa7bb811cc75e39503c96e5e58f41e392f">WS_ERROR_COMPRESSION</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa4b6bd8241f6074e7efa54cc113fce39c">WS_ERROR_CLOSED</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fad8bea1e89b1464f633c15cc454699761">WS_ERROR_WOULD_BLOCK</a>
, <br />
&#160;&#160;<a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fab7f48522858a5f62bb83f2102996daaf">WS_ERROR_TIMEOUT</a>
<br />
 }</td></tr>
<tr class="memdesc:gabd79199a60ad91cf785166f24f41101f"><td class="mdescLeft">&#160;</td><td class="mdescRight">WebSocket-specific error codes for <a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a>.  <a href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">More...</a><br /></td></tr>
<tr class="separator:gabd79199a60ad91cf785166f24f41101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga61d40db3bbab58f4459e01c6bc2c1271" id="r_ga61d40db3bbab58f4459e01c6bc2c1271"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga61d40db3bbab58f4459e01c6bc2c1271">ws_copy_string</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, const char *str)</td></tr>
<tr class="memdesc:ga61d40db3bbab58f4459e01c6bc2c1271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arena-allocated duplicate of input string.  <br /></td></tr>
<tr class="separator:ga61d40db3bbab58f4459e01c6bc2c1271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a311879f7320da8320ad3498a99e34" id="r_gae9a311879f7320da8320ad3498a99e34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34">ws_send_control_frame</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode, const unsigned char *payload, size_t len)</td></tr>
<tr class="memdesc:gae9a311879f7320da8320ad3498a99e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends WebSocket control frame: PING, PONG, or CLOSE.  <br /></td></tr>
<tr class="separator:gae9a311879f7320da8320ad3498a99e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e85c4df84bca9d7182a1196c4e0c723" id="r_ga9e85c4df84bca9d7182a1196c4e0c723"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9e85c4df84bca9d7182a1196c4e0c723">ws_send_data_frame</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode, const unsigned char *data, size_t len, int fin)</td></tr>
<tr class="memdesc:ga9e85c4df84bca9d7182a1196c4e0c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a WebSocket data frame (TEXT or BINARY).  <br /></td></tr>
<tr class="separator:ga9e85c4df84bca9d7182a1196c4e0c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e70a359f4a97f9eb37d3805c776e4f" id="r_gae2e70a359f4a97f9eb37d3805c776e4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f">ws_frame_reset</a> (<a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a> *frame)</td></tr>
<tr class="memdesc:gae2e70a359f4a97f9eb37d3805c776e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset frame parser to initial state for new incoming frame.  <br /></td></tr>
<tr class="separator:gae2e70a359f4a97f9eb37d3805c776e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec0a78346a127f0919e6b9e61e79ecf" id="r_ga8ec0a78346a127f0919e6b9e61e79ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf">ws_frame_parse_header</a> (<a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a> *frame, const unsigned char *data, size_t len, size_t *consumed)</td></tr>
<tr class="memdesc:ga8ec0a78346a127f0919e6b9e61e79ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementally parses WebSocket frame header from input data.  <br /></td></tr>
<tr class="separator:ga8ec0a78346a127f0919e6b9e61e79ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0cb16d7a760ff6ea58750797c85ee15" id="r_gad0cb16d7a760ff6ea58750797c85ee15"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gad0cb16d7a760ff6ea58750797c85ee15">ws_frame_build_header</a> (unsigned char *header, int fin, <a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode, int masked, const unsigned char *mask_key, uint64_t payload_len)</td></tr>
<tr class="memdesc:gad0cb16d7a760ff6ea58750797c85ee15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the binary WebSocket frame header into output buffer.  <br /></td></tr>
<tr class="separator:gad0cb16d7a760ff6ea58750797c85ee15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6113393ea2f0b3b64b3e4a48299f899b" id="r_ga6113393ea2f0b3b64b3e4a48299f899b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga6113393ea2f0b3b64b3e4a48299f899b">ws_mask_payload</a> (unsigned char *data, size_t len, const unsigned char mask[4])</td></tr>
<tr class="memdesc:ga6113393ea2f0b3b64b3e4a48299f899b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies XOR masking to WebSocket payload data in place.  <br /></td></tr>
<tr class="separator:ga6113393ea2f0b3b64b3e4a48299f899b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f8bce3f762e01c75870b2dbb49d63d" id="r_ga90f8bce3f762e01c75870b2dbb49d63d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga90f8bce3f762e01c75870b2dbb49d63d">ws_mask_payload_offset</a> (unsigned char *data, size_t len, const unsigned char mask[4], size_t offset)</td></tr>
<tr class="memdesc:ga90f8bce3f762e01c75870b2dbb49d63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies XOR masking to payload starting from a given mask offset.  <br /></td></tr>
<tr class="separator:ga90f8bce3f762e01c75870b2dbb49d63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1986f23bb035bce3c7e5bbf5c741512" id="r_gae1986f23bb035bce3c7e5bbf5c741512"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gae1986f23bb035bce3c7e5bbf5c741512">ws_handshake_client_init</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gae1986f23bb035bce3c7e5bbf5c741512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the client-side WebSocket handshake.  <br /></td></tr>
<tr class="separator:gae1986f23bb035bce3c7e5bbf5c741512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbed5c235e2175a894cf83f64d8c9859" id="r_gacbed5c235e2175a894cf83f64d8c9859"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gacbed5c235e2175a894cf83f64d8c9859">ws_handshake_client_process</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gacbed5c235e2175a894cf83f64d8c9859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes client handshake I/O in non-blocking manner.  <br /></td></tr>
<tr class="separator:gacbed5c235e2175a894cf83f64d8c9859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169d28fa02ed8486e26122116361cdcd" id="r_ga169d28fa02ed8486e26122116361cdcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga169d28fa02ed8486e26122116361cdcd">ws_handshake_server_init</a> (SocketWS_T ws, const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *request)</td></tr>
<tr class="memdesc:ga169d28fa02ed8486e26122116361cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the server-side WebSocket handshake from HTTP request.  <br /></td></tr>
<tr class="separator:ga169d28fa02ed8486e26122116361cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1dba4490ebb1e999c4755073516058" id="r_gadb1dba4490ebb1e999c4755073516058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gadb1dba4490ebb1e999c4755073516058">ws_handshake_server_process</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gadb1dba4490ebb1e999c4755073516058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes server handshake I/O in non-blocking manner.  <br /></td></tr>
<tr class="separator:gadb1dba4490ebb1e999c4755073516058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef559ed5e6042e33c40db0e7c56844ce" id="r_gaef559ed5e6042e33c40db0e7c56844ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaef559ed5e6042e33c40db0e7c56844ce">ws_handshake_validate_accept</a> (SocketWS_T ws, const char *accept)</td></tr>
<tr class="memdesc:gaef559ed5e6042e33c40db0e7c56844ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the server's Sec-WebSocket-Accept header value.  <br /></td></tr>
<tr class="separator:gaef559ed5e6042e33c40db0e7c56844ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace05878bd32167161fae6250c01d97f" id="r_gaace05878bd32167161fae6250c01d97f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaace05878bd32167161fae6250c01d97f">ws_send_close</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">SocketWS_CloseCode</a> code, const char *reason)</td></tr>
<tr class="memdesc:gaace05878bd32167161fae6250c01d97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a WebSocket CLOSE control frame to initiate graceful shutdown.  <br /></td></tr>
<tr class="separator:gaace05878bd32167161fae6250c01d97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c6c5ca0bace14d46703343595a785b" id="r_ga99c6c5ca0bace14d46703343595a785b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga99c6c5ca0bace14d46703343595a785b">ws_send_ping</a> (SocketWS_T ws, const unsigned char *payload, size_t len)</td></tr>
<tr class="memdesc:ga99c6c5ca0bace14d46703343595a785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a WebSocket PING control frame for keepalive.  <br /></td></tr>
<tr class="separator:ga99c6c5ca0bace14d46703343595a785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7edd214f1189fb37ce58c28a47771151" id="r_ga7edd214f1189fb37ce58c28a47771151"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga7edd214f1189fb37ce58c28a47771151">ws_send_pong</a> (SocketWS_T ws, const unsigned char *payload, size_t len)</td></tr>
<tr class="memdesc:ga7edd214f1189fb37ce58c28a47771151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a WebSocket PONG control frame in response to PING.  <br /></td></tr>
<tr class="separator:ga7edd214f1189fb37ce58c28a47771151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0130824d7127448b8b21b3477f65da72" id="r_ga0130824d7127448b8b21b3477f65da72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga0130824d7127448b8b21b3477f65da72">ws_handle_control_frame</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode, const unsigned char *payload, size_t len)</td></tr>
<tr class="memdesc:ga0130824d7127448b8b21b3477f65da72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a received WebSocket control frame (CLOSE, PING, PONG).  <br /></td></tr>
<tr class="separator:ga0130824d7127448b8b21b3477f65da72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56e5c15d95b50879444eaa9509a77cc" id="r_gac56e5c15d95b50879444eaa9509a77cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gac56e5c15d95b50879444eaa9509a77cc">ws_message_reset</a> (<a class="el" href="group__websocket.html#structSocketWS__MessageAssembly">SocketWS_MessageAssembly</a> *message)</td></tr>
<tr class="memdesc:gac56e5c15d95b50879444eaa9509a77cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the message reassembly state for a new message.  <br /></td></tr>
<tr class="separator:gac56e5c15d95b50879444eaa9509a77cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02d493e3ec3a1da7c2b038813e0b109f" id="r_ga02d493e3ec3a1da7c2b038813e0b109f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga02d493e3ec3a1da7c2b038813e0b109f">ws_message_append</a> (SocketWS_T ws, const unsigned char *data, size_t len, int is_text)</td></tr>
<tr class="memdesc:ga02d493e3ec3a1da7c2b038813e0b109f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a data frame fragment to the current message assembly.  <br /></td></tr>
<tr class="separator:ga02d493e3ec3a1da7c2b038813e0b109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66f78da53262b5c3047bb39ad410a32" id="r_gad66f78da53262b5c3047bb39ad410a32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gad66f78da53262b5c3047bb39ad410a32">ws_message_finalize</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gad66f78da53262b5c3047bb39ad410a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes message assembly on last fragment and delivers to user.  <br /></td></tr>
<tr class="separator:gad66f78da53262b5c3047bb39ad410a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894fa2a0c6b617c386a9c3a462d5782c" id="r_ga894fa2a0c6b617c386a9c3a462d5782c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga894fa2a0c6b617c386a9c3a462d5782c">ws_auto_ping_start</a> (SocketWS_T ws, <a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:ga894fa2a0c6b617c386a9c3a462d5782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the automatic PING timer for keepalive.  <br /></td></tr>
<tr class="separator:ga894fa2a0c6b617c386a9c3a462d5782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b50ea33ceb9a7b2b23a060c88dafe65" id="r_ga8b50ea33ceb9a7b2b23a060c88dafe65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga8b50ea33ceb9a7b2b23a060c88dafe65">ws_auto_ping_stop</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga8b50ea33ceb9a7b2b23a060c88dafe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the automatic PING timer.  <br /></td></tr>
<tr class="separator:ga8b50ea33ceb9a7b2b23a060c88dafe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64371d8325fa07e7e369fb21deed42f8" id="r_ga64371d8325fa07e7e369fb21deed42f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga64371d8325fa07e7e369fb21deed42f8">ws_auto_ping_callback</a> (void *userdata)</td></tr>
<tr class="memdesc:ga64371d8325fa07e7e369fb21deed42f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback invoked to send periodic PING.  <br /></td></tr>
<tr class="separator:ga64371d8325fa07e7e369fb21deed42f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga472e8d20997877be54c73a9250f1f4ee" id="r_ga472e8d20997877be54c73a9250f1f4ee"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga472e8d20997877be54c73a9250f1f4ee">ws_flush_send_buffer</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga472e8d20997877be54c73a9250f1f4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes pending data from send buffer to underlying socket.  <br /></td></tr>
<tr class="separator:ga472e8d20997877be54c73a9250f1f4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434b1ea5d42a6c1be49a4f9e054453a0" id="r_ga434b1ea5d42a6c1be49a4f9e054453a0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga434b1ea5d42a6c1be49a4f9e054453a0">ws_fill_recv_buffer</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga434b1ea5d42a6c1be49a4f9e054453a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the receive buffer from the underlying socket.  <br /></td></tr>
<tr class="separator:ga434b1ea5d42a6c1be49a4f9e054453a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26b26aa679375629c245be95eaaf222" id="r_gab26b26aa679375629c245be95eaaf222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gab26b26aa679375629c245be95eaaf222">ws_set_error</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> error, const char *fmt,...)</td></tr>
<tr class="memdesc:gab26b26aa679375629c245be95eaaf222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last error code and formats error message.  <br /></td></tr>
<tr class="separator:gab26b26aa679375629c245be95eaaf222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf415773c31b2c3cd0c3b2635c22dd567" id="r_gaf415773c31b2c3cd0c3b2635c22dd567"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaf415773c31b2c3cd0c3b2635c22dd567">ws_is_control_opcode</a> (<a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode)</td></tr>
<tr class="memdesc:gaf415773c31b2c3cd0c3b2635c22dd567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if opcode represents a control frame.  <br /></td></tr>
<tr class="separator:gaf415773c31b2c3cd0c3b2635c22dd567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc98c465269b350fadb1880315c719ce" id="r_gafc98c465269b350fadb1880315c719ce"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gafc98c465269b350fadb1880315c719ce">ws_is_data_opcode</a> (<a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode)</td></tr>
<tr class="memdesc:gafc98c465269b350fadb1880315c719ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if opcode represents a data frame.  <br /></td></tr>
<tr class="separator:gafc98c465269b350fadb1880315c719ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac157fe7e464e93ae43cc2adb7450b" id="r_ga29ac157fe7e464e93ae43cc2adb7450b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga29ac157fe7e464e93ae43cc2adb7450b">ws_is_valid_opcode</a> (<a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a> opcode)</td></tr>
<tr class="memdesc:ga29ac157fe7e464e93ae43cc2adb7450b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a WebSocket opcode is valid per RFC 6455.  <br /></td></tr>
<tr class="separator:ga29ac157fe7e464e93ae43cc2adb7450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa294a0ac7ea37e1701081a48f47da419" id="r_gaa294a0ac7ea37e1701081a48f47da419"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaa294a0ac7ea37e1701081a48f47da419">ws_is_valid_close_code</a> (int code)</td></tr>
<tr class="memdesc:gaa294a0ac7ea37e1701081a48f47da419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate close status code per RFC 6455.  <br /></td></tr>
<tr class="separator:gaa294a0ac7ea37e1701081a48f47da419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac129f58e59f8b169f2c2a48a330fb176" id="r_gac129f58e59f8b169f2c2a48a330fb176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176">SocketWS_config_defaults</a> (<a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *config)</td></tr>
<tr class="memdesc:gac129f58e59f8b169f2c2a48a330fb176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize WebSocket configuration with default values.  <br /></td></tr>
<tr class="separator:gac129f58e59f8b169f2c2a48a330fb176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad45d5dbc4f2191ba5f732a1b648842" id="r_gacad45d5dbc4f2191ba5f732a1b648842"><td class="memItemLeft" align="right" valign="top">SocketWS_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842">SocketWS_client_new</a> (Socket_T socket, const char *host, const char *path, const <a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *config)</td></tr>
<tr class="memdesc:gacad45d5dbc4f2191ba5f732a1b648842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new client WebSocket instance from a connected TCP socket.  <br /></td></tr>
<tr class="separator:gacad45d5dbc4f2191ba5f732a1b648842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd34fccaadaee0c043bbb1368c3d0673" id="r_gabd34fccaadaee0c043bbb1368c3d0673"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gabd34fccaadaee0c043bbb1368c3d0673">SocketWS_is_upgrade</a> (const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *request)</td></tr>
<tr class="memdesc:gabd34fccaadaee0c043bbb1368c3d0673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an HTTP request is a valid WebSocket upgrade request.  <br /></td></tr>
<tr class="separator:gabd34fccaadaee0c043bbb1368c3d0673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e02ecca2d5a1b78d0eaf2c08883960" id="r_ga29e02ecca2d5a1b78d0eaf2c08883960"><td class="memItemLeft" align="right" valign="top">SocketWS_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960">SocketWS_server_accept</a> (Socket_T socket, const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *request, const <a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *config)</td></tr>
<tr class="memdesc:ga29e02ecca2d5a1b78d0eaf2c08883960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a WebSocket upgrade from a parsed HTTP request on a server socket.  <br /></td></tr>
<tr class="separator:ga29e02ecca2d5a1b78d0eaf2c08883960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6e400c85623f8603c5965d38b1a60e0" id="r_gad6e400c85623f8603c5965d38b1a60e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gad6e400c85623f8603c5965d38b1a60e0">SocketWS_server_reject</a> (Socket_T socket, int status_code, const char *reason)</td></tr>
<tr class="memdesc:gad6e400c85623f8603c5965d38b1a60e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject a WebSocket upgrade request with an HTTP error response.  <br /></td></tr>
<tr class="separator:gad6e400c85623f8603c5965d38b1a60e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa040ebe5bc5f2673b04b15091a45b944" id="r_gaa040ebe5bc5f2673b04b15091a45b944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944">SocketWS_free</a> (SocketWS_T *ws)</td></tr>
<tr class="memdesc:gaa040ebe5bc5f2673b04b15091a45b944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of a WebSocket instance, closing connection if open.  <br /></td></tr>
<tr class="separator:gaa040ebe5bc5f2673b04b15091a45b944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbea030dbe9d643b7f8bd6c1656ff06" id="r_gacbbea030dbe9d643b7f8bd6c1656ff06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06">SocketWS_handshake</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gacbbea030dbe9d643b7f8bd6c1656ff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform or continue the WebSocket handshake process.  <br /></td></tr>
<tr class="separator:gacbbea030dbe9d643b7f8bd6c1656ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40def588d31ab50126603fa720f83b0" id="r_gaa40def588d31ab50126603fa720f83b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">SocketWS_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0">SocketWS_state</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gaa40def588d31ab50126603fa720f83b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current state of the WebSocket connection.  <br /></td></tr>
<tr class="separator:gaa40def588d31ab50126603fa720f83b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e6f2953f92843874cd7b6c3e363288" id="r_ga00e6f2953f92843874cd7b6c3e363288"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga00e6f2953f92843874cd7b6c3e363288">SocketWS_socket</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga00e6f2953f92843874cd7b6c3e363288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying TCP socket for the WebSocket.  <br /></td></tr>
<tr class="separator:ga00e6f2953f92843874cd7b6c3e363288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1ce264ad5e6d3cf25ce2442504aa20" id="r_ga2a1ce264ad5e6d3cf25ce2442504aa20"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga2a1ce264ad5e6d3cf25ce2442504aa20">SocketWS_selected_subprotocol</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga2a1ce264ad5e6d3cf25ce2442504aa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the negotiated WebSocket subprotocol.  <br /></td></tr>
<tr class="separator:ga2a1ce264ad5e6d3cf25ce2442504aa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02790d0b994d613324052794269b0e22" id="r_ga02790d0b994d613324052794269b0e22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga02790d0b994d613324052794269b0e22">SocketWS_compression_enabled</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga02790d0b994d613324052794269b0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if compression is enabled.  <br /></td></tr>
<tr class="separator:ga02790d0b994d613324052794269b0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8450a05502aaa70e88cdf14a73fa03" id="r_ga4b8450a05502aaa70e88cdf14a73fa03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03">SocketWS_send_text</a> (SocketWS_T ws, const char *data, size_t len)</td></tr>
<tr class="memdesc:ga4b8450a05502aaa70e88cdf14a73fa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a text message over the WebSocket (opcode TEXT).  <br /></td></tr>
<tr class="separator:ga4b8450a05502aaa70e88cdf14a73fa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8aff35f7c69172e0c2f9c0ec53abcb" id="r_ga1a8aff35f7c69172e0c2f9c0ec53abcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga1a8aff35f7c69172e0c2f9c0ec53abcb">SocketWS_send_binary</a> (SocketWS_T ws, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga1a8aff35f7c69172e0c2f9c0ec53abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a binary message over the WebSocket (opcode BINARY).  <br /></td></tr>
<tr class="separator:ga1a8aff35f7c69172e0c2f9c0ec53abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be521a2fe8aa5eb5d30869905371a71" id="r_ga2be521a2fe8aa5eb5d30869905371a71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga2be521a2fe8aa5eb5d30869905371a71">SocketWS_ping</a> (SocketWS_T ws, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga2be521a2fe8aa5eb5d30869905371a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a PING control frame for keepalive or to solicit immediate response from peer.  <br /></td></tr>
<tr class="separator:ga2be521a2fe8aa5eb5d30869905371a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e17279abcb92810c8066f1813287334" id="r_ga3e17279abcb92810c8066f1813287334"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga3e17279abcb92810c8066f1813287334">SocketWS_pong</a> (SocketWS_T ws, const void *data, size_t len)</td></tr>
<tr class="memdesc:ga3e17279abcb92810c8066f1813287334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a PONG control frame, typically in response to PING.  <br /></td></tr>
<tr class="separator:ga3e17279abcb92810c8066f1813287334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04efc033266e882f59db340ca2f8d47" id="r_gaf04efc033266e882f59db340ca2f8d47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47">SocketWS_close</a> (SocketWS_T ws, int code, const char *reason)</td></tr>
<tr class="memdesc:gaf04efc033266e882f59db340ca2f8d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate graceful WebSocket close handshake.  <br /></td></tr>
<tr class="separator:gaf04efc033266e882f59db340ca2f8d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4614f5978e94a42cdb1191dbb6d38e85" id="r_ga4614f5978e94a42cdb1191dbb6d38e85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga4614f5978e94a42cdb1191dbb6d38e85">SocketWS_recv_message</a> (SocketWS_T ws, <a class="el" href="group__websocket.html#structSocketWS__Message">SocketWS_Message</a> *msg)</td></tr>
<tr class="memdesc:ga4614f5978e94a42cdb1191dbb6d38e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive and reassemble a complete WebSocket message.  <br /></td></tr>
<tr class="separator:ga4614f5978e94a42cdb1191dbb6d38e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134ea19e7c00142525cdf82b82425b6d" id="r_ga134ea19e7c00142525cdf82b82425b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga134ea19e7c00142525cdf82b82425b6d">SocketWS_recv_available</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga134ea19e7c00142525cdf82b82425b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for complete messages ready to receive without blocking.  <br /></td></tr>
<tr class="separator:ga134ea19e7c00142525cdf82b82425b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37704f6a0ea36147b25c96efd2981d9b" id="r_ga37704f6a0ea36147b25c96efd2981d9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga37704f6a0ea36147b25c96efd2981d9b">SocketWS_pollfd</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga37704f6a0ea36147b25c96efd2981d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying socket file descriptor for use with poll/epoll/kqueue.  <br /></td></tr>
<tr class="separator:ga37704f6a0ea36147b25c96efd2981d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69518e9542ac69a4a6be77624219685" id="r_gac69518e9542ac69a4a6be77624219685"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gac69518e9542ac69a4a6be77624219685">SocketWS_poll_events</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gac69518e9542ac69a4a6be77624219685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine required poll events for the WebSocket socket.  <br /></td></tr>
<tr class="separator:gac69518e9542ac69a4a6be77624219685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c38be960976fd0d55b7328d1786ed9d" id="r_ga5c38be960976fd0d55b7328d1786ed9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d">SocketWS_process</a> (SocketWS_T ws, unsigned events)</td></tr>
<tr class="memdesc:ga5c38be960976fd0d55b7328d1786ed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process socket events to advance WebSocket state machine.  <br /></td></tr>
<tr class="separator:ga5c38be960976fd0d55b7328d1786ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0049a0e0f8a4218c5d5b3dbf8181b92f" id="r_ga0049a0e0f8a4218c5d5b3dbf8181b92f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga0049a0e0f8a4218c5d5b3dbf8181b92f">SocketWS_enable_auto_ping</a> (SocketWS_T ws, <a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> poll)</td></tr>
<tr class="memdesc:ga0049a0e0f8a4218c5d5b3dbf8181b92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable automatic periodic PING for connection keepalive.  <br /></td></tr>
<tr class="separator:ga0049a0e0f8a4218c5d5b3dbf8181b92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcf20cd5206a2cd971a60a98a58ff5f" id="r_gaedcf20cd5206a2cd971a60a98a58ff5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaedcf20cd5206a2cd971a60a98a58ff5f">SocketWS_disable_auto_ping</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:gaedcf20cd5206a2cd971a60a98a58ff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable and cancel automatic PING keepalive timer.  <br /></td></tr>
<tr class="separator:gaedcf20cd5206a2cd971a60a98a58ff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bb7e4b6127548345c12ddde993704d" id="r_ga12bb7e4b6127548345c12ddde993704d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga12bb7e4b6127548345c12ddde993704d">SocketWS_close_code</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga12bb7e4b6127548345c12ddde993704d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get close code from close frame.  <br /></td></tr>
<tr class="separator:ga12bb7e4b6127548345c12ddde993704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467b55bf31eeff51106a1d111241ad54" id="r_ga467b55bf31eeff51106a1d111241ad54"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga467b55bf31eeff51106a1d111241ad54">SocketWS_close_reason</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga467b55bf31eeff51106a1d111241ad54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get close reason text from close frame.  <br /></td></tr>
<tr class="separator:ga467b55bf31eeff51106a1d111241ad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d42ff813f81187667d894e0da0fce0" id="r_ga89d42ff813f81187667d894e0da0fce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0">SocketWS_last_error</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga89d42ff813f81187667d894e0da0fce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the most recent error code for this WebSocket instance.  <br /></td></tr>
<tr class="separator:ga89d42ff813f81187667d894e0da0fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfa823bd6275bfdcb9bab6f26ab90ee" id="r_ga1bfa823bd6275bfdcb9bab6f26ab90ee"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga1bfa823bd6275bfdcb9bab6f26ab90ee">SocketWS_error_string</a> (<a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> error)</td></tr>
<tr class="memdesc:ga1bfa823bd6275bfdcb9bab6f26ab90ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human-readable string describing a WebSocket error code.  <br /></td></tr>
<tr class="separator:ga1bfa823bd6275bfdcb9bab6f26ab90ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68edb5baf8b959da2c8b63158d65916" id="r_gaf68edb5baf8b959da2c8b63158d65916"><td class="memItemLeft" align="right" valign="top">SocketWS_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaf68edb5baf8b959da2c8b63158d65916">SocketWS_connect</a> (const char *url, const char *protocols)</td></tr>
<tr class="memdesc:gaf68edb5baf8b959da2c8b63158d65916"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-liner WebSocket client connection.  <br /></td></tr>
<tr class="separator:gaf68edb5baf8b959da2c8b63158d65916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcbf4d1f7f94a24cbe57cfee8c5c705" id="r_gacbcbf4d1f7f94a24cbe57cfee8c5c705"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gacbcbf4d1f7f94a24cbe57cfee8c5c705">SocketWS_send_json</a> (SocketWS_T ws, const char *json)</td></tr>
<tr class="memdesc:gacbcbf4d1f7f94a24cbe57cfee8c5c705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send JSON as text frame.  <br /></td></tr>
<tr class="separator:gacbcbf4d1f7f94a24cbe57cfee8c5c705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa120f2de8a8e3fe8d6670d5952ae3069" id="r_gaa120f2de8a8e3fe8d6670d5952ae3069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#gaa120f2de8a8e3fe8d6670d5952ae3069">SocketWS_recv_json</a> (SocketWS_T ws, char **json_out, size_t *json_len)</td></tr>
<tr class="memdesc:gaa120f2de8a8e3fe8d6670d5952ae3069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive and return JSON string.  <br /></td></tr>
<tr class="separator:gaa120f2de8a8e3fe8d6670d5952ae3069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f35bc85185a4084dc4d4e553bbd4559" id="r_ga9f35bc85185a4084dc4d4e553bbd4559"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga9f35bc85185a4084dc4d4e553bbd4559">SocketWS_get_ping_latency</a> (SocketWS_T ws)</td></tr>
<tr class="memdesc:ga9f35bc85185a4084dc4d4e553bbd4559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ping/pong round-trip time.  <br /></td></tr>
<tr class="separator:ga9f35bc85185a4084dc4d4e553bbd4559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc96039ed3f1e6240cc6af7e3fdce13" id="r_ga4bc96039ed3f1e6240cc6af7e3fdce13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga4bc96039ed3f1e6240cc6af7e3fdce13">SocketWS_compression_options_defaults</a> (<a class="el" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a> *options)</td></tr>
<tr class="memdesc:ga4bc96039ed3f1e6240cc6af7e3fdce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize compression options with defaults.  <br /></td></tr>
<tr class="separator:ga4bc96039ed3f1e6240cc6af7e3fdce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519bf217226465597f30e1f87e19d34a" id="r_ga519bf217226465597f30e1f87e19d34a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga519bf217226465597f30e1f87e19d34a">SocketWS_enable_compression</a> (SocketWS_T ws, const <a class="el" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a> *options)</td></tr>
<tr class="memdesc:ga519bf217226465597f30e1f87e19d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable permessage-deflate compression.  <br /></td></tr>
<tr class="separator:ga519bf217226465597f30e1f87e19d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0fb92a65a798e17aca6df1cdba118067" id="r_ga0fb92a65a798e17aca6df1cdba118067"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga0fb92a65a798e17aca6df1cdba118067">SocketWS_Failed</a></td></tr>
<tr class="memdesc:ga0fb92a65a798e17aca6df1cdba118067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception raised for general WebSocket operation failures.  <br /></td></tr>
<tr class="separator:ga0fb92a65a798e17aca6df1cdba118067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8400199bb1b785111015ff06d16de370" id="r_ga8400199bb1b785111015ff06d16de370"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga8400199bb1b785111015ff06d16de370">SocketWS_ProtocolError</a></td></tr>
<tr class="memdesc:ga8400199bb1b785111015ff06d16de370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for WebSocket protocol violations (RFC 6455 non-compliance).  <br /></td></tr>
<tr class="separator:ga8400199bb1b785111015ff06d16de370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51caf3b6f8086dc6535fd843593dcbde" id="r_ga51caf3b6f8086dc6535fd843593dcbde"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__websocket.html#ga51caf3b6f8086dc6535fd843593dcbde">SocketWS_Closed</a></td></tr>
<tr class="memdesc:ga51caf3b6f8086dc6535fd843593dcbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating the WebSocket connection has been closed.  <br /></td></tr>
<tr class="separator:ga51caf3b6f8086dc6535fd843593dcbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>WebSocket protocol support for client and server, with framing, compression, and integration. </p>
<p>The WebSocket module provides full support for the WebSocket protocol (RFC 6455), including client and server roles, message framing, control frames (ping/pong/close), fragmentation, UTF-8 validation, and optional permessage-deflate compression (RFC 7692).</p>
<p>Key Features:</p><ul>
<li>Non-blocking I/O compatible with SocketPoll.</li>
<li>Automatic handling of control frames.</li>
<li>Subprotocol negotiation during handshake.</li>
<li>Integration with SocketTLS for secure WebSocket (wss://).</li>
<li>Configurable limits for frame/message sizes.</li>
</ul>
<p>Dependencies:</p><ul>
<li><a class="el" href="group__http.html">HTTP Modules</a> (SocketHTTP, SocketHTTP1 for upgrade handshake)</li>
<li><a class="el" href="group__core__io.html">Core I/O Modules</a> (Socket, SocketBuf for I/O)</li>
<li><a class="el" href="group__foundation.html">Core Foundation Modules</a> (Arena, Except for memory/errors)</li>
<li><a class="el" href="group__utilities.html">Utilities</a> (SocketUTF8 for text validation, SocketCrypto for masking)</li>
<li><a class="el" href="group__event__system.html">Event System Modules</a> (SocketPoll, SocketTimer for events and keepalive)</li>
</ul>
<p>Usage:</p><ul>
<li>Server: Detect upgrade in HTTP request, accept with <a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a>, handshake.</li>
<li>Client: Connect socket, create with <a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a>, handshake.</li>
<li>Send/Recv: Use send_text/binary, recv_message in OPEN state.</li>
<li>Event Loop: Poll with SocketWS_pollfd/events, process events.</li>
</ul>
<p>Error Handling:</p><ul>
<li>Uses SocketWS_* exceptions for failures.</li>
<li>SocketWS_Error enum for detailed codes.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a> for configuration options. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__Message" title="Complete reassembled WebSocket message from recv_message().">SocketWS_Message</a> for received messages. </dd>
<dd>
<a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d" title="WebSocket connection lifecycle states.">SocketWS_State</a> for connection states. </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketWS__FrameParse" id="structSocketWS__FrameParse"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__FrameParse">&#9670;&#160;</a></span>SocketWS_FrameParse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_FrameParse</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Context for parsing incoming WebSocket frames. </p>
<p>Manages incremental parsing of frame headers and payloads. Supports partial reads for non-blocking sockets. Handles variable-length fields: opcode/fin/rsv, mask bit, 7/16/64-bit length, optional mask key.</p>
<p>Usage:</p><ul>
<li>Initialize: memset or <a class="el" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f" title="Reset frame parser to initial state for new incoming frame.">ws_frame_reset()</a></li>
<li>Parse: <a class="el" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf" title="Incrementally parses WebSocket frame header from input data.">ws_frame_parse_header()</a> advances state and parses bytes</li>
<li>Payload: Read payload_received bytes after header complete</li>
<li>Reset: <a class="el" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f" title="Reset frame parser to initial state for new incoming frame.">ws_frame_reset()</a> for next frame</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gacba3d485716ab762c1ecd90312174721" title="States for the frame parsing state machine.">SocketWS_FrameState</a> for parsing states. </dd>
<dd>
<a class="el" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf" title="Incrementally parses WebSocket frame header from input data.">ws_frame_parse_header()</a> <a class="el" href="connection__pool_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> entry point. </dd>
<dd>
<a class="el" href="group__websocket.html#gad0cb16d7a760ff6ea58750797c85ee15" title="Builds the binary WebSocket frame header into output buffer.">ws_frame_build_header()</a> for sending frames. </dd>
<dd>
RFC 6455 Section 5.2 for frame format details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00314">314</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7d191af8da1c32f20309d0905a3f3426" name="a7d191af8da1c32f20309d0905a3f3426"></a>int</td>
<td class="fieldname">
fin</td>
<td class="fielddoc">
<p>FIN bit: final fragment of message </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a471bfa857a2703d726f558cbadae6585" name="a471bfa857a2703d726f558cbadae6585"></a>unsigned char</td>
<td class="fieldname">
header_buf[14]</td>
<td class="fielddoc">
<p>Temp buffer for header bytes </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aae54ed57c5a5b435301a4bb4a7b3ab17" name="aae54ed57c5a5b435301a4bb4a7b3ab17"></a>size_t</td>
<td class="fieldname">
header_len</td>
<td class="fielddoc">
<p>Bytes accumulated in header_buf </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7aa8b6c28d5aafaffedca2bb9d7afeb8" name="a7aa8b6c28d5aafaffedca2bb9d7afeb8"></a>size_t</td>
<td class="fieldname">
header_needed</td>
<td class="fielddoc">
<p>Remaining bytes needed for current field </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a410925586fa1e5c46d907d88b384eb53" name="a410925586fa1e5c46d907d88b384eb53"></a>unsigned char</td>
<td class="fieldname">
mask_key[4]</td>
<td class="fielddoc">
<p>4-byte mask key if masked </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a858192e2d9b34474a201dabced8999e8" name="a858192e2d9b34474a201dabced8999e8"></a>int</td>
<td class="fieldname">
masked</td>
<td class="fielddoc">
<p>MASK bit: payload masked (client-&gt;server) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7cc0bddb462f4aef8f77b10b237301c9" name="a7cc0bddb462f4aef8f77b10b237301c9"></a><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a></td>
<td class="fieldname">
opcode</td>
<td class="fielddoc">
<p>Frame opcode (data/control) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="add8e3ac9531aa23b1850ddf9c6d2b552" name="add8e3ac9531aa23b1850ddf9c6d2b552"></a>uint64_t</td>
<td class="fieldname">
payload_len</td>
<td class="fielddoc">
<p>Total payload length </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae15f7dfab70a6711fa314ab4ee40a791" name="ae15f7dfab70a6711fa314ab4ee40a791"></a>uint64_t</td>
<td class="fieldname">
payload_received</td>
<td class="fielddoc">
<p>Bytes of payload received so far </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a62c3c0c93ee90ce7cf981fd046009310" name="a62c3c0c93ee90ce7cf981fd046009310"></a>int</td>
<td class="fieldname">
rsv1</td>
<td class="fielddoc">
<p>RSV1: compression flag (permessage-deflate) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0d809042e0cd554c8bdc6e0d1570095" name="ad0d809042e0cd554c8bdc6e0d1570095"></a>int</td>
<td class="fieldname">
rsv2</td>
<td class="fielddoc">
<p>RSV2: reserved, must be 0 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a96d25dcb9a42c7d3053d8bf1e136da97" name="a96d25dcb9a42c7d3053d8bf1e136da97"></a>int</td>
<td class="fieldname">
rsv3</td>
<td class="fielddoc">
<p>RSV3: reserved, must be 0 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac9b323a733a88ac59f9fef9027facf5a" name="ac9b323a733a88ac59f9fef9027facf5a"></a><a class="el" href="group__websocket.html#gacba3d485716ab762c1ecd90312174721">SocketWS_FrameState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Current parsing state </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__MessageAssembly" id="structSocketWS__MessageAssembly"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__MessageAssembly">&#9670;&#160;</a></span>SocketWS_MessageAssembly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_MessageAssembly</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>State for reassembling fragmented WebSocket messages. </p>
<p>Accumulates data from multiple CONTINUATION frames into a single message buffer. Supports UTF-8 validation for text messages across fragments. Handles compression flag from first frame (RSV1).</p>
<p>Limits enforced via config: max_message_size, max_fragments.</p>
<p>Usage:</p><ul>
<li>Reset: <a class="el" href="group__websocket.html#gac56e5c15d95b50879444eaa9509a77cc" title="Resets the message reassembly state for a new message.">ws_message_reset()</a> before first fragment</li>
<li>Append: <a class="el" href="group__websocket.html#ga02d493e3ec3a1da7c2b038813e0b109f" title="Appends a data frame fragment to the current message assembly.">ws_message_append()</a> for each data frame fragment</li>
<li>Finalize: <a class="el" href="group__websocket.html#gad66f78da53262b5c3047bb39ad410a32" title="Finalizes message assembly on last fragment and delivers to user.">ws_message_finalize()</a> on last fragment (FIN=1), validates and delivers</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga02d493e3ec3a1da7c2b038813e0b109f" title="Appends a data frame fragment to the current message assembly.">ws_message_append()</a> for adding fragments. </dd>
<dd>
<a class="el" href="group__websocket.html#gad66f78da53262b5c3047bb39ad410a32" title="Finalizes message assembly on last fragment and delivers to user.">ws_message_finalize()</a> for completion and validation. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__Message" title="Complete reassembled WebSocket message from recv_message().">SocketWS_Message</a> for public message interface. </dd>
<dd>
RFC 6455 Section 5.4 for fragmentation rules. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00366">366</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketWS_MessageAssembly:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketWS__MessageAssembly__coll__graph.svg" width="214" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a3964e0ace40259b1b0b84662c4e6766a" name="a3964e0ace40259b1b0b84662c4e6766a"></a>size_t</td>
<td class="fieldname">
capacity</td>
<td class="fielddoc">
<p>Allocated buffer capacity </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9c00c873176b3cc84d692f11f55c632e" name="a9c00c873176b3cc84d692f11f55c632e"></a>int</td>
<td class="fieldname">
compressed</td>
<td class="fielddoc">
<p>RSV1 set on first fragment (compression used) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2c6e4fb878ba0c23fa0d58e8d9dd5f86" name="a2c6e4fb878ba0c23fa0d58e8d9dd5f86"></a>unsigned char *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>Reassembled message buffer (Arena-allocated) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a250ad8c5cacc4fa1f83d9f2a8434b2c7" name="a250ad8c5cacc4fa1f83d9f2a8434b2c7"></a>size_t</td>
<td class="fieldname">
fragment_count</td>
<td class="fielddoc">
<p>Number of fragments received so far </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abab7570ff97f02c15ebc63316f48c0b1" name="abab7570ff97f02c15ebc63316f48c0b1"></a>size_t</td>
<td class="fieldname">
len</td>
<td class="fielddoc">
<p>Current assembled length </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afa311aff58665c6c0704ebcd55eb292a" name="afa311aff58665c6c0704ebcd55eb292a"></a><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Message type: TEXT or BINARY (from first frame opcode) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a87ce3e4f2389eb0fc7ec1155d4a00f72" name="a87ce3e4f2389eb0fc7ec1155d4a00f72"></a>int</td>
<td class="fieldname">
utf8_initialized</td>
<td class="fielddoc">
<p>Whether UTF-8 validation started </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a11833b079ede7736a47506cf7f5cfa3f" name="a11833b079ede7736a47506cf7f5cfa3f"></a><a class="el" href="group__utilities.html#structSocketUTF8__State">SocketUTF8_State</a></td>
<td class="fieldname">
utf8_state</td>
<td class="fielddoc">
<p>Incremental UTF-8 decoder state </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__Handshake" id="structSocketWS__Handshake"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__Handshake">&#9670;&#160;</a></span>SocketWS_Handshake</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_Handshake</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Context for WebSocket HTTP upgrade handshake. </p>
<p>Manages client or server handshake state, key generation/validation, header negotiation (subprotocols, compression), and HTTP parsing/serialization.</p>
<p>Client:</p><ul>
<li>Generates Sec-WebSocket-Key, builds GET request with Upgrade: websocket</li>
<li>Parses server response, validates Sec-WebSocket-Accept</li>
</ul>
<p>Server:</p><ul>
<li>Parses client request, computes Accept from key</li>
<li>Validates required headers, negotiates extensions/subprotocols</li>
<li>Sends 101 Switching Protocols response</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gafb2bca991ca02e642b76a7ecc166943c" title="States for WebSocket HTTP upgrade handshake.">SocketWS_HandshakeState</a> for <a class="el" href="group__websocket.html#adb63a6e137118cb409e38ab4547018d6">state</a> enum. </dd>
<dd>
<a class="el" href="group__websocket.html#gae1986f23bb035bce3c7e5bbf5c741512" title="Initializes the client-side WebSocket handshake.">ws_handshake_client_init()</a> / <a class="el" href="group__websocket.html#ga169d28fa02ed8486e26122116361cdcd" title="Initializes the server-side WebSocket handshake from HTTP request.">ws_handshake_server_init()</a> for init. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbed5c235e2175a894cf83f64d8c9859" title="Processes client handshake I/O in non-blocking manner.">ws_handshake_client_process()</a> / <a class="el" href="group__websocket.html#gadb1dba4490ebb1e999c4755073516058" title="Processes server handshake I/O in non-blocking manner.">ws_handshake_server_process()</a> for I/O loop. </dd>
<dd>
SocketCrypto_websocket_accept_compute() for key validation. </dd>
<dd>
RFC 6455 Section 4.2 for client handshake, Section 4.1 for server. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00436">436</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a1c7131bf8d7f89121d2d9789ba4185fd" name="a1c7131bf8d7f89121d2d9789ba4185fd"></a>char</td>
<td class="fieldname">
client_key[25]</td>
<td class="fielddoc">
<p>Base64 Sec-WebSocket-Key (24 chars) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a69499ebf077e64c701c00bd44eb5164d" name="a69499ebf077e64c701c00bd44eb5164d"></a>int</td>
<td class="fieldname">
client_max_window_bits</td>
<td class="fielddoc">
<p>Client max window bits (8-15) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a87927c6556cbfd6bcaa36fdab5e5264c" name="a87927c6556cbfd6bcaa36fdab5e5264c"></a>int</td>
<td class="fieldname">
client_no_context_takeover</td>
<td class="fielddoc">
<p>Client no context takeover </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a44a245e4e2bb33a95dbfa68548ad5d96" name="a44a245e4e2bb33a95dbfa68548ad5d96"></a>int</td>
<td class="fieldname">
compression_negotiated</td>
<td class="fielddoc">
<p>permessage-deflate negotiated? </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4b9c590c3f4c1e8b511f804b9438612d" name="a4b9c590c3f4c1e8b511f804b9438612d"></a>char</td>
<td class="fieldname">
expected_accept[29]</td>
<td class="fielddoc">
<p>SHA1(key + magic) base64 </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a439230d90ee363fd497c9f4243b90c6a" name="a439230d90ee363fd497c9f4243b90c6a"></a>SocketHTTP1_Parser_T</td>
<td class="fieldname">
http_parser</td>
<td class="fielddoc">
<p>Parser for HTTP response/request </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aceb939f1304fe766d2477b2df67b1726" name="aceb939f1304fe766d2477b2df67b1726"></a>char *</td>
<td class="fieldname">
request_buf</td>
<td class="fielddoc">
<p>Buffer for HTTP request/response </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9494a537bbcf42f7b7ab6d0719a8cd3d" name="a9494a537bbcf42f7b7ab6d0719a8cd3d"></a>size_t</td>
<td class="fieldname">
request_len</td>
<td class="fielddoc">
<p>Total length of HTTP message </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a85c2e9c78f16afad20caea3d71b5a889" name="a85c2e9c78f16afad20caea3d71b5a889"></a>size_t</td>
<td class="fieldname">
request_sent</td>
<td class="fielddoc">
<p>Bytes already sent </p>
</td></tr>
<tr><td class="fieldtype">
<a id="addc91d6254178c115e87f1d03f2f3a70" name="addc91d6254178c115e87f1d03f2f3a70"></a>char *</td>
<td class="fieldname">
selected_subprotocol</td>
<td class="fielddoc">
<p>Negotiated subprotocol (Arena alloc) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a637224623f4f226bec9d86e45c935b55" name="a637224623f4f226bec9d86e45c935b55"></a>int</td>
<td class="fieldname">
server_max_window_bits</td>
<td class="fielddoc">
<p>Server max window bits (8-15) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9a5c3e0b02ca9069452a74b9a4ca02fd" name="a9a5c3e0b02ca9069452a74b9a4ca02fd"></a>int</td>
<td class="fieldname">
server_no_context_takeover</td>
<td class="fielddoc">
<p>Server no context takeover </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adb63a6e137118cb409e38ab4547018d6" name="adb63a6e137118cb409e38ab4547018d6"></a><a class="el" href="group__websocket.html#gafb2bca991ca02e642b76a7ecc166943c">SocketWS_HandshakeState</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Current handshake state </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS" id="structSocketWS"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS">&#9670;&#160;</a></span>SocketWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Opaque WebSocket connection context holding all protocol state. </p>
<p>Opaque type for WebSocket connection (public interface).</p>
<p>Central opaque structure managing full WebSocket connection lifecycle, from HTTP upgrade handshake through framed data exchange to graceful closure. Publicly accessed only via SocketWS_T pointer and API functions; internal fields private and unstable.</p>
<p>Key Responsibilities</p>
<ul>
<li>HTTP/1.1 upgrade handshake (client/server)</li>
<li>Frame parsing/serialization with masking/compression</li>
<li>Message fragmentation/reassembly with UTF-8 validation</li>
<li>Control frame handling (PING/PONG/CLOSE)</li>
<li>Auto-keepalive via periodic PINGs</li>
<li>Integration with SocketPoll for non-blocking I/O</li>
<li><p class="startli">Error tracking and diagnostics</p>
<p class="startli">Lifecycle Management</p>
</li>
</ul>
<ol type="1">
<li><b>Creation</b>: <a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a> or <a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> allocates and inits</li>
<li><b>Handshake</b>: <a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> or internal ws_handshake_*() completes upgrade</li>
<li><b>Data Exchange</b>: <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS_send()</a>, <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS_recv()</a>, <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> loop</li>
<li><b>Closure</b>: <a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> sends CLOSE frame, awaits response</li>
<li><p class="startli"><b>Cleanup</b>: <a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a> releases arena, buffers, timers</p>
<p class="startli">Resource Ownership</p>
</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Ownership   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">socket   </td><td class="markdownTableBodyNone">Transferred   </td><td class="markdownTableBodyNone">Caller retains? No, owned until free    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">arena   </td><td class="markdownTableBodyNone">Owned   </td><td class="markdownTableBodyNone">All sub-allocs freed on dispose    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">recv_buf/send_buf   </td><td class="markdownTableBodyNone">Owned   </td><td class="markdownTableBodyNone">Circular buffers for buffering    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">poll   </td><td class="markdownTableBodyNone">Referenced   </td><td class="markdownTableBodyNone">Shared event loop instance   </td></tr>
</table>
<p>State Subsystems</p>
<ul>
<li><b>Handshake</b>: HTTP parser, keys, negotiated extensions/subprotocols</li>
<li><b>Frame Parser</b>: Incremental header/payload parse (<a class="el" href="group__websocket.html#structSocketWS__FrameParse" title="Context for parsing incoming WebSocket frames.">SocketWS_FrameParse</a>)</li>
<li><b>Message Assembly</b>: Fragment collection with decompression/UTF-8 (<a class="el" href="group__websocket.html#structSocketWS__MessageAssembly" title="State for reassembling fragmented WebSocket messages.">SocketWS_MessageAssembly</a>)</li>
<li><b>Compression</b>: zlib streams for permessage-deflate (if enabled)</li>
<li><b>Timers</b>: Auto-ping via SocketTimer</li>
<li><b>Error</b>: last_error code + formatted message</li>
</ul>
<p>Thread Safety: Not thread-safe; single-threaded use only. No internal mutexes; concurrent access may corrupt state. For multi-thread, use one ws per thread or external locking (not recommended).</p>
<p>Non-blocking I/O: All functions handle EAGAIN/partial; integrate with SocketPoll via <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS_fd()</a> and <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a>.</p>
<dl class="section user"><dt>Thread Safety\n No - no internal synchronization; serialize all operations on ws</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Dynamic fields (strings, buffers) allocated from ws-&gt;arena </dd>
<dd>
socket field may be NULL post-transfer to higher layers </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Direct field access undefined; use getters/setters where available </dd></dl>
<dl class="section user"><dt>Complexity\n Varies by operation; generally O(1) state access, O(payload) I/O</dt><dd></dd></dl>
<p>Example Internal Access (for library code)</p>
<div class="fragment"><div class="line"><span class="comment">// Internal: accessing state (not for users)</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_variable" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">ws</a>-&gt;state == <a class="code hl_variable" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">WS_OPEN</a> &amp;&amp; <a class="code hl_variable" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">ws</a>-&gt;role == <a class="code hl_variable" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">WS_CLIENT</a>) {</div>
<div class="line">    <a class="code hl_variable" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">ws</a>-&gt;frame.state = <a class="code hl_enumvalue" href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec">WS_FRAME_STATE_HEADER</a>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__websocket_html_a2229fadf97885c574f68d8d98136b2a0"><div class="ttname"><a href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS::port</a></div><div class="ttdeci">int port</div><div class="ttdef"><b>Definition</b> <a href="SocketWS-private_8h_source.html#l00660">SocketWS-private.h:660</a></div></div>
<div class="ttc" id="agroup__websocket_html_ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec"><div class="ttname"><a href="group__websocket.html#ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec">WS_FRAME_STATE_HEADER</a></div><div class="ttdeci">@ WS_FRAME_STATE_HEADER</div><div class="ttdef"><b>Definition</b> <a href="SocketWS-private_8h_source.html#l00285">SocketWS-private.h:284</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS_T</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">Public</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">opaque</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">typedef</a> </dd>
<dd>
<a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS_new()</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">Internal</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">constructor</a> </dd>
<dd>
<a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">Destructor</a> </dd>
<dd>
<a class="el" href="WEBSOCKET_8md.html">docs/WEBSOCKET.md</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">Detailed</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">WebSocket</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">guide</a></dd></dl>
<p>In public header (<a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS.h</a>), defined as <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">define</a> T SocketWS_T <br  />
 typedef struct <a class="el" href="group__websocket.html#structSocketWS" title="Opaque WebSocket connection context holding all protocol state.">SocketWS</a> *T; Here, reveals the pointer to private struct <a class="el" href="group__websocket.html#structSocketWS" title="Opaque WebSocket connection context holding all protocol state.">SocketWS</a>. Users should use opaque T without knowledge of internal layout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS.h</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">public</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">header</a>. </dd>
<dd>
<a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">struct</a> <a class="el" href="group__websocket.html#structSocketWS" title="Opaque WebSocket connection context holding all protocol state.">SocketWS</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">private</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">implementation</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00600">600</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketWS_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structSocketWS__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af70b64fbb3aeee7df1140247c69cf68d" name="af70b64fbb3aeee7df1140247c69cf68d"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Memory arena for all dynamic allocations </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3a249cb9ae8646d2e57d3a0611ea3fce" name="a3a249cb9ae8646d2e57d3a0611ea3fce"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int</a></td>
<td class="fieldname">
awaiting_pong</td>
<td class="fielddoc">
<p>Expecting PONG response? </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a32b7636f3af3ca86278460ab908a39a1" name="a32b7636f3af3ca86278460ab908a39a1"></a><a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">SocketWS_CloseCode</a></td>
<td class="fieldname">
close_code</td>
<td class="fielddoc">
<p>Received/sent close code </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab8999b9889de37462f8813eddd18a584" name="ab8999b9889de37462f8813eddd18a584"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">char</a></td>
<td class="fieldname">
close_reason[123+1]</td>
<td class="fielddoc">
<p>Close reason string </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a77d3a147cd9297721173bad50aef60ba" name="a77d3a147cd9297721173bad50aef60ba"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int</a></td>
<td class="fieldname">
close_received</td>
<td class="fielddoc">
<p>Flag: received CLOSE frame? </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a112b3f978509ffcf10b9ca955caf4f7c" name="a112b3f978509ffcf10b9ca955caf4f7c"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int</a></td>
<td class="fieldname">
close_sent</td>
<td class="fielddoc">
<p>Flag: sent CLOSE frame? </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af6e99508aaae777c1c3a4cd432546c99" name="af6e99508aaae777c1c3a4cd432546c99"></a><a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a></td>
<td class="fieldname">
config</td>
<td class="fielddoc">
<p>User-provided configuration </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a22ba79e5d208b1f2589a486aba8d105e" name="a22ba79e5d208b1f2589a486aba8d105e"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">char</a></td>
<td class="fieldname">
error_buf[256]</td>
<td class="fielddoc">
<p>Human-readable error message </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a03230b45df98043e0d3f42350d0eb5f5" name="a03230b45df98043e0d3f42350d0eb5f5"></a><a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a></td>
<td class="fieldname">
frame</td>
<td class="fielddoc">
<p>Incoming frame parser </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4fb7cb35b9cea02fe11219902430f41c" name="a4fb7cb35b9cea02fe11219902430f41c"></a><a class="el" href="group__websocket.html#structSocketWS__Handshake">SocketWS_Handshake</a></td>
<td class="fieldname">
handshake</td>
<td class="fielddoc">
<p>HTTP upgrade handshake context </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a88593d088458ab124612e10c6945dfb1" name="a88593d088458ab124612e10c6945dfb1"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">char</a> *</td>
<td class="fieldname">
host</td>
<td class="fielddoc">
<p>Target host (for client handshake) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3e6c78c0e878d6b3fa505d14420b1bb3" name="a3e6c78c0e878d6b3fa505d14420b1bb3"></a><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a></td>
<td class="fieldname">
last_error</td>
<td class="fielddoc">
<p>Last error code </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a05d1f55f1818f78d88e2b51b8ecc4695" name="a05d1f55f1818f78d88e2b51b8ecc4695"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int64_t</a></td>
<td class="fieldname">
last_ping_sent_time</td>
<td class="fielddoc">
<p>Time last PING sent </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a784d2b912e8bc696c39a81c26216cdcb" name="a784d2b912e8bc696c39a81c26216cdcb"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int64_t</a></td>
<td class="fieldname">
last_pong_received_time</td>
<td class="fielddoc">
<p>Time last PONG received </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a22d2dcbdbad3c284221786c0eb2376cb" name="a22d2dcbdbad3c284221786c0eb2376cb"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int64_t</a></td>
<td class="fieldname">
last_pong_sent_time</td>
<td class="fielddoc">
<p>Time last PONG sent (response) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab0c5d5fdfadedc7763498157574fde09" name="ab0c5d5fdfadedc7763498157574fde09"></a><a class="el" href="group__websocket.html#structSocketWS__MessageAssembly">SocketWS_MessageAssembly</a></td>
<td class="fieldname">
message</td>
<td class="fielddoc">
<p>Fragmented message assembler </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7ee0e990e48565627438d8dacceac2b2" name="a7ee0e990e48565627438d8dacceac2b2"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">char</a> *</td>
<td class="fieldname">
path</td>
<td class="fielddoc">
<p>Request path (for client handshake) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a44712527e3680cd6a8fd2d4622a84f80" name="a44712527e3680cd6a8fd2d4622a84f80"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">size_t</a></td>
<td class="fieldname">
pending_ping_len</td>
<td class="fielddoc">
<p>Length of pending PING payload </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afadfb33828588c5207ebc7b764568960" name="afadfb33828588c5207ebc7b764568960"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">unsigned</a> <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">char</a></td>
<td class="fieldname">
pending_ping_payload[125]</td>
<td class="fielddoc">
<p>Pending PING payload </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae8fcdda96d92ae6bda7144588c4ec851" name="ae8fcdda96d92ae6bda7144588c4ec851"></a><a class="el" href="group__event__system.html#structSocketTimer__T">SocketTimer_T</a></td>
<td class="fieldname">
ping_timer</td>
<td class="fielddoc">
<p>Internal timer for auto-pings </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9dd8f997c31bd20756958e4a4152dead" name="a9dd8f997c31bd20756958e4a4152dead"></a><a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a></td>
<td class="fieldname">
poll</td>
<td class="fielddoc">
<p>Associated poll instance (for timers) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2229fadf97885c574f68d8d98136b2a0" name="a2229fadf97885c574f68d8d98136b2a0"></a>int</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
<p>Target port </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4a77b12b048b54dbc8bf998d0c69208e" name="a4a77b12b048b54dbc8bf998d0c69208e"></a><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
<td class="fieldname">
recv_buf</td>
<td class="fielddoc">
<p>Receive circular buffer for incoming data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a905227166edca345b1d3d583901d2a75" name="a905227166edca345b1d3d583901d2a75"></a><a class="el" href="group__websocket.html#ga9d14d3d0f1b05e44fcd74782107cbd94">SocketWS_Role</a></td>
<td class="fieldname">
role</td>
<td class="fielddoc">
<p>Client or server role (affects masking) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a78f0d7101e07de351a645d085fe087b7" name="a78f0d7101e07de351a645d085fe087b7"></a><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
<td class="fieldname">
send_buf</td>
<td class="fielddoc">
<p>Send circular buffer for outgoing data </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a39df4e799fd7a9e25ba3ab7b31abb746" name="a39df4e799fd7a9e25ba3ab7b31abb746"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>TCP/TLS socket (may be NULL if ownership transferred) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2203733226e69df51e71aec21966d288" name="a2203733226e69df51e71aec21966d288"></a><a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">SocketWS_State</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>High-level connection state (CONNECTING/OPEN/CLOSING/CLOSED) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa1fd3c138b5fcd4885603f61a6517bd7" name="aa1fd3c138b5fcd4885603f61a6517bd7"></a><a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">int</a></td>
<td class="fieldname">
use_tls</td>
<td class="fielddoc">
<p>Using TLS? (wss://) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__Config" id="structSocketWS__Config"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__Config">&#9670;&#160;</a></span>SocketWS_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_Config</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Configuration parameters for WebSocket instances. </p>
<p>Passed to <a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a> or <a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a>. Defaults set by <a class="el" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176" title="Initialize WebSocket configuration with default values.">SocketWS_config_defaults()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176" title="Initialize WebSocket configuration with default values.">SocketWS_config_defaults()</a> to initialize. </dd>
<dd>
RFC 6455 for protocol requirements on limits, etc. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00306">306</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aaaf3a4b3929373f6d34097ee3360edd7" name="aaaf3a4b3929373f6d34097ee3360edd7"></a>int</td>
<td class="fieldname">
deflate_max_window_bits</td>
<td class="fielddoc">
<p>Deflate window bits (8-15, default: 15). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6990f2e1597412e0fd8101407944f51d" name="a6990f2e1597412e0fd8101407944f51d"></a>int</td>
<td class="fieldname">
deflate_no_context_takeover</td>
<td class="fielddoc">
<p>No context takeover for deflate (default: 0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5b4cb5b34e0960b4964eec24547ebe29" name="a5b4cb5b34e0960b4964eec24547ebe29"></a>int</td>
<td class="fieldname">
enable_permessage_deflate</td>
<td class="fielddoc">
<p>Offer permessage-deflate (RFC 7692, default: 0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac3b980e3936f7e3763e4a6c2c5e466d3" name="ac3b980e3936f7e3763e4a6c2c5e466d3"></a>size_t</td>
<td class="fieldname">
max_fragments</td>
<td class="fielddoc">
<p>Maximum fragments per message (default: 1000). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a622a5556ac8a0b6888819a40851a11fd" name="a622a5556ac8a0b6888819a40851a11fd"></a>size_t</td>
<td class="fieldname">
max_frame_size</td>
<td class="fielddoc">
<p>Maximum single frame payload size (default: 16MB). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2100320f9508ad064f387dc26bbef62f" name="a2100320f9508ad064f387dc26bbef62f"></a>size_t</td>
<td class="fieldname">
max_message_size</td>
<td class="fielddoc">
<p>Maximum reassembled message size (default: 64MB). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a376fe666ac3f3654087792edae1ce054" name="a376fe666ac3f3654087792edae1ce054"></a>int</td>
<td class="fieldname">
ping_interval_ms</td>
<td class="fielddoc">
<p>Auto-ping interval in ms (0=disabled, default: 0). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4ca65b7722835ec62374763fa625596f" name="a4ca65b7722835ec62374763fa625596f"></a>int</td>
<td class="fieldname">
ping_timeout_ms</td>
<td class="fielddoc">
<p>Timeout for pong response in ms (default: 5000). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa895fa89617603768d89d043b41b3bc9" name="aa895fa89617603768d89d043b41b3bc9"></a><a class="el" href="group__websocket.html#ga9d14d3d0f1b05e44fcd74782107cbd94">SocketWS_Role</a></td>
<td class="fieldname">
role</td>
<td class="fielddoc">
<p>Role: client masks frames, server validates masks. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2ff17028ab5d54be79108495bf1c4512" name="a2ff17028ab5d54be79108495bf1c4512"></a>const char **</td>
<td class="fieldname">
subprotocols</td>
<td class="fielddoc">
<p>NULL-terminated array of supported subprotocols. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1873fe17fa2f2d2d3c0d16cbfbcfc3f1" name="a1873fe17fa2f2d2d3c0d16cbfbcfc3f1"></a>int</td>
<td class="fieldname">
validate_utf8</td>
<td class="fielddoc">
<p>Enable UTF-8 validation for text frames (default: 1). </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__Frame" id="structSocketWS__Frame"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__Frame">&#9670;&#160;</a></span>SocketWS_Frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_Frame</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure representing a parsed WebSocket frame. </p>
<p>Filled by internal parsing; not directly filled by user APIs. Payload points to internal buffer; do not free.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketWS-private_8h.html" title="Internal implementation details for WebSocket module.">SocketWS-private.h</a> for internal frame parsing details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00353">353</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a54987d666286860044d3f6bd3f513d85" name="a54987d666286860044d3f6bd3f513d85"></a>int</td>
<td class="fieldname">
fin</td>
<td class="fielddoc">
<p>1 if final fragment of message, 0 otherwise. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3316616d6bd9228919cf2eac7df3c780" name="a3316616d6bd9228919cf2eac7df3c780"></a><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a></td>
<td class="fieldname">
opcode</td>
<td class="fielddoc">
<p>Opcode of the frame (data or control). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab17b0ddda509759d90d3c7f5aa09144b" name="ab17b0ddda509759d90d3c7f5aa09144b"></a>const unsigned char *</td>
<td class="fieldname">
payload</td>
<td class="fielddoc">
<p>Pointer to frame payload data (unmasked). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab6da903ab04e63a093ed73f861b7d5c8" name="ab6da903ab04e63a093ed73f861b7d5c8"></a>size_t</td>
<td class="fieldname">
payload_len</td>
<td class="fielddoc">
<p>Length of payload in bytes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a40b506b65f89a2c8d96acecf636c5191" name="a40b506b65f89a2c8d96acecf636c5191"></a>int</td>
<td class="fieldname">
rsv1</td>
<td class="fielddoc">
<p>RSV1 bit: 1 if compressed (permessage-deflate). </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__Message" id="structSocketWS__Message"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__Message">&#9670;&#160;</a></span>SocketWS_Message</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_Message</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Complete reassembled WebSocket message from recv_message(). </p>
<p>Aggregates potentially fragmented data frames into single buffer. type is from first frame's opcode (TEXT or BINARY). Caller owns data; free with free() or arena equivalent when done.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga4614f5978e94a42cdb1191dbb6d38e85" title="Receive and reassemble a complete WebSocket message.">SocketWS_recv_message()</a> populates this structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00378">378</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af7c3a0707d0a280d08242b3668e4bc14" name="af7c3a0707d0a280d08242b3668e4bc14"></a>unsigned char *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
<p>Allocated message payload (caller frees). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a48e400e0db4731142c0baa97427de817" name="a48e400e0db4731142c0baa97427de817"></a>size_t</td>
<td class="fieldname">
len</td>
<td class="fielddoc">
<p>Total message length in bytes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acb9416eb06a0a6e95260acebee3544b2" name="acb9416eb06a0a6e95260acebee3544b2"></a><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Message type: WS_OPCODE_TEXT or WS_OPCODE_BINARY. </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketWS__CompressionOptions" id="structSocketWS__CompressionOptions"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketWS__CompressionOptions">&#9670;&#160;</a></span>SocketWS_CompressionOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketWS_CompressionOptions</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>WebSocket compression options. </p>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l01181">1181</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6bd6cb4d78b4124f05f7f33a6b2f7ef9" name="a6bd6cb4d78b4124f05f7f33a6b2f7ef9"></a>int</td>
<td class="fieldname">
client_max_window_bits</td>
<td class="fielddoc">
<p>Client LZ77 window (8-15, default 15) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9531af4f7a0ab83dbe5b5264314b0943" name="a9531af4f7a0ab83dbe5b5264314b0943"></a>int</td>
<td class="fieldname">
client_no_context_takeover</td>
<td class="fielddoc">
<p>Client resets context per message </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a79d8c3d69d9897b2f5ee1ae446b4b97f" name="a79d8c3d69d9897b2f5ee1ae446b4b97f"></a>int</td>
<td class="fieldname">
level</td>
<td class="fielddoc">
<p>zlib compression level (1-9, default 6) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad231279c72569dea7f7df4d716d09b86" name="ad231279c72569dea7f7df4d716d09b86"></a>int</td>
<td class="fieldname">
server_max_window_bits</td>
<td class="fielddoc">
<p>Server LZ77 window (8-15, default 15) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a08a9c76cfe8723bcee370a37189441d2" name="a08a9c76cfe8723bcee370a37189441d2"></a>int</td>
<td class="fieldname">
server_no_context_takeover</td>
<td class="fielddoc">
<p>Server resets context per message </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad47afcd717fda7a921345994a4e5f4a5" name="gad47afcd717fda7a921345994a4e5f4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad47afcd717fda7a921345994a4e5f4a5">&#9670;&#160;</a></span>RAISE_WS_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_WS_ERROR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="SocketUtil_8h.html#aba03b2fa3f583e8cc687a3247db5a91b">SOCKET_RAISE_MODULE_ERROR</a> (<a class="el" href="group__websocket.html#structSocketWS">SocketWS</a>, e)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread-local exception declarations for <a class="el" href="group__websocket.html#structSocketWS" title="Opaque WebSocket connection context holding all protocol state.">SocketWS</a> module. </p>
<p>Declares module exceptions using SOCKET_DECLARE_MODULE_EXCEPTION. These are raised via TRY/EXCEPT or RAISE_WS_ERROR macro.</p>
<p>Public exceptions exposed in <a class="el" href="group__websocket.html#a2229fadf97885c574f68d8d98136b2a0">SocketWS.h:</a></p><ul>
<li>SocketWS_Failed: General failures</li>
<li>SocketWS_ProtocolError: RFC violations</li>
<li>SocketWS_Closed: <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> closed</li>
</ul>
<p>Internal use: RAISE_WS_ERROR for quick error raising with module context.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Except_8h.html" title="Structured exception handling for C with TRY/EXCEPT/FINALLY blocks.">Except.h</a> for exception framework. </dd>
<dd>
docs/ERROR_HANDLING.md for patterns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00702">702</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga9be4ad7326c3c8e0480ae9ca4170bc79" name="ga9be4ad7326c3c8e0480ae9ca4170bc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be4ad7326c3c8e0480ae9ca4170bc79">&#9670;&#160;</a></span>SOCKETWS_BASE_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_BASE_HEADER_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="frame_header_constants"></a>
Frame Header Constants</h1>
<p>Constants for WebSocket frame header format and lengths. Header: 2-14 bytes (FIN/RSV/opcode + MASK/len + ext len + mask key).</p>
<p>Length encoding: 7-bit direct, 126=16-bit, 127=64-bit. Control frames: max 125 byte payload, no fragmentation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__FrameParse" title="Context for parsing incoming WebSocket frames.">SocketWS_FrameParse</a> for parsing. </dd>
<dd>
<a class="el" href="group__websocket.html#gad0cb16d7a760ff6ea58750797c85ee15" title="Builds the binary WebSocket frame header into output buffer.">ws_frame_build_header()</a> for serialization. </dd>
<dd>
RFC 6455 Section 5.2 for detailed format. Minimum frame header size: 1 byte (FIN+RSV+opcode) + 1 byte (MASK+len) </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00147">147</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga9b9cdb003a53aa826efee47bcfbd59b6" name="ga9b9cdb003a53aa826efee47bcfbd59b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b9cdb003a53aa826efee47bcfbd59b6">&#9670;&#160;</a></span>SOCKETWS_FIN_BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_FIN_BIT&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="frame_bitmasks"></a>
Frame Header Bit Masks</h1>
<p>Bit masks for extracting fields from frame header bytes. First byte: FIN (7), RSV1-3 (6-4), Opcode (3-0) Second byte: MASK (7), Payload len (6-0)</p>
<p>Used in parsing (ws_frame_parse_header) and building (ws_frame_build_header).</p>
<dl class="section see"><dt>See also</dt><dd>RFC 6455 Section 5.2 Table 2-3 for bit positions. FIN bit: indicates final fragment of message </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00183">183</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga9819e96f9d91fe108c80c7513bf1d4af" name="ga9819e96f9d91fe108c80c7513bf1d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9819e96f9d91fe108c80c7513bf1d4af">&#9670;&#160;</a></span>SOCKETWS_MAX_FRAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_MAX_FRAME_SIZE&#160;&#160;&#160;(16 * 1024 * 1024)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="config_constants"></a>
Configuration Constants</h1>
<p>Compile-time constants controlling WebSocket behavior, limits, and defaults. Override via CMake or preprocessor before including headers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a> for runtime configuration. Maximum WebSocket frame size (default 16MB) </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00056">56</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="gad2f84e7a4e066091e7a75f51507d3391" name="gad2f84e7a4e066091e7a75f51507d3391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f84e7a4e066091e7a75f51507d3391">&#9670;&#160;</a></span>SOCKETWS_PROTOCOL_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_PROTOCOL_VERSION&#160;&#160;&#160;&quot;13&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="handshake_constants"></a>
Handshake Constants</h1>
<p>Constants for HTTP upgrade handshake (client request, server response). Includes protocol version, header values, buffer sizes, key lengths.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Handshake" title="Context for WebSocket HTTP upgrade handshake.">SocketWS_Handshake</a> for runtime handshake state. </dd>
<dd>
RFC 6455 Section 1.3 for version, Section 4 for handshake format. WebSocket protocol version per RFC 6455 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00072">72</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga012fa1b5257d1188d71ec84b86513bda" name="ga012fa1b5257d1188d71ec84b86513bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012fa1b5257d1188d71ec84b86513bda">&#9670;&#160;</a></span>SOCKETWS_SEND_CHUNK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_SEND_CHUNK_SIZE&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="send_config"></a>
Send Buffer Configuration</h1>
<p>Runtime constants for send/recv buffering, message limits, control payloads. Defaults suitable for most use cases; override via config or defines.</p>
<p>Buffers sized for efficiency (64KB), chunks for partial sends. Limits prevent DoS: max frame/message, fragments, close reason.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for underlying buffer impl. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a> for user-configurable limits. Chunk size for data frame payload sending (8KB) </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00220">220</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="gaf21b49963e774f217dd5558e8ce0fbc6" name="gaf21b49963e774f217dd5558e8ce0fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21b49963e774f217dd5558e8ce0fbc6">&#9670;&#160;</a></span>SOCKETWS_XOR_ALIGN_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETWS_XOR_ALIGN_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<h1><a class="anchor" id="masking_constants"></a>
XOR Masking Constants</h1>
<p>Constants for client-to-server payload masking (4-byte key XOR). Optimization: 64-bit aligned XOR loops, mask cycling.</p>
<p>Masking required for client frames to prevent proxy attacks. Server frames unmasked.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga6113393ea2f0b3b64b3e4a48299f899b" title="Applies XOR masking to WebSocket payload data in place.">ws_mask_payload()</a> optimized masking function. </dd>
<dd>
<a class="el" href="group__websocket.html#ga90f8bce3f762e01c75870b2dbb49d63d" title="Applies XOR masking to payload starting from a given mask offset.">ws_mask_payload_offset()</a> for incremental masking. </dd>
<dd>
RFC 6455 Section 5.3 for masking rationale and algorithm. Alignment size for optimized 64-bit XOR masking </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00119">119</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;SocketWS_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00116">116</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga386c437e966aeaeb091d1d81c0e77b13" name="ga386c437e966aeaeb091d1d81c0e77b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga386c437e966aeaeb091d1d81c0e77b13">&#9670;&#160;</a></span>SocketWS_CloseCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">SocketWS_CloseCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status codes for WebSocket CLOSE frames (RFC 6455 section 7.4). </p>
<p>Sent in CLOSE frame payload (2-byte code + optional UTF-8 reason). Codes 0-999 reserved, 1000-1015+ defined, 1016-2999 for libraries, 3000-3999 for apps, 4000+ for private.</p>
<p>Internal codes (1002-1006,1015) not sent on wire.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> to send close with code. </dd>
<dd>
<a class="el" href="group__websocket.html#ga12bb7e4b6127548345c12ddde993704d" title="Get close code from close frame.">SocketWS_close_code()</a> to retrieve received code. </dd>
<dd>
RFC 6455 section 7.4 for full list and semantics. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30" name="gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30"></a>WS_CLOSE_NORMAL&#160;</td><td class="fielddoc"><p>Normal closure, no error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a9bb565620ebf9a5c79afa6281a253b6d" name="gga386c437e966aeaeb091d1d81c0e77b13a9bb565620ebf9a5c79afa6281a253b6d"></a>WS_CLOSE_GOING_AWAY&#160;</td><td class="fielddoc"><p>Endpoint shutting down. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13aaf641b4eedfe849aeed35a84f61709bf" name="gga386c437e966aeaeb091d1d81c0e77b13aaf641b4eedfe849aeed35a84f61709bf"></a>WS_CLOSE_PROTOCOL_ERROR&#160;</td><td class="fielddoc"><p>Generic protocol violation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a2852358b8d5151feda017ab29972f16e" name="gga386c437e966aeaeb091d1d81c0e77b13a2852358b8d5151feda017ab29972f16e"></a>WS_CLOSE_UNSUPPORTED_DATA&#160;</td><td class="fielddoc"><p>Received unsupported frame type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a859b46a0f5a7a29e664a22a1c1c86919" name="gga386c437e966aeaeb091d1d81c0e77b13a859b46a0f5a7a29e664a22a1c1c86919"></a>WS_CLOSE_NO_STATUS&#160;</td><td class="fielddoc"><p>No status rcvd (internal use only). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13aa5b58d4bfbfbeb754edc424760ff4b04" name="gga386c437e966aeaeb091d1d81c0e77b13aa5b58d4bfbfbeb754edc424760ff4b04"></a>WS_CLOSE_ABNORMAL&#160;</td><td class="fielddoc"><p>Closed without CLOSE frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a5fcad814a12fede092794145c328fb9f" name="gga386c437e966aeaeb091d1d81c0e77b13a5fcad814a12fede092794145c328fb9f"></a>WS_CLOSE_INVALID_PAYLOAD&#160;</td><td class="fielddoc"><p>Invalid UTF-8 or other payload error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a35ac58f4457834de3faeb1fa7792366d" name="gga386c437e966aeaeb091d1d81c0e77b13a35ac58f4457834de3faeb1fa7792366d"></a>WS_CLOSE_POLICY_VIOLATION&#160;</td><td class="fielddoc"><p>Message violates policy. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13adbdae48a85dc5e937a163e01508001c6" name="gga386c437e966aeaeb091d1d81c0e77b13adbdae48a85dc5e937a163e01508001c6"></a>WS_CLOSE_MESSAGE_TOO_BIG&#160;</td><td class="fielddoc"><p>Message exceeds size limits. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a1f6f581ca2b8fc652c8ffb993fb8194a" name="gga386c437e966aeaeb091d1d81c0e77b13a1f6f581ca2b8fc652c8ffb993fb8194a"></a>WS_CLOSE_MANDATORY_EXT&#160;</td><td class="fielddoc"><p>Required extension not offered. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a5724188e50f92c13d3673f08ce69412a" name="gga386c437e966aeaeb091d1d81c0e77b13a5724188e50f92c13d3673f08ce69412a"></a>WS_CLOSE_INTERNAL_ERROR&#160;</td><td class="fielddoc"><p>Server internal error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13a9af38cc3ecad679dcf15e666000dfa4b" name="gga386c437e966aeaeb091d1d81c0e77b13a9af38cc3ecad679dcf15e666000dfa4b"></a>WS_CLOSE_SERVICE_RESTART&#160;</td><td class="fielddoc"><p>Server restarting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13ae899716cd2fc4d8f76d4dad9889129e2" name="gga386c437e966aeaeb091d1d81c0e77b13ae899716cd2fc4d8f76d4dad9889129e2"></a>WS_CLOSE_TRY_AGAIN_LATER&#160;</td><td class="fielddoc"><p>Temporary server condition. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13ac0935030c6af954b99019692f8757b1b" name="gga386c437e966aeaeb091d1d81c0e77b13ac0935030c6af954b99019692f8757b1b"></a>WS_CLOSE_BAD_GATEWAY&#160;</td><td class="fielddoc"><p>Bad gateway or tunnel error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga386c437e966aeaeb091d1d81c0e77b13aceffd9fee405e4dee36e9596939ba5ec" name="gga386c437e966aeaeb091d1d81c0e77b13aceffd9fee405e4dee36e9596939ba5ec"></a>WS_CLOSE_TLS_HANDSHAKE&#160;</td><td class="fielddoc"><p>Failed TLS handshake (internal). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00201">201</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<a id="gabd79199a60ad91cf785166f24f41101f" name="gabd79199a60ad91cf785166f24f41101f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd79199a60ad91cf785166f24f41101f">&#9670;&#160;</a></span>SocketWS_Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WebSocket-specific error codes for <a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a>. </p>
<p>Returned by API functions; 0 indicates success.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a> to retrieve after error. </dd>
<dd>
<a class="el" href="group__websocket.html#ga1bfa823bd6275bfdcb9bab6f26ab90ee" title="Get a human-readable string describing a WebSocket error code.">SocketWS_error_string()</a> for descriptions. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb" name="ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb"></a>WS_OK&#160;</td><td class="fielddoc"><p>Operation succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101faa41b8e2f5c20dd621e69746820e10ecd" name="ggabd79199a60ad91cf785166f24f41101faa41b8e2f5c20dd621e69746820e10ecd"></a>WS_ERROR&#160;</td><td class="fielddoc"><p>Generic WebSocket error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa326cba4dbca2cd3fc40aa705e3c8c43c" name="ggabd79199a60ad91cf785166f24f41101fa326cba4dbca2cd3fc40aa705e3c8c43c"></a>WS_ERROR_HANDSHAKE&#160;</td><td class="fielddoc"><p>Handshake failure (invalid response/key). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fac3b45ed8d1cffbe97ae99ad9368edfec" name="ggabd79199a60ad91cf785166f24f41101fac3b45ed8d1cffbe97ae99ad9368edfec"></a>WS_ERROR_PROTOCOL&#160;</td><td class="fielddoc"><p>Protocol violation (bad opcode, etc.). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fad67cba0f02674ecdb494d3c897945304" name="ggabd79199a60ad91cf785166f24f41101fad67cba0f02674ecdb494d3c897945304"></a>WS_ERROR_FRAME_TOO_LARGE&#160;</td><td class="fielddoc"><p>Frame size exceeds config.max_frame_size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa202edc337483e9a546142eeadae60afa" name="ggabd79199a60ad91cf785166f24f41101fa202edc337483e9a546142eeadae60afa"></a>WS_ERROR_MESSAGE_TOO_LARGE&#160;</td><td class="fielddoc"><p>Reassembled message exceeds config.max_message_size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa276c19a5f29e2a5d3032eeebf7d54a8e" name="ggabd79199a60ad91cf785166f24f41101fa276c19a5f29e2a5d3032eeebf7d54a8e"></a>WS_ERROR_INVALID_UTF8&#160;</td><td class="fielddoc"><p>Text frame contains invalid UTF-8. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa7bb811cc75e39503c96e5e58f41e392f" name="ggabd79199a60ad91cf785166f24f41101fa7bb811cc75e39503c96e5e58f41e392f"></a>WS_ERROR_COMPRESSION&#160;</td><td class="fielddoc"><p>permessage-deflate compression/decompression error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fa4b6bd8241f6074e7efa54cc113fce39c" name="ggabd79199a60ad91cf785166f24f41101fa4b6bd8241f6074e7efa54cc113fce39c"></a>WS_ERROR_CLOSED&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> closed during operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fad8bea1e89b1464f633c15cc454699761" name="ggabd79199a60ad91cf785166f24f41101fad8bea1e89b1464f633c15cc454699761"></a>WS_ERROR_WOULD_BLOCK&#160;</td><td class="fielddoc"><p>Non-blocking I/O would block. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd79199a60ad91cf785166f24f41101fab7f48522858a5f62bb83f2102996daaf" name="ggabd79199a60ad91cf785166f24f41101fab7f48522858a5f62bb83f2102996daaf"></a>WS_ERROR_TIMEOUT&#160;</td><td class="fielddoc"><p>Operation timed out (ping or I/O). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00274">274</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<a id="gacba3d485716ab762c1ecd90312174721" name="gacba3d485716ab762c1ecd90312174721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba3d485716ab762c1ecd90312174721">&#9670;&#160;</a></span>SocketWS_FrameState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#gacba3d485716ab762c1ecd90312174721">SocketWS_FrameState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States for the frame parsing state machine. </p>
<p>Tracks progress through frame header parsing, length extension, masking, and payload. Used to handle incremental frame reception in non-blocking mode.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf" title="Incrementally parses WebSocket frame header from input data.">ws_frame_parse_header()</a> for state transitions. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__FrameParse" title="Context for parsing incoming WebSocket frames.">SocketWS_FrameParse</a> for full parse context. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec" name="ggacba3d485716ab762c1ecd90312174721a4a0b680c57f390d60a68f818be6ae1ec"></a>WS_FRAME_STATE_HEADER&#160;</td><td class="fielddoc"><p>Reading frame header (opcode, fin, rsv, mask, len) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba3d485716ab762c1ecd90312174721af660d590efb4ea061786e8482299f185" name="ggacba3d485716ab762c1ecd90312174721af660d590efb4ea061786e8482299f185"></a>WS_FRAME_STATE_EXTENDED_LEN&#160;</td><td class="fielddoc"><p>Reading extended payload length (16/64-bit) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba3d485716ab762c1ecd90312174721ac2be9581030ed942d7ac8a599522a991" name="ggacba3d485716ab762c1ecd90312174721ac2be9581030ed942d7ac8a599522a991"></a>WS_FRAME_STATE_MASK_KEY&#160;</td><td class="fielddoc"><p>Reading 4-byte mask key (client frames only) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba3d485716ab762c1ecd90312174721afe6b85e3f7bb21768bd711b5c788defe" name="ggacba3d485716ab762c1ecd90312174721afe6b85e3f7bb21768bd711b5c788defe"></a>WS_FRAME_STATE_PAYLOAD&#160;</td><td class="fielddoc"><p>Reading payload data </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacba3d485716ab762c1ecd90312174721a03af376c7e0d083cafca2056a7a1913c" name="ggacba3d485716ab762c1ecd90312174721a03af376c7e0d083cafca2056a7a1913c"></a>WS_FRAME_STATE_COMPLETE&#160;</td><td class="fielddoc"><p>Frame fully parsed </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00282">282</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="gafb2bca991ca02e642b76a7ecc166943c" name="gafb2bca991ca02e642b76a7ecc166943c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2bca991ca02e642b76a7ecc166943c">&#9670;&#160;</a></span>SocketWS_HandshakeState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#gafb2bca991ca02e642b76a7ecc166943c">SocketWS_HandshakeState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States for WebSocket HTTP upgrade handshake. </p>
<p>Tracks progress of client or server handshake over HTTP/1.1. Client: INIT -&gt; SEND_REQUEST -&gt; READ_RESPONSE -&gt; COMPLETE/FAILED Server: INIT -&gt; SEND_RESPONSE -&gt; COMPLETE/FAILED (request already parsed)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Handshake" title="Context for WebSocket HTTP upgrade handshake.">SocketWS_Handshake</a> for full handshake context. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> public function that drives state machine. </dd>
<dd>
RFC 6455 Section 4 for handshake details. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafb2bca991ca02e642b76a7ecc166943cafe125c7c26a9431e7e7f5a71e35d47bc" name="ggafb2bca991ca02e642b76a7ecc166943cafe125c7c26a9431e7e7f5a71e35d47bc"></a>WS_HANDSHAKE_INIT&#160;</td><td class="fielddoc"><p>Initial state, prepare handshake data </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb2bca991ca02e642b76a7ecc166943cad8f0ee2a2480a3cde670e3e87265bbc3" name="ggafb2bca991ca02e642b76a7ecc166943cad8f0ee2a2480a3cde670e3e87265bbc3"></a>WS_HANDSHAKE_SENDING_REQUEST&#160;</td><td class="fielddoc"><p>Client: Sending HTTP GET upgrade request </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb2bca991ca02e642b76a7ecc166943ca25652911320a61aa0f678b7b369a222d" name="ggafb2bca991ca02e642b76a7ecc166943ca25652911320a61aa0f678b7b369a222d"></a>WS_HANDSHAKE_READING_RESPONSE&#160;</td><td class="fielddoc"><p>Client: Reading HTTP 101 response; Server: reading client request if needed </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb2bca991ca02e642b76a7ecc166943ca1819c5beb0d322efdacf6438eb3c3c32" name="ggafb2bca991ca02e642b76a7ecc166943ca1819c5beb0d322efdacf6438eb3c3c32"></a>WS_HANDSHAKE_COMPLETE&#160;</td><td class="fielddoc"><p>Handshake successful, transition to frame mode </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafb2bca991ca02e642b76a7ecc166943ca0fb5763d6e764dbe2fbf97169c1a2b1b" name="ggafb2bca991ca02e642b76a7ecc166943ca0fb5763d6e764dbe2fbf97169c1a2b1b"></a>WS_HANDSHAKE_FAILED&#160;</td><td class="fielddoc"><p>Handshake failed, error set </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l00400">400</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga174740343c7f920060f8640f23600c7b" name="ga174740343c7f920060f8640f23600c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174740343c7f920060f8640f23600c7b">&#9670;&#160;</a></span>SocketWS_Opcode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WebSocket frame opcodes as defined in RFC 6455 section 5.2. </p>
<p>Opcodes determine frame type: data (text/binary), control (close/ping/pong), or continuation for fragmented messages.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#a3316616d6bd9228919cf2eac7df3c780">SocketWS_Frame.opcode</a> for frame parsing. </dd>
<dd>
RFC 6455 for full opcode semantics and reserved values. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7ba414ed52e10fc98a59c9fbadc896b3ea3" name="gga174740343c7f920060f8640f23600c7ba414ed52e10fc98a59c9fbadc896b3ea3"></a>WS_OPCODE_CONTINUATION&#160;</td><td class="fielddoc"><p>Continuation frame for fragmented data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7bab290478c848bb099a2fefe6c7b633558" name="gga174740343c7f920060f8640f23600c7bab290478c848bb099a2fefe6c7b633558"></a>WS_OPCODE_TEXT&#160;</td><td class="fielddoc"><p>Text data frame (UTF-8 encoded). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7ba01f825533b31920937ba5ddb2315a361" name="gga174740343c7f920060f8640f23600c7ba01f825533b31920937ba5ddb2315a361"></a>WS_OPCODE_BINARY&#160;</td><td class="fielddoc"><p>Binary data frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5" name="gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5"></a>WS_OPCODE_CLOSE&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> close control frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539" name="gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539"></a>WS_OPCODE_PING&#160;</td><td class="fielddoc"><p>Ping control frame (keepalive). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c" name="gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c"></a>WS_OPCODE_PONG&#160;</td><td class="fielddoc"><p>Pong control frame (response to ping). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00172">172</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<a id="ga9d14d3d0f1b05e44fcd74782107cbd94" name="ga9d14d3d0f1b05e44fcd74782107cbd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d14d3d0f1b05e44fcd74782107cbd94">&#9670;&#160;</a></span>SocketWS_Role</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#ga9d14d3d0f1b05e44fcd74782107cbd94">SocketWS_Role</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WebSocket endpoint roles per RFC 6455. </p>
<p>Clients mask outgoing frames; servers validate masks on incoming. Set in <a class="el" href="group__websocket.html#aa895fa89617603768d89d043b41b3bc9">SocketWS_Config.role</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#aa895fa89617603768d89d043b41b3bc9">SocketWS_Config.role</a> for configuration. </dd>
<dd>
RFC 6455 section 5.3 for masking requirements. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9d14d3d0f1b05e44fcd74782107cbd94adb564f62107e65c4ba508183929404d1" name="gga9d14d3d0f1b05e44fcd74782107cbd94adb564f62107e65c4ba508183929404d1"></a>WS_ROLE_CLIENT&#160;</td><td class="fielddoc"><p>Client: must mask all outgoing data frames. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9d14d3d0f1b05e44fcd74782107cbd94afa4a0c78e19b98cca7f556560ca4061b" name="gga9d14d3d0f1b05e44fcd74782107cbd94afa4a0c78e19b98cca7f556560ca4061b"></a>WS_ROLE_SERVER&#160;</td><td class="fielddoc"><p>Server: rejects unmasked incoming data frames. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00254">254</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<a id="gab8b49607a661224d66bb264b1e597e2d" name="gab8b49607a661224d66bb264b1e597e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b49607a661224d66bb264b1e597e2d">&#9670;&#160;</a></span>SocketWS_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">SocketWS_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WebSocket connection lifecycle states. </p>
<p>Tracks progression from handshake to closure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0" title="Retrieve the current state of the WebSocket connection.">SocketWS_state()</a> to query current state. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> transitions CONNECTING -&gt; OPEN. </dd>
<dd>
<a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> transitions OPEN -&gt; CLOSING. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab8b49607a661224d66bb264b1e597e2da782bbde9b515882abdd6b712c127af31" name="ggab8b49607a661224d66bb264b1e597e2da782bbde9b515882abdd6b712c127af31"></a>WS_STATE_CONNECTING&#160;</td><td class="fielddoc"><p>Handshake (HTTP upgrade) in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c" name="ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c"></a>WS_STATE_OPEN&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> established, ready for read/write. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab8b49607a661224d66bb264b1e597e2daa3bafc31c6e8514011174ffeb2dd1eac" name="ggab8b49607a661224d66bb264b1e597e2daa3bafc31c6e8514011174ffeb2dd1eac"></a>WS_STATE_CLOSING&#160;</td><td class="fielddoc"><p>Close frame sent/received, awaiting ack. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab8b49607a661224d66bb264b1e597e2da4356293e46722d1fa27ca8624f62b296" name="ggab8b49607a661224d66bb264b1e597e2da4356293e46722d1fa27ca8624f62b296"></a>WS_STATE_CLOSED&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> terminated, resources freed on free(). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketWS_8h_source.html#l00236">236</a> of file <a class="el" href="SocketWS_8h_source.html">SocketWS.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacad45d5dbc4f2191ba5f732a1b648842" name="gacad45d5dbc4f2191ba5f732a1b648842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad45d5dbc4f2191ba5f732a1b648842">&#9670;&#160;</a></span>SocketWS_client_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketWS_T SocketWS_client_new </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new client WebSocket instance from a connected TCP socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected TCP socket (transferred to WebSocket; do not close externally). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Value for the Host header in upgrade request (required). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Resource path for the WebSocket endpoint (e.g., "/chat", defaults to "/"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Optional <a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a>; NULL applies defaults via <a class="el" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176" title="Initialize WebSocket configuration with default values.">SocketWS_config_defaults()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned instance starts in WS_STATE_CONNECTING. Call <a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> to send the HTTP/1.1 Upgrade request and receive the server's response.</p>
<p>Supports both blocking and non-blocking sockets, but non-blocking is recommended for production to avoid head-of-line blocking during handshake.</p>
<dl class="section return"><dt>Returns</dt><dd>New SocketWS_T instance, or NULL on failure (except frame raised). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>on invalid parameters, allocation failure, or socket issues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent instance.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md575"></a>
Client Usage Example</h2>
<div class="fragment"><div class="line">  <a class="code hl_struct" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> config;</div>
<div class="line">  <a class="code hl_function" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176">SocketWS_config_defaults</a>(&amp;config);</div>
<div class="line">  <span class="comment">// Optional customizations</span></div>
<div class="line">  config.<a class="code hl_variable" href="group__websocket.html#a2ff17028ab5d54be79108495bf1c4512">subprotocols</a> = (<span class="keyword">const</span> <span class="keywordtype">char</span>*[]){<span class="stringliteral">&quot;chat&quot;</span>, NULL};</div>
<div class="line">  config.<a class="code hl_variable" href="group__websocket.html#a376fe666ac3f3654087792edae1ce054">ping_interval_ms</a> = 30000;  <span class="comment">// Auto-ping every 30s</span></div>
<div class="line">  config.<a class="code hl_variable" href="group__websocket.html#a1873fe17fa2f2d2d3c0d16cbfbcfc3f1">validate_utf8</a> = 1;          <span class="comment">// Enable UTF-8 checks</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;example.com&quot;</span>, 443);  <span class="comment">// Port 80 or 443 for wss</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For secure WebSocket (wss://):</span></div>
<div class="line">    <span class="comment">// SocketTLSContext_T ctx = SocketTLSContext_new(...);</span></div>
<div class="line">    <span class="comment">// SocketTLS_enable(sock, ctx);</span></div>
<div class="line">    <span class="comment">// SocketTLS_set_hostname(sock, &quot;example.com&quot;);</span></div>
<div class="line">    <span class="comment">// SocketTLS_handshake_auto(sock);</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a>(sock);  <span class="comment">// Recommended for production</span></div>
<div class="line"> </div>
<div class="line">    SocketWS_T ws = <a class="code hl_function" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842">SocketWS_client_new</a>(sock, <span class="stringliteral">&quot;example.com&quot;</span>, <span class="stringliteral">&quot;/ws/chat&quot;</span>,</div>
<div class="line">&amp;config);</div>
<div class="line">    <span class="keywordflow">if</span> (ws == NULL) <a class="code hl_define" href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a>(<a class="code hl_variable" href="group__websocket.html#ga0fb92a65a798e17aca6df1cdba118067">SocketWS_Failed</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Non-blocking handshake loop</span></div>
<div class="line">    <span class="keywordtype">int</span> status;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      status = <a class="code hl_function" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06">SocketWS_handshake</a>(ws);</div>
<div class="line">      <span class="keywordflow">if</span> (status &lt; 0) <span class="keywordflow">break</span>;  <span class="comment">// Error</span></div>
<div class="line">      <span class="keywordflow">if</span> (status == 0) <span class="keywordflow">break</span>; <span class="comment">// Success</span></div>
<div class="line">      <span class="comment">// Poll SocketWS_pollfd(ws) for SocketWS_poll_events(ws)</span></div>
<div class="line">      <span class="comment">// Then SocketWS_process(ws, events)</span></div>
<div class="line">    } <span class="keywordflow">while</span> (1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0">SocketWS_state</a>(ws) == <a class="code hl_enumvalue" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c">WS_STATE_OPEN</a>) {</div>
<div class="line">      <span class="comment">// Send text message</span></div>
<div class="line">      <a class="code hl_function" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03">SocketWS_send_text</a>(ws, <span class="stringliteral">&quot;{\&quot;msg\&quot;:\&quot;Hello WebSocket\&quot;}&quot;</span>, 22);</div>
<div class="line">      <span class="comment">// Receive messages via SocketWS_recv_message() or event loop</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944">SocketWS_free</a>(&amp;ws);</div>
<div class="line">  } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a> (<a class="code hl_variable" href="group__websocket.html#ga0fb92a65a798e17aca6df1cdba118067">SocketWS_Failed</a> | <a class="code hl_variable" href="group__websocket.html#ga8400199bb1b785111015ff06d16de370">SocketWS_ProtocolError</a>) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Client WebSocket error: %s&quot;</span>,</div>
<div class="line"><a class="code hl_function" href="group__websocket.html#ga1bfa823bd6275bfdcb9bab6f26ab90ee">SocketWS_error_string</a>(<a class="code hl_function" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0">SocketWS_last_error</a>(ws)));</div>
<div class="line">  } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketUtil_8h_html_a16642c35dec627aeb4976538671b1552"><div class="ttname"><a href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_ERROR_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00548">SocketUtil.h:548</a></div></div>
<div class="ttc" id="agroup__core__io_html_ga35309677a1760480783d5f0c294d0db4"><div class="ttname"><a href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a></div><div class="ttdeci">void Socket_setnonblocking(Socket_T socket)</div><div class="ttdoc">Enable non-blocking mode.</div></div>
<div class="ttc" id="agroup__core__io_html_ga6212fb2b6eefa567592a59f55c25a6f1"><div class="ttname"><a href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a></div><div class="ttdeci">Socket_T Socket_new(int domain, int type, int protocol)</div><div class="ttdoc">Create a new socket with specified domain, type, and protocol.</div></div>
<div class="ttc" id="agroup__core__io_html_gac14390090ee26136c1f7a816fc08406e"><div class="ttname"><a href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a></div><div class="ttdeci">void Socket_connect(Socket_T socket, const char *host, int port)</div><div class="ttdoc">Establish a connection to a remote host and port.</div></div>
<div class="ttc" id="agroup__foundation_html_ga45e87c4d7dee50346b15c7761b0b340a"><div class="ttname"><a href="group__foundation.html#ga45e87c4d7dee50346b15c7761b0b340a">RAISE</a></div><div class="ttdeci">#define RAISE(e)</div><div class="ttdoc">Raise an exception with current file and line information.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00636">Except.h:636</a></div></div>
<div class="ttc" id="agroup__foundation_html_gab5e72fc2bd41014c75e0ace4feabfe8e"><div class="ttname"><a href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a></div><div class="ttdeci">#define EXCEPT(e)</div><div class="ttdoc">Catch a specific exception type within a TRY block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01105">Except.h:1105</a></div></div>
<div class="ttc" id="agroup__foundation_html_gad2746371528bdf15c3910b7bf217dac0"><div class="ttname"><a href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a></div><div class="ttdeci">#define TRY</div><div class="ttdoc">Start a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00991">Except.h:991</a></div></div>
<div class="ttc" id="agroup__foundation_html_gae6628ac788ad213363b89dba9868420b"><div class="ttname"><a href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a></div><div class="ttdeci">#define END_TRY</div><div class="ttdoc">Complete a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01439">Except.h:1439</a></div></div>
<div class="ttc" id="agroup__websocket_html_a1873fe17fa2f2d2d3c0d16cbfbcfc3f1"><div class="ttname"><a href="group__websocket.html#a1873fe17fa2f2d2d3c0d16cbfbcfc3f1">SocketWS_Config::validate_utf8</a></div><div class="ttdeci">int validate_utf8</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00319">SocketWS.h:319</a></div></div>
<div class="ttc" id="agroup__websocket_html_a2ff17028ab5d54be79108495bf1c4512"><div class="ttname"><a href="group__websocket.html#a2ff17028ab5d54be79108495bf1c4512">SocketWS_Config::subprotocols</a></div><div class="ttdeci">const char ** subprotocols</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00331">SocketWS.h:331</a></div></div>
<div class="ttc" id="agroup__websocket_html_a376fe666ac3f3654087792edae1ce054"><div class="ttname"><a href="group__websocket.html#a376fe666ac3f3654087792edae1ce054">SocketWS_Config::ping_interval_ms</a></div><div class="ttdeci">int ping_interval_ms</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00334">SocketWS.h:334</a></div></div>
<div class="ttc" id="agroup__websocket_html_ga0fb92a65a798e17aca6df1cdba118067"><div class="ttname"><a href="group__websocket.html#ga0fb92a65a798e17aca6df1cdba118067">SocketWS_Failed</a></div><div class="ttdeci">const Except_T SocketWS_Failed</div><div class="ttdoc">Exception raised for general WebSocket operation failures.</div></div>
<div class="ttc" id="agroup__websocket_html_ga1bfa823bd6275bfdcb9bab6f26ab90ee"><div class="ttname"><a href="group__websocket.html#ga1bfa823bd6275bfdcb9bab6f26ab90ee">SocketWS_error_string</a></div><div class="ttdeci">const char * SocketWS_error_string(SocketWS_Error error)</div><div class="ttdoc">Get a human-readable string describing a WebSocket error code.</div></div>
<div class="ttc" id="agroup__websocket_html_ga4b8450a05502aaa70e88cdf14a73fa03"><div class="ttname"><a href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03">SocketWS_send_text</a></div><div class="ttdeci">int SocketWS_send_text(SocketWS_T ws, const char *data, size_t len)</div><div class="ttdoc">Send a text message over the WebSocket (opcode TEXT).</div></div>
<div class="ttc" id="agroup__websocket_html_ga8400199bb1b785111015ff06d16de370"><div class="ttname"><a href="group__websocket.html#ga8400199bb1b785111015ff06d16de370">SocketWS_ProtocolError</a></div><div class="ttdeci">const Except_T SocketWS_ProtocolError</div><div class="ttdoc">Exception for WebSocket protocol violations (RFC 6455 non-compliance).</div></div>
<div class="ttc" id="agroup__websocket_html_ga89d42ff813f81187667d894e0da0fce0"><div class="ttname"><a href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0">SocketWS_last_error</a></div><div class="ttdeci">SocketWS_Error SocketWS_last_error(SocketWS_T ws)</div><div class="ttdoc">Retrieve the most recent error code for this WebSocket instance.</div></div>
<div class="ttc" id="agroup__websocket_html_gaa040ebe5bc5f2673b04b15091a45b944"><div class="ttname"><a href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944">SocketWS_free</a></div><div class="ttdeci">void SocketWS_free(SocketWS_T *ws)</div><div class="ttdoc">Dispose of a WebSocket instance, closing connection if open.</div></div>
<div class="ttc" id="agroup__websocket_html_gaa40def588d31ab50126603fa720f83b0"><div class="ttname"><a href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0">SocketWS_state</a></div><div class="ttdeci">SocketWS_State SocketWS_state(SocketWS_T ws)</div><div class="ttdoc">Retrieve the current state of the WebSocket connection.</div></div>
<div class="ttc" id="agroup__websocket_html_gac129f58e59f8b169f2c2a48a330fb176"><div class="ttname"><a href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176">SocketWS_config_defaults</a></div><div class="ttdeci">void SocketWS_config_defaults(SocketWS_Config *config)</div><div class="ttdoc">Initialize WebSocket configuration with default values.</div></div>
<div class="ttc" id="agroup__websocket_html_gacad45d5dbc4f2191ba5f732a1b648842"><div class="ttname"><a href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842">SocketWS_client_new</a></div><div class="ttdeci">SocketWS_T SocketWS_client_new(Socket_T socket, const char *host, const char *path, const SocketWS_Config *config)</div><div class="ttdoc">Create a new client WebSocket instance from a connected TCP socket.</div></div>
<div class="ttc" id="agroup__websocket_html_gacbbea030dbe9d643b7f8bd6c1656ff06"><div class="ttname"><a href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06">SocketWS_handshake</a></div><div class="ttdeci">int SocketWS_handshake(SocketWS_T ws)</div><div class="ttdoc">Perform or continue the WebSocket handshake process.</div></div>
<div class="ttc" id="agroup__websocket_html_ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c"><div class="ttname"><a href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2dab0325195f22aca5be7491a425f84808c">WS_STATE_OPEN</a></div><div class="ttdeci">@ WS_STATE_OPEN</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00239">SocketWS.h:239</a></div></div>
<div class="ttc" id="agroup__websocket_html_structSocketWS__Config"><div class="ttname"><a href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a></div><div class="ttdoc">Configuration parameters for WebSocket instances.</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00306">SocketWS.h:307</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Socket ownership transfers to ws; close via <a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a>. </dd>
<dd>
For wss://, complete TLS handshake before creating ws. </dd>
<dd>
Use SocketWS_enable_auto_ping(ws, poll) after open for keepalive.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - constant time allocation and initialization</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gac129f58e59f8b169f2c2a48a330fb176" title="Initialize WebSocket configuration with default values.">SocketWS_config_defaults()</a> for configuration. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> to complete upgrade. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> for event-driven I/O. </dd>
<dd>
<a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> for server equivalent. </dd>
<dd>
<a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> for HTTP upgrade details. </dd>
<dd>
<a class="el" href="WEBSOCKET_8md.html">docs/WEBSOCKET.md</a> for full guide. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gaf04efc033266e882f59db340ca2f8d47" name="gaf04efc033266e882f59db340ca2f8d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf04efc033266e882f59db340ca2f8d47">&#9670;&#160;</a></span>SocketWS_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_close </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate graceful WebSocket close handshake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance in OPEN or CLOSING state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Close status code (WS_CLOSE_NORMAL=1000 for no error, see SocketWS_CloseCode). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>Optional UTF-8 encoded reason string (max 123 bytes after code, may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>Sends CLOSE frame with code and reason to peer. Transitions state to WS_STATE_CLOSING, awaits peer CLOSE response. On completion or timeout, connection closes. If already closing, updates code/reason if not sent yet.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (frame queued), -1 on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if already fully closed. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on allocation or queue error. </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>on invalid code or reason length/UTF-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies state and send queue.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0" title="Retrieve the current state of the WebSocket connection.">SocketWS_state()</a> to check transition to CLOSING. </dd>
<dd>
<a class="el" href="group__websocket.html#ga12bb7e4b6127548345c12ddde993704d" title="Get close code from close frame.">SocketWS_close_code()</a> and <a class="el" href="group__websocket.html#ga467b55bf31eeff51106a1d111241ad54" title="Get close reason text from close frame.">SocketWS_close_reason()</a> for peer's close info. </dd>
<dd>
<a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a> which calls this if open. </dd>
<dd>
RFC 6455 section 7.1-7.4 for close handshake details. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00092">request_handler()</a>.</p>

</div>
</div>
<a id="ga12bb7e4b6127548345c12ddde993704d" name="ga12bb7e4b6127548345c12ddde993704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bb7e4b6127548345c12ddde993704d">&#9670;&#160;</a></span>SocketWS_close_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_close_code </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get close code from close frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Close code, or -1 if not closed or no close frame received. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads internal state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga467b55bf31eeff51106a1d111241ad54" title="Get close reason text from close frame.">SocketWS_close_reason()</a> for close reason text. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>.</p>

</div>
</div>
<a id="ga467b55bf31eeff51106a1d111241ad54" name="ga467b55bf31eeff51106a1d111241ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga467b55bf31eeff51106a1d111241ad54">&#9670;&#160;</a></span>SocketWS_close_reason()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketWS_close_reason </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get close reason text from close frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Close reason text, or NULL if not available. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>String is valid until WebSocket is freed. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads internal state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga12bb7e4b6127548345c12ddde993704d" title="Get close code from close frame.">SocketWS_close_code()</a> for close code. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga02790d0b994d613324052794269b0e22" name="ga02790d0b994d613324052794269b0e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02790d0b994d613324052794269b0e22">&#9670;&#160;</a></span>SocketWS_compression_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_compression_enabled </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if compression is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if permessage-deflate enabled, 0 otherwise. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads internal state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a> for compression configuration. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga4bc96039ed3f1e6240cc6af7e3fdce13" name="ga4bc96039ed3f1e6240cc6af7e3fdce13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc96039ed3f1e6240cc6af7e3fdce13">&#9670;&#160;</a></span>SocketWS_compression_options_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketWS_compression_options_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize compression options with defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">options</td><td>Options structure to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac129f58e59f8b169f2c2a48a330fb176" name="gac129f58e59f8b169f2c2a48a330fb176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac129f58e59f8b169f2c2a48a330fb176">&#9670;&#160;</a></span>SocketWS_config_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketWS_config_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize WebSocket configuration with default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>[out] Pointer to the configuration structure to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets reasonable defaults such as 16MB max frame size, UTF-8 validation enabled, compression disabled, and ping interval disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function with no side effects.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a> for creating client WebSockets. </dd>
<dd>
<a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> for accepting server WebSockets. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a> for individual field descriptions and customization. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gaf68edb5baf8b959da2c8b63158d65916" name="gaf68edb5baf8b959da2c8b63158d65916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf68edb5baf8b959da2c8b63158d65916">&#9670;&#160;</a></span>SocketWS_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketWS_T SocketWS_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-liner WebSocket client connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">url</td><td>WebSocket URL (ws:// or wss://) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocols</td><td>Optional comma-separated subprotocols (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<p>Parses URL, creates socket, performs TLS handshake if wss://, creates WebSocket, and completes the opening handshake. Returns fully connected WebSocket in OPEN state.</p>
<dl class="section return"><dt>Returns</dt><dd>WebSocket in OPEN state, or NULL on error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>on connection or handshake failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md576"></a>
URL Format</h2>
<div class="fragment"><div class="line">ws:<span class="comment">//host[:port][/path]     - Unencrypted WebSocket</span></div>
<div class="line">wss:<span class="comment">//host[:port][/path]    - TLS-encrypted WebSocket</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md577"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Simple connection</span></div>
<div class="line">SocketWS_T ws = <a class="code hl_function" href="group__websocket.html#gaf68edb5baf8b959da2c8b63158d65916">SocketWS_connect</a>(<span class="stringliteral">&quot;wss://echo.websocket.org&quot;</span>, NULL);</div>
<div class="line"><span class="keywordflow">if</span> (ws) {</div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03">SocketWS_send_text</a>(ws, <span class="stringliteral">&quot;Hello!&quot;</span>, 6);</div>
<div class="line">    <span class="comment">// ... receive ...</span></div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47">SocketWS_close</a>(ws, <a class="code hl_enumvalue" href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30">WS_CLOSE_NORMAL</a>, NULL);</div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944">SocketWS_free</a>(&amp;ws);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With subprotocol</span></div>
<div class="line">SocketWS_T ws = <a class="code hl_function" href="group__websocket.html#gaf68edb5baf8b959da2c8b63158d65916">SocketWS_connect</a>(<span class="stringliteral">&quot;ws://api.example.com/ws&quot;</span>, <span class="stringliteral">&quot;graphql-ws&quot;</span>);</div>
<div class="ttc" id="agroup__websocket_html_gaf04efc033266e882f59db340ca2f8d47"><div class="ttname"><a href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47">SocketWS_close</a></div><div class="ttdeci">int SocketWS_close(SocketWS_T ws, int code, const char *reason)</div><div class="ttdoc">Initiate graceful WebSocket close handshake.</div></div>
<div class="ttc" id="agroup__websocket_html_gaf68edb5baf8b959da2c8b63158d65916"><div class="ttname"><a href="group__websocket.html#gaf68edb5baf8b959da2c8b63158d65916">SocketWS_connect</a></div><div class="ttdeci">SocketWS_T SocketWS_connect(const char *url, const char *protocols)</div><div class="ttdoc">One-liner WebSocket client connection.</div></div>
<div class="ttc" id="agroup__websocket_html_gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30"><div class="ttname"><a href="group__websocket.html#gga386c437e966aeaeb091d1d81c0e77b13a297d5e27c1ad4b7c6660b005308a5f30">WS_CLOSE_NORMAL</a></div><div class="ttdeci">@ WS_CLOSE_NORMAL</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00203">SocketWS.h:203</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For more control, use Socket_new + Socket_connect + SocketWS_client_new </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a> for manual connection setup </dd>
<dd>
<a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a> for cleanup </dd></dl>

</div>
</div>
<a id="gaedcf20cd5206a2cd971a60a98a58ff5f" name="gaedcf20cd5206a2cd971a60a98a58ff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcf20cd5206a2cd971a60a98a58ff5f">&#9670;&#160;</a></span>SocketWS_disable_auto_ping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketWS_disable_auto_ping </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable and cancel automatic PING keepalive timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Removes any installed ping timer from associated poll. Stops sending periodic PINGs and pong monitoring. Does not affect manual ping/pong or current state. Idempotent if not enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies timer state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga0049a0e0f8a4218c5d5b3dbf8181b92f" title="Enable automatic periodic PING for connection keepalive.">SocketWS_enable_auto_ping()</a> to enable. </dd></dl>

</div>
</div>
<a id="ga0049a0e0f8a4218c5d5b3dbf8181b92f" name="ga0049a0e0f8a4218c5d5b3dbf8181b92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0049a0e0f8a4218c5d5b3dbf8181b92f">&#9670;&#160;</a></span>SocketWS_enable_auto_ping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_enable_auto_ping </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable automatic periodic PING for connection keepalive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ws</td><td>SocketWS_T instance in OPEN state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poll</td><td><a class="el" href="group__poll__private.html#structSocketPoll__T" title="Opaque internal state structure for SocketPoll instance.">SocketPoll_T</a> instance for timer callback integration.</td></tr>
  </table>
  </dd>
</dl>
<p>Installs repeating timer to send PING every <a class="el" href="group__websocket.html#a376fe666ac3f3654087792edae1ce054">SocketWS_Config.ping_interval_ms</a>. Monitors for timely PONG response within ping_timeout_ms. Closes connection on missed pongs (after retries). Timer events processed via <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> on poll. Idempotent: already enabled does nothing.</p>
<p>Requires event loop with provided poll instance.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (timer installed), -1 on failure. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>on timer or poll error. </td></tr>
    <tr><td class="paramname">SocketWS_Closed</td><td>if not open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - installs shared timer.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#a376fe666ac3f3654087792edae1ce054">SocketWS_Config::ping_interval_ms</a> for configuration. </dd>
<dd>
<a class="el" href="group__websocket.html#gaedcf20cd5206a2cd971a60a98a58ff5f" title="Disable and cancel automatic PING keepalive timer.">SocketWS_disable_auto_ping()</a> to disable. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> must be called regularly for pong checks. </dd>
<dd>
<a class="el" href="group__event__system.html">SocketTimer</a> for timer details. </dd></dl>

</div>
</div>
<a id="ga519bf217226465597f30e1f87e19d34a" name="ga519bf217226465597f30e1f87e19d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga519bf217226465597f30e1f87e19d34a">&#9670;&#160;</a></span>SocketWS_enable_compression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_enable_compression </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable permessage-deflate compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance (before handshake) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Compression options (NULL for defaults)</td></tr>
  </table>
  </dd>
</dl>
<p>Enables RFC 7692 permessage-deflate compression for this WebSocket. Must be called before the handshake completes. The server may negotiate different parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if compression not supported or already connected</dd></dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md581"></a>
Example</h2>
<div class="fragment"><div class="line">SocketWS_T ws = <a class="code hl_function" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842">SocketWS_client_new</a>(sock, host, path, &amp;config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable compression before handshake</span></div>
<div class="line"><a class="code hl_struct" href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a> opts;</div>
<div class="line"><a class="code hl_function" href="group__websocket.html#ga4bc96039ed3f1e6240cc6af7e3fdce13">SocketWS_compression_options_defaults</a>(&amp;opts);</div>
<div class="line">opts.<a class="code hl_variable" href="group__websocket.html#a79d8c3d69d9897b2f5ee1ae446b4b97f">level</a> = 9;  <span class="comment">// Maximum compression</span></div>
<div class="line"><a class="code hl_function" href="group__websocket.html#ga519bf217226465597f30e1f87e19d34a">SocketWS_enable_compression</a>(ws, &amp;opts);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now complete handshake</span></div>
<div class="line"><a class="code hl_function" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06">SocketWS_handshake</a>(ws);</div>
<div class="ttc" id="agroup__websocket_html_a79d8c3d69d9897b2f5ee1ae446b4b97f"><div class="ttname"><a href="group__websocket.html#a79d8c3d69d9897b2f5ee1ae446b4b97f">SocketWS_CompressionOptions::level</a></div><div class="ttdeci">int level</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l01183">SocketWS.h:1183</a></div></div>
<div class="ttc" id="agroup__websocket_html_ga4bc96039ed3f1e6240cc6af7e3fdce13"><div class="ttname"><a href="group__websocket.html#ga4bc96039ed3f1e6240cc6af7e3fdce13">SocketWS_compression_options_defaults</a></div><div class="ttdeci">void SocketWS_compression_options_defaults(SocketWS_CompressionOptions *options)</div><div class="ttdoc">Initialize compression options with defaults.</div></div>
<div class="ttc" id="agroup__websocket_html_ga519bf217226465597f30e1f87e19d34a"><div class="ttname"><a href="group__websocket.html#ga519bf217226465597f30e1f87e19d34a">SocketWS_enable_compression</a></div><div class="ttdeci">int SocketWS_enable_compression(SocketWS_T ws, const SocketWS_CompressionOptions *options)</div><div class="ttdoc">Enable permessage-deflate compression.</div></div>
<div class="ttc" id="agroup__websocket_html_structSocketWS__CompressionOptions"><div class="ttname"><a href="group__websocket.html#structSocketWS__CompressionOptions">SocketWS_CompressionOptions</a></div><div class="ttdoc">WebSocket compression options.</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l01181">SocketWS.h:1182</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Requires zlib; returns -1 if compiled without SOCKETWS_HAS_DEFLATE </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga02790d0b994d613324052794269b0e22" title="Check if compression is enabled.">SocketWS_compression_enabled()</a> to check if active </dd>
<dd>
SocketWS_Config.enable_compression for config-based setup </dd></dl>

</div>
</div>
<a id="ga1bfa823bd6275bfdcb9bab6f26ab90ee" name="ga1bfa823bd6275bfdcb9bab6f26ab90ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bfa823bd6275bfdcb9bab6f26ab90ee">&#9670;&#160;</a></span>SocketWS_error_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketWS_error_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a>&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a human-readable string describing a WebSocket error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>SocketWS_Error value to describe.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns pointer to static string (do not free or modify). Covers all defined SocketWS_Error values.</p>
<dl class="section return"><dt>Returns</dt><dd>Const char* to error description, never NULL. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - returns static immutable strings.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a> to get code after failed operation. </dd>
<dd>
<a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f" title="WebSocket-specific error codes for SocketWS_last_error().">SocketWS_Error</a> enum for error codes. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gaa040ebe5bc5f2673b04b15091a45b944" name="gaa040ebe5bc5f2673b04b15091a45b944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa040ebe5bc5f2673b04b15091a45b944">&#9670;&#160;</a></span>SocketWS_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketWS_free </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispose of a WebSocket instance, closing connection if open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>[in,out] Pointer to SocketWS_T; set to NULL after disposal.</td></tr>
  </table>
  </dd>
</dl>
<p>Performs graceful close if in OPEN or CLOSING state (sends CLOSE frame if needed). Releases all resources including underlying socket, buffers, compression context, and timers. Arena-allocated memory returned to owning arena.</p>
<p>Safe to call on already-freed or NULL pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- errors during close logged but not raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - instance-specific resources.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> for explicit close before free. </dd>
<dd>
<a class="el" href="group__websocket.html#gacad45d5dbc4f2191ba5f732a1b648842" title="Create a new client WebSocket instance from a connected TCP socket.">SocketWS_client_new()</a>, <a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> for creation. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>, and <a class="el" href="websocket__server_8c_source.html#l00092">request_handler()</a>.</p>

</div>
</div>
<a id="ga9f35bc85185a4084dc4d4e553bbd4559" name="ga9f35bc85185a4084dc4d4e553bbd4559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f35bc85185a4084dc4d4e553bbd4559">&#9670;&#160;</a></span>SocketWS_get_ping_latency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SocketWS_get_ping_latency </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ping/pong round-trip time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the latency (RTT) of the most recent completed PING/PONG cycle. If no ping has been sent or pong not yet received, returns -1.</p>
<dl class="section return"><dt>Returns</dt><dd>RTT in milliseconds (&gt;= 0), or -1 if no data available</dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads internal timestamps</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md580"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Send ping and wait for pong</span></div>
<div class="line"><a class="code hl_function" href="group__websocket.html#ga2be521a2fe8aa5eb5d30869905371a71">SocketWS_ping</a>(ws, <span class="stringliteral">&quot;test&quot;</span>, 4);</div>
<div class="line"><span class="comment">// ... process events until pong received ...</span></div>
<div class="line">int64_t rtt = <a class="code hl_function" href="group__websocket.html#ga9f35bc85185a4084dc4d4e553bbd4559">SocketWS_get_ping_latency</a>(ws);</div>
<div class="line"><span class="keywordflow">if</span> (rtt &gt;= 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Latency: %lld ms\n&quot;</span>, (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)rtt);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__websocket_html_ga2be521a2fe8aa5eb5d30869905371a71"><div class="ttname"><a href="group__websocket.html#ga2be521a2fe8aa5eb5d30869905371a71">SocketWS_ping</a></div><div class="ttdeci">int SocketWS_ping(SocketWS_T ws, const void *data, size_t len)</div><div class="ttdoc">Send a PING control frame for keepalive or to solicit immediate response from peer.</div></div>
<div class="ttc" id="agroup__websocket_html_ga9f35bc85185a4084dc4d4e553bbd4559"><div class="ttname"><a href="group__websocket.html#ga9f35bc85185a4084dc4d4e553bbd4559">SocketWS_get_ping_latency</a></div><div class="ttdeci">int64_t SocketWS_get_ping_latency(SocketWS_T ws)</div><div class="ttdoc">Get ping/pong round-trip time.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga2be521a2fe8aa5eb5d30869905371a71" title="Send a PING control frame for keepalive or to solicit immediate response from peer.">SocketWS_ping()</a> to send PING </dd>
<dd>
<a class="el" href="group__websocket.html#ga0049a0e0f8a4218c5d5b3dbf8181b92f" title="Enable automatic periodic PING for connection keepalive.">SocketWS_enable_auto_ping()</a> for automatic keepalive </dd></dl>

</div>
</div>
<a id="gacbbea030dbe9d643b7f8bd6c1656ff06" name="gacbbea030dbe9d643b7f8bd6c1656ff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbbea030dbe9d643b7f8bd6c1656ff06">&#9670;&#160;</a></span>SocketWS_handshake()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_handshake </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform or continue the WebSocket handshake process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance in CONNECTING state.</td></tr>
  </table>
  </dd>
</dl>
<p>Client mode: Sends HTTP Upgrade request with Sec-WebSocket-Key and extensions, reads response, validates 101 status, Sec-WebSocket-Accept, subprotocols, extensions.</p>
<p>Server mode: Sends HTTP 101 response with computed Sec-WebSocket-Accept, negotiated parameters. Validates client key if not pre-validated.</p>
<p>Non-blocking compatible: returns 1 if more I/O needed (poll and call again). Blocks if socket is blocking.</p>
<p>On success, transitions to WS_STATE_OPEN.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on complete success (now OPEN), 1 if pending (call again after poll), -1 on error (check <a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>on invalid handshake response/request. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on I/O or allocation errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies instance state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0" title="Retrieve the current state of the WebSocket connection.">SocketWS_state()</a> to check current state post-call. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> for ongoing I/O after handshake. </dd>
<dd>
<a class="el" href="group__foundation.html#ga46f8d730d28e8c5cbd55e3cbe4c83945" title="Socket_geterrorcode - Convert last errno to normalized SocketErrorCode.">Socket_geterrorcode()</a> for underlying socket errors. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00092">request_handler()</a>.</p>

</div>
</div>
<a id="gabd34fccaadaee0c043bbb1368c3d0673" name="gabd34fccaadaee0c043bbb1368c3d0673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd34fccaadaee0c043bbb1368c3d0673">&#9670;&#160;</a></span>SocketWS_is_upgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_is_upgrade </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an HTTP request is a valid WebSocket upgrade request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Pointer to parsed <a class="el" href="group__http.html#structSocketHTTP__Request" title="Protocol-agnostic representation of an HTTP request message.">SocketHTTP_Request</a> from HTTP/1.1 parser.</td></tr>
  </table>
  </dd>
</dl>
<p>Validates presence of required headers: Upgrade: websocket, <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a>: Upgrade, Sec-WebSocket-Key, Sec-WebSocket-Version: 13. Optionally checks Sec-WebSocket-Protocol against configured subprotocols.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if valid WebSocket upgrade, 0 if not (missing/invalid headers). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, reads const request.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> to accept the upgrade. </dd>
<dd>
<a class="el" href="group__websocket.html#gad6e400c85623f8603c5965d38b1a60e0" title="Reject a WebSocket upgrade request with an HTTP error response.">SocketWS_server_reject()</a> to reject with error response. </dd>
<dd>
<a class="el" href="group__http.html#structSocketHTTP__Request" title="Protocol-agnostic representation of an HTTP request message.">SocketHTTP_Request</a> for HTTP request structure. </dd></dl>

</div>
</div>
<a id="ga89d42ff813f81187667d894e0da0fce0" name="ga89d42ff813f81187667d894e0da0fce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d42ff813f81187667d894e0da0fce0">&#9670;&#160;</a></span>SocketWS_last_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> SocketWS_last_error </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the most recent error code for this WebSocket instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Provides detailed error from last failed API call on this instance. Returns WS_OK (0) if no error pending. Errors persist until next operation or explicit clear (if any).</p>
<dl class="section return"><dt>Returns</dt><dd>SocketWS_Error code from last operation. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if errors not set concurrently.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga1bfa823bd6275bfdcb9bab6f26ab90ee" title="Get a human-readable string describing a WebSocket error code.">SocketWS_error_string()</a> for textual description. </dd>
<dd>
<a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f" title="WebSocket-specific error codes for SocketWS_last_error().">SocketWS_Error</a> enum for possible values. </dd>
<dd>
SocketWS_clear_error() if implemented for reset. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga2be521a2fe8aa5eb5d30869905371a71" name="ga2be521a2fe8aa5eb5d30869905371a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be521a2fe8aa5eb5d30869905371a71">&#9670;&#160;</a></span>SocketWS_ping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_ping </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a PING control frame for keepalive or to solicit immediate response from peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance in OPEN or CONNECTING state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Optional application-defined data payload (0-125 bytes, may be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data in bytes (must be &lt;=125).</td></tr>
  </table>
  </dd>
</dl>
<p>Triggers peer to send PONG with same payload if provided. Queues frame; call <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> to send. Used for keepalive or latency checks.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (queued for send), -1 on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if connection is closed. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on invalid parameters or internal error. </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>if len &gt; 125. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies send queue.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga3e17279abcb92810c8066f1813287334" title="Send a PONG control frame, typically in response to PING.">SocketWS_pong()</a> to send PONG. </dd>
<dd>
<a class="el" href="group__websocket.html#ga0049a0e0f8a4218c5d5b3dbf8181b92f" title="Enable automatic periodic PING for connection keepalive.">SocketWS_enable_auto_ping()</a> for automatic pings. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> to flush queued frames. </dd>
<dd>
RFC 6455 section 5.5.2 for PING frame details. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gac69518e9542ac69a4a6be77624219685" name="gac69518e9542ac69a4a6be77624219685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac69518e9542ac69a4a6be77624219685">&#9670;&#160;</a></span>SocketWS_poll_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SocketWS_poll_events </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine required poll events for the WebSocket socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns bitmask indicating needed events: always POLL_READ for incoming data/handshake/close. POLL_WRITE if send queue has data to flush. Use with <a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> to update registration dynamically.</p>
<dl class="section return"><dt>Returns</dt><dd>Event bitmask (POLL_READ | POLL_WRITE | 0). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - queue state may change.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga37704f6a0ea36147b25c96efd2981d9b" title="Get the underlying socket file descriptor for use with poll/epoll/kqueue.">SocketWS_pollfd()</a> for FD. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> to handle triggered events. </dd>
<dd>
<a class="el" href="group__event__system.html#ga9e8943c9cb47aba63dda4ad9083142b6" title="Event types for socket I/O monitoring.">SocketPoll_Events</a> for bit definitions. </dd></dl>

</div>
</div>
<a id="ga37704f6a0ea36147b25c96efd2981d9b" name="ga37704f6a0ea36147b25c96efd2981d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37704f6a0ea36147b25c96efd2981d9b">&#9670;&#160;</a></span>SocketWS_pollfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_pollfd </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underlying socket file descriptor for use with poll/epoll/kqueue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the FD of SocketWS_socket(ws) for registration in external event loops. Use with <a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> or native poll APIs. Do not close or modify the FD directly.</p>
<dl class="section return"><dt>Returns</dt><dd>Valid file descriptor (&gt;=0), or -1 if invalid/closed. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - simple FD read, but concurrent close possible.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga00e6f2953f92843874cd7b6c3e363288" title="Access the underlying TCP socket for the WebSocket.">SocketWS_socket()</a> for full Socket_T access. </dd>
<dd>
<a class="el" href="group__websocket.html#gac69518e9542ac69a4a6be77624219685" title="Determine required poll events for the WebSocket socket.">SocketWS_poll_events()</a> for required events. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System Modules</a> for event system integration. </dd>
<dd>
SocketPoll_T::add for example usage. </dd></dl>

</div>
</div>
<a id="ga3e17279abcb92810c8066f1813287334" name="ga3e17279abcb92810c8066f1813287334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e17279abcb92810c8066f1813287334">&#9670;&#160;</a></span>SocketWS_pong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_pong </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a PONG control frame, typically in response to PING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance in OPEN or CONNECTING state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Optional payload to echo back (0-125 bytes, may be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data in bytes (must be &lt;=125).</td></tr>
  </table>
  </dd>
</dl>
<p>Can be sent unsolicited, but usually auto-generated in response to PING. Queues frame for sending.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (queued), -1 on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if closed. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on invalid params or queue error. </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>if len &gt; 125. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies send queue.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga2be521a2fe8aa5eb5d30869905371a71" title="Send a PING control frame for keepalive or to solicit immediate response from peer.">SocketWS_ping()</a> for sending PING. </dd>
<dd>
RFC 6455 section 5.5.3 for PONG details. </dd></dl>

</div>
</div>
<a id="ga5c38be960976fd0d55b7328d1786ed9d" name="ga5c38be960976fd0d55b7328d1786ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c38be960976fd0d55b7328d1786ed9d">&#9670;&#160;</a></span>SocketWS_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_process </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process socket events to advance WebSocket state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Bitmask of occurred events from poller (POLL_READ, POLL_WRITE, POLL_ERROR, etc.).</td></tr>
  </table>
  </dd>
</dl>
<p>On POLL_READ: reads and parses incoming frames, handles controls, reassembles messages. On POLL_WRITE: flushes queued send data/frames. On POLL_ERROR/POLL_HANGUP: handles errors, may close connection. Advances handshake if applicable. Integrates with auto-ping timers if enabled.</p>
<p>Call repeatedly in event loop after poller signals readiness.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (updates last_error). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>on malformed frames. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on I/O failures. </td></tr>
    <tr><td class="paramname">SocketWS_Closed</td><td>on connection closure detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - performs I/O and state changes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga37704f6a0ea36147b25c96efd2981d9b" title="Get the underlying socket file descriptor for use with poll/epoll/kqueue.">SocketWS_pollfd()</a> and <a class="el" href="group__websocket.html#gac69518e9542ac69a4a6be77624219685" title="Determine required poll events for the WebSocket socket.">SocketWS_poll_events()</a> for event setup. </dd>
<dd>
<a class="el" href="group__websocket.html#ga134ea19e7c00142525cdf82b82425b6d" title="Check for complete messages ready to receive without blocking.">SocketWS_recv_available()</a> after process for new messages. </dd>
<dd>
<a class="el" href="group__poll__private.html#structSocketPoll__T" title="Opaque internal state structure for SocketPoll instance.">SocketPoll_T</a> for full event loop example. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga134ea19e7c00142525cdf82b82425b6d" name="ga134ea19e7c00142525cdf82b82425b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134ea19e7c00142525cdf82b82425b6d">&#9670;&#160;</a></span>SocketWS_recv_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_recv_available </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for complete messages ready to receive without blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Useful for non-blocking event loops: poll until &gt;0, then recv_message(). Returns count of fully reassembled messages in internal queue. Handles control frames internally but doesn't return them.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 number of messages available, -1 on error (check last_error). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if no concurrent recv/process.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga4614f5978e94a42cdb1191dbb6d38e85" title="Receive and reassemble a complete WebSocket message.">SocketWS_recv_message()</a> to consume messages. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> to advance parsing after poll events. </dd>
<dd>
<a class="el" href="group__websocket.html#ga89d42ff813f81187667d894e0da0fce0" title="Retrieve the most recent error code for this WebSocket instance.">SocketWS_last_error()</a> for error details. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>.</p>

</div>
</div>
<a id="gaa120f2de8a8e3fe8d6670d5952ae3069" name="gaa120f2de8a8e3fe8d6670d5952ae3069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa120f2de8a8e3fe8d6670d5952ae3069">&#9670;&#160;</a></span>SocketWS_recv_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> SocketWS_recv_json </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>json_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>json_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive and return JSON string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance in OPEN state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">json_out</td><td>Output: received JSON string (caller must free) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">json_len</td><td>Output: length of JSON string</td></tr>
  </table>
  </dd>
</dl>
<p>Receives a complete text message and returns it as a JSON string. Only accepts TEXT frames; returns error for BINARY.</p>
<dl class="section return"><dt>Returns</dt><dd>WS_OK on success, error code on failure</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if connection closes </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on receive error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md579"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *json = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span> len;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__websocket.html#gaa120f2de8a8e3fe8d6670d5952ae3069">SocketWS_recv_json</a>(ws, &amp;json, &amp;len) == <a class="code hl_enumvalue" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb">WS_OK</a>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Received: %s\n&quot;</span>, json);</div>
<div class="line">    <span class="comment">// Parse with your JSON library</span></div>
<div class="line">    free(json);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__websocket_html_gaa120f2de8a8e3fe8d6670d5952ae3069"><div class="ttname"><a href="group__websocket.html#gaa120f2de8a8e3fe8d6670d5952ae3069">SocketWS_recv_json</a></div><div class="ttdeci">SocketWS_Error SocketWS_recv_json(SocketWS_T ws, char **json_out, size_t *json_len)</div><div class="ttdoc">Receive and return JSON string.</div></div>
<div class="ttc" id="agroup__websocket_html_ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb"><div class="ttname"><a href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb">WS_OK</a></div><div class="ttdeci">@ WS_OK</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00276">SocketWS.h:276</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Caller must free(json_out) on success </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga4614f5978e94a42cdb1191dbb6d38e85" title="Receive and reassemble a complete WebSocket message.">SocketWS_recv_message()</a> for full message control </dd>
<dd>
<a class="el" href="group__websocket.html#gacbcbf4d1f7f94a24cbe57cfee8c5c705" title="Send JSON as text frame.">SocketWS_send_json()</a> for sending JSON </dd></dl>

</div>
</div>
<a id="ga4614f5978e94a42cdb1191dbb6d38e85" name="ga4614f5978e94a42cdb1191dbb6d38e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4614f5978e94a42cdb1191dbb6d38e85">&#9670;&#160;</a></span>SocketWS_recv_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_recv_message </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__Message">SocketWS_Message</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive and reassemble a complete WebSocket message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T in OPEN state. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">msg</td><td>[out] <a class="el" href="group__websocket.html#structSocketWS__Message" title="Complete reassembled WebSocket message from recv_message().">SocketWS_Message</a> to populate with received data.</td></tr>
  </table>
  </dd>
</dl>
<p>Handles control frames automatically (pings ponged, closes processed). Reassembles fragmented messages up to max_message_size. Validates UTF-8 for text messages if enabled. Decompresses if negotiated. Blocks until complete message or close/error. For non-blocking: use <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> + <a class="el" href="group__websocket.html#ga134ea19e7c00142525cdf82b82425b6d" title="Check for complete messages ready to receive without blocking.">SocketWS_recv_available()</a>.</p>
<p>Caller must free(msg-&gt;data) after use.</p>
<dl class="section return"><dt>Returns</dt><dd>1 on success (msg populated), 0 on clean close, -1 on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>on peer close. </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>on invalid frames. </td></tr>
    <tr><td class="paramname">SocketWS_Invalid_UTF8</td><td>on text validation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies recv state and msg.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#structSocketWS__Message" title="Complete reassembled WebSocket message from recv_message().">SocketWS_Message</a> for structure details. </dd>
<dd>
<a class="el" href="group__websocket.html#ga134ea19e7c00142525cdf82b82425b6d" title="Check for complete messages ready to receive without blocking.">SocketWS_recv_available()</a> for non-blocking check. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>.</p>

</div>
</div>
<a id="ga2a1ce264ad5e6d3cf25ce2442504aa20" name="ga2a1ce264ad5e6d3cf25ce2442504aa20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1ce264ad5e6d3cf25ce2442504aa20">&#9670;&#160;</a></span>SocketWS_selected_subprotocol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketWS_selected_subprotocol </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the negotiated WebSocket subprotocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance (must be post-handshake).</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the subprotocol selected from client's Sec-WebSocket-Protocol header matching one in server's config.subprotocols (server) or vice versa (client). NULL if none negotiated.</p>
<p>String is owned by WebSocket, valid until free or re-handshake.</p>
<dl class="section return"><dt>Returns</dt><dd>Const char* to subprotocol name, or NULL. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads internal state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#a2ff17028ab5d54be79108495bf1c4512">SocketWS_Config.subprotocols</a> for configuration. </dd>
<dd>
RFC 6455 section 1.9 for subprotocol negotiation. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga1a8aff35f7c69172e0c2f9c0ec53abcb" name="ga1a8aff35f7c69172e0c2f9c0ec53abcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8aff35f7c69172e0c2f9c0ec53abcb">&#9670;&#160;</a></span>SocketWS_send_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_send_binary </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a binary message over the WebSocket (opcode BINARY). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T in OPEN state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to arbitrary binary data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>No UTF-8 validation (binary). Applies masking/compression/fragmentation same as text. Queues for sending.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (queued), -1 on error. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if not open. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on queue or state issues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03" title="Send a text message over the WebSocket (opcode TEXT).">SocketWS_send_text()</a> for text (with UTF-8 validation). </dd>
<dd>
<a class="el" href="group__websocket.html#a622a5556ac8a0b6888819a40851a11fd">SocketWS_Config.max_frame_size</a> for fragmentation threshold. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>.</p>

</div>
</div>
<a id="gacbcbf4d1f7f94a24cbe57cfee8c5c705" name="gacbcbf4d1f7f94a24cbe57cfee8c5c705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbcbf4d1f7f94a24cbe57cfee8c5c705">&#9670;&#160;</a></span>SocketWS_send_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_send_json </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send JSON as text frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>WebSocket instance in OPEN state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">json</td><td>JSON string to send (must be valid UTF-8)</td></tr>
  </table>
  </dd>
</dl>
<p>Convenience wrapper around <a class="el" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03" title="Send a text message over the WebSocket (opcode TEXT).">SocketWS_send_text()</a> that sends JSON data. Validates UTF-8 if config.validate_utf8 is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if not open </td></tr>
    <tr><td class="paramname">SocketWS_Invalid_UTF8</td><td>if validation fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md578"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="stringliteral">&quot;{\&quot;type\&quot;: \&quot;ping\&quot;, \&quot;id\&quot;: 123}&quot;</span>;</div>
<div class="line"><a class="code hl_function" href="group__websocket.html#gacbcbf4d1f7f94a24cbe57cfee8c5c705">SocketWS_send_json</a>(ws, msg);</div>
<div class="ttc" id="agroup__websocket_html_gacbcbf4d1f7f94a24cbe57cfee8c5c705"><div class="ttname"><a href="group__websocket.html#gacbcbf4d1f7f94a24cbe57cfee8c5c705">SocketWS_send_json</a></div><div class="ttdeci">int SocketWS_send_json(SocketWS_T ws, const char *json)</div><div class="ttdoc">Send JSON as text frame.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga4b8450a05502aaa70e88cdf14a73fa03" title="Send a text message over the WebSocket (opcode TEXT).">SocketWS_send_text()</a> for raw text sending </dd>
<dd>
<a class="el" href="group__websocket.html#gaa120f2de8a8e3fe8d6670d5952ae3069" title="Receive and return JSON string.">SocketWS_recv_json()</a> for receiving JSON </dd></dl>

</div>
</div>
<a id="ga4b8450a05502aaa70e88cdf14a73fa03" name="ga4b8450a05502aaa70e88cdf14a73fa03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8450a05502aaa70e88cdf14a73fa03">&#9670;&#160;</a></span>SocketWS_send_text()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketWS_send_text </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a text message over the WebSocket (opcode TEXT). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T in OPEN state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to UTF-8 encoded text. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data in bytes (may include embedded NUL).</td></tr>
  </table>
  </dd>
</dl>
<p>Validates UTF-8 if config.validate_utf8 enabled (raises on invalid). Applies masking (client) or not (server). Compresses if enabled and negotiated. Fragments if exceeds max_frame_size, using continuation frames. Queues for sending; call <a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> or poll to flush.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success (queued), -1 on error (check last_error). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Closed</td><td>if not open. </td></tr>
    <tr><td class="paramname">SocketWS_Invalid_UTF8</td><td>if validation fails. </td></tr>
    <tr><td class="paramname">SocketWS_Failed</td><td>on queue full or other issues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies send buffer/state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga1a8aff35f7c69172e0c2f9c0ec53abcb" title="Send a binary message over the WebSocket (opcode BINARY).">SocketWS_send_binary()</a> for binary data. </dd>
<dd>
<a class="el" href="group__websocket.html#a1873fe17fa2f2d2d3c0d16cbfbcfc3f1">SocketWS_Config.validate_utf8</a> for control. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, and <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>.</p>

</div>
</div>
<a id="ga29e02ecca2d5a1b78d0eaf2c08883960" name="ga29e02ecca2d5a1b78d0eaf2c08883960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e02ecca2d5a1b78d0eaf2c08883960">&#9670;&#160;</a></span>SocketWS_server_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketWS_T SocketWS_server_accept </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__websocket.html#structSocketWS__Config">SocketWS_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept a WebSocket upgrade from a parsed HTTP request on a server socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Accepted TCP socket from <a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> (transferred ownership). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Parsed <a class="el" href="group__http.html#structSocketHTTP__Request" title="Protocol-agnostic representation of an HTTP request message.">SocketHTTP_Request</a> confirming WebSocket upgrade via <a class="el" href="group__websocket.html#gabd34fccaadaee0c043bbb1368c3d0673" title="Check if an HTTP request is a valid WebSocket upgrade request.">SocketWS_is_upgrade()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Optional <a class="el" href="group__websocket.html#structSocketWS__Config" title="Configuration parameters for WebSocket instances.">SocketWS_Config</a>; NULL uses defaults.</td></tr>
  </table>
  </dd>
</dl>
<p>Validates request, computes Sec-WebSocket-Accept key, prepares 101 Switching Protocols response with negotiated subprotocol and extensions. Instance starts in WS_STATE_CONNECTING. Call <a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> to send response and transition to OPEN.</p>
<dl class="section return"><dt>Returns</dt><dd>New SocketWS_T instance, or NULL on failure. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>on validation failure, allocation error, or invalid request. </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>if request headers invalid for WebSocket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent instance.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gabd34fccaadaee0c043bbb1368c3d0673" title="Check if an HTTP request is a valid WebSocket upgrade request.">SocketWS_is_upgrade()</a> to validate request first. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> to send the acceptance response. </dd>
<dd>
<a class="el" href="group__websocket.html#gad6e400c85623f8603c5965d38b1a60e0" title="Reject a WebSocket upgrade request with an HTTP error response.">SocketWS_server_reject()</a> for rejection cases. </dd>
<dd>
<a class="el" href="group__http.html#structSocketHTTP__Response" title="Protocol-agnostic representation of an HTTP response message.">SocketHTTP_Response</a> for response structure used internally. </dd></dl>

</div>
</div>
<a id="gad6e400c85623f8603c5965d38b1a60e0" name="gad6e400c85623f8603c5965d38b1a60e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6e400c85623f8603c5965d38b1a60e0">&#9670;&#160;</a></span>SocketWS_server_reject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketWS_server_reject </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reject a WebSocket upgrade request with an HTTP error response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>TCP socket from accepted connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status_code</td><td>HTTP status code (e.g., 400 Bad Request, 403 Forbidden). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>Optional human-readable reason phrase for the response body.</td></tr>
  </table>
  </dd>
</dl>
<p>Sends HTTP response with given status and reason in body (if provided). Closes the socket after sending. Use before <a class="el" href="group__websocket.html#ga29e02ecca2d5a1b78d0eaf2c08883960" title="Accept a WebSocket upgrade from a parsed HTTP request on a server socket.">SocketWS_server_accept()</a> if upgrade invalid.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>if send fails (e.g., socket closed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Conditional - socket must not be in use by other threads.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gabd34fccaadaee0c043bbb1368c3d0673" title="Check if an HTTP request is a valid WebSocket upgrade request.">SocketWS_is_upgrade()</a> to check validity before accepting/rejecting. </dd>
<dd>
<a class="el" href="group__http.html#structSocketHTTPServer" title="Internal implementation of the SocketHTTPServer opaque type.">SocketHTTPServer</a> for full HTTP server handling including upgrades. </dd></dl>

</div>
</div>
<a id="ga00e6f2953f92843874cd7b6c3e363288" name="ga00e6f2953f92843874cd7b6c3e363288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e6f2953f92843874cd7b6c3e363288">&#9670;&#160;</a></span>SocketWS_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketWS_socket </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying TCP socket for the WebSocket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows integration with external pollers or custom I/O handling. Do NOT close or modify the socket directly; use WebSocket APIs for lifecycle.</p>
<dl class="section return"><dt>Returns</dt><dd>Borrowed reference to Socket_T; valid until <a class="el" href="group__websocket.html#gaa040ebe5bc5f2673b04b15091a45b944" title="Dispose of a WebSocket instance, closing connection if open.">SocketWS_free()</a>. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - concurrent access may race with internal I/O.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga37704f6a0ea36147b25c96efd2981d9b" title="Get the underlying socket file descriptor for use with poll/epoll/kqueue.">SocketWS_pollfd()</a> for poll integration. </dd>
<dd>
<a class="el" href="group__websocket.html#ga5c38be960976fd0d55b7328d1786ed9d" title="Process socket events to advance WebSocket state machine.">SocketWS_process()</a> for processing events on this socket. </dd>
<dd>
Socket_T for socket operations (use cautiously). </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="gaa40def588d31ab50126603fa720f83b0" name="gaa40def588d31ab50126603fa720f83b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40def588d31ab50126603fa720f83b0">&#9670;&#160;</a></span>SocketWS_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d">SocketWS_State</a> SocketWS_state </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current state of the WebSocket connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>SocketWS_T instance.</td></tr>
  </table>
  </dd>
</dl>
<p>Possible states: WS_STATE_CONNECTING (handshake), WS_STATE_OPEN (ready), WS_STATE_CLOSING (closing handshake), WS_STATE_CLOSED (terminated).</p>
<dl class="section return"><dt>Returns</dt><dd>SocketWS_State enum value. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read of state variable.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gab8b49607a661224d66bb264b1e597e2d" title="WebSocket connection lifecycle states.">SocketWS_State</a> enum for state details. </dd>
<dd>
<a class="el" href="group__websocket.html#gacbbea030dbe9d643b7f8bd6c1656ff06" title="Perform or continue the WebSocket handshake process.">SocketWS_handshake()</a> which transitions from CONNECTING to OPEN. </dd>
<dd>
<a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> which initiates CLOSING. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>, <a class="el" href="websocket__server_8c_source.html#l00233">process_websocket_clients()</a>, and <a class="el" href="websocket__server_8c_source.html#l00092">request_handler()</a>.</p>

</div>
</div>
<a id="ga64371d8325fa07e7e369fb21deed42f8" name="ga64371d8325fa07e7e369fb21deed42f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64371d8325fa07e7e369fb21deed42f8">&#9670;&#160;</a></span>ws_auto_ping_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_auto_ping_callback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer callback invoked to send periodic PING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>The WebSocket context (cast from void*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sends PING with empty payload or config payload. </dd>
<dd>
Sets awaiting_pong and timeout check. </dd>
<dd>
Reschedules next timer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gafb51f69cdbf1b882a7a4226959c4fca7" title="Type for timer expiration callback functions.">SocketTimerCallback</a> typedef. </dd>
<dd>
<a class="el" href="group__websocket.html#ga99c6c5ca0bace14d46703343595a785b" title="Sends a WebSocket PING control frame for keepalive.">ws_send_ping()</a> for sending. </dd></dl>

</div>
</div>
<a id="ga894fa2a0c6b617c386a9c3a462d5782c" name="ga894fa2a0c6b617c386a9c3a462d5782c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga894fa2a0c6b617c386a9c3a462d5782c">&#9670;&#160;</a></span>ws_auto_ping_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_auto_ping_start </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the automatic PING timer for keepalive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context with config.ping_interval_ms. </td></tr>
    <tr><td class="paramname">poll</td><td>The SocketPoll instance for timer integration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (timer add fail). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Schedules first ping after interval_ms from now. </dd>
<dd>
Uses SocketTimer_add_repeating for periodic pings. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga64371d8325fa07e7e369fb21deed42f8" title="Timer callback invoked to send periodic PING.">ws_auto_ping_callback()</a> timer handler. </dd>
<dd>
<a class="el" href="group__event__system.html#structSocketTimer__T" title="Internal representation of a single scheduled timer event.">SocketTimer_T</a> for timer management. </dd></dl>

</div>
</div>
<a id="ga8b50ea33ceb9a7b2b23a060c88dafe65" name="ga8b50ea33ceb9a7b2b23a060c88dafe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b50ea33ceb9a7b2b23a060c88dafe65">&#9670;&#160;</a></span>ws_auto_ping_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_auto_ping_stop </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the automatic PING timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cancels the repeating timer using SocketTimer_cancel. </dd>
<dd>
Called on close or disable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga894fa2a0c6b617c386a9c3a462d5782c" title="Starts the automatic PING timer for keepalive.">ws_auto_ping_start()</a> to start. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6f7ca05c6cfc7c69ddc3d676a681bc62" title="Cancel a pending timer (lazy deletion).">SocketTimer_cancel()</a> underlying call. </dd></dl>

</div>
</div>
<a id="ga61d40db3bbab58f4459e01c6bc2c1271" name="ga61d40db3bbab58f4459e01c6bc2c1271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d40db3bbab58f4459e01c6bc2c1271">&#9670;&#160;</a></span>ws_copy_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ws_copy_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arena-allocated duplicate of input string. </p>
<h1><a class="anchor" id="memory_helpers"></a>
Internal Memory Helpers</h1>
<p>Utility functions for arena-based string duplication. All allocations use provided Arena_T for lifecycle management.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Arena_8h.html" title="Arena-based memory allocator for efficient bulk memory management.">Arena.h</a> for memory allocation framework. </dd></dl>
<p>Provides safe string duplication using the library's arena allocator. Handles NULL input gracefully. Used internally for handshake headers, subprotocols, and other string handling. Preserves null-termination.</p>
<p>Edge cases:</p><ul>
<li>NULL str returns NULL without error.</li>
<li>Empty string "" allocates single null byte.</li>
<li>Allocation failure raises Arena_Failed exception.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Memory arena for allocation (must be valid). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Input C string to duplicate (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to arena-allocated copy of str, or NULL if str is NULL. Caller should not free(); managed by arena lifecycle.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Arena_Failed</td><td>If <a class="el" href="group__foundation.html#gad93b1dd7d771cbed846dcc3c5c836917" title="Allocate raw memory block from the specified arena.">Arena_alloc()</a> fails due to insufficient space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic if arena is thread-local or externally locked.</dt><dd>Concurrent calls safe if arena mutexed.</dd></dl>
<p>Basic Usage</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a>();</div>
<div class="line"><span class="keywordtype">char</span> *dup = <a class="code hl_function" href="group__websocket.html#ga61d40db3bbab58f4459e01c6bc2c1271">ws_copy_string</a>(arena, <span class="stringliteral">&quot;ws://example.com/path&quot;</span>);</div>
<div class="line">assert(strcmp(dup, <span class="stringliteral">&quot;ws://example.com/path&quot;</span>) == 0);</div>
<div class="line"><span class="comment">// dup valid until Arena_clear/dispose</span></div>
<div class="line"><a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;arena);</div>
<div class="ttc" id="agroup__foundation_html_ga6842e66018614df08139e67826cf3e0d"><div class="ttname"><a href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a></div><div class="ttdeci">void Arena_dispose(Arena_T *ap)</div><div class="ttdoc">Dispose of an arena and all its allocations, freeing underlying memory chunks.</div></div>
<div class="ttc" id="agroup__foundation_html_ga6a6d6890eb6ed1248ae1a5f0c677c7a4"><div class="ttname"><a href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a></div><div class="ttdeci">Arena_T Arena_new(void)</div><div class="ttdoc">Create a new memory arena with initial capacity and thread-safe protection.</div></div>
<div class="ttc" id="agroup__foundation_html_gac1ed22b9df4eff7a3398cac608c090cc"><div class="ttname"><a href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></div><div class="ttdeci">struct Arena_T * Arena_T</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00080">Arena.h:80</a></div></div>
<div class="ttc" id="agroup__websocket_html_ga61d40db3bbab58f4459e01c6bc2c1271"><div class="ttname"><a href="group__websocket.html#ga61d40db3bbab58f4459e01c6bc2c1271">ws_copy_string</a></div><div class="ttdeci">char * ws_copy_string(Arena_T arena, const char *str)</div><div class="ttdoc">Arena-allocated duplicate of input string.</div></div>
</div><!-- fragment --><p>With Exception Handling</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *header_value;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    header_value = <a class="code hl_function" href="group__websocket.html#ga61d40db3bbab58f4459e01c6bc2c1271">ws_copy_string</a>(arena, http_header);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__foundation.html#ga6053a34c90a976ac971313bd5f201fb3">Arena_Failed</a>) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Failed to duplicate header: %s&quot;</span>, http_header);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga6053a34c90a976ac971313bd5f201fb3"><div class="ttname"><a href="group__foundation.html#ga6053a34c90a976ac971313bd5f201fb3">Arena_Failed</a></div><div class="ttdeci">const Except_T Arena_Failed</div><div class="ttdoc">Exception raised when arena allocation fails.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Equivalent to socket_util_arena_strdup(arena, str) but internal. </dd>
<dd>
Does not perform UTF-8 validation; assumes valid C string. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Arena must outlive all allocated strings.</dd></dl>
<dl class="section user"><dt>Complexity\n O(n) time where n = strlen(str); single allocation.</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(n) space for duplicated string.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#ga1af76425187cb52fda8d569dcc931e2d" title="Duplicate string into arena.">socket_util_arena_strdup()</a> Public equivalent in <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utilities</a>. </dd>
<dd>
<a class="el" href="group__foundation.html#gad93b1dd7d771cbed846dcc3c5c836917" title="Allocate raw memory block from the specified arena.">Arena_alloc()</a> Underlying allocation mechanism. </dd>
<dd>
<a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> For freeing allocated strings. </dd></dl>

</div>
</div>
<a id="ga434b1ea5d42a6c1be49a4f9e054453a0" name="ga434b1ea5d42a6c1be49a4f9e054453a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga434b1ea5d42a6c1be49a4f9e054453a0">&#9670;&#160;</a></span>ws_fill_recv_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ws_fill_recv_buffer </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the receive buffer from the underlying socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes received (&gt;0), 0 on EOF or would block, -1 on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> or TLS recv. </dd>
<dd>
Fills until buffer full or block/EOF. </dd>
<dd>
Handles partial reads for non-blocking. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> recv_buf. </dd>
<dd>
<a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> low-level recv. </dd></dl>

</div>
</div>
<a id="ga472e8d20997877be54c73a9250f1f4ee" name="ga472e8d20997877be54c73a9250f1f4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga472e8d20997877be54c73a9250f1f4ee">&#9670;&#160;</a></span>ws_flush_send_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ws_flush_send_buffer </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes pending data from send buffer to underlying socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent (&gt;0), 0 if would block (EAGAIN), -1 on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> or TLS send if enabled. </dd>
<dd>
Continues until buffer empty or block. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer management. </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> low-level send. </dd></dl>

</div>
</div>
<a id="gad0cb16d7a760ff6ea58750797c85ee15" name="gad0cb16d7a760ff6ea58750797c85ee15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0cb16d7a760ff6ea58750797c85ee15">&#9670;&#160;</a></span>ws_frame_build_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ws_frame_build_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>masked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>mask_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>payload_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the binary WebSocket frame header into output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Output buffer for header bytes (must hold at least SOCKETWS_MAX_HEADER_SIZE). </td></tr>
    <tr><td class="paramname">fin</td><td>Non-zero if final fragment (sets FIN bit). </td></tr>
    <tr><td class="paramname">opcode</td><td>The frame opcode. </td></tr>
    <tr><td class="paramname">masked</td><td>Non-zero if payload is masked (client frames). </td></tr>
    <tr><td class="paramname">mask_key</td><td>4-byte mask key if masked, ignored otherwise. </td></tr>
    <tr><td class="paramname">payload_len</td><td>The payload length (encodes as 7/16/64-bit). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to header (2-14), or 0 on error (invalid params). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Validates opcode and length; does not include payload or mask application. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga6113393ea2f0b3b64b3e4a48299f899b" title="Applies XOR masking to WebSocket payload data in place.">ws_mask_payload()</a> to mask payload after header. </dd>
<dd>
RFC 6455 Section 5.2 for header encoding details. </dd></dl>

</div>
</div>
<a id="ga8ec0a78346a127f0919e6b9e61e79ecf" name="ga8ec0a78346a127f0919e6b9e61e79ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec0a78346a127f0919e6b9e61e79ecf">&#9670;&#160;</a></span>ws_frame_parse_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> ws_frame_parse_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>consumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incrementally parses WebSocket frame header from input data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">frame</td><td>The frame parse state structure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Buffer containing incoming frame bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of data buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">consumed</td><td>Number of bytes consumed from data (updated on call). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SocketWS_Error: WS_OK if header fully parsed, WS_NEED_MORE_DATA if incomplete, or error code (e.g., WS_PROTOCOL_ERROR for invalid header). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Advances frame-&gt;state based on bytes parsed. </dd>
<dd>
Handles variable header length (2-14 bytes). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f" title="Reset frame parser to initial state for new incoming frame.">ws_frame_reset()</a> before first call. </dd>
<dd>
RFC 6455 Section 5.2 for frame header format. </dd></dl>

</div>
</div>
<a id="gae2e70a359f4a97f9eb37d3805c776e4f" name="gae2e70a359f4a97f9eb37d3805c776e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e70a359f4a97f9eb37d3805c776e4f">&#9670;&#160;</a></span>ws_frame_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_frame_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset frame parser to initial state for new incoming frame. </p>
<p>Prepares <a class="el" href="group__websocket.html#structSocketWS__FrameParse" title="Context for parsing incoming WebSocket frames.">SocketWS_FrameParse</a> for parsing a new WebSocket frame header. Clears accumulated header bytes, resets state to HEADER, zeros parsed fields (fin, rsv, opcode, masked, mask_key, payload_len, payload_received), resets header_len and header_needed. Essential for incremental parsing in loops.</p>
<p>Usage pattern: Call after successful frame parse or to recover from partial/error. Does not allocate/deallocate; safe to call frequently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">frame</td><td>Pointer to frame parse structure (fields reset)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - self-contained, no shared state if frame local</dt><dd></dd></dl>
<p>Initialization and Reset</p>
<div class="fragment"><div class="line"><span class="comment">// Initial setup</span></div>
<div class="line"><a class="code hl_struct" href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a> frame;</div>
<div class="line">memset(&amp;frame, 0, <span class="keyword">sizeof</span>(frame));  <span class="comment">// Or use ws_frame_reset(&amp;frame);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In receive loop</span></div>
<div class="line"><span class="keywordtype">size_t</span> consumed;</div>
<div class="line"><a class="code hl_enumeration" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a> err = <a class="code hl_function" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf">ws_frame_parse_header</a>(&amp;frame, recv_data, recv_len,</div>
<div class="line">&amp;consumed); <span class="keywordflow">if</span> (err == <a class="code hl_enumvalue" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fa8d6c24a81bab48a188c7f458bf6ecddb">WS_OK</a>) {</div>
<div class="line">    <span class="comment">// Header parsed, now read payload</span></div>
<div class="line">    <span class="comment">// ... process payload ...</span></div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f">ws_frame_reset</a>(&amp;frame);  <span class="comment">// Ready for next</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err == WS_PROTOCOL_ERROR) {</div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f">ws_frame_reset</a>(&amp;frame);  <span class="comment">// Recover</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__websocket_html_ga8ec0a78346a127f0919e6b9e61e79ecf"><div class="ttname"><a href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf">ws_frame_parse_header</a></div><div class="ttdeci">SocketWS_Error ws_frame_parse_header(SocketWS_FrameParse *frame, const unsigned char *data, size_t len, size_t *consumed)</div><div class="ttdoc">Incrementally parses WebSocket frame header from input data.</div></div>
<div class="ttc" id="agroup__websocket_html_gabd79199a60ad91cf785166f24f41101f"><div class="ttname"><a href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a></div><div class="ttdeci">SocketWS_Error</div><div class="ttdoc">WebSocket-specific error codes for SocketWS_last_error().</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00274">SocketWS.h:275</a></div></div>
<div class="ttc" id="agroup__websocket_html_gae2e70a359f4a97f9eb37d3805c776e4f"><div class="ttname"><a href="group__websocket.html#gae2e70a359f4a97f9eb37d3805c776e4f">ws_frame_reset</a></div><div class="ttdeci">void ws_frame_reset(SocketWS_FrameParse *frame)</div><div class="ttdoc">Reset frame parser to initial state for new incoming frame.</div></div>
<div class="ttc" id="agroup__websocket_html_structSocketWS__FrameParse"><div class="ttname"><a href="group__websocket.html#structSocketWS__FrameParse">SocketWS_FrameParse</a></div><div class="ttdoc">Context for parsing incoming WebSocket frames.</div><div class="ttdef"><b>Definition</b> <a href="SocketWS-private_8h_source.html#l00314">SocketWS-private.h:315</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Can be used interchangeably with memset(&amp;frame, 0, sizeof(frame)) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure frame struct is properly aligned for header_buf </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - fixed field assignments and memset if used</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga8ec0a78346a127f0919e6b9e61e79ecf" title="Incrementally parses WebSocket frame header from input data.">ws_frame_parse_header()</a> Next step after reset </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__FrameParse" title="Context for parsing incoming WebSocket frames.">SocketWS_FrameParse</a> Full structure documentation </dd>
<dd>
<a class="el" href="group__websocket.html#gac56e5c15d95b50879444eaa9509a77cc" title="Resets the message reassembly state for a new message.">ws_message_reset()</a> Analogous for message reassembly </dd></dl>

</div>
</div>
<a id="ga0130824d7127448b8b21b3477f65da72" name="ga0130824d7127448b8b21b3477f65da72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0130824d7127448b8b21b3477f65da72">&#9670;&#160;</a></span>ws_handle_control_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handle_control_frame </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a received WebSocket control frame (CLOSE, PING, PONG). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">opcode</td><td>The control opcode received. </td></tr>
    <tr><td class="paramname">payload</td><td>The unmasked payload data. </td></tr>
    <tr><td class="paramname">len</td><td>The payload length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (e.g., invalid close code). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For PING: sends PONG response, clears timeout. </dd>
<dd>
For CLOSE: sets close_received, may initiate response. </dd>
<dd>
For PONG: updates last_pong_received_time. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga7edd214f1189fb37ce58c28a47771151" title="Sends a WebSocket PONG control frame in response to PING.">ws_send_pong()</a> for PING response. </dd>
<dd>
<a class="el" href="group__websocket.html#gaace05878bd32167161fae6250c01d97f" title="Sends a WebSocket CLOSE control frame to initiate graceful shutdown.">ws_send_close()</a> for CLOSE response. </dd>
<dd>
RFC 6455 Section 5.5 for control frame processing. </dd></dl>

</div>
</div>
<a id="gae1986f23bb035bce3c7e5bbf5c741512" name="gae1986f23bb035bce3c7e5bbf5c741512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1986f23bb035bce3c7e5bbf5c741512">&#9670;&#160;</a></span>ws_handshake_client_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handshake_client_init </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the client-side WebSocket handshake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (sets last_error). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Generates random Sec-WebSocket-Key and constructs HTTP GET upgrade request. </dd>
<dd>
Sets handshake.state to WS_HANDSHAKE_SENDING_REQUEST. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gacbed5c235e2175a894cf83f64d8c9859" title="Processes client handshake I/O in non-blocking manner.">ws_handshake_client_process()</a> to send request and read response. </dd>
<dd>
SocketCrypto for key generation. </dd>
<dd>
RFC 6455 Section 4.1 for client handshake. </dd></dl>

</div>
</div>
<a id="gacbed5c235e2175a894cf83f64d8c9859" name="gacbed5c235e2175a894cf83f64d8c9859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbed5c235e2175a894cf83f64d8c9859">&#9670;&#160;</a></span>ws_handshake_client_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handshake_client_process </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes client handshake I/O in non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if handshake complete (state=COMPLETE), 1 if in progress (need more I/O), -1 on error (sets last_error, state=FAILED). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles sending request and receiving response incrementally. </dd>
<dd>
Validates Sec-WebSocket-Accept header. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gae1986f23bb035bce3c7e5bbf5c741512" title="Initializes the client-side WebSocket handshake.">ws_handshake_client_init()</a> to start. </dd>
<dd>
<a class="el" href="group__websocket.html#gaef559ed5e6042e33c40db0e7c56844ce" title="Validates the server&#39;s Sec-WebSocket-Accept header value.">ws_handshake_validate_accept()</a> for validation. </dd>
<dd>
RFC 6455 Section 1.3 for opening handshake. </dd></dl>

</div>
</div>
<a id="ga169d28fa02ed8486e26122116361cdcd" name="ga169d28fa02ed8486e26122116361cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169d28fa02ed8486e26122116361cdcd">&#9670;&#160;</a></span>ws_handshake_server_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handshake_server_init </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__http.html#structSocketHTTP__Request">SocketHTTP_Request</a> *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the server-side WebSocket handshake from HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">request</td><td>The parsed <a class="el" href="group__http.html#structSocketHTTP__Request" title="Protocol-agnostic representation of an HTTP request message.">SocketHTTP_Request</a> from client upgrade. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (invalid request, sets last_error). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Validates required headers (Upgrade, <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a>, Sec-WebSocket-Key). </dd>
<dd>
Computes Sec-WebSocket-Accept from client key. </dd>
<dd>
Negotiates subprotocols and extensions (e.g., permessage-deflate). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__http1__private.html#structSocketHTTP1__Parser" title="Internal implementation structure for the HTTP/1.1 parser (SocketHTTP1_Parser_T).">SocketHTTP1_Parser</a> for request parsing. </dd>
<dd>
<a class="el" href="group__websocket.html#gadb1dba4490ebb1e999c4755073516058" title="Processes server handshake I/O in non-blocking manner.">ws_handshake_server_process()</a> to send response. </dd>
<dd>
RFC 6455 Section 4.2.2 for server validation. </dd></dl>

</div>
</div>
<a id="gadb1dba4490ebb1e999c4755073516058" name="gadb1dba4490ebb1e999c4755073516058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb1dba4490ebb1e999c4755073516058">&#9670;&#160;</a></span>ws_handshake_server_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handshake_server_process </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes server handshake I/O in non-blocking manner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if handshake complete, 1 if in progress, -1 on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sends 101 response after validation. </dd>
<dd>
Transitions to frame mode on success. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga169d28fa02ed8486e26122116361cdcd" title="Initializes the server-side WebSocket handshake from HTTP request.">ws_handshake_server_init()</a> prerequisite. </dd>
<dd>
RFC 6455 Section 4.1 for server opening handshake. </dd></dl>

</div>
</div>
<a id="gaef559ed5e6042e33c40db0e7c56844ce" name="gaef559ed5e6042e33c40db0e7c56844ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef559ed5e6042e33c40db0e7c56844ce">&#9670;&#160;</a></span>ws_handshake_validate_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_handshake_validate_accept </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>accept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the server's Sec-WebSocket-Accept header value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context (contains expected_accept). </td></tr>
    <tr><td class="paramname">accept</td><td>The received accept string from server response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if matches expected value, -1 if mismatch or invalid. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Computes expected as SHA1(key + magic) base64. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketCrypto_websocket_accept_compute() for computation. </dd>
<dd>
RFC 6455 Section 4.2.2 for accept key derivation. </dd></dl>

</div>
</div>
<a id="gaf415773c31b2c3cd0c3b2635c22dd567" name="gaf415773c31b2c3cd0c3b2635c22dd567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf415773c31b2c3cd0c3b2635c22dd567">&#9670;&#160;</a></span>ws_is_control_opcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ws_is_control_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if opcode represents a control frame. </p>
<p>Control frames: CLOSE (8), PING (9), PONG (A) - high bit set. Data frames: CONT (0), TEXT (1), BINARY (2) - low bits.</p>
<p>Used for special handling: immediate processing, no fragmentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>Frame opcode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if control frame, 0 otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gafc98c465269b350fadb1880315c719ce" title="Check if opcode represents a data frame.">ws_is_data_opcode()</a> for data frames. </dd>
<dd>
RFC 6455 Section 5.2 for opcode ranges. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l01402">1402</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="gafc98c465269b350fadb1880315c719ce" name="gafc98c465269b350fadb1880315c719ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc98c465269b350fadb1880315c719ce">&#9670;&#160;</a></span>ws_is_data_opcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ws_is_data_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if opcode represents a data frame. </p>
<p>Data frames: CONTINUATION (0), TEXT (1), BINARY (2). Can be fragmented (multiple frames per message).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>Frame opcode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if data frame (text/binary/cont), 0 otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaf415773c31b2c3cd0c3b2635c22dd567" title="Check if opcode represents a control frame.">ws_is_control_opcode()</a> for control frames. </dd>
<dd>
RFC 6455 Section 5.2 for data opcodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l01421">1421</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketWS_8h_source.html#l00176">WS_OPCODE_BINARY</a>, and <a class="el" href="SocketWS_8h_source.html#l00175">WS_OPCODE_TEXT</a>.</p>

</div>
</div>
<a id="gaa294a0ac7ea37e1701081a48f47da419" name="gaa294a0ac7ea37e1701081a48f47da419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa294a0ac7ea37e1701081a48f47da419">&#9670;&#160;</a></span>ws_is_valid_close_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ws_is_valid_close_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate close status code per RFC 6455. </p>
<p>Valid codes: 1000-1014 (excluding 1004-1006 sometimes internal), or 3000-4999 (library-specific). Invalid: &lt;1000, 1004-1006 (internal), 1015 (TLS, internal), others.</p>
<p>Used in CLOSE frame processing/sending to ensure compliance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Close code from frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if valid for transmission, 0 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some codes (1001-1014) valid only on close, not status. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>RFC 6455 Section 7.4.1 for defined codes and ranges. </dd>
<dd>
<a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13" title="Status codes for WebSocket CLOSE frames (RFC 6455 section 7.4).">SocketWS_CloseCode</a> enum for common codes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l01461">1461</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

</div>
</div>
<a id="ga29ac157fe7e464e93ae43cc2adb7450b" name="ga29ac157fe7e464e93ae43cc2adb7450b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ac157fe7e464e93ae43cc2adb7450b">&#9670;&#160;</a></span>ws_is_valid_opcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ws_is_valid_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a WebSocket opcode is valid per RFC 6455. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>The opcode to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if valid (0-2 data, 8-A control), 0 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Data: 0 CONT, 1 TEXT, 2 BINARY; Control: 8 CLOSE, 9 PING, A PONG. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaf415773c31b2c3cd0c3b2635c22dd567" title="Check if opcode represents a control frame.">ws_is_control_opcode()</a>, <a class="el" href="group__websocket.html#gafc98c465269b350fadb1880315c719ce" title="Check if opcode represents a data frame.">ws_is_data_opcode()</a>. </dd>
<dd>
RFC 6455 Section 5.2 Table 1 for opcodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketWS-private_8h_source.html#l01437">1437</a> of file <a class="el" href="SocketWS-private_8h_source.html">SocketWS-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketWS_8h_source.html#l00176">WS_OPCODE_BINARY</a>, <a class="el" href="SocketWS_8h_source.html#l00177">WS_OPCODE_CLOSE</a>, and <a class="el" href="SocketWS_8h_source.html#l00179">WS_OPCODE_PONG</a>.</p>

</div>
</div>
<a id="ga6113393ea2f0b3b64b3e4a48299f899b" name="ga6113393ea2f0b3b64b3e4a48299f899b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6113393ea2f0b3b64b3e4a48299f899b">&#9670;&#160;</a></span>ws_mask_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_mask_payload </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>mask</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies XOR masking to WebSocket payload data in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The payload buffer to mask (modified in place). </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to mask. </td></tr>
    <tr><td class="paramname">mask</td><td>The 4-byte masking key (cycles every 4 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Required for client-to-server frames per RFC. </dd>
<dd>
Optimized with 64-bit aligned loops for performance. </dd>
<dd>
Server frames must not be masked. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga90f8bce3f762e01c75870b2dbb49d63d" title="Applies XOR masking to payload starting from a given mask offset.">ws_mask_payload_offset()</a> for incremental masking. </dd>
<dd>
RFC 6455 Section 5.3 for masking algorithm. </dd></dl>

</div>
</div>
<a id="ga90f8bce3f762e01c75870b2dbb49d63d" name="ga90f8bce3f762e01c75870b2dbb49d63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90f8bce3f762e01c75870b2dbb49d63d">&#9670;&#160;</a></span>ws_mask_payload_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ws_mask_payload_offset </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>mask</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies XOR masking to payload starting from a given mask offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The payload buffer to mask (modified in place). </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to mask. </td></tr>
    <tr><td class="paramname">mask</td><td>The 4-byte masking key. </td></tr>
    <tr><td class="paramname">offset</td><td>Initial offset into the mask cycle (0-3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated offset for the next chunk ((offset + len) % 4). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used for incremental masking in streaming scenarios. </dd>
<dd>
Equivalent to <a class="el" href="group__websocket.html#ga6113393ea2f0b3b64b3e4a48299f899b" title="Applies XOR masking to WebSocket payload data in place.">ws_mask_payload()</a> when offset=0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga6113393ea2f0b3b64b3e4a48299f899b" title="Applies XOR masking to WebSocket payload data in place.">ws_mask_payload()</a> for full payload masking. </dd>
<dd>
RFC 6455 Section 5.3 masking details. </dd></dl>

</div>
</div>
<a id="ga02d493e3ec3a1da7c2b038813e0b109f" name="ga02d493e3ec3a1da7c2b038813e0b109f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02d493e3ec3a1da7c2b038813e0b109f">&#9670;&#160;</a></span>ws_message_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_message_append </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a data frame fragment to the current message assembly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">data</td><td>The fragment payload (unmasked). </td></tr>
    <tr><td class="paramname">len</td><td>Length of fragment. </td></tr>
    <tr><td class="paramname">is_text</td><td>Non-zero if text message (enables UTF-8 validation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (exceeds max size/fragments, UTF-8 invalid). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates message.len and fragment_count; checks limits. </dd>
<dd>
Decompresses if RSV1 set on first fragment. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gad66f78da53262b5c3047bb39ad410a32" title="Finalizes message assembly on last fragment and delivers to user.">ws_message_finalize()</a> called on FIN=1. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__MessageAssembly" title="State for reassembling fragmented WebSocket messages.">SocketWS_MessageAssembly</a> for state. </dd>
<dd>
RFC 6455 Section 5.4 for message fragmentation. </dd></dl>

</div>
</div>
<a id="gad66f78da53262b5c3047bb39ad410a32" name="gad66f78da53262b5c3047bb39ad410a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad66f78da53262b5c3047bb39ad410a32">&#9670;&#160;</a></span>ws_message_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_message_finalize </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes message assembly on last fragment and delivers to user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (UTF-8 invalid for text, or other). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called when FIN=1 on data frame. </dd>
<dd>
Performs final UTF-8 validation for text messages. </dd>
<dd>
Invokes user callback with complete <a class="el" href="group__websocket.html#structSocketWS__Message" title="Complete reassembled WebSocket message from recv_message().">SocketWS_Message</a>. </dd>
<dd>
Resets assembly state for next message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketWS_MessageCallback for delivery. </dd>
<dd>
<a class="el" href="group__utilities.html#structSocketUTF8__State" title="State structure for incremental UTF-8 validation.">SocketUTF8_State</a> for validation. </dd></dl>

</div>
</div>
<a id="gac56e5c15d95b50879444eaa9509a77cc" name="gac56e5c15d95b50879444eaa9509a77cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac56e5c15d95b50879444eaa9509a77cc">&#9670;&#160;</a></span>ws_message_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_message_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__websocket.html#structSocketWS__MessageAssembly">SocketWS_MessageAssembly</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the message reassembly state for a new message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message assembly structure to reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Clears data buffer, length, fragments, UTF-8 state. </dd>
<dd>
Called before first fragment of new message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga02d493e3ec3a1da7c2b038813e0b109f" title="Appends a data frame fragment to the current message assembly.">ws_message_append()</a> to start assembly. </dd>
<dd>
<a class="el" href="group__websocket.html#structSocketWS__MessageAssembly" title="State for reassembling fragmented WebSocket messages.">SocketWS_MessageAssembly</a> for fields. </dd></dl>

</div>
</div>
<a id="gaace05878bd32167161fae6250c01d97f" name="gaace05878bd32167161fae6250c01d97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace05878bd32167161fae6250c01d97f">&#9670;&#160;</a></span>ws_send_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_send_close </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga386c437e966aeaeb091d1d81c0e77b13">SocketWS_CloseCode</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a WebSocket CLOSE control frame to initiate graceful shutdown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">code</td><td>The close status code (valid per RFC or 0 for no code). </td></tr>
    <tr><td class="paramname">reason</td><td>Optional UTF-8 reason string (truncated to max length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (sets last_error). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Validates code with <a class="el" href="group__websocket.html#gaa294a0ac7ea37e1701081a48f47da419" title="Validate close status code per RFC 6455.">ws_is_valid_close_code()</a>. </dd>
<dd>
Sets close_sent flag; peer should respond with CLOSE. </dd>
<dd>
After mutual CLOSE, connection enters CLOSING state. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> public API wrapper. </dd>
<dd>
RFC 6455 Section 7.1 for close handshake. </dd></dl>

</div>
</div>
<a id="gae9a311879f7320da8320ad3498a99e34" name="gae9a311879f7320da8320ad3498a99e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a311879f7320da8320ad3498a99e34">&#9670;&#160;</a></span>ws_send_control_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_send_control_frame </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends WebSocket control frame: PING, PONG, or CLOSE. </p>
<p>Constructs and transmits a control frame over the WebSocket connection. Control frames are processed immediately, cannot be fragmented, and have payload limit of 125 bytes. Used for keepalive (PING/PONG) and graceful closure (CLOSE). Automatically flushes to socket if possible; otherwise queues.</p>
<p>Behavior:</p><ul>
<li>Builds frame header with opcode, no RSV (unless extensions), masked if client.</li>
<li>Validates len &lt;= 125, opcode control type.</li>
<li>Applies masking to payload if client role.</li>
<li>Appends to send_buf, calls <a class="el" href="group__websocket.html#ga472e8d20997877be54c73a9250f1f4ee" title="Flushes pending data from send buffer to underlying socket.">ws_flush_send_buffer()</a>.</li>
</ul>
<p>Error conditions:</p><ul>
<li>Invalid opcode (not 8/9/A): SocketWS_Failed</li>
<li>len &gt; SOCKETWS_MAX_CONTROL_PAYLOAD: truncates or fails</li>
<li>Socket send error or closed: sets last_error, returns -1</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ws</td><td>Active WebSocket context (state must be OPEN) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>Control opcode: WS_OPCODE_CLOSE (8), WS_OPCODE_PING (9), WS_OPCODE_PONG (10) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payload</td><td>Payload bytes; NULL=empty. For CLOSE: code(2B)+reason(UTF8); PING/PONG: app data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Exact payload length (0-125 bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Success: frame built and queued/flushed </dd>
<dd>
-1 Failure: error code in ws-&gt;last_error, msg in error_buf</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>Invalid params, build error, or I/O failure </td></tr>
    <tr><td class="paramname">SocketWS_Closed</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> not in OPEN state </td></tr>
    <tr><td class="paramname">SocketWS_ProtocolError</td><td>Invalid control opcode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies ws-&gt;send_buf and socket state; serialize calls</dt><dd></dd></dl>
<p>Sending PING for Keepalive</p>
<div class="fragment"><div class="line"><span class="comment">// Simple ping to check peer responsiveness</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ping_data[] = {<span class="charliteral">&#39;H&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;o&#39;</span>};</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34">ws_send_control_frame</a>(ws, <a class="code hl_enumvalue" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539">WS_OPCODE_PING</a>, ping_data, <span class="keyword">sizeof</span>(ping_data))</div>
<div class="line">!= 0) { <a class="code hl_enumvalue" href="group__foundation.html#ggadf209a9f107e88a5df277fcc3e2641d1a541aa883db8e38a0c52a2d7ccfb795b3">SOCKET_LOG_ERROR</a>(<span class="stringliteral">&quot;PING failed: %s&quot;</span>, SocketWS_get_error_msg(ws));</div>
<div class="line">    <span class="comment">// Consider closing connection</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__foundation_html_ggadf209a9f107e88a5df277fcc3e2641d1a541aa883db8e38a0c52a2d7ccfb795b3"><div class="ttname"><a href="group__foundation.html#ggadf209a9f107e88a5df277fcc3e2641d1a541aa883db8e38a0c52a2d7ccfb795b3">SOCKET_LOG_ERROR</a></div><div class="ttdeci">@ SOCKET_LOG_ERROR</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00056">SocketUtil.h:56</a></div></div>
<div class="ttc" id="agroup__websocket_html_gae9a311879f7320da8320ad3498a99e34"><div class="ttname"><a href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34">ws_send_control_frame</a></div><div class="ttdeci">int ws_send_control_frame(SocketWS_T ws, SocketWS_Opcode opcode, const unsigned char *payload, size_t len)</div><div class="ttdoc">Sends WebSocket control frame: PING, PONG, or CLOSE.</div></div>
<div class="ttc" id="agroup__websocket_html_gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539"><div class="ttname"><a href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539">WS_OPCODE_PING</a></div><div class="ttdeci">@ WS_OPCODE_PING</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00178">SocketWS.h:178</a></div></div>
</div><!-- fragment --><p>Initiating Graceful Close</p>
<div class="fragment"><div class="line"><span class="comment">// Send CLOSE with normal code 1000</span></div>
<div class="line">uint16_t code = htons(1000); <span class="comment">// Big-endian</span></div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34">ws_send_control_frame</a>(ws, <a class="code hl_enumvalue" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5">WS_OPCODE_CLOSE</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)&amp;code, 2);</div>
<div class="line">    ws-&gt;state = WS_CLOSING;  <span class="comment">// Update state</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__websocket.html#ga0fb92a65a798e17aca6df1cdba118067">SocketWS_Failed</a>) {</div>
<div class="line">    <span class="comment">// Fallback to hard close</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga559b1aaebbe5d0ca69ec99e15b1c7e68">Socket_shutdown</a>(ws-&gt;socket, SHUT_RDWR);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_ga559b1aaebbe5d0ca69ec99e15b1c7e68"><div class="ttname"><a href="group__core__io.html#ga559b1aaebbe5d0ca69ec99e15b1c7e68">Socket_shutdown</a></div><div class="ttdeci">void Socket_shutdown(Socket_T socket, int how)</div><div class="ttdoc">Disable further sends and/or receives.</div></div>
<div class="ttc" id="agroup__websocket_html_gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5"><div class="ttname"><a href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba847b054f16b331a8a701b7e76255d8e5">WS_OPCODE_CLOSE</a></div><div class="ttdeci">@ WS_OPCODE_CLOSE</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00177">SocketWS.h:177</a></div></div>
</div><!-- fragment --><p>Responding to PING</p>
<div class="fragment"><div class="line"><span class="comment">// In frame handler: echo payload back as PONG</span></div>
<div class="line"><span class="keywordflow">if</span> (opcode == <a class="code hl_enumvalue" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba2e1dad19209b2641fcb2d12025651539">WS_OPCODE_PING</a>) {</div>
<div class="line">    <a class="code hl_function" href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34">ws_send_control_frame</a>(ws, <a class="code hl_enumvalue" href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c">WS_OPCODE_PONG</a>, received_payload,</div>
<div class="line">received_len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__websocket_html_gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c"><div class="ttname"><a href="group__websocket.html#gga174740343c7f920060f8640f23600c7ba809eaa105785fd07440fa833f602469c">WS_OPCODE_PONG</a></div><div class="ttdeci">@ WS_OPCODE_PONG</div><div class="ttdef"><b>Definition</b> <a href="SocketWS_8h_source.html#l00180">SocketWS.h:179</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Payload for CLOSE: first 2 bytes uint16 BE status code, rest UTF-8 reason (total &lt;=125) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Use only valid close codes; see <a class="el" href="group__websocket.html#gaa294a0ac7ea37e1701081a48f47da419" title="Validate close status code per RFC 6455.">ws_is_valid_close_code()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If ws-&gt;config.close_auto_respond enabled, CLOSE triggers peer response </dd></dl>
<dl class="section user"><dt>Complexity\n O(1 + len) - constant time header + linear payload mask/copy</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga9e85c4df84bca9d7182a1196c4e0c723" title="Sends a WebSocket data frame (TEXT or BINARY).">ws_send_data_frame()</a> For fragmented data messages </dd>
<dd>
<a class="el" href="group__websocket.html#ga0130824d7127448b8b21b3477f65da72" title="Handles a received WebSocket control frame (CLOSE, PING, PONG).">ws_handle_control_frame()</a> Incoming control processing </dd>
<dd>
<a class="el" href="group__websocket.html#gaace05878bd32167161fae6250c01d97f" title="Sends a WebSocket CLOSE control frame to initiate graceful shutdown.">ws_send_close()</a> Higher-level CLOSE sender </dd>
<dd>
<a class="el" href="group__websocket.html#ga472e8d20997877be54c73a9250f1f4ee" title="Flushes pending data from send buffer to underlying socket.">ws_flush_send_buffer()</a> Underlying flush mechanism </dd>
<dd>
RFC 6455 Sec. 5.5 (Control Frames), 7.1 (Close), 5.5.2 (Ping), 5.5.3 (Pong) </dd></dl>

</div>
</div>
<a id="ga9e85c4df84bca9d7182a1196c4e0c723" name="ga9e85c4df84bca9d7182a1196c4e0c723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e85c4df84bca9d7182a1196c4e0c723">&#9670;&#160;</a></span>ws_send_data_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_send_data_frame </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#ga174740343c7f920060f8640f23600c7b">SocketWS_Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a WebSocket data frame (TEXT or BINARY). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket connection context. </td></tr>
    <tr><td class="paramname">opcode</td><td>The data frame opcode (WS_OPCODE_TEXT or WS_OPCODE_BINARY). </td></tr>
    <tr><td class="paramname">data</td><td>The payload data to send. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the payload data. </td></tr>
    <tr><td class="paramname">fin</td><td>Non-zero if this is the final fragment of the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (sets last_error). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketWS_Failed</td><td>if send fails, invalid opcode, or exceeds limits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Supports fragmentation (fin=0 for continuation frames). </dd>
<dd>
Payload masked for client role, unmasked for server. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gae9a311879f7320da8320ad3498a99e34" title="Sends WebSocket control frame: PING, PONG, or CLOSE.">ws_send_control_frame()</a> for control frames. </dd>
<dd>
RFC 6455 Section 5.6 for data frame format and masking. </dd></dl>

</div>
</div>
<a id="ga99c6c5ca0bace14d46703343595a785b" name="ga99c6c5ca0bace14d46703343595a785b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c6c5ca0bace14d46703343595a785b">&#9670;&#160;</a></span>ws_send_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_send_ping </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a WebSocket PING control frame for keepalive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">payload</td><td>Optional application data in ping (NULL for empty). </td></tr>
    <tr><td class="paramname">len</td><td>Length of payload (0 to 125 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Peer must respond with PONG containing same payload. </dd>
<dd>
Used for heartbeat; auto-triggered by timer if configured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga7edd214f1189fb37ce58c28a47771151" title="Sends a WebSocket PONG control frame in response to PING.">ws_send_pong()</a> for response. </dd>
<dd>
<a class="el" href="group__websocket.html#ga894fa2a0c6b617c386a9c3a462d5782c" title="Starts the automatic PING timer for keepalive.">ws_auto_ping_start()</a> for automatic pings. </dd>
<dd>
RFC 6455 Section 5.5.2 for PING/PONG. </dd></dl>

</div>
</div>
<a id="ga7edd214f1189fb37ce58c28a47771151" name="ga7edd214f1189fb37ce58c28a47771151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7edd214f1189fb37ce58c28a47771151">&#9670;&#160;</a></span>ws_send_pong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ws_send_pong </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a WebSocket PONG control frame in response to PING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">payload</td><td>The payload to echo from received PING (or arbitrary). </td></tr>
    <tr><td class="paramname">len</td><td>Length of payload (0-125). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Typically called automatically on PING receipt. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ga0130824d7127448b8b21b3477f65da72" title="Handles a received WebSocket control frame (CLOSE, PING, PONG).">ws_handle_control_frame()</a> for automatic response. </dd>
<dd>
<a class="el" href="group__websocket.html#ga99c6c5ca0bace14d46703343595a785b" title="Sends a WebSocket PING control frame for keepalive.">ws_send_ping()</a> for initiating ping. </dd>
<dd>
RFC 6455 Section 5.5.3 for PONG semantics. </dd></dl>

</div>
</div>
<a id="gab26b26aa679375629c245be95eaaf222" name="gab26b26aa679375629c245be95eaaf222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26b26aa679375629c245be95eaaf222">&#9670;&#160;</a></span>ws_set_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ws_set_error </td>
          <td>(</td>
          <td class="paramtype">SocketWS_T&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f">SocketWS_Error</a>&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the last error code and formats error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>The WebSocket context. </td></tr>
    <tr><td class="paramname">error</td><td>The SocketWS_Error code to set. </td></tr>
    <tr><td class="paramname">fmt</td><td>printf-style format string for error_buf. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments for format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Truncates message to SOCKETWS_ERROR_BUFSIZE. </dd>
<dd>
Used internally for all error paths. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketWS_get_last_error() public accessor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga51caf3b6f8086dc6535fd843593dcbde" name="ga51caf3b6f8086dc6535fd843593dcbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51caf3b6f8086dc6535fd843593dcbde">&#9670;&#160;</a></span>SocketWS_Closed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketWS_Closed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception indicating the WebSocket connection has been closed. </p>
<p>Raised when attempting operations on a CLOSED connection or after clean close.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gaa40def588d31ab50126603fa720f83b0" title="Retrieve the current state of the WebSocket connection.">SocketWS_state()</a> == <a class="el" href="group__websocket.html#ggab8b49607a661224d66bb264b1e597e2da4356293e46722d1fa27ca8624f62b296">WS_STATE_CLOSED</a>. </dd>
<dd>
<a class="el" href="group__websocket.html#gaf04efc033266e882f59db340ca2f8d47" title="Initiate graceful WebSocket close handshake.">SocketWS_close()</a> to initiate close. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga0fb92a65a798e17aca6df1cdba118067" name="ga0fb92a65a798e17aca6df1cdba118067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb92a65a798e17aca6df1cdba118067">&#9670;&#160;</a></span>SocketWS_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketWS_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception raised for general WebSocket operation failures. </p>
<p>Thrown on allocation failures, invalid states, or unrecoverable errors.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#gabd79199a60ad91cf785166f24f41101f" title="WebSocket-specific error codes for SocketWS_last_error().">SocketWS_Error</a> for specific error codes. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
<a id="ga8400199bb1b785111015ff06d16de370" name="ga8400199bb1b785111015ff06d16de370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8400199bb1b785111015ff06d16de370">&#9670;&#160;</a></span>SocketWS_ProtocolError</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketWS_ProtocolError</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception for WebSocket protocol violations (RFC 6455 non-compliance). </p>
<p>Raised on invalid opcodes, malformed frames, missing masks (server), etc.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__websocket.html#ggabd79199a60ad91cf785166f24f41101fac3b45ed8d1cffbe97ae99ad9368edfec">WS_ERROR_PROTOCOL</a> for related non-exception errors. </dd></dl>

<p class="reference">Referenced by <a class="el" href="websocket__client_8c_source.html#l00041">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Custom footer for Tetsuo Pulse -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="footer" style="text-align: center; width: 100%;">
       <a href="https://tetsuocorp.com" target="_blank" rel="noopener">Tetsuo Corp</a>
    </li>
  </ul>
</div>
</body>
</html>
