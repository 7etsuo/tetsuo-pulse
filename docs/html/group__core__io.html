<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tetsuo Pulse: Core I/O Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="socket-brand.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Tetsuo Pulse<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance networking from Tetsuo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__core__io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Core I/O Modules</div></div>
</div><!--header-->
<div class="contents">

<p>Fundamental socket primitives for TCP, UDP, Unix domain, and DNS operations.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Core I/O Modules:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__core__io.svg" width="518" height="299"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__dns" id="r_group__dns"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dns.html">Asynchronous DNS Resolution</a></td></tr>
<tr class="memdesc:group__dns"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool-based DNS resolution with guaranteed timeouts and SocketPoll integration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__socket__live__utils" id="r_group__socket__live__utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket__live__utils.html">Live Socket Counting Utilities</a></td></tr>
<tr class="memdesc:group__socket__live__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe global counter for tracking active Socket_T instances. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__socket__tls__utils" id="r_group__socket__tls__utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__socket__tls__utils.html">Internal TLS Field Utilities</a></td></tr>
<tr class="memdesc:group__socket__tls__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for initializing and managing TLS state in Socket_T. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__proxy__private" id="r_group__proxy__private"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proxy__private.html">SocketProxy Private Implementation Details</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__proxy" id="r_group__proxy"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proxy.html">Proxy Tunneling Module</a></td></tr>
<tr class="memdesc:group__proxy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent TCP proxy support with sync/async APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:Socket-private_8h" id="r_Socket-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket-private_8h.html">Socket-private.h</a></td></tr>
<tr class="memdesc:Socket-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private implementation details for Socket module: internal structure and shared utilities. Internal use only - included by Socket_*.c implementation files. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Socket_8h" id="r_Socket_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html">Socket.h</a></td></tr>
<tr class="memdesc:Socket_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level TCP/IP and Unix domain socket interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketBuf_8h" id="r_SocketBuf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketBuf_8h.html">SocketBuf.h</a></td></tr>
<tr class="memdesc:SocketBuf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer for efficient socket I/O operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketCommon-private_8h" id="r_SocketCommon-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketCommon-private_8h.html">SocketCommon-private.h</a></td></tr>
<tr class="memdesc:SocketCommon-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private declarations for SocketCommon module providing shared socket infrastructure. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketCommon_8h" id="r_SocketCommon_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketCommon_8h.html">SocketCommon.h</a></td></tr>
<tr class="memdesc:SocketCommon_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common utilities shared between Socket and SocketDgram modules. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketDgram-private_8h" id="r_SocketDgram-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketDgram-private_8h.html">SocketDgram-private.h</a></td></tr>
<tr class="memdesc:SocketDgram-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation details for datagram (UDP) socket structure. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketIO_8h" id="r_SocketIO_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketIO_8h.html">SocketIO.h</a></td></tr>
<tr class="memdesc:SocketIO_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal I/O abstraction layer for socket operations with TLS support. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketProxy-private_8h" id="r_SocketProxy-private_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketProxy-private_8h.html">SocketProxy-private.h</a></td></tr>
<tr class="memdesc:SocketProxy-private_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal structures and functions for SocketProxy module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SocketProxy_8h" id="r_SocketProxy_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SocketProxy_8h.html">SocketProxy.h</a></td></tr>
<tr class="memdesc:SocketProxy_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy tunneling module for HTTP CONNECT and SOCKS protocols. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structSocketStats__T" id="r_structSocketStats__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#structSocketStats__T">SocketStats_T</a></td></tr>
<tr class="memdesc:structSocketStats__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-socket I/O statistics structure.  <a href="group__core__io.html#structSocketStats__T">More...</a><br /></td></tr>
<tr class="separator:structSocketStats__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketTCPInfo" id="r_structSocketTCPInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#structSocketTCPInfo">SocketTCPInfo</a></td></tr>
<tr class="memdesc:structSocketTCPInfo"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP connection information structure (Linux-specific).  <a href="group__core__io.html#structSocketTCPInfo">More...</a><br /></td></tr>
<tr class="separator:structSocketTCPInfo"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketBase__T" id="r_structSocketBase__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a></td></tr>
<tr class="memdesc:structSocketBase__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation of <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> opaque type.  <a href="group__core__io.html#structSocketBase__T">More...</a><br /></td></tr>
<tr class="separator:structSocketBase__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketLiveCount" id="r_structSocketLiveCount"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a></td></tr>
<tr class="memdesc:structSocketLiveCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe live count tracker for socket instances.  <a href="group__core__io.html#structSocketLiveCount">More...</a><br /></td></tr>
<tr class="separator:structSocketLiveCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketProxy__Conn__T" id="r_structSocketProxy__Conn__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a></td></tr>
<tr class="memdesc:structSocketProxy__Conn__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque proxy connection context for managing tunneling negotiation.  <a href="group__proxy__private.html#structSocketProxy__Conn__T">More...</a><br /></td></tr>
<tr class="separator:structSocketProxy__Conn__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structSocketProxy__Config" id="r_structSocketProxy__Config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a></td></tr>
<tr class="memdesc:structSocketProxy__Config"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for proxy connections.  <a href="group__proxy.html#structSocketProxy__Config">More...</a><br /></td></tr>
<tr class="separator:structSocketProxy__Config"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7b0cb8d09882f145ebd41ad5a5932a30" id="r_ga7b0cb8d09882f145ebd41ad5a5932a30"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7b0cb8d09882f145ebd41ad5a5932a30">UDP_MAX_PAYLOAD</a></td></tr>
<tr class="memdesc:ga7b0cb8d09882f145ebd41ad5a5932a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum UDP payload size excluding headers.  <br /></td></tr>
<tr class="separator:ga7b0cb8d09882f145ebd41ad5a5932a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6c789e54c4efbc66d4a9cbc947734f" id="r_ga7f6c789e54c4efbc66d4a9cbc947734f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7f6c789e54c4efbc66d4a9cbc947734f">SAFE_UDP_SIZE</a>&#160;&#160;&#160;1472UL /* Safe for Ethernet MTU (1500 - IP/UDP ~28) */</td></tr>
<tr class="memdesc:ga7f6c789e54c4efbc66d4a9cbc947734f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe UDP payload size for Ethernet MTU.  <br /></td></tr>
<tr class="separator:ga7f6c789e54c4efbc66d4a9cbc947734f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86c34b79f0c5546c8b538edcd9372e1" id="r_gaf86c34b79f0c5546c8b538edcd9372e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf86c34b79f0c5546c8b538edcd9372e1">SOCKET_SENDFILE_FALLBACK_BUFFER_SIZE</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:gaf86c34b79f0c5546c8b538edcd9372e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback buffer size for sendfile operations.  <br /></td></tr>
<tr class="separator:gaf86c34b79f0c5546c8b538edcd9372e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19b3a142a302a366a345ce7272763a6" id="r_gad19b3a142a302a366a345ce7272763a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad19b3a142a302a366a345ce7272763a6">SOCKET_MAX_TTL</a>&#160;&#160;&#160;255 /* Standard IP TTL max */</td></tr>
<tr class="memdesc:gad19b3a142a302a366a345ce7272763a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum IP TTL (Time To Live) value.  <br /></td></tr>
<tr class="separator:gad19b3a142a302a366a345ce7272763a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddf48aa583cfb80ca7caa6efd4f7143" id="r_gacddf48aa583cfb80ca7caa6efd4f7143"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacddf48aa583cfb80ca7caa6efd4f7143">SOCKET_IPV6_MAX_PREFIX</a>&#160;&#160;&#160;128 /* IPv6 address bits */</td></tr>
<tr class="memdesc:gacddf48aa583cfb80ca7caa6efd4f7143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum IPv6 prefix length in bits.  <br /></td></tr>
<tr class="separator:gacddf48aa583cfb80ca7caa6efd4f7143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fcedac2973fd36f2ed55cc2f2c13d2" id="r_ga08fcedac2973fd36f2ed55cc2f2c13d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga08fcedac2973fd36f2ed55cc2f2c13d2">SOCKET_IPV4_MAX_PREFIX</a>&#160;&#160;&#160;32 /* IPv4 address bits */</td></tr>
<tr class="memdesc:ga08fcedac2973fd36f2ed55cc2f2c13d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum IPv4 prefix length in bits.  <br /></td></tr>
<tr class="separator:ga08fcedac2973fd36f2ed55cc2f2c13d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3af7fc5447a76f5f64430362d6dfcf" id="r_ga5d3af7fc5447a76f5f64430362d6dfcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5d3af7fc5447a76f5f64430362d6dfcf">SOCKET_MAX_PORT</a>&#160;&#160;&#160;65535 /* Standard TCP/UDP port max */</td></tr>
<tr class="memdesc:ga5d3af7fc5447a76f5f64430362d6dfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum TCP/UDP port number.  <br /></td></tr>
<tr class="separator:ga5d3af7fc5447a76f5f64430362d6dfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb10bfccfe83fb0bb5873949cf8a2f7" id="r_ga2fb10bfccfe83fb0bb5873949cf8a2f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2fb10bfccfe83fb0bb5873949cf8a2f7">SOCKET_MAX_LISTEN_BACKLOG</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga2fb10bfccfe83fb0bb5873949cf8a2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum backlog for listen() system call.  <br /></td></tr>
<tr class="separator:ga2fb10bfccfe83fb0bb5873949cf8a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b64483d1dd5d32bba7937741c36cabf" id="r_ga9b64483d1dd5d32bba7937741c36cabf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga9b64483d1dd5d32bba7937741c36cabf">SOCKET_MAX_FDS_PER_MSG</a>&#160;&#160;&#160;253 /* SCM_MAX_FD on most POSIX systems */</td></tr>
<tr class="memdesc:ga9b64483d1dd5d32bba7937741c36cabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum file descriptors per SCM_RIGHTS message.  <br /></td></tr>
<tr class="separator:ga9b64483d1dd5d32bba7937741c36cabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0563923535025dbd7c98a992dbf8df2" id="r_gab0563923535025dbd7c98a992dbf8df2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab0563923535025dbd7c98a992dbf8df2">SOCKETBUF_MIN_CAPACITY</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:gab0563923535025dbd7c98a992dbf8df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum capacity for circular buffers.  <br /></td></tr>
<tr class="separator:gab0563923535025dbd7c98a992dbf8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2209ca43107de5bec46f534bc7830e04" id="r_ga2209ca43107de5bec46f534bc7830e04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2209ca43107de5bec46f534bc7830e04">SOCKETBUF_INITIAL_CAPACITY</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga2209ca43107de5bec46f534bc7830e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial capacity when buffer reserve grows from zero.  <br /></td></tr>
<tr class="separator:ga2209ca43107de5bec46f534bc7830e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb43699cef4e69257db533e71c8265a" id="r_ga3fb43699cef4e69257db533e71c8265a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3fb43699cef4e69257db533e71c8265a">SOCKETBUF_ALLOC_OVERHEAD</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga3fb43699cef4e69257db533e71c8265a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation overhead for arena bookkeeping during buffer resize.  <br /></td></tr>
<tr class="separator:ga3fb43699cef4e69257db533e71c8265a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7333dd84db01bccd272a0a535cb69ffa" id="r_ga7333dd84db01bccd272a0a535cb69ffa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7333dd84db01bccd272a0a535cb69ffa">SOCKET_DNS_THREAD_COUNT</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga7333dd84db01bccd272a0a535cb69ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of DNS worker threads.  <br /></td></tr>
<tr class="separator:ga7333dd84db01bccd272a0a535cb69ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6640a153bf74038b7a011808d6bf78" id="r_gafe6640a153bf74038b7a011808d6bf78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafe6640a153bf74038b7a011808d6bf78">SOCKET_DNS_MAX_PENDING</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:gafe6640a153bf74038b7a011808d6bf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum pending DNS requests.  <br /></td></tr>
<tr class="separator:gafe6640a153bf74038b7a011808d6bf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d107f9984dd45f9ba4b1618ad373ad" id="r_gab9d107f9984dd45f9ba4b1618ad373ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab9d107f9984dd45f9ba4b1618ad373ad">SOCKET_DNS_MAX_LABEL_LENGTH</a>&#160;&#160;&#160;63</td></tr>
<tr class="memdesc:gab9d107f9984dd45f9ba4b1618ad373ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum DNS label length.  <br /></td></tr>
<tr class="separator:gab9d107f9984dd45f9ba4b1618ad373ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e7a628ce9483f24b2f86ef0e985639" id="r_ga30e7a628ce9483f24b2f86ef0e985639"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga30e7a628ce9483f24b2f86ef0e985639">SOCKET_DNS_WORKER_STACK_SIZE</a>&#160;&#160;&#160;(128 * 1024)</td></tr>
<tr class="memdesc:ga30e7a628ce9483f24b2f86ef0e985639"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS worker thread stack size.  <br /></td></tr>
<tr class="separator:ga30e7a628ce9483f24b2f86ef0e985639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93bb14bccd4fd5d8f37a22b30a4c944" id="r_gad93bb14bccd4fd5d8f37a22b30a4c944"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad93bb14bccd4fd5d8f37a22b30a4c944">SOCKET_DNS_REQUEST_HASH_SIZE</a>&#160;&#160;&#160;1021</td></tr>
<tr class="memdesc:gad93bb14bccd4fd5d8f37a22b30a4c944"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS request hash table size.  <br /></td></tr>
<tr class="separator:gad93bb14bccd4fd5d8f37a22b30a4c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf88e7e79136014eb538ec90cf2a0f4" id="r_gaabf88e7e79136014eb538ec90cf2a0f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaabf88e7e79136014eb538ec90cf2a0f4">SOCKET_DNS_PIPE_BUFFER_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gaabf88e7e79136014eb538ec90cf2a0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion pipe read buffer size.  <br /></td></tr>
<tr class="separator:gaabf88e7e79136014eb538ec90cf2a0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38939e0f4010e9cc311360b1d974d068" id="r_ga38939e0f4010e9cc311360b1d974d068"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga38939e0f4010e9cc311360b1d974d068">SOCKET_DNS_COMPLETION_SIGNAL_BYTE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga38939e0f4010e9cc311360b1d974d068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion signal byte value for DNS pipe signaling.  <br /></td></tr>
<tr class="separator:ga38939e0f4010e9cc311360b1d974d068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd2e41af45c32418159edb2bfa3d4b8" id="r_ga8dd2e41af45c32418159edb2bfa3d4b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8dd2e41af45c32418159edb2bfa3d4b8">SOCKET_DNS_PORT_STR_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga8dd2e41af45c32418159edb2bfa3d4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port number string buffer size.  <br /></td></tr>
<tr class="separator:ga8dd2e41af45c32418159edb2bfa3d4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19af4d3535b2bb856fa673bdaa45983" id="r_gae19af4d3535b2bb856fa673bdaa45983"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae19af4d3535b2bb856fa673bdaa45983">SOCKET_DNS_THREAD_NAME_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gae19af4d3535b2bb856fa673bdaa45983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread name buffer size.  <br /></td></tr>
<tr class="separator:gae19af4d3535b2bb856fa673bdaa45983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718d350473539fc8a704e3afa05bb694" id="r_ga718d350473539fc8a704e3afa05bb694"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga718d350473539fc8a704e3afa05bb694">SOCKET_DNS_DEFAULT_CACHE_TTL_SECONDS</a>&#160;&#160;&#160;300</td></tr>
<tr class="memdesc:ga718d350473539fc8a704e3afa05bb694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default DNS cache TTL in seconds.  <br /></td></tr>
<tr class="separator:ga718d350473539fc8a704e3afa05bb694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176cef29fe829568359c936376db272e" id="r_ga176cef29fe829568359c936376db272e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga176cef29fe829568359c936376db272e">SOCKET_DNS_DEFAULT_CACHE_MAX_ENTRIES</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:ga176cef29fe829568359c936376db272e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum DNS cache entries.  <br /></td></tr>
<tr class="separator:ga176cef29fe829568359c936376db272e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40398fc3798e6302da2f39fcc3b9c64" id="r_gaa40398fc3798e6302da2f39fcc3b9c64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa40398fc3798e6302da2f39fcc3b9c64">SOCKET_DNS_CACHE_HASH_SIZE</a>&#160;&#160;&#160;1021</td></tr>
<tr class="memdesc:gaa40398fc3798e6302da2f39fcc3b9c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS cache hash table size.  <br /></td></tr>
<tr class="separator:gaa40398fc3798e6302da2f39fcc3b9c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1b69dbf142e7aaa4b329f0e0f34dee" id="r_ga3d1b69dbf142e7aaa4b329f0e0f34dee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3d1b69dbf142e7aaa4b329f0e0f34dee">SOCKET_HAS_SENDMSG</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga3d1b69dbf142e7aaa4b329f0e0f34dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">sendmsg() support flag.  <br /></td></tr>
<tr class="separator:ga3d1b69dbf142e7aaa4b329f0e0f34dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4cba449b689c0e2069c5592d65ff70" id="r_ga1b4cba449b689c0e2069c5592d65ff70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1b4cba449b689c0e2069c5592d65ff70">SOCKET_HAS_RECVMSG</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga1b4cba449b689c0e2069c5592d65ff70"><td class="mdescLeft">&#160;</td><td class="mdescRight">recvmsg() support flag.  <br /></td></tr>
<tr class="separator:ga1b4cba449b689c0e2069c5592d65ff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01d46f482abd08d6fb51a115b3590c4" id="r_gac01d46f482abd08d6fb51a115b3590c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac01d46f482abd08d6fb51a115b3590c4">SOCKET_DEFAULT_DNS_TIMEOUT_MS</a>&#160;&#160;&#160;5000 /* 5 seconds */</td></tr>
<tr class="memdesc:gac01d46f482abd08d6fb51a115b3590c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default DNS resolution timeout.  <br /></td></tr>
<tr class="separator:gac01d46f482abd08d6fb51a115b3590c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91c5e89e959589a4c72b572da87aed1" id="r_gae91c5e89e959589a4c72b572da87aed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae91c5e89e959589a4c72b572da87aed1">SOCKET_STREAM_TYPE</a>&#160;&#160;&#160;SOCK_STREAM</td></tr>
<tr class="memdesc:gae91c5e89e959589a4c72b572da87aed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP stream socket type.  <br /></td></tr>
<tr class="separator:gae91c5e89e959589a4c72b572da87aed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb19a3aa101d92d9befe7a980238bf0d" id="r_gaeb19a3aa101d92d9befe7a980238bf0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaeb19a3aa101d92d9befe7a980238bf0d">SOCKET_DGRAM_TYPE</a>&#160;&#160;&#160;SOCK_DGRAM</td></tr>
<tr class="memdesc:gaeb19a3aa101d92d9befe7a980238bf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP datagram socket type.  <br /></td></tr>
<tr class="separator:gaeb19a3aa101d92d9befe7a980238bf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723007dbfa6e622f70650dce72fe4949" id="r_ga723007dbfa6e622f70650dce72fe4949"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga723007dbfa6e622f70650dce72fe4949">SOCKET_AF_UNSPEC</a>&#160;&#160;&#160;AF_UNSPEC</td></tr>
<tr class="memdesc:ga723007dbfa6e622f70650dce72fe4949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unspecified address family.  <br /></td></tr>
<tr class="separator:ga723007dbfa6e622f70650dce72fe4949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ce265041d74932e7d3354651fd0a79" id="r_ga04ce265041d74932e7d3354651fd0a79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga04ce265041d74932e7d3354651fd0a79">SOCKET_AF_INET</a>&#160;&#160;&#160;AF_INET</td></tr>
<tr class="memdesc:ga04ce265041d74932e7d3354651fd0a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv4 address family.  <br /></td></tr>
<tr class="separator:ga04ce265041d74932e7d3354651fd0a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a754a1f4470597ea52da2a678378100" id="r_ga7a754a1f4470597ea52da2a678378100"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7a754a1f4470597ea52da2a678378100">SOCKET_AF_INET6</a>&#160;&#160;&#160;AF_INET6</td></tr>
<tr class="memdesc:ga7a754a1f4470597ea52da2a678378100"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 address family.  <br /></td></tr>
<tr class="separator:ga7a754a1f4470597ea52da2a678378100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26b9f671650b58e0bd264a71ec3cbfa" id="r_gaf26b9f671650b58e0bd264a71ec3cbfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf26b9f671650b58e0bd264a71ec3cbfa">SOCKET_AF_UNIX</a>&#160;&#160;&#160;AF_UNIX</td></tr>
<tr class="memdesc:gaf26b9f671650b58e0bd264a71ec3cbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unix domain socket address family.  <br /></td></tr>
<tr class="separator:gaf26b9f671650b58e0bd264a71ec3cbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ac52f2e8e200798e44cdbf8704096b" id="r_ga23ac52f2e8e200798e44cdbf8704096b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga23ac52f2e8e200798e44cdbf8704096b">SOCKET_IPPROTO_TCP</a>&#160;&#160;&#160;IPPROTO_TCP</td></tr>
<tr class="memdesc:ga23ac52f2e8e200798e44cdbf8704096b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP protocol number.  <br /></td></tr>
<tr class="separator:ga23ac52f2e8e200798e44cdbf8704096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc1bd28b038fdf084f3363167b1f4f4" id="r_gaffc1bd28b038fdf084f3363167b1f4f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaffc1bd28b038fdf084f3363167b1f4f4">SOCKET_IPPROTO_UDP</a>&#160;&#160;&#160;IPPROTO_UDP</td></tr>
<tr class="memdesc:gaffc1bd28b038fdf084f3363167b1f4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UDP protocol number.  <br /></td></tr>
<tr class="separator:gaffc1bd28b038fdf084f3363167b1f4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4deb45fce6ccd9618225ad46d6c414b" id="r_gaf4deb45fce6ccd9618225ad46d6c414b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf4deb45fce6ccd9618225ad46d6c414b">SOCKET_IPPROTO_IP</a>&#160;&#160;&#160;IPPROTO_IP</td></tr>
<tr class="memdesc:gaf4deb45fce6ccd9618225ad46d6c414b"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP protocol number.  <br /></td></tr>
<tr class="separator:gaf4deb45fce6ccd9618225ad46d6c414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c4b46c80919077e8a17075c1843ecf" id="r_ga98c4b46c80919077e8a17075c1843ecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga98c4b46c80919077e8a17075c1843ecf">SOCKET_IPPROTO_IPV6</a>&#160;&#160;&#160;IPPROTO_IPV6</td></tr>
<tr class="memdesc:ga98c4b46c80919077e8a17075c1843ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 protocol number.  <br /></td></tr>
<tr class="separator:ga98c4b46c80919077e8a17075c1843ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4457fd2dac639801c08d5b7633cf0e8" id="r_gaa4457fd2dac639801c08d5b7633cf0e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa4457fd2dac639801c08d5b7633cf0e8">SOCKET_SOL_SOCKET</a>&#160;&#160;&#160;SOL_SOCKET</td></tr>
<tr class="memdesc:gaa4457fd2dac639801c08d5b7633cf0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket options level.  <br /></td></tr>
<tr class="separator:gaa4457fd2dac639801c08d5b7633cf0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a238f64c49ef6c7aea7cfe16d1e0ac5" id="r_ga7a238f64c49ef6c7aea7cfe16d1e0ac5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7a238f64c49ef6c7aea7cfe16d1e0ac5">SOCKET_SO_REUSEADDR</a>&#160;&#160;&#160;SO_REUSEADDR</td></tr>
<tr class="memdesc:ga7a238f64c49ef6c7aea7cfe16d1e0ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow reuse of local addresses.  <br /></td></tr>
<tr class="separator:ga7a238f64c49ef6c7aea7cfe16d1e0ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa677c5c4c9fb9c2901f59bae61218989" id="r_gaa677c5c4c9fb9c2901f59bae61218989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa677c5c4c9fb9c2901f59bae61218989">SOCKET_SO_REUSEPORT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa677c5c4c9fb9c2901f59bae61218989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow reuse of local ports (if available).  <br /></td></tr>
<tr class="separator:gaa677c5c4c9fb9c2901f59bae61218989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9c0eecdab0e5173a8a5c75d84dc932" id="r_ga3e9c0eecdab0e5173a8a5c75d84dc932"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3e9c0eecdab0e5173a8a5c75d84dc932">SOCKET_SOCK_CLOEXEC</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga3e9c0eecdab0e5173a8a5c75d84dc932"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOCK_CLOEXEC flag for socket creation (if available).  <br /></td></tr>
<tr class="separator:ga3e9c0eecdab0e5173a8a5c75d84dc932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179e47f6c98b38853e2f9e223586dc5d" id="r_ga179e47f6c98b38853e2f9e223586dc5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga179e47f6c98b38853e2f9e223586dc5d">SOCKET_HAS_ACCEPT4</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga179e47f6c98b38853e2f9e223586dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linux-specific accept4() support flag.  <br /></td></tr>
<tr class="separator:ga179e47f6c98b38853e2f9e223586dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0cac1c13bb3060c9311bba91b026c63" id="r_gac0cac1c13bb3060c9311bba91b026c63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac0cac1c13bb3060c9311bba91b026c63">SOCKET_FD_CLOEXEC</a>&#160;&#160;&#160;FD_CLOEXEC</td></tr>
<tr class="memdesc:gac0cac1c13bb3060c9311bba91b026c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor close-on-exec flag.  <br /></td></tr>
<tr class="separator:gac0cac1c13bb3060c9311bba91b026c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d16a51106f47efdc76e1495f3cf9ead" id="r_ga1d16a51106f47efdc76e1495f3cf9ead"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1d16a51106f47efdc76e1495f3cf9ead">SOCKET_SO_BROADCAST</a>&#160;&#160;&#160;SO_BROADCAST</td></tr>
<tr class="memdesc:ga1d16a51106f47efdc76e1495f3cf9ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable broadcast transmission.  <br /></td></tr>
<tr class="separator:ga1d16a51106f47efdc76e1495f3cf9ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7074b869b88f5fb750473b41e6eb5e" id="r_ga0f7074b869b88f5fb750473b41e6eb5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0f7074b869b88f5fb750473b41e6eb5e">SOCKET_SO_KEEPALIVE</a>&#160;&#160;&#160;SO_KEEPALIVE</td></tr>
<tr class="memdesc:ga0f7074b869b88f5fb750473b41e6eb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable keep-alive packets.  <br /></td></tr>
<tr class="separator:ga0f7074b869b88f5fb750473b41e6eb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae523e4269e9d3d8d811d9b201cd22bda" id="r_gae523e4269e9d3d8d811d9b201cd22bda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae523e4269e9d3d8d811d9b201cd22bda">SOCKET_SO_RCVTIMEO</a>&#160;&#160;&#160;SO_RCVTIMEO</td></tr>
<tr class="memdesc:gae523e4269e9d3d8d811d9b201cd22bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive timeout.  <br /></td></tr>
<tr class="separator:gae523e4269e9d3d8d811d9b201cd22bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e79c5dbef56609cfb2ca32a5cf82257" id="r_ga4e79c5dbef56609cfb2ca32a5cf82257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4e79c5dbef56609cfb2ca32a5cf82257">SOCKET_SO_SNDTIMEO</a>&#160;&#160;&#160;SO_SNDTIMEO</td></tr>
<tr class="memdesc:ga4e79c5dbef56609cfb2ca32a5cf82257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send timeout.  <br /></td></tr>
<tr class="separator:ga4e79c5dbef56609cfb2ca32a5cf82257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057781fff8a16936f1d2f81e639d17e9" id="r_ga057781fff8a16936f1d2f81e639d17e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga057781fff8a16936f1d2f81e639d17e9">SOCKET_SO_RCVBUF</a>&#160;&#160;&#160;SO_RCVBUF</td></tr>
<tr class="memdesc:ga057781fff8a16936f1d2f81e639d17e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive buffer size.  <br /></td></tr>
<tr class="separator:ga057781fff8a16936f1d2f81e639d17e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458bafdef6d2bfdd698d25935a9a05a8" id="r_ga458bafdef6d2bfdd698d25935a9a05a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga458bafdef6d2bfdd698d25935a9a05a8">SOCKET_SO_SNDBUF</a>&#160;&#160;&#160;SO_SNDBUF</td></tr>
<tr class="memdesc:ga458bafdef6d2bfdd698d25935a9a05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send buffer size.  <br /></td></tr>
<tr class="separator:ga458bafdef6d2bfdd698d25935a9a05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a84a186673663e3306d00e73e6abc1" id="r_gac9a84a186673663e3306d00e73e6abc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac9a84a186673663e3306d00e73e6abc1">SOCKET_SO_PEERCRED</a>&#160;&#160;&#160;SO_PEERCRED</td></tr>
<tr class="memdesc:gac9a84a186673663e3306d00e73e6abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peer credentials.  <br /></td></tr>
<tr class="separator:gac9a84a186673663e3306d00e73e6abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e904b0adcc6c319bc93af43aa172ee" id="r_ga50e904b0adcc6c319bc93af43aa172ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga50e904b0adcc6c319bc93af43aa172ee">SOCKET_TCP_NODELAY</a>&#160;&#160;&#160;TCP_NODELAY</td></tr>
<tr class="memdesc:ga50e904b0adcc6c319bc93af43aa172ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Nagle's algorithm.  <br /></td></tr>
<tr class="separator:ga50e904b0adcc6c319bc93af43aa172ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213393dd843fb9bbb3a8e452fea5838e" id="r_ga213393dd843fb9bbb3a8e452fea5838e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga213393dd843fb9bbb3a8e452fea5838e">SOCKET_TCP_KEEPIDLE</a>&#160;&#160;&#160;TCP_KEEPIDLE</td></tr>
<tr class="memdesc:ga213393dd843fb9bbb3a8e452fea5838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep-alive idle time.  <br /></td></tr>
<tr class="separator:ga213393dd843fb9bbb3a8e452fea5838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddb57a19b17c1e8730658e051d7cb97" id="r_gacddb57a19b17c1e8730658e051d7cb97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacddb57a19b17c1e8730658e051d7cb97">SOCKET_TCP_KEEPINTVL</a>&#160;&#160;&#160;TCP_KEEPINTVL</td></tr>
<tr class="memdesc:gacddb57a19b17c1e8730658e051d7cb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep-alive interval.  <br /></td></tr>
<tr class="separator:gacddb57a19b17c1e8730658e051d7cb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b4cfc38baeb5d092a9dbc968868e17" id="r_gae9b4cfc38baeb5d092a9dbc968868e17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae9b4cfc38baeb5d092a9dbc968868e17">SOCKET_TCP_KEEPCNT</a>&#160;&#160;&#160;TCP_KEEPCNT</td></tr>
<tr class="memdesc:gae9b4cfc38baeb5d092a9dbc968868e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep-alive probe count.  <br /></td></tr>
<tr class="separator:gae9b4cfc38baeb5d092a9dbc968868e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59b371249a0e487e26d4f9e087351e5" id="r_gae59b371249a0e487e26d4f9e087351e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae59b371249a0e487e26d4f9e087351e5">SOCKET_HAS_TCP_CONGESTION</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gae59b371249a0e487e26d4f9e087351e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP congestion control algorithm (if available).  <br /></td></tr>
<tr class="separator:gae59b371249a0e487e26d4f9e087351e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680a9b46408253f21f2fae08fab1a073" id="r_ga680a9b46408253f21f2fae08fab1a073"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga680a9b46408253f21f2fae08fab1a073">SOCKET_HAS_TCP_FASTOPEN</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga680a9b46408253f21f2fae08fab1a073"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP Fast Open support (if available).  <br /></td></tr>
<tr class="separator:ga680a9b46408253f21f2fae08fab1a073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0034bad5cc9db994f51ea107fed151" id="r_ga2e0034bad5cc9db994f51ea107fed151"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2e0034bad5cc9db994f51ea107fed151">SOCKET_HAS_TCP_USER_TIMEOUT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2e0034bad5cc9db994f51ea107fed151"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP user timeout support (if available).  <br /></td></tr>
<tr class="separator:ga2e0034bad5cc9db994f51ea107fed151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc73d2f6f2da35365e09b28eff6364b8" id="r_gabc73d2f6f2da35365e09b28eff6364b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabc73d2f6f2da35365e09b28eff6364b8">SOCKET_IPV6_V6ONLY</a>&#160;&#160;&#160;IPV6_V6ONLY</td></tr>
<tr class="memdesc:gabc73d2f6f2da35365e09b28eff6364b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 only flag.  <br /></td></tr>
<tr class="separator:gabc73d2f6f2da35365e09b28eff6364b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6718d10ef55392425b3e4eea07ee15ce" id="r_ga6718d10ef55392425b3e4eea07ee15ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6718d10ef55392425b3e4eea07ee15ce">SOCKET_IPV6_UNICAST_HOPS</a>&#160;&#160;&#160;IPV6_UNICAST_HOPS</td></tr>
<tr class="memdesc:ga6718d10ef55392425b3e4eea07ee15ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPv6 multicast add membership.  <br /></td></tr>
<tr class="separator:ga6718d10ef55392425b3e4eea07ee15ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa278a4a5238ff43c2eedd874cd289b0" id="r_gaaa278a4a5238ff43c2eedd874cd289b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaaa278a4a5238ff43c2eedd874cd289b0">SOCKET_IP_TTL</a>&#160;&#160;&#160;IP_TTL</td></tr>
<tr class="memdesc:gaaa278a4a5238ff43c2eedd874cd289b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP time to live.  <br /></td></tr>
<tr class="separator:gaaa278a4a5238ff43c2eedd874cd289b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a982d41e0cbfea982c0ee35cab78ae3" id="r_ga3a982d41e0cbfea982c0ee35cab78ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3a982d41e0cbfea982c0ee35cab78ae3">SOCKET_IP_ADD_MEMBERSHIP</a>&#160;&#160;&#160;IP_ADD_MEMBERSHIP</td></tr>
<tr class="memdesc:ga3a982d41e0cbfea982c0ee35cab78ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP multicast add membership.  <br /></td></tr>
<tr class="separator:ga3a982d41e0cbfea982c0ee35cab78ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057793cb88e55bf92024c4c36e81a9e5" id="r_ga057793cb88e55bf92024c4c36e81a9e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga057793cb88e55bf92024c4c36e81a9e5">SOCKET_IP_DROP_MEMBERSHIP</a>&#160;&#160;&#160;IP_DROP_MEMBERSHIP</td></tr>
<tr class="memdesc:ga057793cb88e55bf92024c4c36e81a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP multicast drop membership.  <br /></td></tr>
<tr class="separator:ga057793cb88e55bf92024c4c36e81a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf554ab0a276793e3c2211071e90d2379" id="r_gaf554ab0a276793e3c2211071e90d2379"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf554ab0a276793e3c2211071e90d2379">SOCKET_AI_PASSIVE</a>&#160;&#160;&#160;AI_PASSIVE</td></tr>
<tr class="memdesc:gaf554ab0a276793e3c2211071e90d2379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passive socket flag for getaddrinfo().  <br /></td></tr>
<tr class="separator:gaf554ab0a276793e3c2211071e90d2379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c758285ea3ec616ebef228524e5870" id="r_gac5c758285ea3ec616ebef228524e5870"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac5c758285ea3ec616ebef228524e5870">SOCKET_AI_NUMERICHOST</a>&#160;&#160;&#160;AI_NUMERICHOST</td></tr>
<tr class="memdesc:gac5c758285ea3ec616ebef228524e5870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric host address flag for getaddrinfo().  <br /></td></tr>
<tr class="separator:gac5c758285ea3ec616ebef228524e5870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9650f9a758e7db73f81549f62c336c06" id="r_ga9650f9a758e7db73f81549f62c336c06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga9650f9a758e7db73f81549f62c336c06">SOCKET_AI_NUMERICSERV</a>&#160;&#160;&#160;AI_NUMERICSERV</td></tr>
<tr class="memdesc:ga9650f9a758e7db73f81549f62c336c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric service port flag for getaddrinfo().  <br /></td></tr>
<tr class="separator:ga9650f9a758e7db73f81549f62c336c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed05968c714f431c7489dbbd6491c4da" id="r_gaed05968c714f431c7489dbbd6491c4da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaed05968c714f431c7489dbbd6491c4da">SOCKET_NI_NUMERICHOST</a>&#160;&#160;&#160;NI_NUMERICHOST</td></tr>
<tr class="memdesc:gaed05968c714f431c7489dbbd6491c4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric host address flag for getnameinfo().  <br /></td></tr>
<tr class="separator:gaed05968c714f431c7489dbbd6491c4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189adadf65e2effcf336ae92be1453a3" id="r_ga189adadf65e2effcf336ae92be1453a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga189adadf65e2effcf336ae92be1453a3">SOCKET_NI_NUMERICSERV</a>&#160;&#160;&#160;NI_NUMERICSERV</td></tr>
<tr class="memdesc:ga189adadf65e2effcf336ae92be1453a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric service port flag for getnameinfo().  <br /></td></tr>
<tr class="separator:ga189adadf65e2effcf336ae92be1453a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb714afb577d800a5b6388c5ff985e45" id="r_gabb714afb577d800a5b6388c5ff985e45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabb714afb577d800a5b6388c5ff985e45">SOCKET_NI_MAXHOST</a>&#160;&#160;&#160;NI_MAXHOST</td></tr>
<tr class="memdesc:gabb714afb577d800a5b6388c5ff985e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum host name length for getnameinfo().  <br /></td></tr>
<tr class="separator:gabb714afb577d800a5b6388c5ff985e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0470d30293aefa9d90b1adeae8b2a893" id="r_ga0470d30293aefa9d90b1adeae8b2a893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0470d30293aefa9d90b1adeae8b2a893">SOCKET_NI_MAXSERV</a>&#160;&#160;&#160;NI_MAXSERV</td></tr>
<tr class="memdesc:ga0470d30293aefa9d90b1adeae8b2a893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum service name length for getnameinfo().  <br /></td></tr>
<tr class="separator:ga0470d30293aefa9d90b1adeae8b2a893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad846caae5ed6ec066d9ae975c23d0e10" id="r_gad846caae5ed6ec066d9ae975c23d0e10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad846caae5ed6ec066d9ae975c23d0e10">SOCKET_SHUT_RD</a>&#160;&#160;&#160;SHUT_RD</td></tr>
<tr class="memdesc:gad846caae5ed6ec066d9ae975c23d0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown read direction.  <br /></td></tr>
<tr class="separator:gad846caae5ed6ec066d9ae975c23d0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5549c3faf506d9057ac05de132462f87" id="r_ga5549c3faf506d9057ac05de132462f87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5549c3faf506d9057ac05de132462f87">SOCKET_SHUT_WR</a>&#160;&#160;&#160;SHUT_WR</td></tr>
<tr class="memdesc:ga5549c3faf506d9057ac05de132462f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown write direction.  <br /></td></tr>
<tr class="separator:ga5549c3faf506d9057ac05de132462f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e4937ecabbc1aafef3092ed4d062e4" id="r_ga30e4937ecabbc1aafef3092ed4d062e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga30e4937ecabbc1aafef3092ed4d062e4">SOCKET_SHUT_RDWR</a>&#160;&#160;&#160;SHUT_RDWR</td></tr>
<tr class="memdesc:ga30e4937ecabbc1aafef3092ed4d062e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown both read and write directions.  <br /></td></tr>
<tr class="separator:ga30e4937ecabbc1aafef3092ed4d062e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f55d0e90dc8cc6b2287312435cdde48" id="r_ga9f55d0e90dc8cc6b2287312435cdde48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga9f55d0e90dc8cc6b2287312435cdde48">MSG_NOSIGNAL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga9f55d0e90dc8cc6b2287312435cdde48"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSG_NOSIGNAL fallback for platforms without it.  <br /></td></tr>
<tr class="separator:ga9f55d0e90dc8cc6b2287312435cdde48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8596dc13da264d86966c08b435110a" id="r_ga6d8596dc13da264d86966c08b435110a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6d8596dc13da264d86966c08b435110a">SOCKET_MSG_NOSIGNAL</a>&#160;&#160;&#160;<a class="el" href="group__core__io.html#ga9f55d0e90dc8cc6b2287312435cdde48">MSG_NOSIGNAL</a></td></tr>
<tr class="memdesc:ga6d8596dc13da264d86966c08b435110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppress SIGPIPE on send operations.  <br /></td></tr>
<tr class="separator:ga6d8596dc13da264d86966c08b435110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ffdac83de0d6abd074776faf8eb016" id="r_gac8ffdac83de0d6abd074776faf8eb016"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac8ffdac83de0d6abd074776faf8eb016">SOCKET_HAS_SO_NOSIGPIPE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gac8ffdac83de0d6abd074776faf8eb016"><td class="mdescLeft">&#160;</td><td class="mdescRight">SO_NOSIGPIPE support flag.  <br /></td></tr>
<tr class="separator:gac8ffdac83de0d6abd074776faf8eb016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72227e2f5945efa472401c12608ae6f0" id="r_ga72227e2f5945efa472401c12608ae6f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga72227e2f5945efa472401c12608ae6f0">SOCKET_DEFAULT_KEEPALIVE_IDLE</a>&#160;&#160;&#160;60</td></tr>
<tr class="memdesc:ga72227e2f5945efa472401c12608ae6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TCP keep-alive idle time (seconds).  <br /></td></tr>
<tr class="separator:ga72227e2f5945efa472401c12608ae6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35dee011f3919c4720812ef8b163f03" id="r_gac35dee011f3919c4720812ef8b163f03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac35dee011f3919c4720812ef8b163f03">SOCKET_DEFAULT_KEEPALIVE_INTERVAL</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gac35dee011f3919c4720812ef8b163f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TCP keep-alive interval (seconds).  <br /></td></tr>
<tr class="separator:gac35dee011f3919c4720812ef8b163f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd745a2d91d7bc8aad76a133ef1cb0bf" id="r_gafd745a2d91d7bc8aad76a133ef1cb0bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafd745a2d91d7bc8aad76a133ef1cb0bf">SOCKET_DEFAULT_KEEPALIVE_COUNT</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gafd745a2d91d7bc8aad76a133ef1cb0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TCP keep-alive probe count.  <br /></td></tr>
<tr class="separator:gafd745a2d91d7bc8aad76a133ef1cb0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4fa06ce19af6f368a12df79ff7ad66" id="r_gacd4fa06ce19af6f368a12df79ff7ad66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacd4fa06ce19af6f368a12df79ff7ad66">SOCKET_KEEPALIVE_MAX_IDLE</a>&#160;&#160;&#160;(86400 * 365) /* 1 year in seconds */</td></tr>
<tr class="memdesc:gacd4fa06ce19af6f368a12df79ff7ad66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum TCP keep-alive idle time (seconds).  <br /></td></tr>
<tr class="separator:gacd4fa06ce19af6f368a12df79ff7ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ea2cf17f9bdb3c1486b5507a909b51" id="r_gab1ea2cf17f9bdb3c1486b5507a909b51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab1ea2cf17f9bdb3c1486b5507a909b51">SOCKET_KEEPALIVE_MAX_INTERVAL</a>&#160;&#160;&#160;3600 /* 1 hour */</td></tr>
<tr class="memdesc:gab1ea2cf17f9bdb3c1486b5507a909b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum TCP keep-alive interval (seconds).  <br /></td></tr>
<tr class="separator:gab1ea2cf17f9bdb3c1486b5507a909b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b31ca82a1d8746c1cb6465b8b186ad6" id="r_ga7b31ca82a1d8746c1cb6465b8b186ad6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7b31ca82a1d8746c1cb6465b8b186ad6">SOCKET_KEEPALIVE_MAX_COUNT</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga7b31ca82a1d8746c1cb6465b8b186ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum TCP keep-alive probe count.  <br /></td></tr>
<tr class="separator:ga7b31ca82a1d8746c1cb6465b8b186ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e12edc544b767b4c90fcc27f2dd2f0" id="r_gad2e12edc544b767b4c90fcc27f2dd2f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad2e12edc544b767b4c90fcc27f2dd2f0">SOCKET_MAX_DEFER_ACCEPT_SEC</a>&#160;&#160;&#160;3600 /* 1 hour */</td></tr>
<tr class="memdesc:gad2e12edc544b767b4c90fcc27f2dd2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum TCP defer accept timeout (seconds).  <br /></td></tr>
<tr class="separator:gad2e12edc544b767b4c90fcc27f2dd2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ce13cff9dec99c824f8594e22f159e" id="r_ga73ce13cff9dec99c824f8594e22f159e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga73ce13cff9dec99c824f8594e22f159e">SOCKET_MAX_CONGESTION_ALGO_LEN</a>&#160;&#160;&#160;63</td></tr>
<tr class="memdesc:ga73ce13cff9dec99c824f8594e22f159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum congestion control algorithm name length.  <br /></td></tr>
<tr class="separator:ga73ce13cff9dec99c824f8594e22f159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c36ad0507aab15f0b59b4ccde5dfb31" id="r_ga4c36ad0507aab15f0b59b4ccde5dfb31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4c36ad0507aab15f0b59b4ccde5dfb31">SOCKET_DEFAULT_DATAGRAM_TTL</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga4c36ad0507aab15f0b59b4ccde5dfb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default datagram TTL value.  <br /></td></tr>
<tr class="separator:ga4c36ad0507aab15f0b59b4ccde5dfb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69be862b0cece4e20e7ea283ad91c70" id="r_gaf69be862b0cece4e20e7ea283ad91c70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf69be862b0cece4e20e7ea283ad91c70">SOCKET_MULTICAST_DEFAULT_INTERFACE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaf69be862b0cece4e20e7ea283ad91c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default multicast interface index.  <br /></td></tr>
<tr class="separator:gaf69be862b0cece4e20e7ea283ad91c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;Socket_T</td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque context for managing asynchronous proxy tunneling operations.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ef0927dc8f89dfd9193fc9a39300fc2" id="r_ga2ef0927dc8f89dfd9193fc9a39300fc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2ef0927dc8f89dfd9193fc9a39300fc2">SocketBase_T</a>&#160;&#160;&#160;<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a></td></tr>
<tr class="memdesc:ga2ef0927dc8f89dfd9193fc9a39300fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque base structure for shared socket functionality.  <br /></td></tr>
<tr class="separator:ga2ef0927dc8f89dfd9193fc9a39300fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd7aa5138146bb99a2360fface85b12" id="r_gafdd7aa5138146bb99a2360fface85b12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafdd7aa5138146bb99a2360fface85b12">SOCKETLIVECOUNT_STATIC_INIT</a></td></tr>
<tr class="memdesc:gafdd7aa5138146bb99a2360fface85b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static initializer for <a class="el" href="group__core__io.html#structSocketLiveCount" title="Thread-safe live count tracker for socket instances.">SocketLiveCount</a> structure.  <br /></td></tr>
<tr class="separator:gafdd7aa5138146bb99a2360fface85b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acb682b8260ab1c60b918599864e2e5" id="r_ga0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a></td></tr>
<tr class="memdesc:ga0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque context for managing asynchronous proxy tunneling operations.  <br /></td></tr>
<tr class="separator:ga0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad4b3ec10874282833e1b15760efa1b6c" id="r_gad4b3ec10874282833e1b15760efa1b6c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td></tr>
<tr class="memdesc:gad4b3ec10874282833e1b15760efa1b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque handle to a circular buffer instance.  <br /></td></tr>
<tr class="separator:gad4b3ec10874282833e1b15760efa1b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaa33f7bdae951cc7b53a2fb049e89132" id="r_gaaa33f7bdae951cc7b53a2fb049e89132"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a> { <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132af06430c3c302df7671528157c73c4e0b">SOCKET_PROXY_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132a687548e806513e256fcf2534ddf9cbd6">SOCKET_PROXY_HTTP</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132a7b26d4906e2233ed613ea9b00d402abb">SOCKET_PROXY_HTTPS</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132ab789e6a114edbf61a4df42d8240a51c1">SOCKET_PROXY_SOCKS4</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132a8d530f085d00940efe69768b8cf374c6">SOCKET_PROXY_SOCKS4A</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132a65e12b32adeb0ad03fc8a1031423c21f">SOCKET_PROXY_SOCKS5</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaaa33f7bdae951cc7b53a2fb049e89132ae87246b34aba7c6500664e7be36d8820">SOCKET_PROXY_SOCKS5H</a>
<br />
 }</td></tr>
<tr class="memdesc:gaaa33f7bdae951cc7b53a2fb049e89132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of supported proxy protocol types.  <a href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">More...</a><br /></td></tr>
<tr class="separator:gaaa33f7bdae951cc7b53a2fb049e89132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae980e6a437316380a792464ce32a595e" id="r_gae980e6a437316380a792464ce32a595e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a> { <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea6493782f06c64d4240b03ebc37d10754">PROXY_OK</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595eac8e28cc62a3365a1732c669edf48ede1">PROXY_IN_PROGRESS</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea6e9669d107d6f667fc65e467f8ee6424">PROXY_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea65f9d23b989fea3c0578f03bf69dcbc3">PROXY_ERROR_CONNECT</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595eaae7c553c156d0bc0673280b02c1ed7a0">PROXY_ERROR_AUTH_REQUIRED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595eaeaa9baf16d7658f8553f19fc887ba82f">PROXY_ERROR_AUTH_FAILED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea9519d7d7a824bbb8527737bb565a8d26">PROXY_ERROR_FORBIDDEN</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea79f3625d5f0c085c05bd00e79c7b4878">PROXY_ERROR_HOST_UNREACHABLE</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea2415989b5d247d71236686d18b1eeb9d">PROXY_ERROR_NETWORK_UNREACHABLE</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea533fd840f7baa208f63174952243f28e">PROXY_ERROR_CONNECTION_REFUSED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea942a19cc1c6152dba3f615c94c8190b9">PROXY_ERROR_TTL_EXPIRED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea743f6cf01e958374a7cae9cce8960552">PROXY_ERROR_PROTOCOL</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea9acb784df31ca1f49007e0dbec3899ae">PROXY_ERROR_UNSUPPORTED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea6f79c29997ae1e1063f0f4c079e42128">PROXY_ERROR_TIMEOUT</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea15fe5e5fc15227e92086cc3c76e468d8">PROXY_ERROR_CANCELLED</a>
<br />
 }</td></tr>
<tr class="memdesc:gae980e6a437316380a792464ce32a595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result codes for proxy operations.  <a href="group__core__io.html#gae980e6a437316380a792464ce32a595e">More...</a><br /></td></tr>
<tr class="separator:gae980e6a437316380a792464ce32a595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f1c72bfcb303aa9ee5dae6d903b9be" id="r_gaf9f1c72bfcb303aa9ee5dae6d903b9be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a> { <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9beacba676410c89ad0ae99458a19e8ee240">PROXY_STATE_IDLE</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9beaa138c1108967670476f171409859906c">PROXY_STATE_CONNECTING_PROXY</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9bea5e6d9c22e92e5264322ca6229d697200">PROXY_STATE_TLS_TO_PROXY</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9beaec64bc3a56940bb0b95bd533d3f575d1">PROXY_STATE_HANDSHAKE_SEND</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9bea6692865ae9a1d5913dc9b11bb8ecc053">PROXY_STATE_HANDSHAKE_RECV</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9bea33e574e11d2391e830bb512b5f4cba10">PROXY_STATE_AUTH_SEND</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9beaebe4dde2fe06562c2e05cbe78cdf75d7">PROXY_STATE_AUTH_RECV</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9bea93b0009c07bfe02286b9151523792043">PROXY_STATE_CONNECTED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9bea002d0ae5e052492f5a003f240cce1a07">PROXY_STATE_FAILED</a>
, <br />
&#160;&#160;<a class="el" href="group__core__io.html#ggaf9f1c72bfcb303aa9ee5dae6d903b9beaefd3cf70c9901425e0b6aa6a8325b71a">PROXY_STATE_CANCELLED</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf9f1c72bfcb303aa9ee5dae6d903b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">States in the proxy connection state machine.  <a href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">More...</a><br /></td></tr>
<tr class="separator:gaf9f1c72bfcb303aa9ee5dae6d903b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8517adf0df2e5331a952fb713ec314f9" id="r_ga8517adf0df2e5331a952fb713ec314f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9">Socket_error_is_retryable</a> (int err)</td></tr>
<tr class="memdesc:ga8517adf0df2e5331a952fb713ec314f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an errno indicates a retryable error.  <br /></td></tr>
<tr class="separator:ga8517adf0df2e5331a952fb713ec314f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6212fb2b6eefa567592a59f55c25a6f1" id="r_ga6212fb2b6eefa567592a59f55c25a6f1"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a> (int domain, int type, int protocol)</td></tr>
<tr class="memdesc:ga6212fb2b6eefa567592a59f55c25a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new socket with specified domain, type, and protocol.  <br /></td></tr>
<tr class="separator:ga6212fb2b6eefa567592a59f55c25a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1290da3d1c546b8c550a59e138f722b8" id="r_ga1290da3d1c546b8c550a59e138f722b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1290da3d1c546b8c550a59e138f722b8">SocketPair_new</a> (int type, Socket_T *socket1, Socket_T *socket2)</td></tr>
<tr class="memdesc:ga1290da3d1c546b8c550a59e138f722b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pair of connected Unix domain sockets for inter-process communication.  <br /></td></tr>
<tr class="separator:ga1290da3d1c546b8c550a59e138f722b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ad7a9bb8deaf499c59d90d6e411f37" id="r_ga74ad7a9bb8deaf499c59d90d6e411f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a> (Socket_T *socket)</td></tr>
<tr class="memdesc:ga74ad7a9bb8deaf499c59d90d6e411f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of a socket instance and close the underlying file descriptor.  <br /></td></tr>
<tr class="separator:ga74ad7a9bb8deaf499c59d90d6e411f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c6b82ec5bf6be8131532de9ade5caf" id="r_gae7c6b82ec5bf6be8131532de9ade5caf"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae7c6b82ec5bf6be8131532de9ade5caf">Socket_new_from_fd</a> (int fd)</td></tr>
<tr class="memdesc:gae7c6b82ec5bf6be8131532de9ade5caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Socket_T from existing file descriptor.  <br /></td></tr>
<tr class="separator:gae7c6b82ec5bf6be8131532de9ade5caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8cacd863c275e6e12f7c63b65708e1b" id="r_gaa8cacd863c275e6e12f7c63b65708e1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa8cacd863c275e6e12f7c63b65708e1b">Socket_debug_live_count</a> (void)</td></tr>
<tr class="memdesc:gaa8cacd863c275e6e12f7c63b65708e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of live socket instances (test-only).  <br /></td></tr>
<tr class="separator:gaa8cacd863c275e6e12f7c63b65708e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfd3666a5d9779023f527c3afddf164" id="r_gafdfd3666a5d9779023f527c3afddf164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164">Socket_getstats</a> (const Socket_T socket, <a class="el" href="group__core__io.html#structSocketStats__T">SocketStats_T</a> *stats)</td></tr>
<tr class="memdesc:gafdfd3666a5d9779023f527c3afddf164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current statistics for a socket.  <br /></td></tr>
<tr class="separator:gafdfd3666a5d9779023f527c3afddf164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e5b410845cb71d636f9fbf34771e9c" id="r_ga79e5b410845cb71d636f9fbf34771e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c">Socket_resetstats</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga79e5b410845cb71d636f9fbf34771e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statistics counters for a socket.  <br /></td></tr>
<tr class="separator:ga79e5b410845cb71d636f9fbf34771e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafefcba126efabd940ff1e7e3259ee7d8" id="r_gafefcba126efabd940ff1e7e3259ee7d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafefcba126efabd940ff1e7e3259ee7d8">Socket_probe</a> (Socket_T socket, int timeout_ms)</td></tr>
<tr class="memdesc:gafefcba126efabd940ff1e7e3259ee7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe if a connection is still alive.  <br /></td></tr>
<tr class="separator:gafefcba126efabd940ff1e7e3259ee7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead54f56807d61df1827a49d94870490" id="r_gaead54f56807d61df1827a49d94870490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaead54f56807d61df1827a49d94870490">Socket_get_error</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gaead54f56807d61df1827a49d94870490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pending socket error (SO_ERROR).  <br /></td></tr>
<tr class="separator:gaead54f56807d61df1827a49d94870490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3796b46a9d07c1be492e027eb9dfdee5" id="r_ga3796b46a9d07c1be492e027eb9dfdee5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5">Socket_is_readable</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga3796b46a9d07c1be492e027eb9dfdee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket has data available to read without blocking.  <br /></td></tr>
<tr class="separator:ga3796b46a9d07c1be492e027eb9dfdee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8acb19502c6d3adce7652e61070eee3c" id="r_ga8acb19502c6d3adce7652e61070eee3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8acb19502c6d3adce7652e61070eee3c">Socket_is_writable</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga8acb19502c6d3adce7652e61070eee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket can accept writes without blocking.  <br /></td></tr>
<tr class="separator:ga8acb19502c6d3adce7652e61070eee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf553d73a7db296859dc7a1a92c0f6b12" id="r_gaf553d73a7db296859dc7a1a92c0f6b12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12">Socket_get_tcp_info</a> (Socket_T socket, <a class="el" href="group__core__io.html#structSocketTCPInfo">SocketTCPInfo</a> *info)</td></tr>
<tr class="memdesc:gaf553d73a7db296859dc7a1a92c0f6b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve TCP connection statistics (Linux-specific).  <br /></td></tr>
<tr class="separator:gaf553d73a7db296859dc7a1a92c0f6b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc4637d1e6e996b0f52d553ec884098" id="r_gaddc4637d1e6e996b0f52d553ec884098"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaddc4637d1e6e996b0f52d553ec884098">Socket_get_rtt</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gaddc4637d1e6e996b0f52d553ec884098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current RTT (round-trip time) estimate.  <br /></td></tr>
<tr class="separator:gaddc4637d1e6e996b0f52d553ec884098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b91bb032c977bc19df4dc0f3e4cff7" id="r_ga76b91bb032c977bc19df4dc0f3e4cff7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga76b91bb032c977bc19df4dc0f3e4cff7">Socket_get_cwnd</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga76b91bb032c977bc19df4dc0f3e4cff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current congestion window size.  <br /></td></tr>
<tr class="separator:ga76b91bb032c977bc19df4dc0f3e4cff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb65d693d8c93e2a1fe6411dd0d0af98" id="r_gacb65d693d8c93e2a1fe6411dd0d0af98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a> (Socket_T socket, const char *host, int port)</td></tr>
<tr class="memdesc:gacb65d693d8c93e2a1fe6411dd0d0af98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a socket to a local IP address and port.  <br /></td></tr>
<tr class="separator:gacb65d693d8c93e2a1fe6411dd0d0af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24b026bc4c69e6f766211f44675e189" id="r_gab24b026bc4c69e6f766211f44675e189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a> (Socket_T socket, int backlog)</td></tr>
<tr class="memdesc:gab24b026bc4c69e6f766211f44675e189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for incoming connections.  <br /></td></tr>
<tr class="separator:gab24b026bc4c69e6f766211f44675e189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b67d95639513cd6a602f6175b48f15" id="r_ga32b67d95639513cd6a602f6175b48f15"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga32b67d95639513cd6a602f6175b48f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept incoming connection.  <br /></td></tr>
<tr class="separator:ga32b67d95639513cd6a602f6175b48f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14390090ee26136c1f7a816fc08406e" id="r_gac14390090ee26136c1f7a816fc08406e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a> (Socket_T socket, const char *host, int port)</td></tr>
<tr class="memdesc:gac14390090ee26136c1f7a816fc08406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a connection to a remote host and port.  <br /></td></tr>
<tr class="separator:gac14390090ee26136c1f7a816fc08406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ace6e065fe4b9a01db8caa6513515b" id="r_ga23ace6e065fe4b9a01db8caa6513515b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a> (Socket_T socket, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ga23ace6e065fe4b9a01db8caa6513515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data.  <br /></td></tr>
<tr class="separator:ga23ace6e065fe4b9a01db8caa6513515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95db343f47445925cecd6b20054518e9" id="r_ga95db343f47445925cecd6b20054518e9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a> (Socket_T socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:ga95db343f47445925cecd6b20054518e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data.  <br /></td></tr>
<tr class="separator:ga95db343f47445925cecd6b20054518e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea9ad33d78c50d327c9677b52849bcb" id="r_ga6ea9ad33d78c50d327c9677b52849bcb"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a> (Socket_T socket, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ga6ea9ad33d78c50d327c9677b52849bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all data (handles partial sends).  <br /></td></tr>
<tr class="separator:ga6ea9ad33d78c50d327c9677b52849bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ea888b05b09714cc010463b8cead4b" id="r_ga18ea888b05b09714cc010463b8cead4b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b">Socket_recvall</a> (Socket_T socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:ga18ea888b05b09714cc010463b8cead4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive all requested data (handles partial receives).  <br /></td></tr>
<tr class="separator:ga18ea888b05b09714cc010463b8cead4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb50371f84b2c796c4e57a34d41f180a" id="r_gadb50371f84b2c796c4e57a34d41f180a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a">Socket_sendv</a> (Socket_T socket, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:gadb50371f84b2c796c4e57a34d41f180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather send (writev wrapper).  <br /></td></tr>
<tr class="separator:gadb50371f84b2c796c4e57a34d41f180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1c8e39587d4ea5e3ffe4b06dcaca0f" id="r_gabb1c8e39587d4ea5e3ffe4b06dcaca0f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabb1c8e39587d4ea5e3ffe4b06dcaca0f">Socket_recvv</a> (Socket_T socket, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:gabb1c8e39587d4ea5e3ffe4b06dcaca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather receive (readv wrapper).  <br /></td></tr>
<tr class="separator:gabb1c8e39587d4ea5e3ffe4b06dcaca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d033a04d5041249950fa2f54a8d9fd" id="r_gaf6d033a04d5041249950fa2f54a8d9fd"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf6d033a04d5041249950fa2f54a8d9fd">Socket_sendvall</a> (Socket_T socket, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:gaf6d033a04d5041249950fa2f54a8d9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather send all (handles partial sends).  <br /></td></tr>
<tr class="separator:gaf6d033a04d5041249950fa2f54a8d9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3472c67c78cd29944a87783e09247f9a" id="r_ga3472c67c78cd29944a87783e09247f9a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3472c67c78cd29944a87783e09247f9a">Socket_recvvall</a> (Socket_T socket, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ga3472c67c78cd29944a87783e09247f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather receive all (handles partial receives).  <br /></td></tr>
<tr class="separator:ga3472c67c78cd29944a87783e09247f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1003c289820587894dbfcad9b567c43" id="r_gad1003c289820587894dbfcad9b567c43"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad1003c289820587894dbfcad9b567c43">Socket_sendfile</a> (Socket_T socket, int file_fd, off_t *offset, size_t count)</td></tr>
<tr class="memdesc:gad1003c289820587894dbfcad9b567c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-copy file-to-socket transfer.  <br /></td></tr>
<tr class="separator:gad1003c289820587894dbfcad9b567c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6262f6ab4c927347abc0fb3c105a0575" id="r_ga6262f6ab4c927347abc0fb3c105a0575"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6262f6ab4c927347abc0fb3c105a0575">Socket_sendfileall</a> (Socket_T socket, int file_fd, off_t *offset, size_t count)</td></tr>
<tr class="memdesc:ga6262f6ab4c927347abc0fb3c105a0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-copy file-to-socket transfer (handles partial transfers).  <br /></td></tr>
<tr class="separator:ga6262f6ab4c927347abc0fb3c105a0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea9384979b83066a7a6fa1418a5862d2" id="r_gaea9384979b83066a7a6fa1418a5862d2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaea9384979b83066a7a6fa1418a5862d2">Socket_sendall_timeout</a> (Socket_T socket, const void *buf, size_t len, int timeout_ms)</td></tr>
<tr class="memdesc:gaea9384979b83066a7a6fa1418a5862d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all data with timeout.  <br /></td></tr>
<tr class="separator:gaea9384979b83066a7a6fa1418a5862d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61028bd16150564ea59c7f4c350ca9d4" id="r_ga61028bd16150564ea59c7f4c350ca9d4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga61028bd16150564ea59c7f4c350ca9d4">Socket_recvall_timeout</a> (Socket_T socket, void *buf, size_t len, int timeout_ms)</td></tr>
<tr class="memdesc:ga61028bd16150564ea59c7f4c350ca9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive all requested data with timeout.  <br /></td></tr>
<tr class="separator:ga61028bd16150564ea59c7f4c350ca9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7224aed85b1b920cc62fea881ae6f056" id="r_ga7224aed85b1b920cc62fea881ae6f056"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7224aed85b1b920cc62fea881ae6f056">Socket_sendv_timeout</a> (Socket_T socket, const struct iovec *iov, int iovcnt, int timeout_ms)</td></tr>
<tr class="memdesc:ga7224aed85b1b920cc62fea881ae6f056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather send with timeout.  <br /></td></tr>
<tr class="separator:ga7224aed85b1b920cc62fea881ae6f056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4c3a8cc81d7b66ebc2cc84bce51e8e" id="r_gace4c3a8cc81d7b66ebc2cc84bce51e8e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gace4c3a8cc81d7b66ebc2cc84bce51e8e">Socket_recvv_timeout</a> (Socket_T socket, struct iovec *iov, int iovcnt, int timeout_ms)</td></tr>
<tr class="memdesc:gace4c3a8cc81d7b66ebc2cc84bce51e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter/gather receive with timeout.  <br /></td></tr>
<tr class="separator:gace4c3a8cc81d7b66ebc2cc84bce51e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c26a5a5989a15050513a8a3721f7ea" id="r_ga06c26a5a5989a15050513a8a3721f7ea"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga06c26a5a5989a15050513a8a3721f7ea">Socket_splice</a> (Socket_T socket_in, Socket_T socket_out, size_t len)</td></tr>
<tr class="memdesc:ga06c26a5a5989a15050513a8a3721f7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-copy socket-to-socket transfer (Linux splice).  <br /></td></tr>
<tr class="separator:ga06c26a5a5989a15050513a8a3721f7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650eaa359c457e6118eab764ab7c1512" id="r_ga650eaa359c457e6118eab764ab7c1512"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga650eaa359c457e6118eab764ab7c1512">Socket_cork</a> (Socket_T socket, int enable)</td></tr>
<tr class="memdesc:ga650eaa359c457e6118eab764ab7c1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control TCP_CORK option (Nagle corking).  <br /></td></tr>
<tr class="separator:ga650eaa359c457e6118eab764ab7c1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa999775c5490710cbb8b455060bc1145" id="r_gaa999775c5490710cbb8b455060bc1145"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa999775c5490710cbb8b455060bc1145">Socket_peek</a> (Socket_T socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:gaa999775c5490710cbb8b455060bc1145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at incoming data without consuming it.  <br /></td></tr>
<tr class="separator:gaa999775c5490710cbb8b455060bc1145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1bcd57fc9784fa9863a2fc659df0de1" id="r_gaa1bcd57fc9784fa9863a2fc659df0de1"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa1bcd57fc9784fa9863a2fc659df0de1">Socket_dup</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gaa1bcd57fc9784fa9863a2fc659df0de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a socket (creates new Socket_T sharing same fd).  <br /></td></tr>
<tr class="separator:gaa1bcd57fc9784fa9863a2fc659df0de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0e5436dae38def5b10b26c9d4b6512" id="r_ga4a0e5436dae38def5b10b26c9d4b6512"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4a0e5436dae38def5b10b26c9d4b6512">Socket_dup2</a> (Socket_T socket, int target_fd)</td></tr>
<tr class="memdesc:ga4a0e5436dae38def5b10b26c9d4b6512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate socket fd to a specific file descriptor number.  <br /></td></tr>
<tr class="separator:ga4a0e5436dae38def5b10b26c9d4b6512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb12f81392f3c1fb21255bf44521e20c" id="r_gaeb12f81392f3c1fb21255bf44521e20c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaeb12f81392f3c1fb21255bf44521e20c">Socket_sendmsg</a> (Socket_T socket, const struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:gaeb12f81392f3c1fb21255bf44521e20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send message with ancillary data (sendmsg wrapper).  <br /></td></tr>
<tr class="separator:gaeb12f81392f3c1fb21255bf44521e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c972ba69ef189d5d802e4d1889a9c6" id="r_ga92c972ba69ef189d5d802e4d1889a9c6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga92c972ba69ef189d5d802e4d1889a9c6">Socket_recvmsg</a> (Socket_T socket, struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:ga92c972ba69ef189d5d802e4d1889a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive message with ancillary data (recvmsg wrapper).  <br /></td></tr>
<tr class="separator:ga92c972ba69ef189d5d802e4d1889a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d49f774ed335cf4e42f77c07948119" id="r_ga10d49f774ed335cf4e42f77c07948119"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119">Socket_isconnected</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga10d49f774ed335cf4e42f77c07948119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket is connected.  <br /></td></tr>
<tr class="separator:ga10d49f774ed335cf4e42f77c07948119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1710f1e1251df44fb4f82c60ff199a76" id="r_ga1710f1e1251df44fb4f82c60ff199a76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1710f1e1251df44fb4f82c60ff199a76">Socket_isbound</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga1710f1e1251df44fb4f82c60ff199a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket is bound to an address.  <br /></td></tr>
<tr class="separator:ga1710f1e1251df44fb4f82c60ff199a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab693dfb51bcfe2b284969a5f1db14a84" id="r_gab693dfb51bcfe2b284969a5f1db14a84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab693dfb51bcfe2b284969a5f1db14a84">Socket_islistening</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gab693dfb51bcfe2b284969a5f1db14a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket is listening for connections.  <br /></td></tr>
<tr class="separator:gab693dfb51bcfe2b284969a5f1db14a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d727948c677509eec04746585819877" id="r_ga4d727948c677509eec04746585819877"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877">Socket_fd</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga4d727948c677509eec04746585819877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying file descriptor.  <br /></td></tr>
<tr class="separator:ga4d727948c677509eec04746585819877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0957f43694d0728e70b23364a89623c" id="r_gab0957f43694d0728e70b23364a89623c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c">Socket_getpeeraddr</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:gab0957f43694d0728e70b23364a89623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peer IP address.  <br /></td></tr>
<tr class="separator:gab0957f43694d0728e70b23364a89623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d7e5845519867261a9f24dfe0e03db" id="r_ga38d7e5845519867261a9f24dfe0e03db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga38d7e5845519867261a9f24dfe0e03db">Socket_getpeerport</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga38d7e5845519867261a9f24dfe0e03db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peer port number.  <br /></td></tr>
<tr class="separator:ga38d7e5845519867261a9f24dfe0e03db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e55475bcedbc100767663e1e7d9de1" id="r_ga04e55475bcedbc100767663e1e7d9de1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga04e55475bcedbc100767663e1e7d9de1">Socket_getlocaladdr</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga04e55475bcedbc100767663e1e7d9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local IP address.  <br /></td></tr>
<tr class="separator:ga04e55475bcedbc100767663e1e7d9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdedaea9dac966d75343cdffa5d1f3e" id="r_ga3bdedaea9dac966d75343cdffa5d1f3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e">Socket_getlocalport</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga3bdedaea9dac966d75343cdffa5d1f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local port number.  <br /></td></tr>
<tr class="separator:ga3bdedaea9dac966d75343cdffa5d1f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35309677a1760480783d5f0c294d0db4" id="r_ga35309677a1760480783d5f0c294d0db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga35309677a1760480783d5f0c294d0db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable non-blocking mode.  <br /></td></tr>
<tr class="separator:ga35309677a1760480783d5f0c294d0db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c6f352cec920859c71206898ed135fc" id="r_ga2c6f352cec920859c71206898ed135fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2c6f352cec920859c71206898ed135fc">Socket_setreuseaddr</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga2c6f352cec920859c71206898ed135fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable address reuse.  <br /></td></tr>
<tr class="separator:ga2c6f352cec920859c71206898ed135fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2126127d2fa85fb5de27587e0d41a466" id="r_ga2126127d2fa85fb5de27587e0d41a466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2126127d2fa85fb5de27587e0d41a466">Socket_setreuseport</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga2126127d2fa85fb5de27587e0d41a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable port reuse across sockets.  <br /></td></tr>
<tr class="separator:ga2126127d2fa85fb5de27587e0d41a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210cbf763685c0b201b0f5caa2dc0f06" id="r_ga210cbf763685c0b201b0f5caa2dc0f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga210cbf763685c0b201b0f5caa2dc0f06">Socket_settimeout</a> (Socket_T socket, int timeout_sec)</td></tr>
<tr class="memdesc:ga210cbf763685c0b201b0f5caa2dc0f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket timeout.  <br /></td></tr>
<tr class="separator:ga210cbf763685c0b201b0f5caa2dc0f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03ef2a81d1894713aeb96c12bb2389b" id="r_gaf03ef2a81d1894713aeb96c12bb2389b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf03ef2a81d1894713aeb96c12bb2389b">Socket_setkeepalive</a> (Socket_T socket, int idle, int interval, int count)</td></tr>
<tr class="memdesc:gaf03ef2a81d1894713aeb96c12bb2389b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TCP keepalive.  <br /></td></tr>
<tr class="separator:gaf03ef2a81d1894713aeb96c12bb2389b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55174d7f9aca0e94d25321540646e6b0" id="r_ga55174d7f9aca0e94d25321540646e6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga55174d7f9aca0e94d25321540646e6b0">Socket_setnodelay</a> (Socket_T socket, int nodelay)</td></tr>
<tr class="memdesc:ga55174d7f9aca0e94d25321540646e6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Nagle's algorithm.  <br /></td></tr>
<tr class="separator:ga55174d7f9aca0e94d25321540646e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40c1cdc37abfc34cbc17cdcbf607241" id="r_gaa40c1cdc37abfc34cbc17cdcbf607241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa40c1cdc37abfc34cbc17cdcbf607241">Socket_gettimeout</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gaa40c1cdc37abfc34cbc17cdcbf607241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket timeout.  <br /></td></tr>
<tr class="separator:gaa40c1cdc37abfc34cbc17cdcbf607241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2f2e66892b062079f4c0a1dd7f8bac" id="r_gacd2f2e66892b062079f4c0a1dd7f8bac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacd2f2e66892b062079f4c0a1dd7f8bac">Socket_getkeepalive</a> (Socket_T socket, int *idle, int *interval, int *count)</td></tr>
<tr class="memdesc:gacd2f2e66892b062079f4c0a1dd7f8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP keepalive configuration.  <br /></td></tr>
<tr class="separator:gacd2f2e66892b062079f4c0a1dd7f8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01aa484c370addf3f117cfdb4f9adb8a" id="r_ga01aa484c370addf3f117cfdb4f9adb8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga01aa484c370addf3f117cfdb4f9adb8a">Socket_getnodelay</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga01aa484c370addf3f117cfdb4f9adb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP_NODELAY setting.  <br /></td></tr>
<tr class="separator:ga01aa484c370addf3f117cfdb4f9adb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b2908934ed8757725da6e6d22ff60c" id="r_ga73b2908934ed8757725da6e6d22ff60c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga73b2908934ed8757725da6e6d22ff60c">Socket_getrcvbuf</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga73b2908934ed8757725da6e6d22ff60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get receive buffer size.  <br /></td></tr>
<tr class="separator:ga73b2908934ed8757725da6e6d22ff60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a3e2bbff42609e2e4089d5e6c55bbd" id="r_ga23a3e2bbff42609e2e4089d5e6c55bbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga23a3e2bbff42609e2e4089d5e6c55bbd">Socket_getsndbuf</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga23a3e2bbff42609e2e4089d5e6c55bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get send buffer size.  <br /></td></tr>
<tr class="separator:ga23a3e2bbff42609e2e4089d5e6c55bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59dc86a3f3728e75983daa0f5b34550" id="r_gad59dc86a3f3728e75983daa0f5b34550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad59dc86a3f3728e75983daa0f5b34550">Socket_setrcvbuf</a> (Socket_T socket, int size)</td></tr>
<tr class="memdesc:gad59dc86a3f3728e75983daa0f5b34550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set receive buffer size.  <br /></td></tr>
<tr class="separator:gad59dc86a3f3728e75983daa0f5b34550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430b3464f6e656f4d8884031deffa507" id="r_ga430b3464f6e656f4d8884031deffa507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga430b3464f6e656f4d8884031deffa507">Socket_setsndbuf</a> (Socket_T socket, int size)</td></tr>
<tr class="memdesc:ga430b3464f6e656f4d8884031deffa507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set send buffer size.  <br /></td></tr>
<tr class="separator:ga430b3464f6e656f4d8884031deffa507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae144a341a05e25011d95761368eefe13" id="r_gae144a341a05e25011d95761368eefe13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae144a341a05e25011d95761368eefe13">Socket_setcongestion</a> (Socket_T socket, const char *algorithm)</td></tr>
<tr class="memdesc:gae144a341a05e25011d95761368eefe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set TCP congestion control algorithm.  <br /></td></tr>
<tr class="separator:gae144a341a05e25011d95761368eefe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaf7f944985462e9198998a650f2b5c" id="r_gaebaf7f944985462e9198998a650f2b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaebaf7f944985462e9198998a650f2b5c">Socket_getcongestion</a> (Socket_T socket, char *algorithm, size_t len)</td></tr>
<tr class="memdesc:gaebaf7f944985462e9198998a650f2b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP congestion control algorithm.  <br /></td></tr>
<tr class="separator:gaebaf7f944985462e9198998a650f2b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c1651e6f9e3e97ddab01d40ac1d39d" id="r_gaa7c1651e6f9e3e97ddab01d40ac1d39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa7c1651e6f9e3e97ddab01d40ac1d39d">Socket_setfastopen</a> (Socket_T socket, int enable)</td></tr>
<tr class="memdesc:gaa7c1651e6f9e3e97ddab01d40ac1d39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TCP Fast Open.  <br /></td></tr>
<tr class="separator:gaa7c1651e6f9e3e97ddab01d40ac1d39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762ad6759e76f58f5a8f1fcb305387a8" id="r_ga762ad6759e76f58f5a8f1fcb305387a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga762ad6759e76f58f5a8f1fcb305387a8">Socket_getfastopen</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga762ad6759e76f58f5a8f1fcb305387a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP Fast Open setting.  <br /></td></tr>
<tr class="separator:ga762ad6759e76f58f5a8f1fcb305387a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfad0f5567b5f8720a4667e13e79f282" id="r_gabfad0f5567b5f8720a4667e13e79f282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabfad0f5567b5f8720a4667e13e79f282">Socket_setusertimeout</a> (Socket_T socket, unsigned int timeout_ms)</td></tr>
<tr class="memdesc:gabfad0f5567b5f8720a4667e13e79f282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set TCP user timeout.  <br /></td></tr>
<tr class="separator:gabfad0f5567b5f8720a4667e13e79f282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b81fe340e400d96d2552a65cfde5430" id="r_ga2b81fe340e400d96d2552a65cfde5430"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2b81fe340e400d96d2552a65cfde5430">Socket_getusertimeout</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga2b81fe340e400d96d2552a65cfde5430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP user timeout.  <br /></td></tr>
<tr class="separator:ga2b81fe340e400d96d2552a65cfde5430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559b1aaebbe5d0ca69ec99e15b1c7e68" id="r_ga559b1aaebbe5d0ca69ec99e15b1c7e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga559b1aaebbe5d0ca69ec99e15b1c7e68">Socket_shutdown</a> (Socket_T socket, int how)</td></tr>
<tr class="memdesc:ga559b1aaebbe5d0ca69ec99e15b1c7e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable further sends and/or receives.  <br /></td></tr>
<tr class="separator:ga559b1aaebbe5d0ca69ec99e15b1c7e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ad1f92bb3233c463ea4067b69f73c2" id="r_ga18ad1f92bb3233c463ea4067b69f73c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga18ad1f92bb3233c463ea4067b69f73c2">Socket_setcloexec</a> (Socket_T socket, int enable)</td></tr>
<tr class="memdesc:ga18ad1f92bb3233c463ea4067b69f73c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control close-on-exec flag.  <br /></td></tr>
<tr class="separator:ga18ad1f92bb3233c463ea4067b69f73c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b9e684faf1a8d5c1ccb9e231ef1354" id="r_gab5b9e684faf1a8d5c1ccb9e231ef1354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab5b9e684faf1a8d5c1ccb9e231ef1354">Socket_setdeferaccept</a> (Socket_T socket, int timeout_sec)</td></tr>
<tr class="memdesc:gab5b9e684faf1a8d5c1ccb9e231ef1354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable TCP_DEFER_ACCEPT.  <br /></td></tr>
<tr class="separator:gab5b9e684faf1a8d5c1ccb9e231ef1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f9fc5782bf3caf5228e458d3f3c112" id="r_ga80f9fc5782bf3caf5228e458d3f3c112"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga80f9fc5782bf3caf5228e458d3f3c112">Socket_getdeferaccept</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga80f9fc5782bf3caf5228e458d3f3c112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TCP_DEFER_ACCEPT timeout.  <br /></td></tr>
<tr class="separator:ga80f9fc5782bf3caf5228e458d3f3c112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa0449e34ebfb141da236023da3edb7" id="r_ga5fa0449e34ebfb141da236023da3edb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5fa0449e34ebfb141da236023da3edb7">Socket_timeouts_get</a> (const Socket_T socket, <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:ga5fa0449e34ebfb141da236023da3edb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve per-socket timeout configuration.  <br /></td></tr>
<tr class="separator:ga5fa0449e34ebfb141da236023da3edb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3b95a49618f5a56869606adeeda58f" id="r_ga3e3b95a49618f5a56869606adeeda58f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f">Socket_timeouts_set</a> (Socket_T socket, const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:ga3e3b95a49618f5a56869606adeeda58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set per-socket timeout configuration.  <br /></td></tr>
<tr class="separator:ga3e3b95a49618f5a56869606adeeda58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcc79428e54b0284cc7cad257d56adf" id="r_gacfcc79428e54b0284cc7cad257d56adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacfcc79428e54b0284cc7cad257d56adf">Socket_timeouts_getdefaults</a> (<a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:gacfcc79428e54b0284cc7cad257d56adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global default timeouts.  <br /></td></tr>
<tr class="separator:gacfcc79428e54b0284cc7cad257d56adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0385e87c51740c37c9d90ff5bba1eced" id="r_ga0385e87c51740c37c9d90ff5bba1eced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0385e87c51740c37c9d90ff5bba1eced">Socket_timeouts_setdefaults</a> (const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:ga0385e87c51740c37c9d90ff5bba1eced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global default timeouts.  <br /></td></tr>
<tr class="separator:ga0385e87c51740c37c9d90ff5bba1eced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad663873fbc8f0846c092a380f64b1f52" id="r_gad663873fbc8f0846c092a380f64b1f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad663873fbc8f0846c092a380f64b1f52">Socket_timeouts_set_extended</a> (Socket_T socket, const <a class="el" href="group__foundation.html#structSocketTimeouts__Extended__T">SocketTimeouts_Extended_T</a> *extended)</td></tr>
<tr class="memdesc:gad663873fbc8f0846c092a380f64b1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set per-socket extended timeout configuration.  <br /></td></tr>
<tr class="separator:gad663873fbc8f0846c092a380f64b1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4affc77e30721f266acfc9ba7870dff5" id="r_ga4affc77e30721f266acfc9ba7870dff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4affc77e30721f266acfc9ba7870dff5">Socket_timeouts_get_extended</a> (const Socket_T socket, <a class="el" href="group__foundation.html#structSocketTimeouts__Extended__T">SocketTimeouts_Extended_T</a> *extended)</td></tr>
<tr class="memdesc:ga4affc77e30721f266acfc9ba7870dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve per-socket extended timeout configuration.  <br /></td></tr>
<tr class="separator:ga4affc77e30721f266acfc9ba7870dff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab565f9a6e6c40c56d6d21df89b30a9" id="r_gacab565f9a6e6c40c56d6d21df89b30a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacab565f9a6e6c40c56d6d21df89b30a9">Socket_setbandwidth</a> (Socket_T socket, size_t bytes_per_sec)</td></tr>
<tr class="memdesc:gacab565f9a6e6c40c56d6d21df89b30a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bandwidth limit for socket.  <br /></td></tr>
<tr class="separator:gacab565f9a6e6c40c56d6d21df89b30a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49a9ad4c524354506bef71ec6cffdf9" id="r_gae49a9ad4c524354506bef71ec6cffdf9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae49a9ad4c524354506bef71ec6cffdf9">Socket_getbandwidth</a> (Socket_T socket)</td></tr>
<tr class="memdesc:gae49a9ad4c524354506bef71ec6cffdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bandwidth limit for socket.  <br /></td></tr>
<tr class="separator:gae49a9ad4c524354506bef71ec6cffdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274b6782b2029d2d8aa33579ad60a4c1" id="r_ga274b6782b2029d2d8aa33579ad60a4c1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga274b6782b2029d2d8aa33579ad60a4c1">Socket_send_limited</a> (Socket_T socket, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ga274b6782b2029d2d8aa33579ad60a4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data with bandwidth limiting.  <br /></td></tr>
<tr class="separator:ga274b6782b2029d2d8aa33579ad60a4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6839d0b5738d2764b47de35bf7e16430" id="r_ga6839d0b5738d2764b47de35bf7e16430"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6839d0b5738d2764b47de35bf7e16430">Socket_recv_limited</a> (Socket_T socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:ga6839d0b5738d2764b47de35bf7e16430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data with bandwidth limiting.  <br /></td></tr>
<tr class="separator:ga6839d0b5738d2764b47de35bf7e16430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89643e52780099fe0012e2fa22725e07" id="r_ga89643e52780099fe0012e2fa22725e07"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga89643e52780099fe0012e2fa22725e07">Socket_bandwidth_wait_ms</a> (Socket_T socket, size_t bytes)</td></tr>
<tr class="memdesc:ga89643e52780099fe0012e2fa22725e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get wait time until bandwidth available.  <br /></td></tr>
<tr class="separator:ga89643e52780099fe0012e2fa22725e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85ee4be563a1006b7518645995ab65e" id="r_gad85ee4be563a1006b7518645995ab65e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e">Socket_bind_unix</a> (Socket_T socket, const char *path)</td></tr>
<tr class="memdesc:gad85ee4be563a1006b7518645995ab65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to Unix domain socket path.  <br /></td></tr>
<tr class="separator:gad85ee4be563a1006b7518645995ab65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad353c95a8994569af7b650f1fda7036f" id="r_gad353c95a8994569af7b650f1fda7036f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad353c95a8994569af7b650f1fda7036f">Socket_connect_unix</a> (Socket_T socket, const char *path)</td></tr>
<tr class="memdesc:gad353c95a8994569af7b650f1fda7036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to Unix domain socket path.  <br /></td></tr>
<tr class="separator:gad353c95a8994569af7b650f1fda7036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc2fdbcfb3c619c05c7aa3c4c555382" id="r_gaabc2fdbcfb3c619c05c7aa3c4c555382"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaabc2fdbcfb3c619c05c7aa3c4c555382">Socket_getpeerpid</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:gaabc2fdbcfb3c619c05c7aa3c4c555382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peer process ID (Linux only).  <br /></td></tr>
<tr class="separator:gaabc2fdbcfb3c619c05c7aa3c4c555382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf945a195478ed5a85c881b0f163a08" id="r_ga0bf945a195478ed5a85c881b0f163a08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0bf945a195478ed5a85c881b0f163a08">Socket_getpeeruid</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga0bf945a195478ed5a85c881b0f163a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peer user ID (Linux only).  <br /></td></tr>
<tr class="separator:ga0bf945a195478ed5a85c881b0f163a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a5bd6dc33ef5f000b9f7d334a1fdfa" id="r_ga64a5bd6dc33ef5f000b9f7d334a1fdfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga64a5bd6dc33ef5f000b9f7d334a1fdfa">Socket_getpeergid</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga64a5bd6dc33ef5f000b9f7d334a1fdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get peer group ID (Linux only).  <br /></td></tr>
<tr class="separator:ga64a5bd6dc33ef5f000b9f7d334a1fdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001e932180b059a805ca53a8edbeef15" id="r_ga001e932180b059a805ca53a8edbeef15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga001e932180b059a805ca53a8edbeef15">Socket_sendfd</a> (Socket_T socket, int fd_to_pass)</td></tr>
<tr class="memdesc:ga001e932180b059a805ca53a8edbeef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a file descriptor over Unix domain socket.  <br /></td></tr>
<tr class="separator:ga001e932180b059a805ca53a8edbeef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1236a73c0cac828b3079b74d1b0996d" id="r_gad1236a73c0cac828b3079b74d1b0996d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad1236a73c0cac828b3079b74d1b0996d">Socket_recvfd</a> (Socket_T socket, int *fd_received)</td></tr>
<tr class="memdesc:gad1236a73c0cac828b3079b74d1b0996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a file descriptor over Unix domain socket.  <br /></td></tr>
<tr class="separator:gad1236a73c0cac828b3079b74d1b0996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c2f94b87d307842c7d11de0b6a2bce" id="r_ga70c2f94b87d307842c7d11de0b6a2bce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga70c2f94b87d307842c7d11de0b6a2bce">Socket_sendfds</a> (Socket_T socket, const int *fds, size_t count)</td></tr>
<tr class="memdesc:ga70c2f94b87d307842c7d11de0b6a2bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send multiple file descriptors.  <br /></td></tr>
<tr class="separator:ga70c2f94b87d307842c7d11de0b6a2bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab806cbdac1b78ff644c4f841151cf3a8" id="r_gab806cbdac1b78ff644c4f841151cf3a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab806cbdac1b78ff644c4f841151cf3a8">Socket_recvfds</a> (Socket_T socket, int *fds, size_t max_count, size_t *received_count)</td></tr>
<tr class="memdesc:gab806cbdac1b78ff644c4f841151cf3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple file descriptors.  <br /></td></tr>
<tr class="separator:gab806cbdac1b78ff644c4f841151cf3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12cd27d2531c8ea2b762e0ab4659d63" id="r_gad12cd27d2531c8ea2b762e0ab4659d63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad12cd27d2531c8ea2b762e0ab4659d63">SocketUnix_bind</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const char *path, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gad12cd27d2531c8ea2b762e0ab4659d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind Unix domain socket to a filesystem path.  <br /></td></tr>
<tr class="separator:gad12cd27d2531c8ea2b762e0ab4659d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadda7c72f287b85c490f04aec8623e1" id="r_gafadda7c72f287b85c490f04aec8623e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafadda7c72f287b85c490f04aec8623e1">SocketUnix_connect</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const char *path, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gafadda7c72f287b85c490f04aec8623e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect Unix domain socket to a filesystem path.  <br /></td></tr>
<tr class="separator:gafadda7c72f287b85c490f04aec8623e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039fc234ac9f3aa259ea01e22218e442" id="r_ga039fc234ac9f3aa259ea01e22218e442"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga039fc234ac9f3aa259ea01e22218e442">SocketUnix_validate_unix_path</a> (const char *path, size_t path_len)</td></tr>
<tr class="memdesc:ga039fc234ac9f3aa259ea01e22218e442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a Unix domain socket path.  <br /></td></tr>
<tr class="separator:ga039fc234ac9f3aa259ea01e22218e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4812aea6cf0f2c665825d6cb35d49da" id="r_gab4812aea6cf0f2c665825d6cb35d49da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da">Socket_bind_async</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, Socket_T socket, const char *host, int port)</td></tr>
<tr class="memdesc:gab4812aea6cf0f2c665825d6cb35d49da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start async DNS resolution for bind.  <br /></td></tr>
<tr class="separator:gab4812aea6cf0f2c665825d6cb35d49da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ca42197a8a1d7151a3cee15c093dea" id="r_ga36ca42197a8a1d7151a3cee15c093dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga36ca42197a8a1d7151a3cee15c093dea">Socket_bind_async_cancel</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga36ca42197a8a1d7151a3cee15c093dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel pending async bind resolution.  <br /></td></tr>
<tr class="separator:ga36ca42197a8a1d7151a3cee15c093dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ab3a8c8b70328f9b72cc5a1e771e87" id="r_ga04ab3a8c8b70328f9b72cc5a1e771e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87">Socket_connect_async</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, Socket_T socket, const char *host, int port)</td></tr>
<tr class="memdesc:ga04ab3a8c8b70328f9b72cc5a1e771e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start async DNS resolution for connect.  <br /></td></tr>
<tr class="separator:ga04ab3a8c8b70328f9b72cc5a1e771e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f9515df873a2af7b054451afec8fd71" id="r_ga0f9515df873a2af7b054451afec8fd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0f9515df873a2af7b054451afec8fd71">Socket_connect_async_cancel</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> req)</td></tr>
<tr class="memdesc:ga0f9515df873a2af7b054451afec8fd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel pending async connect resolution.  <br /></td></tr>
<tr class="separator:ga0f9515df873a2af7b054451afec8fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7147a127f3463d5861da5a16435ef4e7" id="r_ga7147a127f3463d5861da5a16435ef4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7147a127f3463d5861da5a16435ef4e7">Socket_bind_with_addrinfo</a> (Socket_T socket, struct addrinfo *res)</td></tr>
<tr class="memdesc:ga7147a127f3463d5861da5a16435ef4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind socket using resolved address.  <br /></td></tr>
<tr class="separator:ga7147a127f3463d5861da5a16435ef4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28271af8ebad671a64fd37ffb2d07e0c" id="r_ga28271af8ebad671a64fd37ffb2d07e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga28271af8ebad671a64fd37ffb2d07e0c">Socket_connect_with_addrinfo</a> (Socket_T socket, struct addrinfo *res)</td></tr>
<tr class="memdesc:ga28271af8ebad671a64fd37ffb2d07e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect socket using resolved address.  <br /></td></tr>
<tr class="separator:ga28271af8ebad671a64fd37ffb2d07e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410b67062c053c3af7e86531acc1620c" id="r_ga410b67062c053c3af7e86531acc1620c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga410b67062c053c3af7e86531acc1620c">Socket_ignore_sigpipe</a> (void)</td></tr>
<tr class="memdesc:ga410b67062c053c3af7e86531acc1620c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally ignore SIGPIPE signal.  <br /></td></tr>
<tr class="separator:ga410b67062c053c3af7e86531acc1620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf72952b9d7d0e4fc8255de6c92fbe11" id="r_gabf72952b9d7d0e4fc8255de6c92fbe11"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabf72952b9d7d0e4fc8255de6c92fbe11">Socket_listen_tcp</a> (const char *host, int port, int backlog)</td></tr>
<tr class="memdesc:gabf72952b9d7d0e4fc8255de6c92fbe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a listening TCP server socket in one call.  <br /></td></tr>
<tr class="separator:gabf72952b9d7d0e4fc8255de6c92fbe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7e9cc726b2eeabb19787f27e931fd7" id="r_ga2f7e9cc726b2eeabb19787f27e931fd7"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2f7e9cc726b2eeabb19787f27e931fd7">Socket_connect_tcp</a> (const char *host, int port, int timeout_ms)</td></tr>
<tr class="memdesc:ga2f7e9cc726b2eeabb19787f27e931fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connected TCP client socket in one call.  <br /></td></tr>
<tr class="separator:ga2f7e9cc726b2eeabb19787f27e931fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63fc7b454ab8202278b1e3073ec961a0" id="r_ga63fc7b454ab8202278b1e3073ec961a0"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga63fc7b454ab8202278b1e3073ec961a0">Socket_accept_timeout</a> (Socket_T socket, int timeout_ms)</td></tr>
<tr class="memdesc:ga63fc7b454ab8202278b1e3073ec961a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept incoming connection with explicit timeout.  <br /></td></tr>
<tr class="separator:ga63fc7b454ab8202278b1e3073ec961a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab85e4ae7965fc1334bbc547642dcdd42" id="r_gab85e4ae7965fc1334bbc547642dcdd42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab85e4ae7965fc1334bbc547642dcdd42">Socket_connect_nonblocking</a> (Socket_T socket, const char *ip_address, int port)</td></tr>
<tr class="memdesc:gab85e4ae7965fc1334bbc547642dcdd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate non-blocking connect (no DNS, IP address only).  <br /></td></tr>
<tr class="separator:gab85e4ae7965fc1334bbc547642dcdd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295887e87b95de840e1a5c5ad4d7f530" id="r_ga295887e87b95de840e1a5c5ad4d7f530"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga295887e87b95de840e1a5c5ad4d7f530">Socket_listen_unix</a> (const char *path, int backlog)</td></tr>
<tr class="memdesc:ga295887e87b95de840e1a5c5ad4d7f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a listening Unix domain socket in one call.  <br /></td></tr>
<tr class="separator:ga295887e87b95de840e1a5c5ad4d7f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e27e618c92028d428e4d58aec6818c8" id="r_ga1e27e618c92028d428e4d58aec6818c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1e27e618c92028d428e4d58aec6818c8">Socket_connect_unix_timeout</a> (Socket_T socket, const char *path, int timeout_ms)</td></tr>
<tr class="memdesc:ga1e27e618c92028d428e4d58aec6818c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to Unix domain socket with timeout.  <br /></td></tr>
<tr class="separator:ga1e27e618c92028d428e4d58aec6818c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82b13f33ba79d9fa97582a64654e8ef" id="r_gac82b13f33ba79d9fa97582a64654e8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef">SocketBuf_new</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, size_t capacity)</td></tr>
<tr class="memdesc:gac82b13f33ba79d9fa97582a64654e8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new circular buffer with specified initial capacity.  <br /></td></tr>
<tr class="separator:gac82b13f33ba79d9fa97582a64654e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e38c8dbadd8bd771d70ec98eda9f448" id="r_ga7e38c8dbadd8bd771d70ec98eda9f448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> *buf)</td></tr>
<tr class="memdesc:ga7e38c8dbadd8bd771d70ec98eda9f448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the buffer handle and invalidate the pointer.  <br /></td></tr>
<tr class="separator:ga7e38c8dbadd8bd771d70ec98eda9f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad296e666bf8d65669ab7c71d6b8d97" id="r_gabad296e666bf8d65669ab7c71d6b8d97"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97">SocketBuf_write</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, const void *data, size_t len)</td></tr>
<tr class="memdesc:gabad296e666bf8d65669ab7c71d6b8d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the buffer.  <br /></td></tr>
<tr class="separator:gabad296e666bf8d65669ab7c71d6b8d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aacfb9008833f24abec18b1d65d0d42" id="r_ga4aacfb9008833f24abec18b1d65d0d42"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42">SocketBuf_read</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, void *data, size_t len)</td></tr>
<tr class="memdesc:ga4aacfb9008833f24abec18b1d65d0d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and remove data from the buffer.  <br /></td></tr>
<tr class="separator:ga4aacfb9008833f24abec18b1d65d0d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55cfa577b17ee4e2ea965a841deccab0" id="r_ga55cfa577b17ee4e2ea965a841deccab0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga55cfa577b17ee4e2ea965a841deccab0">SocketBuf_peek</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, void *data, size_t len)</td></tr>
<tr class="memdesc:ga55cfa577b17ee4e2ea965a841deccab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at data without removing it from the buffer.  <br /></td></tr>
<tr class="separator:ga55cfa577b17ee4e2ea965a841deccab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11c3dede8563afbb1a3e9b9f4e936e6" id="r_gad11c3dede8563afbb1a3e9b9f4e936e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad11c3dede8563afbb1a3e9b9f4e936e6">SocketBuf_consume</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t len)</td></tr>
<tr class="memdesc:gad11c3dede8563afbb1a3e9b9f4e936e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard data from the front of the buffer without reading it.  <br /></td></tr>
<tr class="separator:gad11c3dede8563afbb1a3e9b9f4e936e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f350e096708c438bc2002909325b143" id="r_ga4f350e096708c438bc2002909325b143"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143">SocketBuf_available</a> (const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga4f350e096708c438bc2002909325b143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of bytes available for reading.  <br /></td></tr>
<tr class="separator:ga4f350e096708c438bc2002909325b143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f511809edb33ba3ff3a051544bff0d1" id="r_ga4f511809edb33ba3ff3a051544bff0d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1">SocketBuf_space</a> (const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga4f511809edb33ba3ff3a051544bff0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of bytes available for writing.  <br /></td></tr>
<tr class="separator:ga4f511809edb33ba3ff3a051544bff0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga886e91e5cdff04cbc06b2d99eb887808" id="r_ga886e91e5cdff04cbc06b2d99eb887808"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga886e91e5cdff04cbc06b2d99eb887808">SocketBuf_empty</a> (const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga886e91e5cdff04cbc06b2d99eb887808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer contains no data.  <br /></td></tr>
<tr class="separator:ga886e91e5cdff04cbc06b2d99eb887808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae7a3d2576f6d28c91511e10790e99a" id="r_ga8ae7a3d2576f6d28c91511e10790e99a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8ae7a3d2576f6d28c91511e10790e99a">SocketBuf_full</a> (const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga8ae7a3d2576f6d28c91511e10790e99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer has no space for writing.  <br /></td></tr>
<tr class="separator:ga8ae7a3d2576f6d28c91511e10790e99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b062261e8e954240edf8d3a6a01fb8" id="r_ga61b062261e8e954240edf8d3a6a01fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga61b062261e8e954240edf8d3a6a01fb8">SocketBuf_clear</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga61b062261e8e954240edf8d3a6a01fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset buffer to empty state without zeroing memory.  <br /></td></tr>
<tr class="separator:ga61b062261e8e954240edf8d3a6a01fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f12ab9bbed33398141c41561c1fcb7" id="r_gaf0f12ab9bbed33398141c41561c1fcb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf0f12ab9bbed33398141c41561c1fcb7">SocketBuf_secureclear</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:gaf0f12ab9bbed33398141c41561c1fcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Securely erase all data by zeroing memory contents.  <br /></td></tr>
<tr class="separator:gaf0f12ab9bbed33398141c41561c1fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d70e899c26ac30bad4aac232505f1e" id="r_ga77d70e899c26ac30bad4aac232505f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e">SocketBuf_reserve</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t min_space)</td></tr>
<tr class="memdesc:ga77d70e899c26ac30bad4aac232505f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically resize buffer to ensure at least min_space available.  <br /></td></tr>
<tr class="separator:ga77d70e899c26ac30bad4aac232505f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884735923c2cf7dbe7def9d9062ac512" id="r_ga884735923c2cf7dbe7def9d9062ac512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga884735923c2cf7dbe7def9d9062ac512">SocketBuf_check_invariants</a> (const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga884735923c2cf7dbe7def9d9062ac512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate internal buffer consistency without assertions.  <br /></td></tr>
<tr class="separator:ga884735923c2cf7dbe7def9d9062ac512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d5d95ed126030f6414b7f607cd555e" id="r_gae4d5d95ed126030f6414b7f607cd555e"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae4d5d95ed126030f6414b7f607cd555e">SocketBuf_readptr</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t *len)</td></tr>
<tr class="memdesc:gae4d5d95ed126030f6414b7f607cd555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a direct pointer to readable data for zero-copy access.  <br /></td></tr>
<tr class="separator:gae4d5d95ed126030f6414b7f607cd555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d845ceca49625b8c317310a757ad9dc" id="r_ga0d845ceca49625b8c317310a757ad9dc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc">SocketBuf_writeptr</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t *len)</td></tr>
<tr class="memdesc:ga0d845ceca49625b8c317310a757ad9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a direct pointer for zero-copy writing into the buffer.  <br /></td></tr>
<tr class="separator:ga0d845ceca49625b8c317310a757ad9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4e93aa0feab70464515b0ef3a57186" id="r_ga2e4e93aa0feab70464515b0ef3a57186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2e4e93aa0feab70464515b0ef3a57186">SocketBuf_written</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t len)</td></tr>
<tr class="memdesc:ga2e4e93aa0feab70464515b0ef3a57186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit bytes written via direct write pointer.  <br /></td></tr>
<tr class="separator:ga2e4e93aa0feab70464515b0ef3a57186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d28ec4481d1f695ddda98a9cf069dc" id="r_ga42d28ec4481d1f695ddda98a9cf069dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga42d28ec4481d1f695ddda98a9cf069dc">SocketBuf_compact</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf)</td></tr>
<tr class="memdesc:ga42d28ec4481d1f695ddda98a9cf069dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move data to front of buffer, maximizing contiguous write space.  <br /></td></tr>
<tr class="separator:ga42d28ec4481d1f695ddda98a9cf069dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474df61426f231015e3efbf1afd0687d" id="r_ga474df61426f231015e3efbf1afd0687d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga474df61426f231015e3efbf1afd0687d">SocketBuf_ensure</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, size_t min_space)</td></tr>
<tr class="memdesc:ga474df61426f231015e3efbf1afd0687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure minimum write space is available, resizing if necessary.  <br /></td></tr>
<tr class="separator:ga474df61426f231015e3efbf1afd0687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600c7d30acf5132a0e790140aacba506" id="r_ga600c7d30acf5132a0e790140aacba506"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga600c7d30acf5132a0e790140aacba506">SocketBuf_find</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, const void *needle, size_t needle_len)</td></tr>
<tr class="memdesc:ga600c7d30acf5132a0e790140aacba506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a byte sequence in the buffer.  <br /></td></tr>
<tr class="separator:ga600c7d30acf5132a0e790140aacba506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da1d72bb58c67433db7e075b833a47b" id="r_ga3da1d72bb58c67433db7e075b833a47b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga3da1d72bb58c67433db7e075b833a47b">SocketBuf_readline</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, char *line, size_t max_len)</td></tr>
<tr class="memdesc:ga3da1d72bb58c67433db7e075b833a47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line (up to and including newline) from the buffer.  <br /></td></tr>
<tr class="separator:ga3da1d72bb58c67433db7e075b833a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf29683accb04578c0fb3869d31ba1d" id="r_gaaaf29683accb04578c0fb3869d31ba1d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaaaf29683accb04578c0fb3869d31ba1d">SocketBuf_readv</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:gaaaf29683accb04578c0fb3869d31ba1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter read from buffer into multiple iovecs.  <br /></td></tr>
<tr class="separator:gaaaf29683accb04578c0fb3869d31ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315c19dd862a58b89ca13f3fb1165d09" id="r_ga315c19dd862a58b89ca13f3fb1165d09"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga315c19dd862a58b89ca13f3fb1165d09">SocketBuf_writev</a> (<a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ga315c19dd862a58b89ca13f3fb1165d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather write from multiple iovecs into buffer.  <br /></td></tr>
<tr class="separator:ga315c19dd862a58b89ca13f3fb1165d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7094c29ef2257e271eb2e6be911dd2ab" id="r_ga7094c29ef2257e271eb2e6be911dd2ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7094c29ef2257e271eb2e6be911dd2ab">SocketBase_fd</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:ga7094c29ef2257e271eb2e6be911dd2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the socket file descriptor from the base structure.  <br /></td></tr>
<tr class="separator:ga7094c29ef2257e271eb2e6be911dd2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae819168ebf1a49f132758d251e14958c" id="r_gae819168ebf1a49f132758d251e14958c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae819168ebf1a49f132758d251e14958c">SocketBase_arena</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:gae819168ebf1a49f132758d251e14958c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory arena associated with the socket base.  <br /></td></tr>
<tr class="separator:gae819168ebf1a49f132758d251e14958c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16683bd3c975d0bc23a0ebf7df57767" id="r_gaa16683bd3c975d0bc23a0ebf7df57767"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa16683bd3c975d0bc23a0ebf7df57767">SocketBase_domain</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:gaa16683bd3c975d0bc23a0ebf7df57767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address domain (family) of the socket.  <br /></td></tr>
<tr class="separator:gaa16683bd3c975d0bc23a0ebf7df57767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad581bb396e7b4577cafb85f46586c307" id="r_gad581bb396e7b4577cafb85f46586c307"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad581bb396e7b4577cafb85f46586c307">SocketBase_remoteaddr</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:gad581bb396e7b4577cafb85f46586c307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cached remote address string representation.  <br /></td></tr>
<tr class="separator:gad581bb396e7b4577cafb85f46586c307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61536a3bd580b6f1321a38fa7098387c" id="r_ga61536a3bd580b6f1321a38fa7098387c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga61536a3bd580b6f1321a38fa7098387c">SocketBase_remoteport</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:ga61536a3bd580b6f1321a38fa7098387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remote peer port number.  <br /></td></tr>
<tr class="separator:ga61536a3bd580b6f1321a38fa7098387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d501b6ffc63a265a180b903abb26ef" id="r_ga65d501b6ffc63a265a180b903abb26ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga65d501b6ffc63a265a180b903abb26ef">SocketBase_set_timeouts</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:ga65d501b6ffc63a265a180b903abb26ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeouts configuration in the socket base structure.  <br /></td></tr>
<tr class="separator:ga65d501b6ffc63a265a180b903abb26ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64fef3c801aa2661b32ec73f368458f0" id="r_ga64fef3c801aa2661b32ec73f368458f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga64fef3c801aa2661b32ec73f368458f0">SocketCommon_create_fd</a> (int domain, int type, int protocol, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga64fef3c801aa2661b32ec73f368458f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new socket file descriptor with error handling and CLOEXEC setup.  <br /></td></tr>
<tr class="separator:ga64fef3c801aa2661b32ec73f368458f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa5d2cb4d591e902973e55dc9f1282d" id="r_ga1aa5d2cb4d591e902973e55dc9f1282d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d">SocketCommon_init_base</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, int fd, int domain, int type, int protocol, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga1aa5d2cb4d591e902973e55dc9f1282d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize pre-allocated <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> with FD and parameters.  <br /></td></tr>
<tr class="separator:ga1aa5d2cb4d591e902973e55dc9f1282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37fe3d789eae0e522f29fca1ec49956" id="r_gac37fe3d789eae0e522f29fca1ec49956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac37fe3d789eae0e522f29fca1ec49956">socketcommon_sanitize_timeout</a> (int timeout_ms)</td></tr>
<tr class="memdesc:gac37fe3d789eae0e522f29fca1ec49956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanitize raw timeout value, applying library policy for valid range.  <br /></td></tr>
<tr class="separator:gac37fe3d789eae0e522f29fca1ec49956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47abb5d32959260cc8251419d652de1b" id="r_ga47abb5d32959260cc8251419d652de1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b">SocketCommon_setup_hints</a> (struct addrinfo *hints, int socktype, int flags)</td></tr>
<tr class="memdesc:ga47abb5d32959260cc8251419d652de1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize addrinfo hints structure for address resolution operations.  <br /></td></tr>
<tr class="separator:ga47abb5d32959260cc8251419d652de1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc66958f42deef2824a80188baf4534" id="r_ga7fc66958f42deef2824a80188baf4534"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534">SocketCommon_resolve_address</a> (const char *host, int port, const struct addrinfo *hints, struct addrinfo **res, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type, int socket_family, int use_exceptions)</td></tr>
<tr class="memdesc:ga7fc66958f42deef2824a80188baf4534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.  <br /></td></tr>
<tr class="separator:ga7fc66958f42deef2824a80188baf4534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac849aa92d4bd728b61c37b6e63e2a804" id="r_gac849aa92d4bd728b61c37b6e63e2a804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804">SocketCommon_validate_port</a> (int port, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:gac849aa92d4bd728b61c37b6e63e2a804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that a port number is within the valid range for socket operations.  <br /></td></tr>
<tr class="separator:gac849aa92d4bd728b61c37b6e63e2a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab782ed7ac027b9d3c92cb4bef1b20b4a" id="r_gab782ed7ac027b9d3c92cb4bef1b20b4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab782ed7ac027b9d3c92cb4bef1b20b4a">SocketCommon_validate_hostname</a> (const char *host, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:gab782ed7ac027b9d3c92cb4bef1b20b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that a hostname string is not excessively long for system buffers.  <br /></td></tr>
<tr class="separator:gab782ed7ac027b9d3c92cb4bef1b20b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b10ea8fcfd5f154b54d81a8000c827" id="r_ga68b10ea8fcfd5f154b54d81a8000c827"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga68b10ea8fcfd5f154b54d81a8000c827">SocketCommon_normalize_wildcard_host</a> (const char *host)</td></tr>
<tr class="memdesc:ga68b10ea8fcfd5f154b54d81a8000c827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize wildcard/any-address host strings to NULL for internal use.  <br /></td></tr>
<tr class="separator:ga68b10ea8fcfd5f154b54d81a8000c827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc31bff834af43e2a6ee2facd9951d4" id="r_gadfc31bff834af43e2a6ee2facd9951d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4">SocketCommon_cache_endpoint</a> (<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, const struct sockaddr *addr, socklen_t addrlen, char **addr_out, int *port_out)</td></tr>
<tr class="memdesc:gadfc31bff834af43e2a6ee2facd9951d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract and cache human-readable numeric address and port from sockaddr structure.  <br /></td></tr>
<tr class="separator:gadfc31bff834af43e2a6ee2facd9951d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3eb3f6fe09b2b58693a7044631916d8" id="r_gad3eb3f6fe09b2b58693a7044631916d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad3eb3f6fe09b2b58693a7044631916d8">SocketCommon_setcloexec</a> (int fd, int enable)</td></tr>
<tr class="memdesc:gad3eb3f6fe09b2b58693a7044631916d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or clear the close-on-exec (CLOEXEC) flag on a file descriptor.  <br /></td></tr>
<tr class="separator:gad3eb3f6fe09b2b58693a7044631916d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5641340520942ec7ba2412f3d50f3f12" id="r_ga5641340520942ec7ba2412f3d50f3f12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5641340520942ec7ba2412f3d50f3f12">SocketCommon_has_cloexec</a> (int fd)</td></tr>
<tr class="memdesc:ga5641340520942ec7ba2412f3d50f3f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if close-on-exec flag is set.  <br /></td></tr>
<tr class="separator:ga5641340520942ec7ba2412f3d50f3f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229de2f12f6169d6817195fb6490267d" id="r_ga229de2f12f6169d6817195fb6490267d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga229de2f12f6169d6817195fb6490267d">SocketCommon_getoption_int</a> (int fd, int level, int optname, int *value, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:ga229de2f12f6169d6817195fb6490267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get integer socket option.  <br /></td></tr>
<tr class="separator:ga229de2f12f6169d6817195fb6490267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c81dabc2c964625f56fd02b0a4f9c93" id="r_ga5c81dabc2c964625f56fd02b0a4f9c93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5c81dabc2c964625f56fd02b0a4f9c93">SocketCommon_getoption_timeval</a> (int fd, int level, int optname, struct timeval *tv, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:ga5c81dabc2c964625f56fd02b0a4f9c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timeval socket option.  <br /></td></tr>
<tr class="separator:ga5c81dabc2c964625f56fd02b0a4f9c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19eb14b9730f57df54eb5db71e1f5489" id="r_ga19eb14b9730f57df54eb5db71e1f5489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga19eb14b9730f57df54eb5db71e1f5489">SocketCommon_reverse_lookup</a> (const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:ga19eb14b9730f57df54eb5db71e1f5489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reverse DNS lookup (getnameinfo wrapper)  <br /></td></tr>
<tr class="separator:ga19eb14b9730f57df54eb5db71e1f5489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d4b6a3c291b6ebbb73c13743304b42" id="r_gaf8d4b6a3c291b6ebbb73c13743304b42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf8d4b6a3c291b6ebbb73c13743304b42">SocketCommon_parse_ip</a> (const char *ip_str, int *family)</td></tr>
<tr class="memdesc:gaf8d4b6a3c291b6ebbb73c13743304b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate and parse IP address string.  <br /></td></tr>
<tr class="separator:gaf8d4b6a3c291b6ebbb73c13743304b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5584b123bcf71749129a64c8312d0023" id="r_ga5584b123bcf71749129a64c8312d0023"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5584b123bcf71749129a64c8312d0023">SocketCommon_cidr_match</a> (const char *ip_str, const char *cidr_str)</td></tr>
<tr class="memdesc:ga5584b123bcf71749129a64c8312d0023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if IP address matches CIDR range.  <br /></td></tr>
<tr class="separator:ga5584b123bcf71749129a64c8312d0023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9498d7bdb363435a4efce0f32011914" id="r_gae9498d7bdb363435a4efce0f32011914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914">SocketCommon_new_base</a> (int domain, int type, int protocol)</td></tr>
<tr class="memdesc:gae9498d7bdb363435a4efce0f32011914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new socket base structure.  <br /></td></tr>
<tr class="separator:gae9498d7bdb363435a4efce0f32011914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb641ee1edaa618b8680babae9a98c6" id="r_gaaeb641ee1edaa618b8680babae9a98c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaaeb641ee1edaa618b8680babae9a98c6">SocketCommon_free_base</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> *base_ptr)</td></tr>
<tr class="memdesc:gaaeb641ee1edaa618b8680babae9a98c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a socket base structure.  <br /></td></tr>
<tr class="separator:gaaeb641ee1edaa618b8680babae9a98c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2e7917d36f5e23eab8c1238433dfba" id="r_ga0a2e7917d36f5e23eab8c1238433dfba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0a2e7917d36f5e23eab8c1238433dfba">SocketCommon_set_option_int</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, int level, int optname, int value, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga0a2e7917d36f5e23eab8c1238433dfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set integer socket option.  <br /></td></tr>
<tr class="separator:ga0a2e7917d36f5e23eab8c1238433dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eab30cecc7dae2a4c02efd95c5feae5" id="r_ga1eab30cecc7dae2a4c02efd95c5feae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1eab30cecc7dae2a4c02efd95c5feae5">SocketCommon_set_ttl</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, int family, int ttl, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga1eab30cecc7dae2a4c02efd95c5feae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set TTL or hop limit based on family.  <br /></td></tr>
<tr class="separator:ga1eab30cecc7dae2a4c02efd95c5feae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59068eaf0e0e017bb7492f2804a342b5" id="r_ga59068eaf0e0e017bb7492f2804a342b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga59068eaf0e0e017bb7492f2804a342b5">SocketCommon_join_multicast</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const char *group, const char *interface, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga59068eaf0e0e017bb7492f2804a342b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join multicast group.  <br /></td></tr>
<tr class="separator:ga59068eaf0e0e017bb7492f2804a342b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4923693d222515c078f6bcfbf9d0f5" id="r_ga1c4923693d222515c078f6bcfbf9d0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1c4923693d222515c078f6bcfbf9d0f5">SocketCommon_leave_multicast</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const char *group, const char *interface, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga1c4923693d222515c078f6bcfbf9d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave multicast group.  <br /></td></tr>
<tr class="separator:ga1c4923693d222515c078f6bcfbf9d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff179c5fc64896d364008582e755a8c4" id="r_gaff179c5fc64896d364008582e755a8c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaff179c5fc64896d364008582e755a8c4">SocketCommon_set_nonblock</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, bool enable, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gaff179c5fc64896d364008582e755a8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set non-blocking mode.  <br /></td></tr>
<tr class="separator:gaff179c5fc64896d364008582e755a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb36ce89ba4091b0a1bee148506d586b" id="r_gabb36ce89ba4091b0a1bee148506d586b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabb36ce89ba4091b0a1bee148506d586b">SocketCommon_calculate_total_iov_len</a> (const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:gabb36ce89ba4091b0a1bee148506d586b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate total length of iovec array with overflow protection.  <br /></td></tr>
<tr class="separator:gabb36ce89ba4091b0a1bee148506d586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33af6b6698782c490ff383bb37c197e7" id="r_ga33af6b6698782c490ff383bb37c197e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga33af6b6698782c490ff383bb37c197e7">SocketCommon_advance_iov</a> (struct iovec *iov, int iovcnt, size_t bytes)</td></tr>
<tr class="memdesc:ga33af6b6698782c490ff383bb37c197e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance iovec array past sent/received bytes (modifies in place)  <br /></td></tr>
<tr class="separator:ga33af6b6698782c490ff383bb37c197e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9037b75f684ba9a4fda235b0bf0ca0" id="r_ga0b9037b75f684ba9a4fda235b0bf0ca0"><td class="memItemLeft" align="right" valign="top">struct iovec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0b9037b75f684ba9a4fda235b0bf0ca0">SocketCommon_find_active_iov</a> (struct iovec *iov, int iovcnt, int *active_iovcnt)</td></tr>
<tr class="memdesc:ga0b9037b75f684ba9a4fda235b0bf0ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first non-empty iovec in array.  <br /></td></tr>
<tr class="separator:ga0b9037b75f684ba9a4fda235b0bf0ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad5b4b92ce57c8168a7cb4462ee73d99" id="r_gaad5b4b92ce57c8168a7cb4462ee73d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaad5b4b92ce57c8168a7cb4462ee73d99">SocketCommon_sync_iov_progress</a> (struct iovec *original, const struct iovec *copy, int iovcnt)</td></tr>
<tr class="memdesc:gaad5b4b92ce57c8168a7cb4462ee73d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync original iovec with working copy progress.  <br /></td></tr>
<tr class="separator:gaad5b4b92ce57c8168a7cb4462ee73d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccd95f99962c7a6631b93bf9adfea4d" id="r_ga0ccd95f99962c7a6631b93bf9adfea4d"><td class="memItemLeft" align="right" valign="top">struct iovec *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga0ccd95f99962c7a6631b93bf9adfea4d">SocketCommon_alloc_iov_copy</a> (const struct iovec *iov, int iovcnt, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:ga0ccd95f99962c7a6631b93bf9adfea4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and copy iovec array.  <br /></td></tr>
<tr class="separator:ga0ccd95f99962c7a6631b93bf9adfea4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32f45a0216c1be50d0a411459bc426c" id="r_gac32f45a0216c1be50d0a411459bc426c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac32f45a0216c1be50d0a411459bc426c">SocketCommon_set_cloexec_fd</a> (int fd, bool enable, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gac32f45a0216c1be50d0a411459bc426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set close-on-exec flag on fd (unifies dups)  <br /></td></tr>
<tr class="separator:gac32f45a0216c1be50d0a411459bc426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecff13e4edc3230da4141714e2e9297f" id="r_gaecff13e4edc3230da4141714e2e9297f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaecff13e4edc3230da4141714e2e9297f">SocketCommon_try_bind_address</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, const struct sockaddr *addr, socklen_t addrlen, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gaecff13e4edc3230da4141714e2e9297f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try bind fd to address (extracted from Socket.c)  <br /></td></tr>
<tr class="separator:gaecff13e4edc3230da4141714e2e9297f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae257e8500385dffd243e9be383ade862" id="r_gae257e8500385dffd243e9be383ade862"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae257e8500385dffd243e9be383ade862">SocketCommon_try_bind_resolved_addresses</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base, struct addrinfo *res, int family, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gae257e8500385dffd243e9be383ade862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try bind to resolved addrinfo list.  <br /></td></tr>
<tr class="separator:gae257e8500385dffd243e9be383ade862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28feafa0784876f732f4b79e03dcc8b" id="r_gab28feafa0784876f732f4b79e03dcc8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab28feafa0784876f732f4b79e03dcc8b">SocketCommon_handle_bind_error</a> (int err, const char *addr_str, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exc_type)</td></tr>
<tr class="memdesc:gab28feafa0784876f732f4b79e03dcc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log and raise bind error.  <br /></td></tr>
<tr class="separator:gab28feafa0784876f732f4b79e03dcc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c533bda5b245453885e07e2a7b4e83" id="r_gae1c533bda5b245453885e07e2a7b4e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae1c533bda5b245453885e07e2a7b4e83">SocketCommon_format_bind_error</a> (const char *host, int port)</td></tr>
<tr class="memdesc:gae1c533bda5b245453885e07e2a7b4e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format descriptive bind error message.  <br /></td></tr>
<tr class="separator:gae1c533bda5b245453885e07e2a7b4e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e1b3e6d9c494062a97bcc88a0e6a97" id="r_gae2e1b3e6d9c494062a97bcc88a0e6a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae2e1b3e6d9c494062a97bcc88a0e6a97">SocketCommon_update_local_endpoint</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:gae2e1b3e6d9c494062a97bcc88a0e6a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update local endpoint information from getsockname.  <br /></td></tr>
<tr class="separator:gae2e1b3e6d9c494062a97bcc88a0e6a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab555c6739c1f1582b1d1aebfb008897e" id="r_gab555c6739c1f1582b1d1aebfb008897e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab555c6739c1f1582b1d1aebfb008897e">SocketCommon_get_socket_family</a> (<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base)</td></tr>
<tr class="memdesc:gab555c6739c1f1582b1d1aebfb008897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket's address family.  <br /></td></tr>
<tr class="separator:gab555c6739c1f1582b1d1aebfb008897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552530543d655ce8871dcfe96a6675fb" id="r_ga552530543d655ce8871dcfe96a6675fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga552530543d655ce8871dcfe96a6675fb">SocketCommon_validate_host_not_null</a> (const char *host, <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> exception_type)</td></tr>
<tr class="memdesc:ga552530543d655ce8871dcfe96a6675fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate host is not NULL.  <br /></td></tr>
<tr class="separator:ga552530543d655ce8871dcfe96a6675fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d98c31897344c8c2e6e6cde65045f09" id="r_ga1d98c31897344c8c2e6e6cde65045f09"><td class="memItemLeft" align="right" valign="top">struct addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1d98c31897344c8c2e6e6cde65045f09">SocketCommon_copy_addrinfo</a> (const struct addrinfo *src)</td></tr>
<tr class="memdesc:ga1d98c31897344c8c2e6e6cde65045f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy of addrinfo linked list.  <br /></td></tr>
<tr class="separator:ga1d98c31897344c8c2e6e6cde65045f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c73595d93eeee7b21ad12b980770f5a" id="r_ga6c73595d93eeee7b21ad12b980770f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6c73595d93eeee7b21ad12b980770f5a">SocketCommon_free_addrinfo</a> (struct addrinfo *ai)</td></tr>
<tr class="memdesc:ga6c73595d93eeee7b21ad12b980770f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free addrinfo chain created by copy_addrinfo.  <br /></td></tr>
<tr class="separator:ga6c73595d93eeee7b21ad12b980770f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2318fb3606f6a71c2a11e247ff876d5" id="r_gad2318fb3606f6a71c2a11e247ff876d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad2318fb3606f6a71c2a11e247ff876d5">SocketCommon_timeouts_getdefaults</a> (<a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:gad2318fb3606f6a71c2a11e247ff876d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global default timeouts.  <br /></td></tr>
<tr class="separator:gad2318fb3606f6a71c2a11e247ff876d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a87ba229cdf264bec87129ce8918f5" id="r_ga98a87ba229cdf264bec87129ce8918f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga98a87ba229cdf264bec87129ce8918f5">SocketCommon_timeouts_setdefaults</a> (const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:ga98a87ba229cdf264bec87129ce8918f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global default timeouts.  <br /></td></tr>
<tr class="separator:ga98a87ba229cdf264bec87129ce8918f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fb698963ebcc4f8f1d86d03b2ba3b7" id="r_ga37fb698963ebcc4f8f1d86d03b2ba3b7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga37fb698963ebcc4f8f1d86d03b2ba3b7">SocketCommon_check_bound_ipv4</a> (const struct sockaddr_storage *addr)</td></tr>
<tr class="memdesc:ga37fb698963ebcc4f8f1d86d03b2ba3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if IPv4 socket is bound.  <br /></td></tr>
<tr class="separator:ga37fb698963ebcc4f8f1d86d03b2ba3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560dfe8bbb25d43c0ade5b295e20e1a7" id="r_ga560dfe8bbb25d43c0ade5b295e20e1a7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga560dfe8bbb25d43c0ade5b295e20e1a7">SocketCommon_check_bound_ipv6</a> (const struct sockaddr_storage *addr)</td></tr>
<tr class="memdesc:ga560dfe8bbb25d43c0ade5b295e20e1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if IPv6 socket is bound.  <br /></td></tr>
<tr class="separator:ga560dfe8bbb25d43c0ade5b295e20e1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bdea854665ec5ea7e4578b316092a4" id="r_ga06bdea854665ec5ea7e4578b316092a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga06bdea854665ec5ea7e4578b316092a4">SocketCommon_check_bound_unix</a> (const struct sockaddr_storage *addr)</td></tr>
<tr class="memdesc:ga06bdea854665ec5ea7e4578b316092a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if Unix socket is bound.  <br /></td></tr>
<tr class="separator:ga06bdea854665ec5ea7e4578b316092a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0c8010b4e1cb65941a1c9be090742c" id="r_ga7a0c8010b4e1cb65941a1c9be090742c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga7a0c8010b4e1cb65941a1c9be090742c">SocketCommon_check_bound_by_family</a> (const struct sockaddr_storage *addr)</td></tr>
<tr class="memdesc:ga7a0c8010b4e1cb65941a1c9be090742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket is bound based on family.  <br /></td></tr>
<tr class="separator:ga7a0c8010b4e1cb65941a1c9be090742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d46dcf1a875ef525eb96d5f2271fb3" id="r_ga93d46dcf1a875ef525eb96d5f2271fb3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga93d46dcf1a875ef525eb96d5f2271fb3">SocketLiveCount_increment</a> (struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *tracker)</td></tr>
<tr class="memdesc:ga93d46dcf1a875ef525eb96d5f2271fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment live count (thread-safe)  <br /></td></tr>
<tr class="separator:ga93d46dcf1a875ef525eb96d5f2271fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433d928caa9de0b29ab9f2d48e166c5c" id="r_ga433d928caa9de0b29ab9f2d48e166c5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga433d928caa9de0b29ab9f2d48e166c5c">SocketLiveCount_decrement</a> (struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *tracker)</td></tr>
<tr class="memdesc:ga433d928caa9de0b29ab9f2d48e166c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement live count (thread-safe)  <br /></td></tr>
<tr class="separator:ga433d928caa9de0b29ab9f2d48e166c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02b16726c7750c470af8a59ffe041098" id="r_ga02b16726c7750c470af8a59ffe041098"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga02b16726c7750c470af8a59ffe041098">SocketLiveCount_get</a> (struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *tracker)</td></tr>
<tr class="memdesc:ga02b16726c7750c470af8a59ffe041098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current live count (thread-safe)  <br /></td></tr>
<tr class="separator:ga02b16726c7750c470af8a59ffe041098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70954c6e125769d15ffd6c3e31c89b75" id="r_ga70954c6e125769d15ffd6c3e31c89b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga70954c6e125769d15ffd6c3e31c89b75">SocketCommon_get_dns_resolver</a> (void)</td></tr>
<tr class="memdesc:ga70954c6e125769d15ffd6c3e31c89b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global DNS resolver instance.  <br /></td></tr>
<tr class="separator:ga70954c6e125769d15ffd6c3e31c89b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df045c4215eb7538ad543cd9368864c" id="r_ga8df045c4215eb7538ad543cd9368864c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8df045c4215eb7538ad543cd9368864c">SocketCommon_set_dns_timeout</a> (int timeout_ms)</td></tr>
<tr class="memdesc:ga8df045c4215eb7538ad543cd9368864c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global DNS resolution timeout.  <br /></td></tr>
<tr class="separator:ga8df045c4215eb7538ad543cd9368864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abf1412f29d6cec69326ca2a10e9e21" id="r_ga4abf1412f29d6cec69326ca2a10e9e21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4abf1412f29d6cec69326ca2a10e9e21">SocketCommon_get_dns_timeout</a> (void)</td></tr>
<tr class="memdesc:ga4abf1412f29d6cec69326ca2a10e9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current global DNS timeout.  <br /></td></tr>
<tr class="separator:ga4abf1412f29d6cec69326ca2a10e9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a42dead580007f2f04aac09eabf7a4" id="r_gab2a42dead580007f2f04aac09eabf7a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab2a42dead580007f2f04aac09eabf7a4">SocketCommon_shutdown_globals</a> (void)</td></tr>
<tr class="memdesc:gab2a42dead580007f2f04aac09eabf7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown global resources (e.g., DNS resolver) to prevent leaks in testsCall at program exit after all operations complete.  <br /></td></tr>
<tr class="separator:gab2a42dead580007f2f04aac09eabf7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65971e86ea8dcbaa79e4e457612d3a6" id="r_gad65971e86ea8dcbaa79e4e457612d3a6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gad65971e86ea8dcbaa79e4e457612d3a6">socket_send_internal</a> (Socket_T socket, const void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:gad65971e86ea8dcbaa79e4e457612d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal send operation (TLS-aware)  <br /></td></tr>
<tr class="separator:gad65971e86ea8dcbaa79e4e457612d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c16a6d184c96f82dd1185d315f29e2" id="r_ga12c16a6d184c96f82dd1185d315f29e2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga12c16a6d184c96f82dd1185d315f29e2">socket_recv_internal</a> (Socket_T socket, void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:ga12c16a6d184c96f82dd1185d315f29e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal receive operation (TLS-aware)  <br /></td></tr>
<tr class="separator:ga12c16a6d184c96f82dd1185d315f29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714a501a951663d0248972ef6cc75818" id="r_ga714a501a951663d0248972ef6cc75818"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga714a501a951663d0248972ef6cc75818">socket_sendv_internal</a> (Socket_T socket, const struct iovec *iov, int iovcnt, int flags)</td></tr>
<tr class="memdesc:ga714a501a951663d0248972ef6cc75818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal scatter/gather send (TLS-aware)  <br /></td></tr>
<tr class="separator:ga714a501a951663d0248972ef6cc75818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7fc21bc639d4077480b1d2b7c2bef7e" id="r_gaa7fc21bc639d4077480b1d2b7c2bef7e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa7fc21bc639d4077480b1d2b7c2bef7e">socket_recvv_internal</a> (Socket_T socket, struct iovec *iov, int iovcnt, int flags)</td></tr>
<tr class="memdesc:gaa7fc21bc639d4077480b1d2b7c2bef7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal scatter/gather receive (TLS-aware)  <br /></td></tr>
<tr class="separator:gaa7fc21bc639d4077480b1d2b7c2bef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc70395a3d965153d4502752c496544e" id="r_gabc70395a3d965153d4502752c496544e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gabc70395a3d965153d4502752c496544e">socket_is_tls_enabled</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:gabc70395a3d965153d4502752c496544e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if socket has TLS enabled.  <br /></td></tr>
<tr class="separator:gabc70395a3d965153d4502752c496544e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665b41107ebf850f631386135fa58791" id="r_ga665b41107ebf850f631386135fa58791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga665b41107ebf850f631386135fa58791">socket_tls_want_read</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:ga665b41107ebf850f631386135fa58791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TLS wants to read more data for handshake or protocol.  <br /></td></tr>
<tr class="separator:ga665b41107ebf850f631386135fa58791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a7fe487c65b17fdea95a118bc98a97" id="r_gae7a7fe487c65b17fdea95a118bc98a97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae7a7fe487c65b17fdea95a118bc98a97">socket_tls_want_write</a> (const Socket_T socket)</td></tr>
<tr class="memdesc:gae7a7fe487c65b17fdea95a118bc98a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TLS wants to write more data for handshake or protocol.  <br /></td></tr>
<tr class="separator:gae7a7fe487c65b17fdea95a118bc98a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f7b61974c6adb4ac454b4fb671c6b8" id="r_ga92f7b61974c6adb4ac454b4fb671c6b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga92f7b61974c6adb4ac454b4fb671c6b8">socket_handle_ssl_error</a> (Socket_T socket, SSL *ssl, int ssl_result)</td></tr>
<tr class="memdesc:ga92f7b61974c6adb4ac454b4fb671c6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to handle SSL error codes.  <br /></td></tr>
<tr class="separator:ga92f7b61974c6adb4ac454b4fb671c6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326db6a48e839e56bd1599fc3a651723" id="r_ga326db6a48e839e56bd1599fc3a651723"><td class="memItemLeft" align="right" valign="top">SSL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga326db6a48e839e56bd1599fc3a651723">socket_get_ssl</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga326db6a48e839e56bd1599fc3a651723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SSL object from socket.  <br /></td></tr>
<tr class="separator:ga326db6a48e839e56bd1599fc3a651723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ddc2a7b61b559013a79f7d1297d409" id="r_ga10ddc2a7b61b559013a79f7d1297d409"><td class="memItemLeft" align="right" valign="top">SSL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga10ddc2a7b61b559013a79f7d1297d409">socket_validate_tls_ready</a> (Socket_T socket)</td></tr>
<tr class="memdesc:ga10ddc2a7b61b559013a79f7d1297d409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate TLS is ready for I/O.  <br /></td></tr>
<tr class="separator:ga10ddc2a7b61b559013a79f7d1297d409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6b10100f449aef91c884fcebc9f9a5" id="r_gacc6b10100f449aef91c884fcebc9f9a5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gacc6b10100f449aef91c884fcebc9f9a5">socketio_is_wouldblock</a> (void)</td></tr>
<tr class="memdesc:gacc6b10100f449aef91c884fcebc9f9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if errno indicates operation would block.  <br /></td></tr>
<tr class="separator:gacc6b10100f449aef91c884fcebc9f9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74bde3935e0a14d633eb374dada531d1" id="r_ga74bde3935e0a14d633eb374dada531d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga74bde3935e0a14d633eb374dada531d1">socketio_is_connection_closed_send</a> (void)</td></tr>
<tr class="memdesc:ga74bde3935e0a14d633eb374dada531d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if send error indicates closed connection.  <br /></td></tr>
<tr class="separator:ga74bde3935e0a14d633eb374dada531d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed3e966870af6d524f8956253594ef4" id="r_ga9ed3e966870af6d524f8956253594ef4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga9ed3e966870af6d524f8956253594ef4">socketio_is_connection_closed_recv</a> (void)</td></tr>
<tr class="memdesc:ga9ed3e966870af6d524f8956253594ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if recv error indicates closed connection.  <br /></td></tr>
<tr class="separator:ga9ed3e966870af6d524f8956253594ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a14153269ffab409e6ebfaf6deebdd" id="r_ga89a14153269ffab409e6ebfaf6deebdd"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga89a14153269ffab409e6ebfaf6deebdd">socketproxy_get_time_ms</a> (void)</td></tr>
<tr class="memdesc:ga89a14153269ffab409e6ebfaf6deebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current monotonic time in milliseconds.  <br /></td></tr>
<tr class="separator:ga89a14153269ffab409e6ebfaf6deebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6f15d7cead4ae400033b6811f283e6" id="r_gaed6f15d7cead4ae400033b6811f283e6"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaed6f15d7cead4ae400033b6811f283e6">socketproxy_elapsed_ms</a> (int64_t start_ms)</td></tr>
<tr class="memdesc:gaed6f15d7cead4ae400033b6811f283e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate elapsed time since start in milliseconds.  <br /></td></tr>
<tr class="separator:gaed6f15d7cead4ae400033b6811f283e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e6170ecb08801fd53c849e1456e83c" id="r_ga71e6170ecb08801fd53c849e1456e83c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga71e6170ecb08801fd53c849e1456e83c">socketproxy_do_send</a> (struct <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *conn)</td></tr>
<tr class="memdesc:ga71e6170ecb08801fd53c849e1456e83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send pending protocol data from conn-&gt;send_buf.  <br /></td></tr>
<tr class="separator:ga71e6170ecb08801fd53c849e1456e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab87758fdfc1cbbf3af9740989da246fd" id="r_gab87758fdfc1cbbf3af9740989da246fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab87758fdfc1cbbf3af9740989da246fd">socketproxy_do_recv</a> (struct <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *conn)</td></tr>
<tr class="memdesc:gab87758fdfc1cbbf3af9740989da246fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive protocol data into conn-&gt;recv_buf.  <br /></td></tr>
<tr class="separator:gab87758fdfc1cbbf3af9740989da246fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2907aa0b8b21056fcf6c9ba35337ed3" id="r_gab2907aa0b8b21056fcf6c9ba35337ed3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab2907aa0b8b21056fcf6c9ba35337ed3">socketproxy_parse_scheme</a> (const char *url, <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *config, const char **end)</td></tr>
<tr class="memdesc:gab2907aa0b8b21056fcf6c9ba35337ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for parsing proxy URLs.  <br /></td></tr>
<tr class="separator:gab2907aa0b8b21056fcf6c9ba35337ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4284e6c37f6f115b2099885ae0f5622c" id="r_ga4284e6c37f6f115b2099885ae0f5622c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4284e6c37f6f115b2099885ae0f5622c">socketproxy_parse_userinfo</a> (const char *start, <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *config, <a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, const char **end)</td></tr>
<tr class="memdesc:ga4284e6c37f6f115b2099885ae0f5622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse optional [user[:pass]@] from URL.  <br /></td></tr>
<tr class="separator:ga4284e6c37f6f115b2099885ae0f5622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11b9c1ecceaca495ac3a397682a3dc0" id="r_gaa11b9c1ecceaca495ac3a397682a3dc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaa11b9c1ecceaca495ac3a397682a3dc0">socketproxy_parse_hostport</a> (const char *start, <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *config, <a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena, size_t *consumed_out)</td></tr>
<tr class="memdesc:gaa11b9c1ecceaca495ac3a397682a3dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse [host]:port from URL, handling IPv6 literals.  <br /></td></tr>
<tr class="separator:gaa11b9c1ecceaca495ac3a397682a3dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197242786615adf218d849747bc0fd67" id="r_ga197242786615adf218d849747bc0fd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga197242786615adf218d849747bc0fd67">SocketProxy_config_defaults</a> (<a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *config)</td></tr>
<tr class="memdesc:ga197242786615adf218d849747bc0fd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize proxy configuration with safe default values.  <br /></td></tr>
<tr class="separator:ga197242786615adf218d849747bc0fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16c20e1d43f38171ccaad8408598490" id="r_gae16c20e1d43f38171ccaad8408598490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gae16c20e1d43f38171ccaad8408598490">SocketProxy_parse_url</a> (const char *url, <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *config, <a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena)</td></tr>
<tr class="memdesc:gae16c20e1d43f38171ccaad8408598490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse proxy URL string into configuration structure.  <br /></td></tr>
<tr class="separator:gae16c20e1d43f38171ccaad8408598490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad72c8e58d88ee4bbc975c9163266ef0" id="r_gaad72c8e58d88ee4bbc975c9163266ef0"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaad72c8e58d88ee4bbc975c9163266ef0">SocketProxy_connect</a> (const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *proxy, const char *target_host, int target_port)</td></tr>
<tr class="memdesc:gaad72c8e58d88ee4bbc975c9163266ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish synchronous connection to target via proxy tunnel.  <br /></td></tr>
<tr class="separator:gaad72c8e58d88ee4bbc975c9163266ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fac7f1a89c5921c7152e393dd8ad36" id="r_ga58fac7f1a89c5921c7152e393dd8ad36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga58fac7f1a89c5921c7152e393dd8ad36">SocketProxy_tunnel</a> (Socket_T socket, const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *proxy, const char *target_host, int target_port, <a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena)</td></tr>
<tr class="memdesc:ga58fac7f1a89c5921c7152e393dd8ad36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform proxy handshake on pre-connected socket to establish tunnel.  <br /></td></tr>
<tr class="separator:ga58fac7f1a89c5921c7152e393dd8ad36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6fd1cde0a54b41805862ce002f6f97" id="r_ga5f6fd1cde0a54b41805862ce002f6f97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97">SocketProxy_Conn_start</a> (<a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns, <a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> poll, const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *proxy, const char *target_host, int target_port)</td></tr>
<tr class="memdesc:ga5f6fd1cde0a54b41805862ce002f6f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and start fully asynchronous proxy tunneling operation.  <br /></td></tr>
<tr class="separator:ga5f6fd1cde0a54b41805862ce002f6f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d17fac3f6b21b9905aa7c4b0d7d47f7" id="r_ga6d17fac3f6b21b9905aa7c4b0d7d47f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7">SocketProxy_Conn_new</a> (const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *proxy, const char *target_host, int target_port)</td></tr>
<tr class="memdesc:ga6d17fac3f6b21b9905aa7c4b0d7d47f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create proxy connection context with blocking proxy connect, async handshake.  <br /></td></tr>
<tr class="separator:ga6d17fac3f6b21b9905aa7c4b0d7d47f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12fc736c9952313a4846dd50380bc3f" id="r_gac12fc736c9952313a4846dd50380bc3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f">SocketProxy_Conn_poll</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:gac12fc736c9952313a4846dd50380bc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if proxy operation has completed.  <br /></td></tr>
<tr class="separator:gac12fc736c9952313a4846dd50380bc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45ecd7d9e7c6214e6bfcc6b2a42f977" id="r_gaf45ecd7d9e7c6214e6bfcc6b2a42f977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977">SocketProxy_Conn_process</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:gaf45ecd7d9e7c6214e6bfcc6b2a42f977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance asynchronous proxy connection state machine.  <br /></td></tr>
<tr class="separator:gaf45ecd7d9e7c6214e6bfcc6b2a42f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1d539486b8b250489938c4b71c89a9" id="r_gaff1d539486b8b250489938c4b71c89a9"><td class="memItemLeft" align="right" valign="top">Socket_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9">SocketProxy_Conn_socket</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:gaff1d539486b8b250489938c4b71c89a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract successfully tunneled socket from completed context.  <br /></td></tr>
<tr class="separator:gaff1d539486b8b250489938c4b71c89a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2853a36e933b9ac3803173169b1b159e" id="r_ga2853a36e933b9ac3803173169b1b159e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2853a36e933b9ac3803173169b1b159e">SocketProxy_Conn_cancel</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:ga2853a36e933b9ac3803173169b1b159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel ongoing proxy connection and cleanup resources.  <br /></td></tr>
<tr class="separator:ga2853a36e933b9ac3803173169b1b159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee164cf3e979f5cfe745a33366812d9" id="r_gafee164cf3e979f5cfe745a33366812d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9">SocketProxy_Conn_free</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *conn)</td></tr>
<tr class="memdesc:gafee164cf3e979f5cfe745a33366812d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release proxy connection context and associated resources.  <br /></td></tr>
<tr class="separator:gafee164cf3e979f5cfe745a33366812d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee518c3b280abda4ae21871fae53040" id="r_ga1ee518c3b280abda4ae21871fae53040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040">SocketProxy_Conn_state</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:ga1ee518c3b280abda4ae21871fae53040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current state of proxy connection.  <br /></td></tr>
<tr class="separator:ga1ee518c3b280abda4ae21871fae53040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf191ce0cae571b057d5ea278392bdf24" id="r_gaf191ce0cae571b057d5ea278392bdf24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24">SocketProxy_Conn_result</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:gaf191ce0cae571b057d5ea278392bdf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get final result code after operation completion.  <br /></td></tr>
<tr class="separator:gaf191ce0cae571b057d5ea278392bdf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a495a98a7efa7ecc9d42ce838d4a3e" id="r_ga93a495a98a7efa7ecc9d42ce838d4a3e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga93a495a98a7efa7ecc9d42ce838d4a3e">SocketProxy_Conn_error</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:ga93a495a98a7efa7ecc9d42ce838d4a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve human-readable error description for failed operations.  <br /></td></tr>
<tr class="separator:ga93a495a98a7efa7ecc9d42ce838d4a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1139d24bcabc22e6e2b07762e8f753" id="r_ga9d1139d24bcabc22e6e2b07762e8f753"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga9d1139d24bcabc22e6e2b07762e8f753">SocketProxy_Conn_fd</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:ga9d1139d24bcabc22e6e2b07762e8f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying file descriptor for poll integration.  <br /></td></tr>
<tr class="separator:ga9d1139d24bcabc22e6e2b07762e8f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7492a46210e78249073e289c556ea8" id="r_ga8d7492a46210e78249073e289c556ea8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8d7492a46210e78249073e289c556ea8">SocketProxy_Conn_events</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:ga8d7492a46210e78249073e289c556ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get poll event mask for current connection phase.  <br /></td></tr>
<tr class="separator:ga8d7492a46210e78249073e289c556ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64af0e87ee1735152783f2b7fd132c9" id="r_gaf64af0e87ee1735152783f2b7fd132c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaf64af0e87ee1735152783f2b7fd132c9">SocketProxy_Conn_next_timeout_ms</a> (<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> conn)</td></tr>
<tr class="memdesc:gaf64af0e87ee1735152783f2b7fd132c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate milliseconds until next internal timeout.  <br /></td></tr>
<tr class="separator:gaf64af0e87ee1735152783f2b7fd132c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a0ac262c4e03ed00c5eeb2aa8d210bd" id="r_ga2a0ac262c4e03ed00c5eeb2aa8d210bd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2a0ac262c4e03ed00c5eeb2aa8d210bd">SocketProxy_result_string</a> (<a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a> result)</td></tr>
<tr class="memdesc:ga2a0ac262c4e03ed00c5eeb2aa8d210bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SocketProxy_Result code to descriptive string.  <br /></td></tr>
<tr class="separator:ga2a0ac262c4e03ed00c5eeb2aa8d210bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6340dd7fd6f41c692c0a2f770dbd5877" id="r_ga6340dd7fd6f41c692c0a2f770dbd5877"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga6340dd7fd6f41c692c0a2f770dbd5877">SocketProxy_state_string</a> (<a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a> state)</td></tr>
<tr class="memdesc:ga6340dd7fd6f41c692c0a2f770dbd5877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SocketProxy_State to descriptive string.  <br /></td></tr>
<tr class="separator:ga6340dd7fd6f41c692c0a2f770dbd5877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b7d727085605b2f6bc620118462b13" id="r_ga50b7d727085605b2f6bc620118462b13"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga50b7d727085605b2f6bc620118462b13">SocketProxy_type_string</a> (<a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a> type)</td></tr>
<tr class="memdesc:ga50b7d727085605b2f6bc620118462b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert proxy type enum to protocol name string.  <br /></td></tr>
<tr class="separator:ga50b7d727085605b2f6bc620118462b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga225f4a8fd657fd52a05146c6fc4f58b0" id="r_ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a></td></tr>
<tr class="memdesc:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">General socket operation failure exception.  <br /></td></tr>
<tr class="separator:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db3d742dcea3f39ad2eb37d4fb1e453" id="r_ga2db3d742dcea3f39ad2eb37d4fb1e453"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga2db3d742dcea3f39ad2eb37d4fb1e453">Socket_Closed</a></td></tr>
<tr class="memdesc:ga2db3d742dcea3f39ad2eb37d4fb1e453"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> closed by peer exception.  <br /></td></tr>
<tr class="separator:ga2db3d742dcea3f39ad2eb37d4fb1e453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05e641cc9abed67180036e51a1dc633" id="r_gab05e641cc9abed67180036e51a1dc633"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gab05e641cc9abed67180036e51a1dc633">SocketUnix_Failed</a></td></tr>
<tr class="memdesc:gab05e641cc9abed67180036e51a1dc633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unix domain socket operation failure.  <br /></td></tr>
<tr class="separator:gab05e641cc9abed67180036e51a1dc633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246f86a3226316f3922ee9eba0436777" id="r_ga246f86a3226316f3922ee9eba0436777"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga246f86a3226316f3922ee9eba0436777">SocketBuf_Failed</a></td></tr>
<tr class="memdesc:ga246f86a3226316f3922ee9eba0436777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating failure in buffer operations such as allocation or resize errors.  <br /></td></tr>
<tr class="separator:ga246f86a3226316f3922ee9eba0436777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga225f4a8fd657fd52a05146c6fc4f58b0" id="r_ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a></td></tr>
<tr class="memdesc:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module Exception Forward Declarations.  <br /></td></tr>
<tr class="separator:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28354c49d1726c674932f420a57bb21d" id="r_ga28354c49d1726c674932f420a57bb21d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga28354c49d1726c674932f420a57bb21d">SocketDgram_Failed</a></td></tr>
<tr class="memdesc:ga28354c49d1726c674932f420a57bb21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datagram/UDP-specific operation failure exception.  <br /></td></tr>
<tr class="separator:ga28354c49d1726c674932f420a57bb21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4218ae116e8def59908f76fd1e9dbe3e" id="r_ga4218ae116e8def59908f76fd1e9dbe3e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4218ae116e8def59908f76fd1e9dbe3e">SocketCommon_Failed</a></td></tr>
<tr class="memdesc:ga4218ae116e8def59908f76fd1e9dbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared utility function failure exception.  <br /></td></tr>
<tr class="separator:ga4218ae116e8def59908f76fd1e9dbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga225f4a8fd657fd52a05146c6fc4f58b0" id="r_ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a></td></tr>
<tr class="memdesc:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">General TCP socket operation failure exception.  <br /></td></tr>
<tr class="separator:ga225f4a8fd657fd52a05146c6fc4f58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28354c49d1726c674932f420a57bb21d" id="r_ga28354c49d1726c674932f420a57bb21d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga28354c49d1726c674932f420a57bb21d">SocketDgram_Failed</a></td></tr>
<tr class="memdesc:ga28354c49d1726c674932f420a57bb21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">General UDP/datagram socket operation failure exception.  <br /></td></tr>
<tr class="separator:ga28354c49d1726c674932f420a57bb21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4218ae116e8def59908f76fd1e9dbe3e" id="r_ga4218ae116e8def59908f76fd1e9dbe3e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga4218ae116e8def59908f76fd1e9dbe3e">SocketCommon_Failed</a></td></tr>
<tr class="memdesc:ga4218ae116e8def59908f76fd1e9dbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">General failure in shared socket common utilities.  <br /></td></tr>
<tr class="separator:ga4218ae116e8def59908f76fd1e9dbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1385083c8f3a50e20e1ce11faec7b1" id="r_ga8c1385083c8f3a50e20e1ce11faec7b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#ga8c1385083c8f3a50e20e1ce11faec7b1">SocketProxy_Failed</a></td></tr>
<tr class="memdesc:ga8c1385083c8f3a50e20e1ce11faec7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception raised on general proxy operation failures.  <br /></td></tr>
<tr class="separator:ga8c1385083c8f3a50e20e1ce11faec7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaca3ee3e0d6c13e6ea304edba0e47ce" id="r_gaaaca3ee3e0d6c13e6ea304edba0e47ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__io.html#gaaaca3ee3e0d6c13e6ea304edba0e47ce">SocketDgram_T::base</a></td></tr>
<tr class="separator:gaaaca3ee3e0d6c13e6ea304edba0e47ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Fundamental socket primitives for TCP, UDP, Unix domain, and DNS operations. </p>
<p>This group forms the foundation for all networking in the library, providing low-level but safe abstractions over POSIX sockets. It handles cross-platform differences, error mapping to exceptions, and common patterns like partial I/O.</p>
<h2><a class="anchor" id="autotoc_md395"></a>
Architecture Overview</h2>
<div class="fragment"><div class="line"></div>
<div class="line">   Application Modules       </div>
<div class="line"> HTTP, TLS, Pool, Poll, etc. </div>
<div class="line"></div>
<div class="line">               Uses</div>
<div class="line"></div>
<div class="line">     Core I/O Modules        </div>
<div class="line"> Socket_T, DNS, Proxy, Buf   </div>
<div class="line"></div>
<div class="line">               Uses</div>
<div class="line"></div>
<div class="line">    Foundation Modules       </div>
<div class="line"> Arena, Except, Config, Util </div>
<div class="line"></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md396"></a>
Module Breakdown</h2>
<p>| Module | Purpose | Key Features | Dependencies | |-----&mdash;|------&mdash;|-----------&mdash;|-----------&mdash;| | Socket_T | TCP/Unix sockets | Bind/connect/I/O/options/fd passing | Foundation | | <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a> | UDP/Datagram | Sendto/recvfrom/multicast/broadcast | Foundation | | SocketBuf_T | Circular buffers | Zero-copy read/write/secure clear | Arena | | <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> | Async DNS | Worker threads/non-blocking resolve | Socket, Timer | | SocketProxy_T | Proxy tunneling | HTTP CONNECT/SOCKS4/5 | Socket, DNS |</p>
<h2><a class="anchor" id="autotoc_md397"></a>
Relationships</h2>
<ul>
<li><b>Depends on</b>: <a class="el" href="group__foundation.html">Core Foundation Modules</a> (memory, exceptions, utils)</li>
<li><b>Used by</b>: <a class="el" href="group__event__system.html">Event System Modules</a> (poll integration), <a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> (pooling), <a class="el" href="group__http.html">HTTP Modules</a> (HTTP over sockets), <a class="el" href="group__security.html">Security Modules</a> (protections), <a class="el" href="group__async__io.html">Async I/O Modules</a> (happy eyeballs)</li>
<li><b>Thread Safety</b>: Operations marked <dl class="section user"><dt>Thread Safety\n; instances not shared</dt><dd>without locks</dd></dl>
</li>
<li><b>Performance</b>: O(1) most ops; DNS may block unless async</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html">Core Foundation Modules</a> Base infrastructure </dd>
<dd>
<a class="el" href="group__event__system.html">Event System Modules</a> Event system built on Core I/O </dd>
<dd>
Socket_T Primary TCP/Unix abstraction </dd>
<dd>
<a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a> UDP abstraction </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> Integration guide </dd></dl>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structSocketStats__T" id="structSocketStats__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketStats__T">&#9670;&#160;</a></span>SocketStats_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketStats_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Per-socket I/O statistics structure. </p>
<p>Tracks cumulative statistics for a single socket instance including bytes transferred, packet counts, and timing information. Statistics are updated automatically by send/recv operations and can be queried or reset via <a class="el" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164" title="Retrieve current statistics for a socket.">Socket_getstats()</a> and <a class="el" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c" title="Reset statistics counters for a socket.">Socket_resetstats()</a>.</p>
<p>All timing values use monotonic clock (milliseconds since epoch or socket creation).</p>
<h2><a class="anchor" id="autotoc_md414"></a>
Usage Example</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... send/recv operations ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__core__io.html#structSocketStats__T">SocketStats_T</a> stats;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164">Socket_getstats</a>(sock, &amp;stats);</div>
<div class="line">printf(<span class="stringliteral">&quot;Sent: %zu bytes in %zu packets\n&quot;</span>, stats.<a class="code hl_variable" href="group__core__io.html#a1a306a747a6858b1c2745deb7cbda232">bytes_sent</a>,</div>
<div class="line">stats.<a class="code hl_variable" href="group__core__io.html#ac1fc3da8e3224e5de2359d367092693b">packets_sent</a>); printf(<span class="stringliteral">&quot;Connect time: %lld ms\n&quot;</span>,</div>
<div class="line">(<span class="keywordtype">long</span> <span class="keywordtype">long</span>)stats.<a class="code hl_variable" href="group__core__io.html#a144a2c11649916fbe9800036b7bdbeb8">connect_time_ms</a>); printf(<span class="stringliteral">&quot;Last recv: %lld ms ago\n&quot;</span>,</div>
<div class="line">       (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(<a class="code hl_function" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms</a>() - stats.<a class="code hl_variable" href="group__core__io.html#af29cdd4bb1a460f622e706f0c6aafab4">last_recv_time_ms</a>));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c">Socket_resetstats</a>(sock);  <span class="comment">// Reset counters for next interval</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
<div class="ttc" id="agroup__core__io_html_a144a2c11649916fbe9800036b7bdbeb8"><div class="ttname"><a href="group__core__io.html#a144a2c11649916fbe9800036b7bdbeb8">SocketStats_T::connect_time_ms</a></div><div class="ttdeci">int64_t connect_time_ms</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00682">Socket.h:682</a></div></div>
<div class="ttc" id="agroup__core__io_html_a1a306a747a6858b1c2745deb7cbda232"><div class="ttname"><a href="group__core__io.html#a1a306a747a6858b1c2745deb7cbda232">SocketStats_T::bytes_sent</a></div><div class="ttdeci">uint64_t bytes_sent</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00669">Socket.h:669</a></div></div>
<div class="ttc" id="agroup__core__io_html_ac1fc3da8e3224e5de2359d367092693b"><div class="ttname"><a href="group__core__io.html#ac1fc3da8e3224e5de2359d367092693b">SocketStats_T::packets_sent</a></div><div class="ttdeci">uint64_t packets_sent</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00673">Socket.h:673</a></div></div>
<div class="ttc" id="agroup__core__io_html_af29cdd4bb1a460f622e706f0c6aafab4"><div class="ttname"><a href="group__core__io.html#af29cdd4bb1a460f622e706f0c6aafab4">SocketStats_T::last_recv_time_ms</a></div><div class="ttdeci">int64_t last_recv_time_ms</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00685">Socket.h:685</a></div></div>
<div class="ttc" id="agroup__core__io_html_ga6212fb2b6eefa567592a59f55c25a6f1"><div class="ttname"><a href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a></div><div class="ttdeci">Socket_T Socket_new(int domain, int type, int protocol)</div><div class="ttdoc">Create a new socket with specified domain, type, and protocol.</div></div>
<div class="ttc" id="agroup__core__io_html_ga74ad7a9bb8deaf499c59d90d6e411f37"><div class="ttname"><a href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a></div><div class="ttdeci">void Socket_free(Socket_T *socket)</div><div class="ttdoc">Dispose of a socket instance and close the underlying file descriptor.</div></div>
<div class="ttc" id="agroup__core__io_html_ga79e5b410845cb71d636f9fbf34771e9c"><div class="ttname"><a href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c">Socket_resetstats</a></div><div class="ttdeci">void Socket_resetstats(Socket_T socket)</div><div class="ttdoc">Reset statistics counters for a socket.</div></div>
<div class="ttc" id="agroup__core__io_html_gac14390090ee26136c1f7a816fc08406e"><div class="ttname"><a href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a></div><div class="ttdeci">void Socket_connect(Socket_T socket, const char *host, int port)</div><div class="ttdoc">Establish a connection to a remote host and port.</div></div>
<div class="ttc" id="agroup__core__io_html_gafdfd3666a5d9779023f527c3afddf164"><div class="ttname"><a href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164">Socket_getstats</a></div><div class="ttdeci">void Socket_getstats(const Socket_T socket, SocketStats_T *stats)</div><div class="ttdoc">Retrieve current statistics for a socket.</div></div>
<div class="ttc" id="agroup__core__io_html_structSocketStats__T"><div class="ttname"><a href="group__core__io.html#structSocketStats__T">SocketStats_T</a></div><div class="ttdoc">Per-socket I/O statistics structure.</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00666">Socket.h:667</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga264bfa9d1cf07aa22446a4df6c4936bf"><div class="ttname"><a href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf">Socket_get_monotonic_ms</a></div><div class="ttdeci">int64_t Socket_get_monotonic_ms(void)</div><div class="ttdoc">Socket_get_monotonic_ms - Get current monotonic time in milliseconds.</div></div>
</div><!-- fragment --><dl class="section user"><dt>Thread Safety\n Partial - stats snapshot is atomic, but rapid updates may race</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164" title="Retrieve current statistics for a socket.">Socket_getstats()</a> to retrieve current statistics </dd>
<dd>
<a class="el" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c" title="Reset statistics counters for a socket.">Socket_resetstats()</a> to reset counters </dd>
<dd>
<a class="el" href="group__utilities.html#ga734ddc8b0557270744359de21721674b" title="Get current count of open sockets.">SocketMetrics_get_socket_count()</a> for global socket metrics </dd></dl>

<p class="definition">Definition at line <a class="el" href="Socket_8h_source.html#l00666">666</a> of file <a class="el" href="Socket_8h_source.html">Socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a66852de9dd3886d61d34598a0987dde6" name="a66852de9dd3886d61d34598a0987dde6"></a>uint64_t</td>
<td class="fieldname">
bytes_received</td>
<td class="fielddoc">
<p>Total bytes received since creation/reset </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1a306a747a6858b1c2745deb7cbda232" name="a1a306a747a6858b1c2745deb7cbda232"></a>uint64_t</td>
<td class="fieldname">
bytes_sent</td>
<td class="fielddoc">
<p>Total bytes sent since creation/reset </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a144a2c11649916fbe9800036b7bdbeb8" name="a144a2c11649916fbe9800036b7bdbeb8"></a>int64_t</td>
<td class="fieldname">
connect_time_ms</td>
<td class="fielddoc">
<p>Time spent in connect() (0 if not connected) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a14056db13d715c50412fa9b4ab30b3e6" name="a14056db13d715c50412fa9b4ab30b3e6"></a>int64_t</td>
<td class="fieldname">
create_time_ms</td>
<td class="fielddoc">
<p>Socket creation timestamp </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af29cdd4bb1a460f622e706f0c6aafab4" name="af29cdd4bb1a460f622e706f0c6aafab4"></a>int64_t</td>
<td class="fieldname">
last_recv_time_ms</td>
<td class="fielddoc">
<p>Last successful recv timestamp (0 if never) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa4d3f3de922183b6669b2cf0b64b72a2" name="aa4d3f3de922183b6669b2cf0b64b72a2"></a>int64_t</td>
<td class="fieldname">
last_send_time_ms</td>
<td class="fielddoc">
<p>Last successful send timestamp (0 if never) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a78542783f1f4728ac202fc09f248d364" name="a78542783f1f4728ac202fc09f248d364"></a>uint64_t</td>
<td class="fieldname">
packets_received</td>
<td class="fielddoc">
<p>Number of recv operations </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac1fc3da8e3224e5de2359d367092693b" name="ac1fc3da8e3224e5de2359d367092693b"></a>uint64_t</td>
<td class="fieldname">
packets_sent</td>
<td class="fielddoc">
<p>Number of send operations </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5f397c61a4b33194f48c00a4a6e8f995" name="a5f397c61a4b33194f48c00a4a6e8f995"></a>uint64_t</td>
<td class="fieldname">
recv_errors</td>
<td class="fielddoc">
<p>Number of failed recv operations </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a41a4f659a79cb76006eb875feb1ee5f4" name="a41a4f659a79cb76006eb875feb1ee5f4"></a>int32_t</td>
<td class="fieldname">
rtt_us</td>
<td class="fielddoc">
<p>Smoothed RTT in microseconds (-1 if N/A) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a901e4a4482d95b5798b367d3a6456fed" name="a901e4a4482d95b5798b367d3a6456fed"></a>int32_t</td>
<td class="fieldname">
rtt_var_us</td>
<td class="fielddoc">
<p>RTT variance in microseconds (-1 if N/A) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa2d9467b2593b9f2448eb8667a607c9b" name="aa2d9467b2593b9f2448eb8667a607c9b"></a>uint64_t</td>
<td class="fieldname">
send_errors</td>
<td class="fielddoc">
<p>Number of failed send operations </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketTCPInfo" id="structSocketTCPInfo"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketTCPInfo">&#9670;&#160;</a></span>SocketTCPInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketTCPInfo</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>TCP connection information structure (Linux-specific). </p>
<p>Provides detailed TCP stack information via TCP_INFO sockopt. All timing values are in microseconds unless noted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12" title="Retrieve TCP connection statistics (Linux-specific).">Socket_get_tcp_info()</a> to retrieve this information </dd></dl>

<p class="definition">Definition at line <a class="el" href="Socket_8h_source.html#l00936">936</a> of file <a class="el" href="Socket_8h_source.html">Socket.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a98e53c4229f9284deffb2d97b9e5525b" name="a98e53c4229f9284deffb2d97b9e5525b"></a>uint32_t</td>
<td class="fieldname">
advmss</td>
<td class="fielddoc">
<p>Advertised MSS </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9ec621ee37989227cc3133a2c33c9ded" name="a9ec621ee37989227cc3133a2c33c9ded"></a>uint32_t</td>
<td class="fieldname">
ato_us</td>
<td class="fielddoc">
<p>ACK timeout (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="affc7868e056309d3d73449360749fb13" name="affc7868e056309d3d73449360749fb13"></a>uint8_t</td>
<td class="fieldname">
backoff</td>
<td class="fielddoc">
<p>Backoff exponent for RTO </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2260e32e09d6c2875ea205455b01d9b3" name="a2260e32e09d6c2875ea205455b01d9b3"></a>uint64_t</td>
<td class="fieldname">
bytes_acked</td>
<td class="fielddoc">
<p>Bytes acknowledged </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a667aa15bf01de73c53186540c837c20d" name="a667aa15bf01de73c53186540c837c20d"></a>uint64_t</td>
<td class="fieldname">
bytes_received</td>
<td class="fielddoc">
<p>Bytes received </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a700468c7d3360df49c6d6591f0551e13" name="a700468c7d3360df49c6d6591f0551e13"></a>uint8_t</td>
<td class="fieldname">
ca_state</td>
<td class="fielddoc">
<p>Congestion avoidance state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6cbcc4155764467745a761e5637a335d" name="a6cbcc4155764467745a761e5637a335d"></a>uint32_t</td>
<td class="fieldname">
data_segs_in</td>
<td class="fielddoc">
<p>Data segments received </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aff22f10e35e802fb2ccd4768739d46a1" name="aff22f10e35e802fb2ccd4768739d46a1"></a>uint32_t</td>
<td class="fieldname">
data_segs_out</td>
<td class="fielddoc">
<p>Data segments sent </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6cf6fcadad72a1f6a26dfe613a230727" name="a6cf6fcadad72a1f6a26dfe613a230727"></a>uint64_t</td>
<td class="fieldname">
delivery_rate</td>
<td class="fielddoc">
<p>Delivery rate (bytes/sec) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a37a673a6a9e1dce2e9aaffac804b3418" name="a37a673a6a9e1dce2e9aaffac804b3418"></a>uint32_t</td>
<td class="fieldname">
fackets</td>
<td class="fielddoc">
<p>FACKed segments </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4bd61b8d41cc3e9f45937e35f42d0398" name="a4bd61b8d41cc3e9f45937e35f42d0398"></a>uint32_t</td>
<td class="fieldname">
last_ack_recv_ms</td>
<td class="fielddoc">
<p>Time since last ACK received (ms) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1b068692c62cb94fa46ff580138f933d" name="a1b068692c62cb94fa46ff580138f933d"></a>uint32_t</td>
<td class="fieldname">
last_ack_sent_ms</td>
<td class="fielddoc">
<p>Time since last ACK sent (ms) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a487437c60a559639cf2801956c495544" name="a487437c60a559639cf2801956c495544"></a>uint32_t</td>
<td class="fieldname">
last_data_recv_ms</td>
<td class="fielddoc">
<p>Time since last data received (ms) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a35ff2fb743ec1546885510aa0002667b" name="a35ff2fb743ec1546885510aa0002667b"></a>uint32_t</td>
<td class="fieldname">
last_data_sent_ms</td>
<td class="fielddoc">
<p>Time since last data sent (ms) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4ac7f0e4f542c893a338b803f1329d87" name="a4ac7f0e4f542c893a338b803f1329d87"></a>uint32_t</td>
<td class="fieldname">
lost</td>
<td class="fielddoc">
<p>Lost segments </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afff8d49b7c0d07575b0d41ebfa1e85fa" name="afff8d49b7c0d07575b0d41ebfa1e85fa"></a>uint64_t</td>
<td class="fieldname">
max_pacing_rate</td>
<td class="fielddoc">
<p>Maximum pacing rate (bytes/sec) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac2ba47c98262ba333bca5a54ea330e36" name="ac2ba47c98262ba333bca5a54ea330e36"></a>uint32_t</td>
<td class="fieldname">
min_rtt_us</td>
<td class="fielddoc">
<p>Minimum observed RTT (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af329573b8031050e04099b4ef14ca69b" name="af329573b8031050e04099b4ef14ca69b"></a>uint32_t</td>
<td class="fieldname">
notsent_bytes</td>
<td class="fielddoc">
<p>Not-yet-sent bytes in write queue </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6595f8d0f50b07c9ab4362c3d64116dc" name="a6595f8d0f50b07c9ab4362c3d64116dc"></a>uint8_t</td>
<td class="fieldname">
options</td>
<td class="fielddoc">
<p>TCP options enabled </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afb49467c69ff4e22f7b1649bcc2967d6" name="afb49467c69ff4e22f7b1649bcc2967d6"></a>uint64_t</td>
<td class="fieldname">
pacing_rate</td>
<td class="fielddoc">
<p>Current pacing rate (bytes/sec) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aeb27f38ceb2331c61a4917d975f0a632" name="aeb27f38ceb2331c61a4917d975f0a632"></a>uint32_t</td>
<td class="fieldname">
pmtu</td>
<td class="fielddoc">
<p>Path MTU </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae852430ef5ec828a465c087eaa7cde50" name="ae852430ef5ec828a465c087eaa7cde50"></a>uint8_t</td>
<td class="fieldname">
probes</td>
<td class="fielddoc">
<p>Number of unanswered zero-window probes </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3e9d1e8e035941461af9fd36ba22ee8c" name="a3e9d1e8e035941461af9fd36ba22ee8c"></a>uint32_t</td>
<td class="fieldname">
rcv_mss</td>
<td class="fielddoc">
<p>Receive MSS </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a504467b12b576aca9413f1037820359a" name="a504467b12b576aca9413f1037820359a"></a>uint32_t</td>
<td class="fieldname">
rcv_rtt_us</td>
<td class="fielddoc">
<p>Receiver RTT estimate (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a952e9c247b8eabf61c8b91d183aeb701" name="a952e9c247b8eabf61c8b91d183aeb701"></a>uint32_t</td>
<td class="fieldname">
rcv_space</td>
<td class="fielddoc">
<p>Receive buffer space </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2900d0523cfb57df5439d323dfd9ef66" name="a2900d0523cfb57df5439d323dfd9ef66"></a>uint32_t</td>
<td class="fieldname">
rcv_ssthresh</td>
<td class="fielddoc">
<p>Receive slow-start threshold </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9064a580c9822cbf49f586ec883bc186" name="a9064a580c9822cbf49f586ec883bc186"></a>uint8_t</td>
<td class="fieldname">
rcv_wscale</td>
<td class="fielddoc">
<p>Receive window scale </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1f1c3ec11b9b905c285b8f4acf1f4c0c" name="a1f1c3ec11b9b905c285b8f4acf1f4c0c"></a>uint32_t</td>
<td class="fieldname">
reordering</td>
<td class="fielddoc">
<p>Reordering metric </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae45f4066cc48de3e35e4726845ce11ae" name="ae45f4066cc48de3e35e4726845ce11ae"></a>uint32_t</td>
<td class="fieldname">
retrans</td>
<td class="fielddoc">
<p>Retransmitted segments </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3e95f2b4365cb6f6c2c2379347355250" name="a3e95f2b4365cb6f6c2c2379347355250"></a>uint8_t</td>
<td class="fieldname">
retransmits</td>
<td class="fielddoc">
<p>Number of unrecovered RTOs </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6432af5380be6d0a6ea8564b0072f79c" name="a6432af5380be6d0a6ea8564b0072f79c"></a>uint32_t</td>
<td class="fieldname">
rto_us</td>
<td class="fielddoc">
<p>Retransmission timeout (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aab4ba2040044e6dfcd4b96fc186126a0" name="aab4ba2040044e6dfcd4b96fc186126a0"></a>uint32_t</td>
<td class="fieldname">
rtt_us</td>
<td class="fielddoc">
<p>Smoothed RTT (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6766b0686666a67e35ab3fd4ac134d91" name="a6766b0686666a67e35ab3fd4ac134d91"></a>uint32_t</td>
<td class="fieldname">
rttvar_us</td>
<td class="fielddoc">
<p>RTT variance (microseconds) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4c69bbc16aaaa86e580d3875d5132e26" name="a4c69bbc16aaaa86e580d3875d5132e26"></a>uint32_t</td>
<td class="fieldname">
sacked</td>
<td class="fielddoc">
<p>SACKed segments </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa40b2a265b1e68a80b67cf796f72e97f" name="aa40b2a265b1e68a80b67cf796f72e97f"></a>uint32_t</td>
<td class="fieldname">
segs_in</td>
<td class="fielddoc">
<p>Segments received </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a955f331a01cc059b096602de5079822d" name="a955f331a01cc059b096602de5079822d"></a>uint32_t</td>
<td class="fieldname">
segs_out</td>
<td class="fielddoc">
<p>Segments sent </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abc51ce63ef8aa4fc7c34bd7926460f6c" name="abc51ce63ef8aa4fc7c34bd7926460f6c"></a>uint32_t</td>
<td class="fieldname">
snd_cwnd</td>
<td class="fielddoc">
<p>Send congestion window </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a72eb3e3a6eb2a9c297b2df50a933ecb4" name="a72eb3e3a6eb2a9c297b2df50a933ecb4"></a>uint32_t</td>
<td class="fieldname">
snd_mss</td>
<td class="fielddoc">
<p>Send MSS </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aae38094a511fadb6342154e45c689524" name="aae38094a511fadb6342154e45c689524"></a>uint32_t</td>
<td class="fieldname">
snd_ssthresh</td>
<td class="fielddoc">
<p>Send slow-start threshold </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a18e88ae47daa3524487f13d63e3243d4" name="a18e88ae47daa3524487f13d63e3243d4"></a>uint8_t</td>
<td class="fieldname">
snd_wscale</td>
<td class="fielddoc">
<p>Send window scale </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2d542b59930742fe780edae1fe6d2024" name="a2d542b59930742fe780edae1fe6d2024"></a>uint8_t</td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>TCP state (TCP_ESTABLISHED, etc.) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afc6256ec520cf71dff6ee7d713b7c798" name="afc6256ec520cf71dff6ee7d713b7c798"></a>uint32_t</td>
<td class="fieldname">
total_retrans</td>
<td class="fielddoc">
<p>Total retransmissions </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac1df7df75fed6d4a360437234d3346fd" name="ac1df7df75fed6d4a360437234d3346fd"></a>uint32_t</td>
<td class="fieldname">
unacked</td>
<td class="fielddoc">
<p>Unacknowledged segments </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketBase__T" id="structSocketBase__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketBase__T">&#9670;&#160;</a></span>SocketBase_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketBase_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Internal implementation of <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> opaque type. </p>
<p>Complete structure definition for the shared socket base, which is embedded directly within subtype implementations (e.g., struct Socket_T, struct <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a>). Centralizes management of common socket state: file descriptor, memory arena, endpoint addresses/ports, timeouts, metrics, and synchronization primitives.</p>
<p>Embedding Pattern</p>
<p>Subtypes declare:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Subtype_T {</div>
<div class="line">  <a class="code hl_struct" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base;  <span class="comment">// Embedded, not pointer</span></div>
<div class="line">  <span class="comment">// Subtype-specific fields</span></div>
<div class="line">};</div>
<div class="ttc" id="agroup__core__io_html_structSocketBase__T"><div class="ttname"><a href="group__core__io.html#structSocketBase__T">SocketBase_T</a></div><div class="ttdoc">Internal implementation of SocketBase_T opaque type.</div><div class="ttdef"><b>Definition</b> <a href="SocketCommon-private_8h_source.html#l00141">SocketCommon-private.h:142</a></div></div>
</div><!-- fragment --><p>Access via getters/setters in this private header to maintain encapsulation.</p>
<p>Thread Safety</p>
<ul>
<li><b>Read Access</b>: Conditional - safe for immutable fields (domain, type) without lock.</li>
<li><b>Write Access</b>: Requires pthread_mutex_lock(&amp;base.mutex) / unlock.</li>
<li><p class="startli"><b>Concurrent Use</b>: External synchronization needed for shared sockets across threads.</p>
<p class="startli">Resource Lifecycle</p>
</li>
<li><b>Creation</b>: <a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914" title="Create a new socket base structure.">SocketCommon_new_base()</a> or <a class="el" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d" title="Initialize pre-allocated SocketBase_T with FD and parameters.">SocketCommon_init_base()</a> allocates arena, initializes mutex, sets CLOEXEC.</li>
<li><b>Cleanup</b>: <a class="el" href="group__core__io.html#gaaeb641ee1edaa618b8680babae9a98c6" title="Free a socket base structure.">SocketCommon_free_base()</a> closes fd, destroys mutex, disposes arena.</li>
<li><b>Order</b>: FD close before mutex destroy before arena dispose.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Endpoint strings (localaddr, remoteaddr) allocated in base.arena; lifetime tied to base. </dd>
<dd>
Metrics snapshot updated by I/O operations; use for per-socket statistics. </dd>
<dd>
Timeouts applied to connect, send/recv, etc. via base.timeouts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> opaque typedef in <a class="el" href="SocketCommon_8h.html" title="Common utilities shared between Socket and SocketDgram modules.">SocketCommon.h</a> </dd>
<dd>
<a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914" title="Create a new socket base structure.">SocketCommon_new_base()</a> for allocation </dd>
<dd>
<a class="el" href="group__core__io.html#gaaeb641ee1edaa618b8680babae9a98c6" title="Free a socket base structure.">SocketCommon_free_base()</a> for deallocation </dd>
<dd>
<a class="el" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d" title="Initialize pre-allocated SocketBase_T with FD and parameters.">SocketCommon_init_base()</a> for initialization from existing FD </dd>
<dd>
docs/METRICS.md for metrics usage </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">core/SocketConfig.h</a> for <a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a> details </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon-private_8h_source.html#l00141">141</a> of file <a class="el" href="SocketCommon-private_8h_source.html">SocketCommon-private.h</a>.</p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketBase_T:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketBase__T__coll__graph.svg" width="463" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a379d42a2097bb1a3bd1ca816c4c12082" name="a379d42a2097bb1a3bd1ca816c4c12082"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Per-socket memory arena for lifecycle </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acd295bedf2538156c0057d81fda7c746" name="acd295bedf2538156c0057d81fda7c746"></a>int</td>
<td class="fieldname">
domain</td>
<td class="fielddoc">
<p>Address domain (AF_INET, AF_INET6, AF_UNIX) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab01b32fb2de3a704eaf34d370900b2c1" name="ab01b32fb2de3a704eaf34d370900b2c1"></a>int</td>
<td class="fieldname">
fd</td>
<td class="fielddoc">
<p>Socket file descriptor (-1 if closed) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a18eb7639ee7541dc1f648d5247eefc7b" name="a18eb7639ee7541dc1f648d5247eefc7b"></a>struct sockaddr_storage</td>
<td class="fieldname">
local_addr</td>
<td class="fielddoc">
<p>Local bound address </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7993e56983ef974a4049347acd140dc8" name="a7993e56983ef974a4049347acd140dc8"></a>socklen_t</td>
<td class="fieldname">
local_addrlen</td>
<td class="fielddoc">
<p>Length of local_addr </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a73fdf506fac941d50b3be36d3d39c473" name="a73fdf506fac941d50b3be36d3d39c473"></a>char *</td>
<td class="fieldname">
localaddr</td>
<td class="fielddoc">
<p>String representation of local address (allocated in arena) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a13259affe210915e55bf525ecf16e27d" name="a13259affe210915e55bf525ecf16e27d"></a>int</td>
<td class="fieldname">
localport</td>
<td class="fielddoc">
<p>Local port number </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac08486d6944d83a58eb40c800f916e88" name="ac08486d6944d83a58eb40c800f916e88"></a><a class="el" href="group__foundation.html#structSocketMetricsSnapshot">SocketMetricsSnapshot</a></td>
<td class="fieldname">
metrics</td>
<td class="fielddoc">
<p>Per-socket metrics snapshot (legacy) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a13cd00fe16b3cefd9a452d9c1f65f515" name="a13cd00fe16b3cefd9a452d9c1f65f515"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
<p>Mutex for thread-safe base access (options, endpoints) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9a622ad04843bbf3a1c722f7574a707b" name="a9a622ad04843bbf3a1c722f7574a707b"></a>int</td>
<td class="fieldname">
protocol</td>
<td class="fielddoc">
<p>Protocol (0 for default) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5ab274badf8ecaa1a655c7a0d17d7787" name="a5ab274badf8ecaa1a655c7a0d17d7787"></a>struct sockaddr_storage</td>
<td class="fieldname">
remote_addr</td>
<td class="fielddoc">
<p>Remote peer address </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0553821afb7b1028576f1d2c5efa737b" name="a0553821afb7b1028576f1d2c5efa737b"></a>socklen_t</td>
<td class="fieldname">
remote_addrlen</td>
<td class="fielddoc">
<p>Length of remote_addr </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aceb1ee55b03c6fd1c0f7181f9602a5fe" name="aceb1ee55b03c6fd1c0f7181f9602a5fe"></a>char *</td>
<td class="fieldname">
remoteaddr</td>
<td class="fielddoc">
<p>String representation of remote address (allocated in arena) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="afd758e86987da928869ef3423702657b" name="afd758e86987da928869ef3423702657b"></a>int</td>
<td class="fieldname">
remoteport</td>
<td class="fielddoc">
<p>Remote port number </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a12bc6e41774944e9ffcb432818c5b650" name="a12bc6e41774944e9ffcb432818c5b650"></a><a class="el" href="group__core__io.html#structSocketStats__T">SocketStats_T</a></td>
<td class="fieldname">
stats</td>
<td class="fielddoc">
<p>Cumulative I/O statistics for this socket </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae8e8251cc5e3777f97ff402b5040404c" name="ae8e8251cc5e3777f97ff402b5040404c"></a><a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a></td>
<td class="fieldname">
timeouts</td>
<td class="fielddoc">
<p>Timeout configuration </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2c7f813a92514f2cb7389bf3b92ae46b" name="a2c7f813a92514f2cb7389bf3b92ae46b"></a>int</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Socket type (SOCK_STREAM, SOCK_DGRAM) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketLiveCount" id="structSocketLiveCount"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketLiveCount">&#9670;&#160;</a></span>SocketLiveCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketLiveCount</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Thread-safe live count tracker for socket instances. </p>
<p>Provides thread-safe increment/decrement operations for tracking live socket instances. Used by both Socket_T and <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a> implementations for debugging and leak detection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__socket__live__utils.html#gaa8cacd863c275e6e12f7c63b65708e1b" title="Query current number of active Socket_T instances (public for tests).">Socket_debug_live_count()</a> for querying the <a class="el" href="group__core__io.html#aa0eb80c5ca5d1e5862958659252abf7e">count</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01069">1069</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa0eb80c5ca5d1e5862958659252abf7e" name="aa0eb80c5ca5d1e5862958659252abf7e"></a>int</td>
<td class="fieldname">
count</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2184fefc1d68daf0fa7309d8de989e88" name="a2184fefc1d68daf0fa7309d8de989e88"></a>pthread_mutex_t</td>
<td class="fieldname">
mutex</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structSocketProxy__Conn__T" id="structSocketProxy__Conn__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketProxy__Conn__T">&#9670;&#160;</a></span>SocketProxy_Conn_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketProxy_Conn_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Opaque proxy connection context for managing tunneling negotiation. </p>
<p>Central structure for a single proxy operation, handling configuration, resources, asynchronous components, state machine, I/O buffering, timing, and error tracking.</p>
<p>Lifecycle: Allocated from arena in public APIs like <a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a>; fields private. Success transfers socket to caller; failure sets error; free cleans remaining.</p>
<p>Groups:</p><ul>
<li>Configuration (copied from user config): proxy/target details, creds, timeouts, headers, TLS.</li>
<li>Resources (owned/managed): arena for memory, socket for I/O (transferred), recvbuf for parsing.</li>
<li>Async resources: dns resolver, poll instance, HappyEyeballs for connect racing (optional external).</li>
<li>HTTP specific: http_parser for CONNECT response validation.</li>
<li>State machine: high-level state, proto_state, result code, SOCKS5 auth flags.</li>
<li>Timing: start times for timeout enforcement using monotonic clock.</li>
<li>I/O state: send/recv buffers (SOCKET_PROXY_BUFFER_SIZE=64KB), offsets for partial transfers.</li>
<li>Error handling: error_buf for messages, transferred flag to prevent double-free.</li>
</ul>
<p>Thread safety: No - single-threaded design; concurrent access undefined. Memory safety: Arena-managed; secure clear for creds if implemented. TLS conditional: tls_ctx and tls_enabled for HTTPS proxy support.</p>
<dl class="section note"><dt>Note</dt><dd>Opaque to public; internal access only via module functions. </dd>
<dd>
owns_dns_poll flag determines cleanup of async resources. </dd>
<dd>
Buffer sizes configurable via defines; error_buf fixed size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketProxy_8h.html" title="Proxy tunneling module for HTTP CONNECT and SOCKS protocols.">SocketProxy.h</a> public SocketProxy_Conn_* API for usage. </dd>
<dd>
<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T" title="Opaque proxy connection context for managing tunneling negotiation.">SocketProxy_Conn_T</a> fields (internal reference). </dd>
<dd>
<a class="el" href="group__proxy__private.html#ga8d5525862e31c82df86ea8ec9ccd493c" title="Protocol-specific sub-state for proxy handshakes.">SocketProxy_ProtoState</a> for detailed protocol sub-states. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be" title="States in the proxy connection state machine.">SocketProxy_State</a> for connection lifecycle states. </dd>
<dd>
SocketHappyEyeballs_T::he for <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> server connection. </dd>
<dd>
SocketHTTP1_Parser_T::http_parser for HTTP parsing. </dd>
<dd>
SocketBuf_T::recvbuf for receive buffering. </dd>
<dd>
Arena_T::arena for memory management. </dd>
<dd>
<a class="el" href="group__dns.html">DNS module</a> for resolution. </dd>
<dd>
<a class="el" href="group__event__system.html">Event system</a> for <a class="el" href="group__proxy__private.html#a84361c1bf1c9efec61171b729effa6e1">poll</a> integration. </dd>
<dd>
<a class="el" href="group__security.html">Security module</a> for TLS. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for internals and examples. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md for <a class="el" href="group__proxy__private.html#a083369e24cff29efd9dc20163e541a16">arena</a> usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketProxy-private_8h_source.html#l00611">611</a> of file <a class="el" href="SocketProxy-private_8h_source.html">SocketProxy-private.h</a>.</p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketProxy_Conn_T:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structSocketProxy__Conn__T__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a083369e24cff29efd9dc20163e541a16" name="a083369e24cff29efd9dc20163e541a16"></a><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></td>
<td class="fieldname">
arena</td>
<td class="fielddoc">
<p>Memory arena for all allocations </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae0aebb2175653871184fe8875f57c633" name="ae0aebb2175653871184fe8875f57c633"></a>int</td>
<td class="fieldname">
connect_timeout_ms</td>
<td class="fielddoc">
<p>Proxy connect timeout </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a431a582be92ea3900cddfcf6ace76048" name="a431a582be92ea3900cddfcf6ace76048"></a><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></td>
<td class="fieldname">
dns</td>
<td class="fielddoc">
<p>DNS resolver for async connection </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aaaed59222364e1228661678468b42283" name="aaaed59222364e1228661678468b42283"></a>char</td>
<td class="fieldname">
error_buf[256]</td>
<td class="fielddoc">
<p>Error message </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2224b074511d1fe06fdcae44d6953dc5" name="a2224b074511d1fe06fdcae44d6953dc5"></a>SocketHTTP_Headers_T</td>
<td class="fieldname">
extra_headers</td>
<td class="fielddoc">
<p>HTTP CONNECT extra headers </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac8dbe4bd33e376a5595c7966f9f40113" name="ac8dbe4bd33e376a5595c7966f9f40113"></a>int64_t</td>
<td class="fieldname">
handshake_start_time_ms</td>
<td class="fielddoc">
<p>When handshake started </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa314392e96e493c77a1deed89728e43c" name="aa314392e96e493c77a1deed89728e43c"></a>int</td>
<td class="fieldname">
handshake_timeout_ms</td>
<td class="fielddoc">
<p>Handshake timeout </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2153b2db669de8d281e0139a91c7c92e" name="a2153b2db669de8d281e0139a91c7c92e"></a><a class="el" href="group__async__io.html#structSocketHE__T">SocketHE_T</a></td>
<td class="fieldname">
he</td>
<td class="fielddoc">
<p>HappyEyeballs context (during connect) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a901962a8ee7faa216d870d2394a8d17d" name="a901962a8ee7faa216d870d2394a8d17d"></a>SocketHTTP1_Parser_T</td>
<td class="fieldname">
http_parser</td>
<td class="fielddoc">
<p>HTTP response parser </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a548c64d7e226630e791314c204c547c4" name="a548c64d7e226630e791314c204c547c4"></a>int</td>
<td class="fieldname">
owns_dns_poll</td>
<td class="fielddoc">
<p>1 if we own dns/poll (sync wrapper), 0 if external </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7d71e6abcb8cb29cc286d94caa492142" name="a7d71e6abcb8cb29cc286d94caa492142"></a>char *</td>
<td class="fieldname">
password</td>
<td class="fielddoc">
<p>Password (arena copy, may be NULL) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a84361c1bf1c9efec61171b729effa6e1" name="a84361c1bf1c9efec61171b729effa6e1"></a><a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a></td>
<td class="fieldname">
poll</td>
<td class="fielddoc">
<p>Poll instance for async connection </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a813513bee1ea5117ffea491c85edcd81" name="a813513bee1ea5117ffea491c85edcd81"></a><a class="el" href="group__proxy__private.html#ga8d5525862e31c82df86ea8ec9ccd493c">SocketProxy_ProtoState</a></td>
<td class="fieldname">
proto_state</td>
<td class="fielddoc">
<p>Protocol sub-state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0e96e5f0261bce7086ad5cc7af7e4b08" name="a0e96e5f0261bce7086ad5cc7af7e4b08"></a>char *</td>
<td class="fieldname">
proxy_host</td>
<td class="fielddoc">
<p>Proxy hostname (arena copy) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a11cf9d48eaae7621057f67b9589edf6b" name="a11cf9d48eaae7621057f67b9589edf6b"></a>int</td>
<td class="fieldname">
proxy_port</td>
<td class="fielddoc">
<p>Proxy port </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a614ffa636c6ca6f92b39f8af950c50a3" name="a614ffa636c6ca6f92b39f8af950c50a3"></a>unsigned char</td>
<td class="fieldname">
recv_buf[65536]</td>
<td class="fielddoc">
<p>Temp receive buffer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a74f03365dce0726d5f66c35f561b742b" name="a74f03365dce0726d5f66c35f561b742b"></a>size_t</td>
<td class="fieldname">
recv_len</td>
<td class="fielddoc">
<p>Data in receive buffer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a63bb3dea323c1f69e223786294aac653" name="a63bb3dea323c1f69e223786294aac653"></a>size_t</td>
<td class="fieldname">
recv_offset</td>
<td class="fielddoc">
<p>Bytes already processed </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aafa5f04a528b20448930f6524568beb2" name="aafa5f04a528b20448930f6524568beb2"></a><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
<td class="fieldname">
recvbuf</td>
<td class="fielddoc">
<p>Receive buffer for protocol parsing </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5e794c6894f28dda56acf59529745a7e" name="a5e794c6894f28dda56acf59529745a7e"></a><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a></td>
<td class="fieldname">
result</td>
<td class="fielddoc">
<p>Final result </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a64870d3e5ff24323c4d1566bc1fb06c6" name="a64870d3e5ff24323c4d1566bc1fb06c6"></a>unsigned char</td>
<td class="fieldname">
send_buf[65536]</td>
<td class="fielddoc">
<p>Send buffer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af843e68c0b6e0e73085fc72e3a28823d" name="af843e68c0b6e0e73085fc72e3a28823d"></a>size_t</td>
<td class="fieldname">
send_len</td>
<td class="fielddoc">
<p>Data in send buffer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="abcf5a9fbce4f4235b67e65f35833611c" name="abcf5a9fbce4f4235b67e65f35833611c"></a>size_t</td>
<td class="fieldname">
send_offset</td>
<td class="fielddoc">
<p>Bytes already sent </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a2c3fc65e5bee85f64a52dea4c4efeb33" name="a2c3fc65e5bee85f64a52dea4c4efeb33"></a>Socket_T</td>
<td class="fieldname">
socket</td>
<td class="fielddoc">
<p>Proxy socket (transferred to caller on success) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af601d7eeeb78ef4fe2c694ad20ee6f44" name="af601d7eeeb78ef4fe2c694ad20ee6f44"></a>int</td>
<td class="fieldname">
socks5_auth_method</td>
<td class="fielddoc">
<p>Selected auth method </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4fa34ec2122d2d9c4a3718565359c86b" name="a4fa34ec2122d2d9c4a3718565359c86b"></a>int</td>
<td class="fieldname">
socks5_need_auth</td>
<td class="fielddoc">
<p>1 if auth required </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a82625ab8fed897529b509e9caf5461b8" name="a82625ab8fed897529b509e9caf5461b8"></a>int64_t</td>
<td class="fieldname">
start_time_ms</td>
<td class="fielddoc">
<p>When operation started </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6676b0ed3643ee6154d26738af148a99" name="a6676b0ed3643ee6154d26738af148a99"></a><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a></td>
<td class="fieldname">
state</td>
<td class="fielddoc">
<p>Main state </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a257faf2aa4300a913c14f65c5941e820" name="a257faf2aa4300a913c14f65c5941e820"></a>char *</td>
<td class="fieldname">
target_host</td>
<td class="fielddoc">
<p>Target hostname (arena copy) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae390638a08d19534bc6d0e698b4da476" name="ae390638a08d19534bc6d0e698b4da476"></a>int</td>
<td class="fieldname">
target_port</td>
<td class="fielddoc">
<p>Target port </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5a7d11532a403ff7f63d99eac1186617" name="a5a7d11532a403ff7f63d99eac1186617"></a><a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a></td>
<td class="fieldname">
tls_ctx</td>
<td class="fielddoc">
<p>TLS context from config (copied ptr) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4858544617c2129855e2b8574df86cf7" name="a4858544617c2129855e2b8574df86cf7"></a>int</td>
<td class="fieldname">
tls_enabled</td>
<td class="fielddoc">
<p>1 after successful TLS handshake to proxy </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a12a3779149de75f678c5c1329e6cf88c" name="a12a3779149de75f678c5c1329e6cf88c"></a>int</td>
<td class="fieldname">
transferred</td>
<td class="fielddoc">
<p>1 if socket transferred to caller </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a894986448a6771af2c160558763cf5cc" name="a894986448a6771af2c160558763cf5cc"></a><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
<p>Proxy type </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad2b795e71eb9323949e6384665970a84" name="ad2b795e71eb9323949e6384665970a84"></a>char *</td>
<td class="fieldname">
username</td>
<td class="fielddoc">
<p>Username (arena copy, may be NULL) </p>
</td></tr>
</table>

</div>
</div>
<a name="structSocketProxy__Config" id="structSocketProxy__Config"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structSocketProxy__Config">&#9670;&#160;</a></span>SocketProxy_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct SocketProxy_Config</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Configuration structure for proxy connections. </p>
<p>Proxy configuration structure (opaque).</p>
<p>Specifies proxy type, server details, authentication credentials, optional HTTP headers, TLS context (for HTTPS proxies), and timeouts.</p>
<p>Important: String fields (host, username, password) are borrowed references. The caller must ensure these pointers remain valid throughout the proxy operation lifetime. Use Arena allocation or static strings accordingly. Sensitive data in password is securely cleared after use where possible.</p>
<p>Default ports per type:</p><ul>
<li>HTTP/HTTPS: 8080</li>
<li>SOCKS: 1080</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga197242786615adf218d849747bc0fd67" title="Initialize proxy configuration with safe default values.">SocketProxy_config_defaults()</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">to</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">initialize</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">with</a> safe <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">defaults</a>. </dd>
<dd>
<a class="el" href="group__core__io.html#gae16c20e1d43f38171ccaad8408598490" title="Parse proxy URL string into configuration structure.">SocketProxy_parse_url()</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">to</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">populate</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">from</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">URL</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">string</a>. </dd>
<dd>
<a class="el" href="group__http.html">HTTP module</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">for</a> <a class="el" href="group__proxy.html#a1a667bd87d678a4e0cb64c14aa0ffd3d" title="HTTP CONNECT-specific options.">extra_headers</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">usage</a>. </dd>
<dd>
<a class="el" href="group__security.html">Security module</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">for</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">TLS</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">configuration</a>. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">for</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">credential</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">handling</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">best</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">practices</a>.</dd>
<dd>
<a class="el" href="group__connection__mgmt.html">Connection Management</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">for</a> <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">details</a>. </dd>
<dd>
<a class="el" href="SocketProxy_8h.html" title="Proxy tunneling module for HTTP CONNECT and SOCKS protocols.">include/socket/SocketProxy.h</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">for</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">full</a> <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">API</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketProxy_8h_source.html#l00379">379</a> of file <a class="el" href="SocketProxy_8h_source.html">SocketProxy.h</a>.</p>
</div><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Collaboration diagram for SocketProxy_Config:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structSocketProxy__Config__coll__graph.svg" width="468" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa761e79e5c6644f3ccb22a4c0300105a" name="aa761e79e5c6644f3ccb22a4c0300105a"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">int</a></td>
<td class="fieldname">
connect_timeout_ms</td>
<td class="fielddoc">
Timeout configuration (0 = use module defaults). <p>Timeout for connecting to proxy server (default: 30s). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a1a667bd87d678a4e0cb64c14aa0ffd3d" name="a1a667bd87d678a4e0cb64c14aa0ffd3d"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">SocketHTTP_Headers_T</a></td>
<td class="fieldname">
extra_headers</td>
<td class="fielddoc">
HTTP CONNECT-specific options. <p>Additional request headers. NULL for none. Owned by caller. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aaefad91d7469f34f214a7fac5e1779d6" name="aaefad91d7469f34f214a7fac5e1779d6"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">int</a></td>
<td class="fieldname">
handshake_timeout_ms</td>
<td class="fielddoc">
<p>Timeout for proxy protocol handshake and auth (default: 30s). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a507287d832417162da30794693e16a6e" name="a507287d832417162da30794693e16a6e"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">const</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">char</a> *</td>
<td class="fieldname">
host</td>
<td class="fielddoc">
Proxy server details. <p>Proxy hostname or IP address. Must remain valid during operation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae619303ab820c36c920c509d735748f2" name="ae619303ab820c36c920c509d735748f2"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">const</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">char</a> *</td>
<td class="fieldname">
password</td>
<td class="fielddoc">
<p>Password string. NULL if no auth or username NULL. Securely handled. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aff28145ee5466be9d0e12fba3e07dc97" name="aff28145ee5466be9d0e12fba3e07dc97"></a>int</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
<p>Proxy port. 0 uses default for type (SOCKS:1080, HTTP:8080). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8939bbe96f2f2f866cab11f6a2713949" name="a8939bbe96f2f2f866cab11f6a2713949"></a><a class="el" href="group__security.html#structSocketTLSContext__T">SocketTLSContext_T</a></td>
<td class="fieldname">
tls_ctx</td>
<td class="fielddoc">
TLS configuration for HTTPS proxies (TLS to proxy server). <p>TLS context. NULL uses secure system defaults if available. Requires <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">if</a> SOCKET_HAS_TLS. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa04cfa88d52d6c1f889f9f936a141141" name="aa04cfa88d52d6c1f889f9f936a141141"></a><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
Proxy protocol type (e.g., SOCKET_PROXY_SOCKS5). </td></tr>
<tr><td class="fieldtype">
<a id="a579714517d79e28bb9b03190d67158d5" name="a579714517d79e28bb9b03190d67158d5"></a><a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">const</a> <a class="el" href="group__proxy.html#aff28145ee5466be9d0e12fba3e07dc97">char</a> *</td>
<td class="fieldname">
username</td>
<td class="fielddoc">
Optional authentication credentials for SOCKS5 or HTTP Basic auth. <p>Username string. NULL if no auth required. Borrowed reference. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga9f55d0e90dc8cc6b2287312435cdde48" name="ga9f55d0e90dc8cc6b2287312435cdde48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f55d0e90dc8cc6b2287312435cdde48">&#9670;&#160;</a></span>MSG_NOSIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_NOSIGNAL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MSG_NOSIGNAL fallback for platforms without it. </p>
<p>Suppress SIGPIPE on send operations (Linux/FreeBSD). On platforms without MSG_NOSIGNAL (macOS), we use SO_NOSIGPIPE instead which is set at socket creation time. When MSG_NOSIGNAL is unavailable, we define it as 0 so it can be safely OR'd into flags without effect.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga9f55d0e90dc8cc6b2287312435cdde48" title="MSG_NOSIGNAL fallback for platforms without it.">MSG_NOSIGNAL</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02469">2469</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7f6c789e54c4efbc66d4a9cbc947734f" name="ga7f6c789e54c4efbc66d4a9cbc947734f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6c789e54c4efbc66d4a9cbc947734f">&#9670;&#160;</a></span>SAFE_UDP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_UDP_SIZE&#160;&#160;&#160;1472UL /* Safe for Ethernet MTU (1500 - IP/UDP ~28) */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe UDP payload size for Ethernet MTU. </p>
<p>Ensures packets fit within standard 1500-byte Ethernet MTU after IP/UDP headers (~28 bytes).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga7b0cb8d09882f145ebd41ad5a5932a30" title="Maximum UDP payload size excluding headers.">UDP_MAX_PAYLOAD</a> for protocol maximum. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00302">302</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga04ce265041d74932e7d3354651fd0a79" name="ga04ce265041d74932e7d3354651fd0a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ce265041d74932e7d3354651fd0a79">&#9670;&#160;</a></span>SOCKET_AF_INET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AF_INET&#160;&#160;&#160;AF_INET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPv4 address family. </p>
<dl class="section see"><dt>See also</dt><dd>AF_INET </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01984">1984</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7a754a1f4470597ea52da2a678378100" name="ga7a754a1f4470597ea52da2a678378100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a754a1f4470597ea52da2a678378100">&#9670;&#160;</a></span>SOCKET_AF_INET6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AF_INET6&#160;&#160;&#160;AF_INET6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPv6 address family. </p>
<dl class="section see"><dt>See also</dt><dd>AF_INET6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01992">1992</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaf26b9f671650b58e0bd264a71ec3cbfa" name="gaf26b9f671650b58e0bd264a71ec3cbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf26b9f671650b58e0bd264a71ec3cbfa">&#9670;&#160;</a></span>SOCKET_AF_UNIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AF_UNIX&#160;&#160;&#160;AF_UNIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unix domain socket address family. </p>
<dl class="section see"><dt>See also</dt><dd>AF_UNIX </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02000">2000</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga723007dbfa6e622f70650dce72fe4949" name="ga723007dbfa6e622f70650dce72fe4949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723007dbfa6e622f70650dce72fe4949">&#9670;&#160;</a></span>SOCKET_AF_UNSPEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AF_UNSPEC&#160;&#160;&#160;AF_UNSPEC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unspecified address family. </p>
<dl class="section see"><dt>See also</dt><dd>AF_UNSPEC </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01976">1976</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac5c758285ea3ec616ebef228524e5870" name="gac5c758285ea3ec616ebef228524e5870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c758285ea3ec616ebef228524e5870">&#9670;&#160;</a></span>SOCKET_AI_NUMERICHOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AI_NUMERICHOST&#160;&#160;&#160;AI_NUMERICHOST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numeric host address flag for getaddrinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>AI_NUMERICHOST </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02386">2386</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga9650f9a758e7db73f81549f62c336c06" name="ga9650f9a758e7db73f81549f62c336c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9650f9a758e7db73f81549f62c336c06">&#9670;&#160;</a></span>SOCKET_AI_NUMERICSERV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AI_NUMERICSERV&#160;&#160;&#160;AI_NUMERICSERV</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numeric service port flag for getaddrinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>AI_NUMERICSERV </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02394">2394</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaf554ab0a276793e3c2211071e90d2379" name="gaf554ab0a276793e3c2211071e90d2379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf554ab0a276793e3c2211071e90d2379">&#9670;&#160;</a></span>SOCKET_AI_PASSIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_AI_PASSIVE&#160;&#160;&#160;AI_PASSIVE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passive socket flag for getaddrinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>AI_PASSIVE </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02378">2378</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga4c36ad0507aab15f0b59b4ccde5dfb31" name="ga4c36ad0507aab15f0b59b4ccde5dfb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c36ad0507aab15f0b59b4ccde5dfb31">&#9670;&#160;</a></span>SOCKET_DEFAULT_DATAGRAM_TTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_DATAGRAM_TTL&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default datagram TTL value. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02577">2577</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac01d46f482abd08d6fb51a115b3590c4" name="gac01d46f482abd08d6fb51a115b3590c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac01d46f482abd08d6fb51a115b3590c4">&#9670;&#160;</a></span>SOCKET_DEFAULT_DNS_TIMEOUT_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_DNS_TIMEOUT_MS&#160;&#160;&#160;5000 /* 5 seconds */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default DNS resolution timeout. </p>
<dl class="section see"><dt>See also</dt><dd>SocketHappyEyeballs_T for Happy Eyeballs implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01411">1411</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gafd745a2d91d7bc8aad76a133ef1cb0bf" name="gafd745a2d91d7bc8aad76a133ef1cb0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd745a2d91d7bc8aad76a133ef1cb0bf">&#9670;&#160;</a></span>SOCKET_DEFAULT_KEEPALIVE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_KEEPALIVE_COUNT&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default TCP keep-alive probe count. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02520">2520</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga72227e2f5945efa472401c12608ae6f0" name="ga72227e2f5945efa472401c12608ae6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72227e2f5945efa472401c12608ae6f0">&#9670;&#160;</a></span>SOCKET_DEFAULT_KEEPALIVE_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_KEEPALIVE_IDLE&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default TCP keep-alive idle time (seconds). </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02506">2506</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac35dee011f3919c4720812ef8b163f03" name="gac35dee011f3919c4720812ef8b163f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac35dee011f3919c4720812ef8b163f03">&#9670;&#160;</a></span>SOCKET_DEFAULT_KEEPALIVE_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DEFAULT_KEEPALIVE_INTERVAL&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default TCP keep-alive interval (seconds). </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02513">2513</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaeb19a3aa101d92d9befe7a980238bf0d" name="gaeb19a3aa101d92d9befe7a980238bf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb19a3aa101d92d9befe7a980238bf0d">&#9670;&#160;</a></span>SOCKET_DGRAM_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DGRAM_TYPE&#160;&#160;&#160;SOCK_DGRAM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UDP datagram socket type. </p>
<dl class="section see"><dt>See also</dt><dd>SOCK_DGRAM </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01968">1968</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa40398fc3798e6302da2f39fcc3b9c64" name="gaa40398fc3798e6302da2f39fcc3b9c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40398fc3798e6302da2f39fcc3b9c64">&#9670;&#160;</a></span>SOCKET_DNS_CACHE_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_CACHE_HASH_SIZE&#160;&#160;&#160;1021</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DNS cache hash table size. </p>
<p>Prime number for optimal hash distribution in cache lookups. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00630">630</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga38939e0f4010e9cc311360b1d974d068" name="ga38939e0f4010e9cc311360b1d974d068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38939e0f4010e9cc311360b1d974d068">&#9670;&#160;</a></span>SOCKET_DNS_COMPLETION_SIGNAL_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_COMPLETION_SIGNAL_BYTE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion signal byte value for DNS pipe signaling. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00573">573</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga176cef29fe829568359c936376db272e" name="ga176cef29fe829568359c936376db272e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176cef29fe829568359c936376db272e">&#9670;&#160;</a></span>SOCKET_DNS_DEFAULT_CACHE_MAX_ENTRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_DEFAULT_CACHE_MAX_ENTRIES&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default maximum DNS cache entries. </p>
<p>Limits memory usage by capping cached DNS results. When exceeded, oldest entries are evicted (LRU).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#ga358ec74cbdfba760e98798bb0269ec70" title="Set the maximum number of entries in the DNS cache.">SocketDNS_cache_set_max_entries()</a> to configure at runtime. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00619">619</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga718d350473539fc8a704e3afa05bb694" name="ga718d350473539fc8a704e3afa05bb694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga718d350473539fc8a704e3afa05bb694">&#9670;&#160;</a></span>SOCKET_DNS_DEFAULT_CACHE_TTL_SECONDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_DEFAULT_CACHE_TTL_SECONDS&#160;&#160;&#160;300</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default DNS cache TTL in seconds. </p>
<p>Controls how long DNS resolution results are cached before being considered stale. Default 5 minutes balances freshness with performance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#gaaf578d18322c0da146bfc52e236ae91d" title="Set the TTL (time-to-live) for cached DNS results.">SocketDNS_cache_set_ttl()</a> to configure at runtime. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00606">606</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gab9d107f9984dd45f9ba4b1618ad373ad" name="gab9d107f9984dd45f9ba4b1618ad373ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9d107f9984dd45f9ba4b1618ad373ad">&#9670;&#160;</a></span>SOCKET_DNS_MAX_LABEL_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_MAX_LABEL_LENGTH&#160;&#160;&#160;63</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum DNS label length. </p>
<p>Per RFC 1035, DNS labels are limited to 63 characters. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00534">534</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gafe6640a153bf74038b7a011808d6bf78" name="gafe6640a153bf74038b7a011808d6bf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe6640a153bf74038b7a011808d6bf78">&#9670;&#160;</a></span>SOCKET_DNS_MAX_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_MAX_PENDING&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum pending DNS requests. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> for DNS implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00523">523</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaabf88e7e79136014eb538ec90cf2a0f4" name="gaabf88e7e79136014eb538ec90cf2a0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabf88e7e79136014eb538ec90cf2a0f4">&#9670;&#160;</a></span>SOCKET_DNS_PIPE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_PIPE_BUFFER_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completion pipe read buffer size. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00564">564</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga8dd2e41af45c32418159edb2bfa3d4b8" name="ga8dd2e41af45c32418159edb2bfa3d4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd2e41af45c32418159edb2bfa3d4b8">&#9670;&#160;</a></span>SOCKET_DNS_PORT_STR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_PORT_STR_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Port number string buffer size. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00582">582</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad93bb14bccd4fd5d8f37a22b30a4c944" name="gad93bb14bccd4fd5d8f37a22b30a4c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93bb14bccd4fd5d8f37a22b30a4c944">&#9670;&#160;</a></span>SOCKET_DNS_REQUEST_HASH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_REQUEST_HASH_SIZE&#160;&#160;&#160;1021</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DNS request hash table size. </p>
<p>Prime number for optimal hash distribution.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gafe6640a153bf74038b7a011808d6bf78" title="Maximum pending DNS requests.">SOCKET_DNS_MAX_PENDING</a> for request limits. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00555">555</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7333dd84db01bccd272a0a535cb69ffa" name="ga7333dd84db01bccd272a0a535cb69ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7333dd84db01bccd272a0a535cb69ffa">&#9670;&#160;</a></span>SOCKET_DNS_THREAD_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_THREAD_COUNT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of DNS worker threads. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> for async DNS resolution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00513">513</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae19af4d3535b2bb856fa673bdaa45983" name="gae19af4d3535b2bb856fa673bdaa45983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19af4d3535b2bb856fa673bdaa45983">&#9670;&#160;</a></span>SOCKET_DNS_THREAD_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_THREAD_NAME_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread name buffer size. </p>
<p>POSIX maximum 16 characters including null terminator. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00593">593</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga30e7a628ce9483f24b2f86ef0e985639" name="ga30e7a628ce9483f24b2f86ef0e985639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e7a628ce9483f24b2f86ef0e985639">&#9670;&#160;</a></span>SOCKET_DNS_WORKER_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_DNS_WORKER_STACK_SIZE&#160;&#160;&#160;(128 * 1024)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DNS worker thread stack size. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00543">543</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac0cac1c13bb3060c9311bba91b026c63" name="gac0cac1c13bb3060c9311bba91b026c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0cac1c13bb3060c9311bba91b026c63">&#9670;&#160;</a></span>SOCKET_FD_CLOEXEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_FD_CLOEXEC&#160;&#160;&#160;FD_CLOEXEC</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File descriptor close-on-exec flag. </p>
<dl class="section see"><dt>See also</dt><dd>FD_CLOEXEC </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02119">2119</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga179e47f6c98b38853e2f9e223586dc5d" name="ga179e47f6c98b38853e2f9e223586dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179e47f6c98b38853e2f9e223586dc5d">&#9670;&#160;</a></span>SOCKET_HAS_ACCEPT4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_ACCEPT4&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linux-specific accept4() support flag. </p>
<p>Linux-specific features detection.</p>
<p>Detects Linux platform (<b>linux</b>) to enable Linux-only optimizations and options:</p><ul>
<li>accept4(): Atomic accept with non-blocking and CLOEXEC flags.</li>
<li>SO_DOMAIN: Socket option to query address family (AF_INET, etc.).</li>
</ul>
<p>On non-Linux platforms, these fall back to standard accept() + fcntl() and no SO_DOMAIN support.</p>
<dl class="section see"><dt>See also</dt><dd>accept4(2) Linux man page for accept4 details. </dd>
<dd>
<a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> portable wrapper. </dd>
<dd>
getsockopt(2) for SO_DOMAIN usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02105">2105</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga1b4cba449b689c0e2069c5592d65ff70" name="ga1b4cba449b689c0e2069c5592d65ff70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b4cba449b689c0e2069c5592d65ff70">&#9670;&#160;</a></span>SOCKET_HAS_RECVMSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_RECVMSG&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recvmsg() support flag. </p>
<p>Standard POSIX - always available. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01365">1365</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga3d1b69dbf142e7aaa4b329f0e0f34dee" name="ga3d1b69dbf142e7aaa4b329f0e0f34dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1b69dbf142e7aaa4b329f0e0f34dee">&#9670;&#160;</a></span>SOCKET_HAS_SENDMSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_SENDMSG&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sendmsg() support flag. </p>
<p>Standard POSIX - always available. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01356">1356</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac8ffdac83de0d6abd074776faf8eb016" name="gac8ffdac83de0d6abd074776faf8eb016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8ffdac83de0d6abd074776faf8eb016">&#9670;&#160;</a></span>SOCKET_HAS_SO_NOSIGPIPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_SO_NOSIGPIPE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SO_NOSIGPIPE support flag. </p>
<p>BSD/macOS socket option to suppress SIGPIPE. This is set once at socket creation time as an alternative to MSG_NOSIGNAL. On Linux, MSG_NOSIGNAL is preferred and this macro will be 0.</p>
<dl class="section see"><dt>See also</dt><dd>SO_NOSIGPIPE </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02493">2493</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae59b371249a0e487e26d4f9e087351e5" name="gae59b371249a0e487e26d4f9e087351e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae59b371249a0e487e26d4f9e087351e5">&#9670;&#160;</a></span>SOCKET_HAS_TCP_CONGESTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_TCP_CONGESTION&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP congestion control algorithm (if available). </p>
<dl class="section see"><dt>See also</dt><dd>TCP_CONGESTION </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02224">2224</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga680a9b46408253f21f2fae08fab1a073" name="ga680a9b46408253f21f2fae08fab1a073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680a9b46408253f21f2fae08fab1a073">&#9670;&#160;</a></span>SOCKET_HAS_TCP_FASTOPEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_TCP_FASTOPEN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP Fast Open support (if available). </p>
<dl class="section see"><dt>See also</dt><dd>TCP_FASTOPEN </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02240">2240</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2e0034bad5cc9db994f51ea107fed151" name="ga2e0034bad5cc9db994f51ea107fed151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0034bad5cc9db994f51ea107fed151">&#9670;&#160;</a></span>SOCKET_HAS_TCP_USER_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_HAS_TCP_USER_TIMEOUT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP user timeout support (if available). </p>
<dl class="section see"><dt>See also</dt><dd>TCP_USER_TIMEOUT </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02253">2253</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga3a982d41e0cbfea982c0ee35cab78ae3" name="ga3a982d41e0cbfea982c0ee35cab78ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a982d41e0cbfea982c0ee35cab78ae3">&#9670;&#160;</a></span>SOCKET_IP_ADD_MEMBERSHIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IP_ADD_MEMBERSHIP&#160;&#160;&#160;IP_ADD_MEMBERSHIP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IP multicast add membership. </p>
<dl class="section see"><dt>See also</dt><dd>IP_ADD_MEMBERSHIP </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02357">2357</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga057793cb88e55bf92024c4c36e81a9e5" name="ga057793cb88e55bf92024c4c36e81a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057793cb88e55bf92024c4c36e81a9e5">&#9670;&#160;</a></span>SOCKET_IP_DROP_MEMBERSHIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IP_DROP_MEMBERSHIP&#160;&#160;&#160;IP_DROP_MEMBERSHIP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IP multicast drop membership. </p>
<dl class="section see"><dt>See also</dt><dd>IP_DROP_MEMBERSHIP </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02365">2365</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaaa278a4a5238ff43c2eedd874cd289b0" name="gaaa278a4a5238ff43c2eedd874cd289b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa278a4a5238ff43c2eedd874cd289b0">&#9670;&#160;</a></span>SOCKET_IP_TTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IP_TTL&#160;&#160;&#160;IP_TTL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IP time to live. </p>
<dl class="section see"><dt>See also</dt><dd>IP_TTL </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02349">2349</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaf4deb45fce6ccd9618225ad46d6c414b" name="gaf4deb45fce6ccd9618225ad46d6c414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4deb45fce6ccd9618225ad46d6c414b">&#9670;&#160;</a></span>SOCKET_IPPROTO_IP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPPROTO_IP&#160;&#160;&#160;IPPROTO_IP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IP protocol number. </p>
<dl class="section see"><dt>See also</dt><dd>IPPROTO_IP </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02024">2024</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga98c4b46c80919077e8a17075c1843ecf" name="ga98c4b46c80919077e8a17075c1843ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98c4b46c80919077e8a17075c1843ecf">&#9670;&#160;</a></span>SOCKET_IPPROTO_IPV6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPPROTO_IPV6&#160;&#160;&#160;IPPROTO_IPV6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPv6 protocol number. </p>
<dl class="section see"><dt>See also</dt><dd>IPPROTO_IPV6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02032">2032</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga23ac52f2e8e200798e44cdbf8704096b" name="ga23ac52f2e8e200798e44cdbf8704096b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ac52f2e8e200798e44cdbf8704096b">&#9670;&#160;</a></span>SOCKET_IPPROTO_TCP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPPROTO_TCP&#160;&#160;&#160;IPPROTO_TCP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP protocol number. </p>
<dl class="section see"><dt>See also</dt><dd>IPPROTO_TCP </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02008">2008</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaffc1bd28b038fdf084f3363167b1f4f4" name="gaffc1bd28b038fdf084f3363167b1f4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffc1bd28b038fdf084f3363167b1f4f4">&#9670;&#160;</a></span>SOCKET_IPPROTO_UDP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPPROTO_UDP&#160;&#160;&#160;IPPROTO_UDP</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UDP protocol number. </p>
<dl class="section see"><dt>See also</dt><dd>IPPROTO_UDP </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02016">2016</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga08fcedac2973fd36f2ed55cc2f2c13d2" name="ga08fcedac2973fd36f2ed55cc2f2c13d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08fcedac2973fd36f2ed55cc2f2c13d2">&#9670;&#160;</a></span>SOCKET_IPV4_MAX_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPV4_MAX_PREFIX&#160;&#160;&#160;32 /* IPv4 address bits */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum IPv4 prefix length in bits. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00342">342</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacddf48aa583cfb80ca7caa6efd4f7143" name="gacddf48aa583cfb80ca7caa6efd4f7143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddf48aa583cfb80ca7caa6efd4f7143">&#9670;&#160;</a></span>SOCKET_IPV6_MAX_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPV6_MAX_PREFIX&#160;&#160;&#160;128 /* IPv6 address bits */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum IPv6 prefix length in bits. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00333">333</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga6718d10ef55392425b3e4eea07ee15ce" name="ga6718d10ef55392425b3e4eea07ee15ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6718d10ef55392425b3e4eea07ee15ce">&#9670;&#160;</a></span>SOCKET_IPV6_UNICAST_HOPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPV6_UNICAST_HOPS&#160;&#160;&#160;IPV6_UNICAST_HOPS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPv6 multicast add membership. </p>
<dl class="section see"><dt>See also</dt><dd>IPV6_ADD_MEMBERSHIP, IPV6_JOIN_GROUP</dd></dl>
<p>IPv6 multicast drop membership.</p>
<dl class="section see"><dt>See also</dt><dd>IPV6_DROP_MEMBERSHIP, IPV6_LEAVE_GROUP</dd></dl>
<p>IPv6 unicast hop limit.</p>
<dl class="section see"><dt>See also</dt><dd>IPV6_UNICAST_HOPS </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02336">2336</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gabc73d2f6f2da35365e09b28eff6364b8" name="gabc73d2f6f2da35365e09b28eff6364b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc73d2f6f2da35365e09b28eff6364b8">&#9670;&#160;</a></span>SOCKET_IPV6_V6ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_IPV6_V6ONLY&#160;&#160;&#160;IPV6_V6ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPv6 only flag. </p>
<p>Restricts socket to IPv6 only (no IPv4-mapped IPv6 addresses).</p>
<dl class="section see"><dt>See also</dt><dd>IPV6_V6ONLY </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02300">2300</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7b31ca82a1d8746c1cb6465b8b186ad6" name="ga7b31ca82a1d8746c1cb6465b8b186ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b31ca82a1d8746c1cb6465b8b186ad6">&#9670;&#160;</a></span>SOCKET_KEEPALIVE_MAX_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_KEEPALIVE_MAX_COUNT&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum TCP keep-alive probe count. </p>
<p>Limits the number of failed probes before disconnect. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02549">2549</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacd4fa06ce19af6f368a12df79ff7ad66" name="gacd4fa06ce19af6f368a12df79ff7ad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4fa06ce19af6f368a12df79ff7ad66">&#9670;&#160;</a></span>SOCKET_KEEPALIVE_MAX_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_KEEPALIVE_MAX_IDLE&#160;&#160;&#160;(86400 * 365) /* 1 year in seconds */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum TCP keep-alive idle time (seconds). </p>
<p>Limits the idle time before first probe to 1 year. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02529">2529</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gab1ea2cf17f9bdb3c1486b5507a909b51" name="gab1ea2cf17f9bdb3c1486b5507a909b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ea2cf17f9bdb3c1486b5507a909b51">&#9670;&#160;</a></span>SOCKET_KEEPALIVE_MAX_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_KEEPALIVE_MAX_INTERVAL&#160;&#160;&#160;3600 /* 1 hour */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum TCP keep-alive interval (seconds). </p>
<p>Limits the interval between probes to 1 hour. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02539">2539</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga73ce13cff9dec99c824f8594e22f159e" name="ga73ce13cff9dec99c824f8594e22f159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73ce13cff9dec99c824f8594e22f159e">&#9670;&#160;</a></span>SOCKET_MAX_CONGESTION_ALGO_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_CONGESTION_ALGO_LEN&#160;&#160;&#160;63</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum congestion control algorithm name length. </p>
<p>Maximum length of TCP_CONGESTION algorithm name string (excluding null). </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02569">2569</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad2e12edc544b767b4c90fcc27f2dd2f0" name="gad2e12edc544b767b4c90fcc27f2dd2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e12edc544b767b4c90fcc27f2dd2f0">&#9670;&#160;</a></span>SOCKET_MAX_DEFER_ACCEPT_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_DEFER_ACCEPT_SEC&#160;&#160;&#160;3600 /* 1 hour */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum TCP defer accept timeout (seconds). </p>
<p>Limits TCP_DEFER_ACCEPT/SO_ACCEPTFILTER timeout to 1 hour. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02559">2559</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga9b64483d1dd5d32bba7937741c36cabf" name="ga9b64483d1dd5d32bba7937741c36cabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b64483d1dd5d32bba7937741c36cabf">&#9670;&#160;</a></span>SOCKET_MAX_FDS_PER_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_FDS_PER_MSG&#160;&#160;&#160;253 /* SCM_MAX_FD on most POSIX systems */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum file descriptors per SCM_RIGHTS message. </p>
<p>Unix domain socket file descriptor passing limit.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga70c2f94b87d307842c7d11de0b6a2bce" title="Send multiple file descriptors.">Socket_sendfds()</a> for FD passing implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00387">387</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2fb10bfccfe83fb0bb5873949cf8a2f7" name="ga2fb10bfccfe83fb0bb5873949cf8a2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb10bfccfe83fb0bb5873949cf8a2f7">&#9670;&#160;</a></span>SOCKET_MAX_LISTEN_BACKLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_LISTEN_BACKLOG&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum backlog for listen() system call. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> for server socket setup. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00375">375</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga5d3af7fc5447a76f5f64430362d6dfcf" name="ga5d3af7fc5447a76f5f64430362d6dfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3af7fc5447a76f5f64430362d6dfcf">&#9670;&#160;</a></span>SOCKET_MAX_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_PORT&#160;&#160;&#160;65535 /* Standard TCP/UDP port max */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum TCP/UDP port number. </p>
<p>Standard maximum for port numbers. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00353">353</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad19b3a142a302a366a345ce7272763a6" name="gad19b3a142a302a366a345ce7272763a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad19b3a142a302a366a345ce7272763a6">&#9670;&#160;</a></span>SOCKET_MAX_TTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MAX_TTL&#160;&#160;&#160;255 /* Standard IP TTL max */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum IP TTL (Time To Live) value. </p>
<p>Standard maximum for IP packets. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00324">324</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga6d8596dc13da264d86966c08b435110a" name="ga6d8596dc13da264d86966c08b435110a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8596dc13da264d86966c08b435110a">&#9670;&#160;</a></span>SOCKET_MSG_NOSIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MSG_NOSIGNAL&#160;&#160;&#160;<a class="el" href="group__core__io.html#ga9f55d0e90dc8cc6b2287312435cdde48">MSG_NOSIGNAL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppress SIGPIPE on send operations. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga9f55d0e90dc8cc6b2287312435cdde48" title="MSG_NOSIGNAL fallback for platforms without it.">MSG_NOSIGNAL</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02478">2478</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaf69be862b0cece4e20e7ea283ad91c70" name="gaf69be862b0cece4e20e7ea283ad91c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf69be862b0cece4e20e7ea283ad91c70">&#9670;&#160;</a></span>SOCKET_MULTICAST_DEFAULT_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_MULTICAST_DEFAULT_INTERFACE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default multicast interface index. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02584">2584</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gabb714afb577d800a5b6388c5ff985e45" name="gabb714afb577d800a5b6388c5ff985e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb714afb577d800a5b6388c5ff985e45">&#9670;&#160;</a></span>SOCKET_NI_MAXHOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_NI_MAXHOST&#160;&#160;&#160;NI_MAXHOST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum host name length for getnameinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>NI_MAXHOST </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02418">2418</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0470d30293aefa9d90b1adeae8b2a893" name="ga0470d30293aefa9d90b1adeae8b2a893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0470d30293aefa9d90b1adeae8b2a893">&#9670;&#160;</a></span>SOCKET_NI_MAXSERV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_NI_MAXSERV&#160;&#160;&#160;NI_MAXSERV</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum service name length for getnameinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>NI_MAXSERV </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02426">2426</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaed05968c714f431c7489dbbd6491c4da" name="gaed05968c714f431c7489dbbd6491c4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed05968c714f431c7489dbbd6491c4da">&#9670;&#160;</a></span>SOCKET_NI_NUMERICHOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_NI_NUMERICHOST&#160;&#160;&#160;NI_NUMERICHOST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numeric host address flag for getnameinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>NI_NUMERICHOST </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02402">2402</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga189adadf65e2effcf336ae92be1453a3" name="ga189adadf65e2effcf336ae92be1453a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga189adadf65e2effcf336ae92be1453a3">&#9670;&#160;</a></span>SOCKET_NI_NUMERICSERV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_NI_NUMERICSERV&#160;&#160;&#160;NI_NUMERICSERV</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numeric service port flag for getnameinfo(). </p>
<dl class="section see"><dt>See also</dt><dd>NI_NUMERICSERV </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02410">2410</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaf86c34b79f0c5546c8b538edcd9372e1" name="gaf86c34b79f0c5546c8b538edcd9372e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86c34b79f0c5546c8b538edcd9372e1">&#9670;&#160;</a></span>SOCKET_SENDFILE_FALLBACK_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SENDFILE_FALLBACK_BUFFER_SIZE&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fallback buffer size for sendfile operations. </p>
<p>Used when sendfile() is not available or fails. </p>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00313">313</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gad846caae5ed6ec066d9ae975c23d0e10" name="gad846caae5ed6ec066d9ae975c23d0e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad846caae5ed6ec066d9ae975c23d0e10">&#9670;&#160;</a></span>SOCKET_SHUT_RD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SHUT_RD&#160;&#160;&#160;SHUT_RD</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown read direction. </p>
<dl class="section see"><dt>See also</dt><dd>SHUT_RD </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02439">2439</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga30e4937ecabbc1aafef3092ed4d062e4" name="ga30e4937ecabbc1aafef3092ed4d062e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e4937ecabbc1aafef3092ed4d062e4">&#9670;&#160;</a></span>SOCKET_SHUT_RDWR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SHUT_RDWR&#160;&#160;&#160;SHUT_RDWR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown both read and write directions. </p>
<dl class="section see"><dt>See also</dt><dd>SHUT_RDWR </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02455">2455</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga5549c3faf506d9057ac05de132462f87" name="ga5549c3faf506d9057ac05de132462f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5549c3faf506d9057ac05de132462f87">&#9670;&#160;</a></span>SOCKET_SHUT_WR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SHUT_WR&#160;&#160;&#160;SHUT_WR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown write direction. </p>
<dl class="section see"><dt>See also</dt><dd>SHUT_WR </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02447">2447</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga1d16a51106f47efdc76e1495f3cf9ead" name="ga1d16a51106f47efdc76e1495f3cf9ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d16a51106f47efdc76e1495f3cf9ead">&#9670;&#160;</a></span>SOCKET_SO_BROADCAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_BROADCAST&#160;&#160;&#160;SO_BROADCAST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable broadcast transmission. </p>
<dl class="section see"><dt>See also</dt><dd>SO_BROADCAST </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02127">2127</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga0f7074b869b88f5fb750473b41e6eb5e" name="ga0f7074b869b88f5fb750473b41e6eb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7074b869b88f5fb750473b41e6eb5e">&#9670;&#160;</a></span>SOCKET_SO_KEEPALIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_KEEPALIVE&#160;&#160;&#160;SO_KEEPALIVE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable keep-alive packets. </p>
<dl class="section see"><dt>See also</dt><dd>SO_KEEPALIVE </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02135">2135</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gac9a84a186673663e3306d00e73e6abc1" name="gac9a84a186673663e3306d00e73e6abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a84a186673663e3306d00e73e6abc1">&#9670;&#160;</a></span>SOCKET_SO_PEERCRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_PEERCRED&#160;&#160;&#160;SO_PEERCRED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peer credentials. </p>
<dl class="section see"><dt>See also</dt><dd>SO_PEERCRED </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02175">2175</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga057781fff8a16936f1d2f81e639d17e9" name="ga057781fff8a16936f1d2f81e639d17e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057781fff8a16936f1d2f81e639d17e9">&#9670;&#160;</a></span>SOCKET_SO_RCVBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_RCVBUF&#160;&#160;&#160;SO_RCVBUF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive buffer size. </p>
<dl class="section see"><dt>See also</dt><dd>SO_RCVBUF </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02159">2159</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae523e4269e9d3d8d811d9b201cd22bda" name="gae523e4269e9d3d8d811d9b201cd22bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae523e4269e9d3d8d811d9b201cd22bda">&#9670;&#160;</a></span>SOCKET_SO_RCVTIMEO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_RCVTIMEO&#160;&#160;&#160;SO_RCVTIMEO</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive timeout. </p>
<dl class="section see"><dt>See also</dt><dd>SO_RCVTIMEO </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02143">2143</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga7a238f64c49ef6c7aea7cfe16d1e0ac5" name="ga7a238f64c49ef6c7aea7cfe16d1e0ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a238f64c49ef6c7aea7cfe16d1e0ac5">&#9670;&#160;</a></span>SOCKET_SO_REUSEADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_REUSEADDR&#160;&#160;&#160;SO_REUSEADDR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow reuse of local addresses. </p>
<dl class="section see"><dt>See also</dt><dd>SO_REUSEADDR </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02053">2053</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa677c5c4c9fb9c2901f59bae61218989" name="gaa677c5c4c9fb9c2901f59bae61218989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa677c5c4c9fb9c2901f59bae61218989">&#9670;&#160;</a></span>SOCKET_SO_REUSEPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_REUSEPORT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow reuse of local ports (if available). </p>
<dl class="section see"><dt>See also</dt><dd>SO_REUSEPORT </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02065">2065</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga458bafdef6d2bfdd698d25935a9a05a8" name="ga458bafdef6d2bfdd698d25935a9a05a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458bafdef6d2bfdd698d25935a9a05a8">&#9670;&#160;</a></span>SOCKET_SO_SNDBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_SNDBUF&#160;&#160;&#160;SO_SNDBUF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send buffer size. </p>
<dl class="section see"><dt>See also</dt><dd>SO_SNDBUF </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02167">2167</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga4e79c5dbef56609cfb2ca32a5cf82257" name="ga4e79c5dbef56609cfb2ca32a5cf82257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e79c5dbef56609cfb2ca32a5cf82257">&#9670;&#160;</a></span>SOCKET_SO_SNDTIMEO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SO_SNDTIMEO&#160;&#160;&#160;SO_SNDTIMEO</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send timeout. </p>
<dl class="section see"><dt>See also</dt><dd>SO_SNDTIMEO </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02151">2151</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga3e9c0eecdab0e5173a8a5c75d84dc932" name="ga3e9c0eecdab0e5173a8a5c75d84dc932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e9c0eecdab0e5173a8a5c75d84dc932">&#9670;&#160;</a></span>SOCKET_SOCK_CLOEXEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SOCK_CLOEXEC&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SOCK_CLOEXEC flag for socket creation (if available). </p>
<dl class="section see"><dt>See also</dt><dd>SOCK_CLOEXEC </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02079">2079</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gaa4457fd2dac639801c08d5b7633cf0e8" name="gaa4457fd2dac639801c08d5b7633cf0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4457fd2dac639801c08d5b7633cf0e8">&#9670;&#160;</a></span>SOCKET_SOL_SOCKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_SOL_SOCKET&#160;&#160;&#160;SOL_SOCKET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Socket options level. </p>
<dl class="section see"><dt>See also</dt><dd>SOL_SOCKET </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02045">2045</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae91c5e89e959589a4c72b572da87aed1" name="gae91c5e89e959589a4c72b572da87aed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae91c5e89e959589a4c72b572da87aed1">&#9670;&#160;</a></span>SOCKET_STREAM_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_STREAM_TYPE&#160;&#160;&#160;SOCK_STREAM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TCP stream socket type. </p>
<dl class="section see"><dt>See also</dt><dd>SOCK_STREAM </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l01960">1960</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gae9b4cfc38baeb5d092a9dbc968868e17" name="gae9b4cfc38baeb5d092a9dbc968868e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9b4cfc38baeb5d092a9dbc968868e17">&#9670;&#160;</a></span>SOCKET_TCP_KEEPCNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TCP_KEEPCNT&#160;&#160;&#160;TCP_KEEPCNT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep-alive probe count. </p>
<dl class="section see"><dt>See also</dt><dd>TCP_KEEPCNT </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02212">2212</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga213393dd843fb9bbb3a8e452fea5838e" name="ga213393dd843fb9bbb3a8e452fea5838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213393dd843fb9bbb3a8e452fea5838e">&#9670;&#160;</a></span>SOCKET_TCP_KEEPIDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TCP_KEEPIDLE&#160;&#160;&#160;TCP_KEEPIDLE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep-alive idle time. </p>
<dl class="section see"><dt>See also</dt><dd>TCP_KEEPIDLE </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02196">2196</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gacddb57a19b17c1e8730658e051d7cb97" name="gacddb57a19b17c1e8730658e051d7cb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddb57a19b17c1e8730658e051d7cb97">&#9670;&#160;</a></span>SOCKET_TCP_KEEPINTVL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TCP_KEEPINTVL&#160;&#160;&#160;TCP_KEEPINTVL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep-alive interval. </p>
<dl class="section see"><dt>See also</dt><dd>TCP_KEEPINTVL </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02204">2204</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga50e904b0adcc6c319bc93af43aa172ee" name="ga50e904b0adcc6c319bc93af43aa172ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e904b0adcc6c319bc93af43aa172ee">&#9670;&#160;</a></span>SOCKET_TCP_NODELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_TCP_NODELAY&#160;&#160;&#160;TCP_NODELAY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Nagle's algorithm. </p>
<dl class="section see"><dt>See also</dt><dd>TCP_NODELAY </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l02188">2188</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2ef0927dc8f89dfd9193fc9a39300fc2" name="ga2ef0927dc8f89dfd9193fc9a39300fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ef0927dc8f89dfd9193fc9a39300fc2">&#9670;&#160;</a></span>SocketBase_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> * <a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;&#160;&#160;<a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque base structure for shared socket functionality. </p>
<p>Contains common fields shared across socket subtypes (Socket_T, <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a>, etc.):</p><ul>
<li>File descriptor (fd)</li>
<li>Memory arena for lifecycle management</li>
<li>Local and remote endpoint information (addresses, ports)</li>
<li>Timeouts configuration</li>
<li>Metrics snapshot</li>
<li>Domain, type, protocol</li>
</ul>
<p>Subtypes embed a pointer to <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> for shared resource management. Allocation: Use <a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914" title="Create a new socket base structure.">SocketCommon_new_base()</a> which creates arena and initializes. Deallocation: Use <a class="el" href="group__core__io.html#gaaeb641ee1edaa618b8680babae9a98c6" title="Free a socket base structure.">SocketCommon_free_base()</a> in reverse order. Thread Safety: Individual fields not thread-safe; protect with external mutexes if shared.</p>
<p>Rationale: Reduces code duplication in creation, initialization, cleanup across modules. Ensures consistent resource acquisition/cleanup order per layered architecture rules. </p>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l00660">660</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

</div>
</div>
<a id="ga3fb43699cef4e69257db533e71c8265a" name="ga3fb43699cef4e69257db533e71c8265a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb43699cef4e69257db533e71c8265a">&#9670;&#160;</a></span>SOCKETBUF_ALLOC_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETBUF_ALLOC_OVERHEAD&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation overhead for arena bookkeeping during buffer resize. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00485">485</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="ga2209ca43107de5bec46f534bc7830e04" name="ga2209ca43107de5bec46f534bc7830e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2209ca43107de5bec46f534bc7830e04">&#9670;&#160;</a></span>SOCKETBUF_INITIAL_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETBUF_INITIAL_CAPACITY&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial capacity when buffer reserve grows from zero. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00475">475</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gab0563923535025dbd7c98a992dbf8df2" name="gab0563923535025dbd7c98a992dbf8df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0563923535025dbd7c98a992dbf8df2">&#9670;&#160;</a></span>SOCKETBUF_MIN_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETBUF_MIN_CAPACITY&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum capacity for circular buffers. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c" title="Opaque handle to a circular buffer instance.">SocketBuf_T</a> for buffer implementation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00465">465</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<a id="gafdd7aa5138146bb99a2360fface85b12" name="gafdd7aa5138146bb99a2360fface85b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdd7aa5138146bb99a2360fface85b12">&#9670;&#160;</a></span>SOCKETLIVECOUNT_STATIC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKETLIVECOUNT_STATIC_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                           \</div>
<div class="line">    0, PTHREAD_MUTEX_INITIALIZER                                              \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Static initializer for <a class="el" href="group__core__io.html#structSocketLiveCount" title="Thread-safe live count tracker for socket instances.">SocketLiveCount</a> structure. </p>
<p>Initializes the count to 0 and the mutex to the default unlocked state using PTHREAD_MUTEX_INITIALIZER.</p>
<p>Usage: static struct <a class="el" href="group__core__io.html#structSocketLiveCount" title="Thread-safe live count tracker for socket instances.">SocketLiveCount</a> tracker = SOCKETLIVECOUNT_STATIC_INIT;</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="group__core__io.html#structSocketLiveCount" title="Thread-safe live count tracker for socket instances.">SocketLiveCount</a> for field details. </dd>
<dd>
<a class="el" href="group__core__io.html#ga93d46dcf1a875ef525eb96d5f2271fb3" title="Increment live count (thread-safe)">SocketLiveCount_increment()</a>, <a class="el" href="group__core__io.html#ga433d928caa9de0b29ab9f2d48e166c5c" title="Decrement live count (thread-safe)">SocketLiveCount_decrement()</a> for usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01088">1088</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;Socket_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque context for managing asynchronous proxy tunneling operations. </p>
<p>Handles connection to proxy server, protocol handshake, authentication, and state transitions for various proxy types (HTTP CONNECT, SOCKS). Integrates with SocketPoll for event-driven processing and SocketDNS for proxy server resolution.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a> for creating a new connection context. </dd>
<dd>
<a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a> for fully asynchronous start. </dd>
<dd>
<a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9" title="Release proxy connection context and associated resources.">SocketProxy_Conn_free()</a> for resource cleanup. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be" title="States in the proxy connection state machine.">SocketProxy_State</a> for connection states. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for detailed <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> configuration and usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Socket_8h_source.html#l00174">174</a> of file <a class="el" href="Socket_8h_source.html">Socket.h</a>.</p>

</div>
</div>
<a id="ga0acb682b8260ab1c60b918599864e2e5" name="ga0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T&#160;&#160;&#160;<a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque context for managing asynchronous proxy tunneling operations. </p>
<p>Handles connection to proxy server, protocol handshake, authentication, and state transitions for various proxy types (HTTP CONNECT, SOCKS). Integrates with SocketPoll for event-driven processing and SocketDNS for proxy server resolution.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a> for creating a new connection context. </dd>
<dd>
<a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a> for fully asynchronous start. </dd>
<dd>
<a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9" title="Release proxy connection context and associated resources.">SocketProxy_Conn_free()</a> for resource cleanup. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be" title="States in the proxy connection state machine.">SocketProxy_State</a> for connection states. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for detailed <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> configuration and usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketProxy_8h_source.html#l00117">117</a> of file <a class="el" href="SocketProxy_8h_source.html">SocketProxy.h</a>.</p>

</div>
</div>
<a id="ga7b0cb8d09882f145ebd41ad5a5932a30" name="ga7b0cb8d09882f145ebd41ad5a5932a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0cb8d09882f145ebd41ad5a5932a30">&#9670;&#160;</a></span>UDP_MAX_PAYLOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDP_MAX_PAYLOAD</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  65507UL <span class="comment">/* IPv4/6 max UDP payload excluding headers                         \</span></div>
<div class="line"><span class="comment">           */</span></div>
</div><!-- fragment -->
<p>Maximum UDP payload size excluding headers. </p>
<p>Respects IPv4/IPv6 protocol maximums to avoid fragmentation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga7f6c789e54c4efbc66d4a9cbc947734f" title="Safe UDP payload size for Ethernet MTU.">SAFE_UDP_SIZE</a> for MTU-safe size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketConfig_8h_source.html#l00288">288</a> of file <a class="el" href="SocketConfig_8h_source.html">SocketConfig.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad4b3ec10874282833e1b15760efa1b6c" name="gad4b3ec10874282833e1b15760efa1b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4b3ec10874282833e1b15760efa1b6c">&#9670;&#160;</a></span>SocketBuf_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>* <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque handle to a circular buffer instance. </p>
<p>This type represents a circular buffer used for efficient buffering in socket I/O operations. It supports zero-copy read/write, dynamic resizing, and secure clearing for sensitive data.</p>
<p>Memory is managed via an associated Arena_T, allowing batch deallocation. The buffer automatically handles wraparound logic internally.</p>
<dl class="section user"><dt>Thread Safety\n Conditional - individual operations are atomic, but concurrent</dt><dd>access requires external synchronization for multi-threaded use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef" title="Create a new circular buffer with specified initial capacity.">SocketBuf_new()</a> to create an instance. </dd>
<dd>
<a class="el" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448" title="Release the buffer handle and invalidate the pointer.">SocketBuf_release()</a> to release the handle (sets pointer to NULL). </dd>
<dd>
Arena_T for memory management. </dd>
<dd>
<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> in <a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for pool-integrated buffers. </dd>
<dd>
SocketHTTP1_Parser_T in <a class="el" href="group__http.html">HTTP Modules</a> for HTTP parsing usage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketBuf_8h_source.html#l00115">115</a> of file <a class="el" href="SocketBuf_8h_source.html">SocketBuf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae980e6a437316380a792464ce32a595e" name="gae980e6a437316380a792464ce32a595e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae980e6a437316380a792464ce32a595e">&#9670;&#160;</a></span>SocketProxy_Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result codes for proxy operations. </p>
<p>Standardized error and status codes mapping protocol-specific responses (e.g., SOCKS5 reply codes, HTTP status) to a unified interface. Use <a class="el" href="group__core__io.html#ga2a0ac262c4e03ed00c5eeb2aa8d210bd" title="Convert SocketProxy_Result code to descriptive string.">SocketProxy_result_string()</a> for human-readable descriptions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> to retrieve after async completion. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2a0ac262c4e03ed00c5eeb2aa8d210bd" title="Convert SocketProxy_Result code to descriptive string.">SocketProxy_result_string()</a> for string conversion. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for mapping to specific protocol errors. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea6493782f06c64d4240b03ebc37d10754" name="ggae980e6a437316380a792464ce32a595ea6493782f06c64d4240b03ebc37d10754"></a>PROXY_OK&#160;</td><td class="fielddoc"><p>Success: tunnel established and ready for use. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595eac8e28cc62a3365a1732c669edf48ede1" name="ggae980e6a437316380a792464ce32a595eac8e28cc62a3365a1732c669edf48ede1"></a>PROXY_IN_PROGRESS&#160;</td><td class="fielddoc"><p>Asynchronous operation still in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea6e9669d107d6f667fc65e467f8ee6424" name="ggae980e6a437316380a792464ce32a595ea6e9669d107d6f667fc65e467f8ee6424"></a>PROXY_ERROR&#160;</td><td class="fielddoc"><p>Generic proxy error (unspecified cause). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea65f9d23b989fea3c0578f03bf69dcbc3" name="ggae980e6a437316380a792464ce32a595ea65f9d23b989fea3c0578f03bf69dcbc3"></a>PROXY_ERROR_CONNECT&#160;</td><td class="fielddoc"><p>Failed to establish connection to proxy server. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595eaae7c553c156d0bc0673280b02c1ed7a0" name="ggae980e6a437316380a792464ce32a595eaae7c553c156d0bc0673280b02c1ed7a0"></a>PROXY_ERROR_AUTH_REQUIRED&#160;</td><td class="fielddoc"><p>Proxy requires authentication not provided. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595eaeaa9baf16d7658f8553f19fc887ba82f" name="ggae980e6a437316380a792464ce32a595eaeaa9baf16d7658f8553f19fc887ba82f"></a>PROXY_ERROR_AUTH_FAILED&#160;</td><td class="fielddoc"><p>Provided credentials rejected by proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea9519d7d7a824bbb8527737bb565a8d26" name="ggae980e6a437316380a792464ce32a595ea9519d7d7a824bbb8527737bb565a8d26"></a>PROXY_ERROR_FORBIDDEN&#160;</td><td class="fielddoc"><p>Proxy forbids connection to specified target. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea79f3625d5f0c085c05bd00e79c7b4878" name="ggae980e6a437316380a792464ce32a595ea79f3625d5f0c085c05bd00e79c7b4878"></a>PROXY_ERROR_HOST_UNREACHABLE&#160;</td><td class="fielddoc"><p>Target host cannot be reached (SOCKS5 code 3). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea2415989b5d247d71236686d18b1eeb9d" name="ggae980e6a437316380a792464ce32a595ea2415989b5d247d71236686d18b1eeb9d"></a>PROXY_ERROR_NETWORK_UNREACHABLE&#160;</td><td class="fielddoc"><p>Target network unreachable (SOCKS5 code 4). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea533fd840f7baa208f63174952243f28e" name="ggae980e6a437316380a792464ce32a595ea533fd840f7baa208f63174952243f28e"></a>PROXY_ERROR_CONNECTION_REFUSED&#160;</td><td class="fielddoc"><p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> refused by target (SOCKS5 code 5). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea942a19cc1c6152dba3f615c94c8190b9" name="ggae980e6a437316380a792464ce32a595ea942a19cc1c6152dba3f615c94c8190b9"></a>PROXY_ERROR_TTL_EXPIRED&#160;</td><td class="fielddoc"><p>TTL expired en route to target (SOCKS5 code 6). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea743f6cf01e958374a7cae9cce8960552" name="ggae980e6a437316380a792464ce32a595ea743f6cf01e958374a7cae9cce8960552"></a>PROXY_ERROR_PROTOCOL&#160;</td><td class="fielddoc"><p>Protocol-level error (invalid response, etc.). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea9acb784df31ca1f49007e0dbec3899ae" name="ggae980e6a437316380a792464ce32a595ea9acb784df31ca1f49007e0dbec3899ae"></a>PROXY_ERROR_UNSUPPORTED&#160;</td><td class="fielddoc"><p>Command or address type not supported by proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea6f79c29997ae1e1063f0f4c079e42128" name="ggae980e6a437316380a792464ce32a595ea6f79c29997ae1e1063f0f4c079e42128"></a>PROXY_ERROR_TIMEOUT&#160;</td><td class="fielddoc"><p>Operation timed out (connect or handshake). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae980e6a437316380a792464ce32a595ea15fe5e5fc15227e92086cc3c76e468d8" name="ggae980e6a437316380a792464ce32a595ea15fe5e5fc15227e92086cc3c76e468d8"></a>PROXY_ERROR_CANCELLED&#160;</td><td class="fielddoc"><p>Operation explicitly cancelled by user. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketProxy_8h_source.html#l00287">287</a> of file <a class="el" href="SocketProxy_8h_source.html">SocketProxy.h</a>.</p>

</div>
</div>
<a id="gaf9f1c72bfcb303aa9ee5dae6d903b9be" name="gaf9f1c72bfcb303aa9ee5dae6d903b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f1c72bfcb303aa9ee5dae6d903b9be">&#9670;&#160;</a></span>SocketProxy_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States in the proxy connection state machine. </p>
<p>Tracks progress through proxy connection phases: resolution, connection, TLS (if HTTPS proxy), authentication, and protocol handshake.</p>
<p>State transition diagram: IDLE  CONNECTING_PROXY  [TLS_TO_PROXY (HTTPS only)]  HANDSHAKE_SEND   CONNECTED  HANDSHAKE_RECV  [AUTH_SEND/AUTH_RECV (SOCKS5)]  FAILED or CANCELLED</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040" title="Retrieve current state of proxy connection.">SocketProxy_Conn_state()</a> to query current state. </dd>
<dd>
<a class="el" href="group__core__io.html#ga6340dd7fd6f41c692c0a2f770dbd5877" title="Convert SocketProxy_State to descriptive string.">SocketProxy_state_string()</a> for string names. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for integration with event loops. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9beacba676410c89ad0ae99458a19e8ee240" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9beacba676410c89ad0ae99458a19e8ee240"></a>PROXY_STATE_IDLE&#160;</td><td class="fielddoc"><p>Initial state: connection not started. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaa138c1108967670476f171409859906c" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaa138c1108967670476f171409859906c"></a>PROXY_STATE_CONNECTING_PROXY&#160;</td><td class="fielddoc"><p>Resolving/connecting to proxy server via HappyEyeballs. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea5e6d9c22e92e5264322ca6229d697200" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea5e6d9c22e92e5264322ca6229d697200"></a>PROXY_STATE_TLS_TO_PROXY&#160;</td><td class="fielddoc"><p>Performing TLS handshake to HTTPS proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaec64bc3a56940bb0b95bd533d3f575d1" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaec64bc3a56940bb0b95bd533d3f575d1"></a>PROXY_STATE_HANDSHAKE_SEND&#160;</td><td class="fielddoc"><p>Sending proxy protocol request (CONNECT or SOCKS). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea6692865ae9a1d5913dc9b11bb8ecc053" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea6692865ae9a1d5913dc9b11bb8ecc053"></a>PROXY_STATE_HANDSHAKE_RECV&#160;</td><td class="fielddoc"><p>Awaiting and parsing proxy response. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea33e574e11d2391e830bb512b5f4cba10" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea33e574e11d2391e830bb512b5f4cba10"></a>PROXY_STATE_AUTH_SEND&#160;</td><td class="fielddoc"><p>Sending SOCKS5 authentication subnegotiation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaebe4dde2fe06562c2e05cbe78cdf75d7" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaebe4dde2fe06562c2e05cbe78cdf75d7"></a>PROXY_STATE_AUTH_RECV&#160;</td><td class="fielddoc"><p>Receiving SOCKS5 auth response. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea93b0009c07bfe02286b9151523792043" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea93b0009c07bfe02286b9151523792043"></a>PROXY_STATE_CONNECTED&#160;</td><td class="fielddoc"><p>Success: tunnel ready for target communication. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea002d0ae5e052492f5a003f240cce1a07" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9bea002d0ae5e052492f5a003f240cce1a07"></a>PROXY_STATE_FAILED&#160;</td><td class="fielddoc"><p>Terminal: operation failed with error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaefd3cf70c9901425e0b6aa6a8325b71a" name="ggaf9f1c72bfcb303aa9ee5dae6d903b9beaefd3cf70c9901425e0b6aa6a8325b71a"></a>PROXY_STATE_CANCELLED&#160;</td><td class="fielddoc"><p>Terminal: operation cancelled by user. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketProxy_8h_source.html#l00335">335</a> of file <a class="el" href="SocketProxy_8h_source.html">SocketProxy.h</a>.</p>

</div>
</div>
<a id="gaaa33f7bdae951cc7b53a2fb049e89132" name="gaaa33f7bdae951cc7b53a2fb049e89132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa33f7bdae951cc7b53a2fb049e89132">&#9670;&#160;</a></span>SocketProxyType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of supported proxy protocol types. </p>
<p>Defines the proxy protocols handled by the SocketProxy module, including HTTP CONNECT for web proxies and SOCKS variants for general tunneling.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy.html#aa04cfa88d52d6c1f889f9f936a141141" title="Proxy protocol type (e.g., SOCKET_PROXY_SOCKS5).">SocketProxy_Config::type</a> for configuration. </dd>
<dd>
<a class="el" href="group__core__io.html#ga50b7d727085605b2f6bc620118462b13" title="Convert proxy type enum to protocol name string.">SocketProxy_type_string()</a> for string representations. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for protocol-specific details and limitations. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132af06430c3c302df7671528157c73c4e0b" name="ggaaa33f7bdae951cc7b53a2fb049e89132af06430c3c302df7671528157c73c4e0b"></a>SOCKET_PROXY_NONE&#160;</td><td class="fielddoc"><p>No proxy - direct connection to target. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132a687548e806513e256fcf2534ddf9cbd6" name="ggaaa33f7bdae951cc7b53a2fb049e89132a687548e806513e256fcf2534ddf9cbd6"></a>SOCKET_PROXY_HTTP&#160;</td><td class="fielddoc"><p>HTTP CONNECT method (RFC 7231). Supports Basic auth. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132a7b26d4906e2233ed613ea9b00d402abb" name="ggaaa33f7bdae951cc7b53a2fb049e89132a7b26d4906e2233ed613ea9b00d402abb"></a>SOCKET_PROXY_HTTPS&#160;</td><td class="fielddoc"><p>HTTPS CONNECT - TLS-encrypted connection to proxy before handshake. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132ab789e6a114edbf61a4df42d8240a51c1" name="ggaaa33f7bdae951cc7b53a2fb049e89132ab789e6a114edbf61a4df42d8240a51c1"></a>SOCKET_PROXY_SOCKS4&#160;</td><td class="fielddoc"><p>SOCKS4 protocol - IPv4 addresses only, no auth. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132a8d530f085d00940efe69768b8cf374c6" name="ggaaa33f7bdae951cc7b53a2fb049e89132a8d530f085d00940efe69768b8cf374c6"></a>SOCKET_PROXY_SOCKS4A&#160;</td><td class="fielddoc"><p>SOCKS4a extension - supports domain name resolution at proxy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132a65e12b32adeb0ad03fc8a1031423c21f" name="ggaaa33f7bdae951cc7b53a2fb049e89132a65e12b32adeb0ad03fc8a1031423c21f"></a>SOCKET_PROXY_SOCKS5&#160;</td><td class="fielddoc"><p>SOCKS5 protocol (RFC 1928) - supports IPv6, auth, UDP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa33f7bdae951cc7b53a2fb049e89132ae87246b34aba7c6500664e7be36d8820" name="ggaaa33f7bdae951cc7b53a2fb049e89132ae87246b34aba7c6500664e7be36d8820"></a>SOCKET_PROXY_SOCKS5H&#160;</td><td class="fielddoc"><p>SOCKS5 with hostname resolution performed by proxy server. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SocketProxy_8h_source.html#l00254">254</a> of file <a class="el" href="SocketProxy_8h_source.html">SocketProxy.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga32b67d95639513cd6a602f6175b48f15" name="ga32b67d95639513cd6a602f6175b48f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b67d95639513cd6a602f6175b48f15">&#9670;&#160;</a></span>Socket_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_accept </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept incoming connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Listening socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New socket or NULL if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Returns NULL for non-blocking sockets when no connection is pending. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> for setting up listening sockets. </dd></dl>

<p class="reference">Referenced by <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga63fc7b454ab8202278b1e3073ec961a0" name="ga63fc7b454ab8202278b1e3073ec961a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63fc7b454ab8202278b1e3073ec961a0">&#9670;&#160;</a></span>Socket_accept_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_accept_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept incoming connection with explicit timeout. </p>
<p>Like <a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> but with explicit timeout support. Useful for servers that need to periodically check for shutdown signals or perform maintenance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Listening socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = return immediately if no connection, -1 = block indefinitely)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New client socket, or NULL if timeout expired with no connection</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on accept error (not including timeout/EAGAIN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on listening socket</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md445"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    Socket_T client = <a class="code hl_function" href="group__core__io.html#ga63fc7b454ab8202278b1e3073ec961a0">Socket_accept_timeout</a>(server, 1000);</div>
<div class="line">    <span class="keywordflow">if</span> (client) {</div>
<div class="line">        handle_client(client);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Check shutdown flag every second</span></div>
<div class="line">}</div>
<div class="ttc" id="aconnection__pool_8c_html_af1f449cc09f8d36befcce07bc38c29c0"><div class="ttname"><a href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a></div><div class="ttdeci">static volatile int running</div><div class="ttdef"><b>Definition</b> <a href="connection__pool_8c_source.html#l00029">connection_pool.c:29</a></div></div>
<div class="ttc" id="agroup__core__io_html_ga63fc7b454ab8202278b1e3073ec961a0"><div class="ttname"><a href="group__core__io.html#ga63fc7b454ab8202278b1e3073ec961a0">Socket_accept_timeout</a></div><div class="ttdeci">Socket_T Socket_accept_timeout(Socket_T socket, int timeout_ms)</div><div class="ttdoc">Accept incoming connection with explicit timeout.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Temporarily sets socket to non-blocking mode if needed </dd>
<dd>
Returns NULL (not exception) when timeout expires</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for basic accept without timeout </dd>
<dd>
<a class="el" href="group__core__io.html#gabf72952b9d7d0e4fc8255de6c92fbe11" title="Create a listening TCP server socket in one call.">Socket_listen_tcp()</a> for creating listening socket </dd></dl>

</div>
</div>
<a id="ga89643e52780099fe0012e2fa22725e07" name="ga89643e52780099fe0012e2fa22725e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89643e52780099fe0012e2fa22725e07">&#9670;&#160;</a></span>Socket_bandwidth_wait_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Socket_bandwidth_wait_ms </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get wait time until bandwidth available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
    <tr><td class="paramname">bytes</td><td>Number of bytes needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Milliseconds to wait, 0 if immediate, -1 if impossible. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<p>Useful for event loop integration - use as poll timeout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga274b6782b2029d2d8aa33579ad60a4c1" title="Send data with bandwidth limiting.">Socket_send_limited()</a> for bandwidth-limited operations. </dd></dl>

</div>
</div>
<a id="gacb65d693d8c93e2a1fe6411dd0d0af98" name="gacb65d693d8c93e2a1fe6411dd0d0af98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb65d693d8c93e2a1fe6411dd0d0af98">&#9670;&#160;</a></span>Socket_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a socket to a local IP address and port. </p>
<p>Associates the socket with a local network address and port using bind(2). This is required for servers (before listen()) and clients wanting specific local endpoints (e.g., source IP selection). Hostnames trigger synchronous DNS resolution, which may block; use IP literals or async DNS for non-blocking.</p>
<p>Supported formats for host:</p><ul>
<li>NULL or "0.0.0.0": Bind to all IPv4 interfaces</li>
<li>"::": Bind to all IPv6 interfaces (dual-stack if possible)</li>
<li>Specific IP: "192.168.1.100" or "[2001:db8::1]"</li>
<li>Hostname: Resolves via getaddrinfo(3), blocks up to ~30s on failure</li>
</ul>
<p>Port range: 1-65535 (SOCKET_MAX_PORT); 0 for kernel-assigned ephemeral port.</p>
<p>Edge cases:</p><ul>
<li>Port 0: OS assigns available port; query with <a class="el" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e" title="Get local port number.">Socket_getlocalport()</a></li>
<li>Already bound: Raises Socket_Failed (EINVAL or EADDRINUSE)</li>
<li>Permission denied on privileged ports (&lt;1024): Socket_Failed (EACCES)</li>
<li>Address not local: Socket_Failed (EADDRNOTAVAIL)</li>
</ul>
<p>For non-blocking bind, resolve hostname first with <a class="el" href="group__dns.html#gab988727825887d34e87d144d30c30c2f" title="Synchronous DNS resolution with optional timeout guarantee.">SocketDNS_resolve_sync()</a> or async.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">socket</td><td>Unbound socket to bind (updated with local addr/port state) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Local address string (IP or hostname; NULL for any) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Local port (1-65535; 0 for ephemeral)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>Bind failed: EADDRINUSE (port busy), EADDRNOTAVAIL (invalid local addr), EACCES (permission), ENETDOWN (interface down), getaddrinfo errors for hostnames</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - binds specific socket instance atomically</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md426"></a>
Basic Server Bind</h2>
<div class="fragment"><div class="line">Socket_T server = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(server, NULL, 8080);  <span class="comment">// Bind to any IP on port 8080</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a>(server, SOMAXCONN);</div>
<div class="ttc" id="agroup__core__io_html_gab24b026bc4c69e6f766211f44675e189"><div class="ttname"><a href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a></div><div class="ttdeci">void Socket_listen(Socket_T socket, int backlog)</div><div class="ttdoc">Listen for incoming connections.</div></div>
<div class="ttc" id="agroup__core__io_html_gacb65d693d8c93e2a1fe6411dd0d0af98"><div class="ttname"><a href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a></div><div class="ttdeci">void Socket_bind(Socket_T socket, const char *host, int port)</div><div class="ttdoc">Bind a socket to a local IP address and port.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md427"></a>
Client Bind to Specific Interface</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    Socket_T client = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET6, SOCK_STREAM, 0);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(client, <span class="stringliteral">&quot;::1&quot;</span>, 0);  <span class="comment">// Bind to loopback, ephemeral port</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(client, <span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line">    <span class="keywordtype">int</span> local_port = <a class="code hl_function" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e">Socket_getlocalport</a>(client);  <span class="comment">// Query assigned port</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// Handle bind/connect failure</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_ga225f4a8fd657fd52a05146c6fc4f58b0"><div class="ttname"><a href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a></div><div class="ttdeci">const Except_T Socket_Failed</div><div class="ttdoc">General socket operation failure exception.</div></div>
<div class="ttc" id="agroup__core__io_html_ga3bdedaea9dac966d75343cdffa5d1f3e"><div class="ttname"><a href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e">Socket_getlocalport</a></div><div class="ttdeci">int Socket_getlocalport(const Socket_T socket)</div><div class="ttdoc">Get local port number.</div></div>
<div class="ttc" id="agroup__foundation_html_gab5e72fc2bd41014c75e0ace4feabfe8e"><div class="ttname"><a href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a></div><div class="ttdeci">#define EXCEPT(e)</div><div class="ttdoc">Catch a specific exception type within a TRY block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01105">Except.h:1105</a></div></div>
<div class="ttc" id="agroup__foundation_html_gad2746371528bdf15c3910b7bf217dac0"><div class="ttname"><a href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a></div><div class="ttdeci">#define TRY</div><div class="ttdoc">Start a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l00991">Except.h:991</a></div></div>
<div class="ttc" id="agroup__foundation_html_gae6628ac788ad213363b89dba9868420b"><div class="ttname"><a href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a></div><div class="ttdeci">#define END_TRY</div><div class="ttdoc">Complete a TRY/EXCEPT/FINALLY exception handling block.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01439">Except.h:1439</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md428"></a>
Async DNS for Non-Blocking</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> dns = <a class="code hl_function" href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a>();</div>
<div class="line"><a class="code hl_struct" href="group__dns.html#structSocketDNS__Request__T">Request_T</a> req = <a class="code hl_function" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da">Socket_bind_async</a>(dns, sock, <span class="stringliteral">&quot;localhost&quot;</span>, 8080);</div>
<div class="line"><span class="comment">// Poll dns fd or integrate with event loop</span></div>
<div class="line"><span class="keyword">struct </span>addrinfo *res = <a class="code hl_function" href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a>(dns, req);</div>
<div class="line"><span class="keywordflow">if</span> (res) <a class="code hl_function" href="group__core__io.html#ga7147a127f3463d5861da5a16435ef4e7">Socket_bind_with_addrinfo</a>(sock, res);</div>
<div class="line">freeaddrinfo(res);</div>
<div class="ttc" id="agroup__core__io_html_ga7147a127f3463d5861da5a16435ef4e7"><div class="ttname"><a href="group__core__io.html#ga7147a127f3463d5861da5a16435ef4e7">Socket_bind_with_addrinfo</a></div><div class="ttdeci">void Socket_bind_with_addrinfo(Socket_T socket, struct addrinfo *res)</div><div class="ttdoc">Bind socket using resolved address.</div></div>
<div class="ttc" id="agroup__core__io_html_gab4812aea6cf0f2c665825d6cb35d49da"><div class="ttname"><a href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da">Socket_bind_async</a></div><div class="ttdeci">Request_T Socket_bind_async(SocketDNS_T dns, Socket_T socket, const char *host, int port)</div><div class="ttdoc">Start async DNS resolution for bind.</div></div>
<div class="ttc" id="agroup__dns_html_ga799f4d96c77eef54ecb9be5523b591fd"><div class="ttname"><a href="group__dns.html#ga799f4d96c77eef54ecb9be5523b591fd">SocketDNS_new</a></div><div class="ttdeci">SocketDNS_T SocketDNS_new(void)</div><div class="ttdoc">Create a new asynchronous DNS resolver.</div></div>
<div class="ttc" id="agroup__dns_html_ga8f7c4c4455c9158ccd272fe8c15235b5"><div class="ttname"><a href="group__dns.html#ga8f7c4c4455c9158ccd272fe8c15235b5">SocketDNS_getresult</a></div><div class="ttdeci">struct addrinfo * SocketDNS_getresult(SocketDNS_T dns, Request_T req)</div><div class="ttdoc">Retrieve completed DNS resolution result, transferring ownership to caller.</div></div>
<div class="ttc" id="agroup__dns_html_structSocketDNS__Request__T"><div class="ttname"><a href="group__dns.html#structSocketDNS__Request__T">SocketDNS_Request_T</a></div><div class="ttdoc">DNS resolution request structure.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00211">SocketDNS-private.h:212</a></div></div>
<div class="ttc" id="agroup__dns_html_structSocketDNS__T"><div class="ttname"><a href="group__dns.html#structSocketDNS__T">SocketDNS_T</a></div><div class="ttdoc">Async DNS resolver structure.</div><div class="ttdef"><b>Definition</b> <a href="SocketDNS-private_8h_source.html#l00260">SocketDNS-private.h:261</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>After bind, use <a class="el" href="group__core__io.html#ga04e55475bcedbc100767663e1e7d9de1" title="Get local IP address.">Socket_getlocaladdr()</a> and <a class="el" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e" title="Get local port number.">Socket_getlocalport()</a> to confirm </dd>
<dd>
For IPv6, prefer "::" for dual-stack; use SocketConfig_set_ipv6only() for v6-only </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Hostname resolution blocks; use <a class="el" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da" title="Start async DNS resolution for bind.">Socket_bind_async()</a> or IP for async apps </dd>
<dd>
Privileged ports require root or cap_net_bind_service; use setcap or non-privileged </dd>
<dd>
In containers/Docker, ensure &ndash;cap-add=NET_BIND_SERVICE or run as root</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) for IP bind; O(n) for hostname resolution where n=lookup</dt><dd>time</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> next step for servers </dd>
<dd>
<a class="el" href="group__core__io.html#ga04e55475bcedbc100767663e1e7d9de1" title="Get local IP address.">Socket_getlocaladdr()</a>, <a class="el" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e" title="Get local port number.">Socket_getlocalport()</a> for bound address query </dd>
<dd>
<a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e" title="Bind to Unix domain socket path.">Socket_bind_unix()</a> for Unix domain binding </dd>
<dd>
<a class="el" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da" title="Start async DNS resolution for bind.">Socket_bind_async()</a>, <a class="el" href="group__core__io.html#ga7147a127f3463d5861da5a16435ef4e7" title="Bind socket using resolved address.">Socket_bind_with_addrinfo()</a> for async variant </dd>
<dd>
<a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> <a class="el" href="group__core__io.html">Core I/O Modules</a> for async resolution </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> bind <a class="el" href="group__security.html" title="Comprehensive security protections for network applications.">Security Modules</a> considerations </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gab4812aea6cf0f2c665825d6cb35d49da" name="gab4812aea6cf0f2c665825d6cb35d49da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4812aea6cf0f2c665825d6cb35d49da">&#9670;&#160;</a></span>Socket_bind_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> Socket_bind_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start async DNS resolution for bind. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket to bind. </td></tr>
    <tr><td class="paramname">host</td><td>IP address or hostname (NULL for any). </td></tr>
    <tr><td class="paramname">port</td><td>Port number (1 to SOCKET_MAX_PORT). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DNS request handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga36ca42197a8a1d7151a3cee15c093dea" title="Cancel pending async bind resolution.">Socket_bind_async_cancel()</a> for canceling the request. </dd>
<dd>
<a class="el" href="group__core__io.html#ga7147a127f3463d5861da5a16435ef4e7" title="Bind socket using resolved address.">Socket_bind_with_addrinfo()</a> for binding with resolved address. </dd></dl>

</div>
</div>
<a id="ga36ca42197a8a1d7151a3cee15c093dea" name="ga36ca42197a8a1d7151a3cee15c093dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ca42197a8a1d7151a3cee15c093dea">&#9670;&#160;</a></span>Socket_bind_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_async_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel pending async bind resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle returned by Socket_bind_async. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da" title="Start async DNS resolution for bind.">Socket_bind_async()</a> for starting async bind. </dd></dl>

</div>
</div>
<a id="gad85ee4be563a1006b7518645995ab65e" name="gad85ee4be563a1006b7518645995ab65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad85ee4be563a1006b7518645995ab65e">&#9670;&#160;</a></span>Socket_bind_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_unix </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind to Unix domain socket path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to bind (AF_UNIX). </td></tr>
    <tr><td class="paramname">path</td><td>Socket file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Fails with EADDRINUSE if path exists. Max path length ~108 bytes. </dd>
<dd>
Supports abstract namespace sockets on Linux (path starting with '@'). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad353c95a8994569af7b650f1fda7036f" title="Connect to Unix domain socket path.">Socket_connect_unix()</a> for connecting to Unix sockets. </dd></dl>

</div>
</div>
<a id="ga7147a127f3463d5861da5a16435ef4e7" name="ga7147a127f3463d5861da5a16435ef4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7147a127f3463d5861da5a16435ef4e7">&#9670;&#160;</a></span>Socket_bind_with_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_with_addrinfo </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind socket using resolved address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to bind. </td></tr>
    <tr><td class="paramname">res</td><td>Resolved addrinfo result from DNS resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab4812aea6cf0f2c665825d6cb35d49da" title="Start async DNS resolution for bind.">Socket_bind_async()</a> for async DNS resolution. </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for direct binding. </dd></dl>

</div>
</div>
<a id="gac14390090ee26136c1f7a816fc08406e" name="gac14390090ee26136c1f7a816fc08406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14390090ee26136c1f7a816fc08406e">&#9670;&#160;</a></span>Socket_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establish a connection to a remote host and port. </p>
<p>Initiates a connection to the remote endpoint using connect(2). For TCP sockets, this performs the 3-way handshake; for UDP, sets default peer address for send(). Hostnames trigger synchronous DNS via getaddrinfo(3), potentially blocking.</p>
<p>Supported host formats:</p><ul>
<li>IP address: "192.168.1.1", "[2001:db8::1]"</li>
<li>Hostname: "example.com" - resolves A/AAAA records</li>
<li>IPv6 literals require [] brackets</li>
</ul>
<p>Port: 1-65535; common services like 80 (HTTP), 443 (HTTPS)</p>
<p>Behavior:</p><ul>
<li>Blocking mode: Waits for handshake completion or timeout/failure</li>
<li>Non-blocking: Returns immediately; use <a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a> or poll for completion</li>
</ul>
<p>Edge cases:</p><ul>
<li>Unreachable host: Socket_Failed (ETIMEDOUT or ENETUNREACH)</li>
<li>Refused connection: Socket_Failed (ECONNREFUSED)</li>
<li>DNS failure: Socket_Failed with EAI_* mapped to errno</li>
<li>Already connected: Socket_Failed (EISCONN)</li>
</ul>
<p>For non-blocking connect, pair with SocketPoll for writable event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">socket</td><td>Unconnected socket (updated with peer addr/port on success) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Remote address (IP or hostname) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Remote port (1-65535)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>Connect failed: ECONNREFUSED (no listener), ETIMEDOUT (no route/response), ENETUNREACH/EHOSTUNREACH (routing), getaddrinfo/DNS errors, EMSGSIZE (MTU issue)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - connects specific socket instance</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md429"></a>
Basic Client Connect</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;www.example.com&quot;</span>, 80);</div>
<div class="line"><span class="comment">// Now connected; send HTTP request</span></div>
<div class="line">ssize_t n = <a class="code hl_function" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a>(sock, <span class="stringliteral">&quot;GET / HTTP/1.1\r\nHost:</span></div>
<div class="line"><span class="stringliteral">example.com\r\n\r\n&quot;</span>, len); <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
<div class="ttc" id="agroup__core__io_html_ga6ea9ad33d78c50d327c9677b52849bcb"><div class="ttname"><a href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a></div><div class="ttdeci">ssize_t Socket_sendall(Socket_T socket, const void *buf, size_t len)</div><div class="ttdoc">Send all data (handles partial sends).</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md430"></a>
Non-Blocking Connect</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a>(sock);</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;example.com&quot;</span>, 443);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5">Socket_geterrno</a>() == EINPROGRESS) {</div>
<div class="line">        <span class="comment">// Poll for writable</span></div>
<div class="line">        <a class="code hl_struct" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> poll = <a class="code hl_function" href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a>(1);</div>
<div class="line">        <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, sock, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a>, sock);</div>
<div class="line">        <a class="code hl_struct" href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a> *ev = NULL;</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a>(poll, &amp;ev, timeout) &gt; 0) {</div>
<div class="line">            <span class="comment">// Check getsockopt SO_ERROR for connect result</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga35309677a1760480783d5f0c294d0db4"><div class="ttname"><a href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a></div><div class="ttdeci">void Socket_setnonblocking(Socket_T socket)</div><div class="ttdoc">Enable non-blocking mode.</div></div>
<div class="ttc" id="agroup__event__system_html_ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e"><div class="ttname"><a href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a></div><div class="ttdeci">void SocketPoll_add(SocketPoll_T poll, Socket_T socket, unsigned events, void *data)</div><div class="ttdoc">Register a socket for I/O event monitoring within the poll instance.</div></div>
<div class="ttc" id="agroup__event__system_html_gaa3d47365dd18329d50ee636284839738"><div class="ttname"><a href="group__event__system.html#gaa3d47365dd18329d50ee636284839738">SocketPoll_wait</a></div><div class="ttdeci">int SocketPoll_wait(SocketPoll_T poll, SocketEvent_T **events, int timeout)</div><div class="ttdoc">Block and wait for I/O events or timeout on registered sockets.</div></div>
<div class="ttc" id="agroup__event__system_html_gac1fbd1a09d564f7988b0e427e5707ca7"><div class="ttname"><a href="group__event__system.html#gac1fbd1a09d564f7988b0e427e5707ca7">SocketPoll_new</a></div><div class="ttdeci">SocketPoll_T SocketPoll_new(int maxevents)</div><div class="ttdoc">Create a new event poll instance.</div></div>
<div class="ttc" id="agroup__event__system_html_gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195"><div class="ttname"><a href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a></div><div class="ttdeci">@ POLL_WRITE</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00182">SocketPoll.h:182</a></div></div>
<div class="ttc" id="agroup__event__system_html_structSocketEvent__T"><div class="ttname"><a href="group__event__system.html#structSocketEvent__T">SocketEvent_T</a></div><div class="ttdoc">Event notification structure returned by polling operations.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll_8h_source.html#l00205">SocketPoll.h:206</a></div></div>
<div class="ttc" id="agroup__foundation_html_gaacd3ef2f86186c451f2eb90cd490eae5"><div class="ttname"><a href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5">Socket_geterrno</a></div><div class="ttdeci">int Socket_geterrno(void)</div><div class="ttdoc">Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...</div></div>
<div class="ttc" id="agroup__poll__private_html_structSocketPoll__T"><div class="ttname"><a href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a></div><div class="ttdoc">Opaque internal state structure for SocketPoll instance.</div><div class="ttdef"><b>Definition</b> <a href="SocketPoll-private_8h_source.html#l00404">SocketPoll-private.h:405</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md431"></a>
With Local Bind and Timeout</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> to = { .connect_ms = 5000 };</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f">Socket_timeouts_set</a>(sock, &amp;to);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(sock, <span class="stringliteral">&quot;192.168.1.10&quot;</span>, 0);  <span class="comment">// Specific source IP</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;::1&quot;</span>, 8080);  <span class="comment">// IPv6 loopback</span></div>
<div class="ttc" id="agroup__core__io_html_ga3e3b95a49618f5a56869606adeeda58f"><div class="ttname"><a href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f">Socket_timeouts_set</a></div><div class="ttdeci">void Socket_timeouts_set(Socket_T socket, const SocketTimeouts_T *timeouts)</div><div class="ttdoc">Set per-socket timeout configuration.</div></div>
<div class="ttc" id="agroup__foundation_html_structSocketTimeouts__T"><div class="ttname"><a href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a></div><div class="ttdoc">Basic timeout configuration structure for socket operations.</div><div class="ttdef"><b>Definition</b> <a href="SocketConfig_8h_source.html#l01500">SocketConfig.h:1501</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Success sets peer address; query with Socket_getpeeraddr/port() </dd>
<dd>
For UDP, connect sets default peer for send() without addr </dd>
<dd>
Dual-stack: Prefers IPv6 if available; configure via hints in async DNS </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Synchronous DNS blocks; use <a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a> for event loops </dd>
<dd>
Firewalls/NAT may affect connectivity; test with real networks </dd>
<dd>
In non-blocking, EINPROGRESS means pending - check SO_ERROR later</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) handshake time; O(n) for DNS where n=resolution latency</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a> to verify connection status </dd>
<dd>
<a class="el" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c" title="Get peer IP address.">Socket_getpeeraddr()</a>, <a class="el" href="group__core__io.html#ga38d7e5845519867261a9f24dfe0e03db" title="Get peer port number.">Socket_getpeerport()</a> for remote endpoint </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for local address binding before connect </dd>
<dd>
<a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a>, <a class="el" href="group__core__io.html#ga28271af8ebad671a64fd37ffb2d07e0c" title="Connect socket using resolved address.">Socket_connect_with_addrinfo()</a> for async </dd>
<dd>
<a class="el" href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f" title="Set per-socket timeout configuration.">Socket_timeouts_set()</a> for connect timeout control </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> non-blocking connect patterns </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> secure connect practices (TLS, verify host) </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>.</p>

</div>
</div>
<a id="ga04ab3a8c8b70328f9b72cc5a1e771e87" name="ga04ab3a8c8b70328f9b72cc5a1e771e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ab3a8c8b70328f9b72cc5a1e771e87">&#9670;&#160;</a></span>Socket_connect_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a> Socket_connect_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start async DNS resolution for connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">socket</td><td>Socket to connect. </td></tr>
    <tr><td class="paramname">host</td><td>Remote IP address or hostname. </td></tr>
    <tr><td class="paramname">port</td><td>Remote port (1 to SOCKET_MAX_PORT). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DNS request handle. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga0f9515df873a2af7b054451afec8fd71" title="Cancel pending async connect resolution.">Socket_connect_async_cancel()</a> for canceling the request. </dd>
<dd>
<a class="el" href="group__core__io.html#ga28271af8ebad671a64fd37ffb2d07e0c" title="Connect socket using resolved address.">Socket_connect_with_addrinfo()</a> for connecting with resolved address. </dd></dl>

</div>
</div>
<a id="ga0f9515df873a2af7b054451afec8fd71" name="ga0f9515df873a2af7b054451afec8fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f9515df873a2af7b054451afec8fd71">&#9670;&#160;</a></span>Socket_connect_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_async_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dns.html#gaec7a4f82232cde2b125b4b1e1df03b1f">Request_T</a>&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel pending async connect resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>DNS resolver instance. </td></tr>
    <tr><td class="paramname">req</td><td>Request handle returned by Socket_connect_async. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a> for starting async connect. </dd></dl>

</div>
</div>
<a id="gab85e4ae7965fc1334bbc547642dcdd42" name="gab85e4ae7965fc1334bbc547642dcdd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab85e4ae7965fc1334bbc547642dcdd42">&#9670;&#160;</a></span>Socket_connect_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_connect_nonblocking </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate non-blocking connect (no DNS, IP address only). </p>
<p>Starts a non-blocking TCP connect operation. Unlike <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a>, this function:</p><ul>
<li>Only accepts IP addresses (no DNS resolution)</li>
<li>Returns immediately without blocking</li>
<li>Requires polling for completion via SocketPoll or select/poll</li>
</ul>
<p>After calling, poll the socket for writability. When writable, check SO_ERROR via getsockopt() or call <a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">socket</td><td>Socket (will be set to non-blocking mode) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip_address</td><td>Remote IP address (IPv4 or IPv6, no hostnames) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Remote port (1-65535)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if connect completed immediately, 1 if in progress (poll for completion)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on invalid IP or immediate connect failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md446"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="group__core__io.html#gab85e4ae7965fc1334bbc547642dcdd42">Socket_connect_nonblocking</a>(sock, <span class="stringliteral">&quot;192.168.1.1&quot;</span>, 8080);</div>
<div class="line"><span class="keywordflow">if</span> (status == 1) {</div>
<div class="line">    <span class="comment">// In progress - add to poll</span></div>
<div class="line">    <a class="code hl_function" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e">SocketPoll_add</a>(poll, sock, <a class="code hl_enumvalue" href="group__event__system.html#gga9e8943c9cb47aba63dda4ad9083142b6acd6f685ba9cebb83074be444222ae195">POLL_WRITE</a>, NULL);</div>
<div class="line">    <span class="comment">// When writable, check Socket_isconnected()</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gab85e4ae7965fc1334bbc547642dcdd42"><div class="ttname"><a href="group__core__io.html#gab85e4ae7965fc1334bbc547642dcdd42">Socket_connect_nonblocking</a></div><div class="ttdeci">int Socket_connect_nonblocking(Socket_T socket, const char *ip_address, int port)</div><div class="ttdoc">Initiate non-blocking connect (no DNS, IP address only).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For hostname resolution, use <a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a> with <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> </dd>
<dd>
Socket is left in non-blocking mode after this call</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a> to check connection status </dd>
<dd>
<a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a> for async DNS + connect </dd>
<dd>
SocketHappyEyeballs for RFC 8305 connection racing </dd></dl>

</div>
</div>
<a id="ga2f7e9cc726b2eeabb19787f27e931fd7" name="ga2f7e9cc726b2eeabb19787f27e931fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f7e9cc726b2eeabb19787f27e931fd7">&#9670;&#160;</a></span>Socket_connect_tcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_connect_tcp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a connected TCP client socket in one call. </p>
<p>Convenience function that combines <a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1" title="Create a new socket with specified domain, type, and protocol.">Socket_new()</a>, <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> with timeout support. Creates a connected TCP client socket ready for I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Remote address (IP or hostname) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Remote port (1-65535) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> timeout in milliseconds (0 = no timeout)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New connected socket ready for <a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a>/Socket_recv()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on socket creation, DNS resolution, or connect failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates new socket instance</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md444"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T client = <a class="code hl_function" href="group__core__io.html#ga2f7e9cc726b2eeabb19787f27e931fd7">Socket_connect_tcp</a>(<span class="stringliteral">&quot;api.example.com&quot;</span>, 443, 5000);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a>(client, request, len);</div>
<div class="line">ssize_t n = <a class="code hl_function" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a>(client, response, <span class="keyword">sizeof</span>(response));</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;client);</div>
<div class="ttc" id="agroup__core__io_html_ga2f7e9cc726b2eeabb19787f27e931fd7"><div class="ttname"><a href="group__core__io.html#ga2f7e9cc726b2eeabb19787f27e931fd7">Socket_connect_tcp</a></div><div class="ttdeci">Socket_T Socket_connect_tcp(const char *host, int port, int timeout_ms)</div><div class="ttdoc">Create a connected TCP client socket in one call.</div></div>
<div class="ttc" id="agroup__core__io_html_ga95db343f47445925cecd6b20054518e9"><div class="ttname"><a href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a></div><div class="ttdeci">ssize_t Socket_recv(Socket_T socket, void *buf, size_t len)</div><div class="ttdoc">Receive data.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>DNS resolution uses synchronous getaddrinfo() which may block </dd>
<dd>
For non-blocking connect, use <a class="el" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4" title="Enable non-blocking mode.">Socket_setnonblocking()</a> + <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga1e27e618c92028d428e4d58aec6818c8" title="Connect to Unix domain socket with timeout.">Socket_connect_unix_timeout()</a> for Unix domain sockets </dd>
<dd>
<a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for more control over socket options </dd></dl>

</div>
</div>
<a id="gad353c95a8994569af7b650f1fda7036f" name="gad353c95a8994569af7b650f1fda7036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad353c95a8994569af7b650f1fda7036f">&#9670;&#160;</a></span>Socket_connect_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_unix </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to Unix domain socket path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to connect (AF_UNIX). </td></tr>
    <tr><td class="paramname">path</td><td>Socket file path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Supports abstract namespace sockets on Linux (path starting with '@'). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e" title="Bind to Unix domain socket path.">Socket_bind_unix()</a> for binding Unix sockets. </dd></dl>

</div>
</div>
<a id="ga1e27e618c92028d428e4d58aec6818c8" name="ga1e27e618c92028d428e4d58aec6818c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e27e618c92028d428e4d58aec6818c8">&#9670;&#160;</a></span>Socket_connect_unix_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_unix_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect to Unix domain socket with timeout. </p>
<p>Connects an existing Unix domain socket to a server path with timeout support. The socket must already be created with AF_UNIX domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">socket</td><td>Unix domain socket (AF_UNIX) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Server socket path </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> timeout in milliseconds (0 = no timeout)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketUnix_Failed</td><td>on connect failure or timeout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md448"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_UNIX, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga1e27e618c92028d428e4d58aec6818c8">Socket_connect_unix_timeout</a>(sock, <span class="stringliteral">&quot;/var/run/myapp.sock&quot;</span>, 5000);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a>(sock, message, len);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
<div class="ttc" id="agroup__core__io_html_ga1e27e618c92028d428e4d58aec6818c8"><div class="ttname"><a href="group__core__io.html#ga1e27e618c92028d428e4d58aec6818c8">Socket_connect_unix_timeout</a></div><div class="ttdeci">void Socket_connect_unix_timeout(Socket_T socket, const char *path, int timeout_ms)</div><div class="ttdoc">Connect to Unix domain socket with timeout.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For one-call client creation, first create socket then call this</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad353c95a8994569af7b650f1fda7036f" title="Connect to Unix domain socket path.">Socket_connect_unix()</a> for connect without timeout </dd>
<dd>
<a class="el" href="group__core__io.html#ga295887e87b95de840e1a5c5ad4d7f530" title="Create a listening Unix domain socket in one call.">Socket_listen_unix()</a> for creating Unix domain server </dd></dl>

</div>
</div>
<a id="ga28271af8ebad671a64fd37ffb2d07e0c" name="ga28271af8ebad671a64fd37ffb2d07e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28271af8ebad671a64fd37ffb2d07e0c">&#9670;&#160;</a></span>Socket_connect_with_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_with_addrinfo </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect socket using resolved address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to connect. </td></tr>
    <tr><td class="paramname">res</td><td>Resolved addrinfo result from DNS resolution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga04ab3a8c8b70328f9b72cc5a1e771e87" title="Start async DNS resolution for connect.">Socket_connect_async()</a> for async DNS resolution. </dd>
<dd>
<a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for direct connection. </dd></dl>

</div>
</div>
<a id="ga650eaa359c457e6118eab764ab7c1512" name="ga650eaa359c457e6118eab764ab7c1512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650eaa359c457e6118eab764ab7c1512">&#9670;&#160;</a></span>Socket_cork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_cork </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control TCP_CORK option (Nagle corking). </p>
<p>When corking is enabled, TCP accumulates small writes into larger segments before sending. Useful for building complete messages before transmission (e.g., HTTP headers + body).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>TCP socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>1 to enable corking, 0 to disable (flush)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if not supported</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md437"></a>
Platform Support</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Support    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone">Full (TCP_CORK)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FreeBSD/macOS   </td><td class="markdownTableBodyNone">Partial (TCP_NOPUSH)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Other   </td><td class="markdownTableBodyNone">Returns -1   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md438"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Cork while building response</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga650eaa359c457e6118eab764ab7c1512">Socket_cork</a>(sock, 1);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a>(sock, headers, header_len);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a>(sock, body, body_len);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga650eaa359c457e6118eab764ab7c1512">Socket_cork</a>(sock, 0);  <span class="comment">// Flush all data</span></div>
<div class="ttc" id="agroup__core__io_html_ga23ace6e065fe4b9a01db8caa6513515b"><div class="ttname"><a href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a></div><div class="ttdeci">ssize_t Socket_send(Socket_T socket, const void *buf, size_t len)</div><div class="ttdoc">Send data.</div></div>
<div class="ttc" id="agroup__core__io_html_ga650eaa359c457e6118eab764ab7c1512"><div class="ttname"><a href="group__core__io.html#ga650eaa359c457e6118eab764ab7c1512">Socket_cork</a></div><div class="ttdeci">int Socket_cork(Socket_T socket, int enable)</div><div class="ttdoc">Control TCP_CORK option (Nagle corking).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Corking is automatically released when socket buffer is full </dd>
<dd>
Different from TCP_NODELAY which disables Nagle algorithm entirely</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga55174d7f9aca0e94d25321540646e6b0" title="Disable Nagle&#39;s algorithm.">Socket_setnodelay()</a> for disabling Nagle algorithm </dd></dl>

</div>
</div>
<a id="gaa8cacd863c275e6e12f7c63b65708e1b" name="gaa8cacd863c275e6e12f7c63b65708e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8cacd863c275e6e12f7c63b65708e1b">&#9670;&#160;</a></span>Socket_debug_live_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_debug_live_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of live socket instances (test-only). </p>
<dl class="section return"><dt>Returns</dt><dd>Current count of allocated Socket_T instances. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For testing and leak detection. </dd></dl>

</div>
</div>
<a id="gaa1bcd57fc9784fa9863a2fc659df0de1" name="gaa1bcd57fc9784fa9863a2fc659df0de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1bcd57fc9784fa9863a2fc659df0de1">&#9670;&#160;</a></span>Socket_dup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_dup </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate a socket (creates new Socket_T sharing same fd). </p>
<p>Creates a new Socket_T instance with a duplicated file descriptor (via dup()). Both sockets share the same underlying connection but have independent Socket_T state (buffers, settings, etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to duplicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Socket_T with duplicated fd, or NULL on error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on dup() or allocation failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md440"></a>
Use Cases</h2>
<ul>
<li>Separate reader/writer for same connection</li>
<li>Passing socket to child process (fork safety)</li>
<li>Multiple references to same connection</li>
</ul>
<h2><a class="anchor" id="autotoc_md441"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T reader = socket;</div>
<div class="line">Socket_T writer = <a class="code hl_function" href="group__core__io.html#gaa1bcd57fc9784fa9863a2fc659df0de1">Socket_dup</a>(socket);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now can use in separate threads</span></div>
<div class="line"><span class="comment">// reader thread: Socket_recv(reader, ...)</span></div>
<div class="line"><span class="comment">// writer thread: Socket_send(writer, ...)</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;writer);  <span class="comment">// Closes duplicated fd</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;reader);  <span class="comment">// Closes original fd</span></div>
<div class="ttc" id="agroup__core__io_html_gaa1bcd57fc9784fa9863a2fc659df0de1"><div class="ttname"><a href="group__core__io.html#gaa1bcd57fc9784fa9863a2fc659df0de1">Socket_dup</a></div><div class="ttdeci">Socket_T Socket_dup(Socket_T socket)</div><div class="ttdoc">Duplicate a socket (creates new Socket_T sharing same fd).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Both sockets must be freed separately </dd>
<dd>
Closing one does not affect the other's fd </dd>
<dd>
Socket options are shared (both see setsockopt changes)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4a0e5436dae38def5b10b26c9d4b6512" title="Duplicate socket fd to a specific file descriptor number.">Socket_dup2()</a> for duplicating to specific fd </dd></dl>

</div>
</div>
<a id="ga4a0e5436dae38def5b10b26c9d4b6512" name="ga4a0e5436dae38def5b10b26c9d4b6512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a0e5436dae38def5b10b26c9d4b6512">&#9670;&#160;</a></span>Socket_dup2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_dup2 </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate socket fd to a specific file descriptor number. </p>
<p>Creates a new Socket_T instance with the file descriptor duplicated to a specific number (via dup2()). If target_fd is already open, it is closed first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to duplicate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_fd</td><td>Target file descriptor number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Socket_T with fd = target_fd, or NULL on error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on dup2() or allocation failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md442"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Duplicate socket to specific fd for exec()</span></div>
<div class="line">Socket_T sock_on_fd3 = <a class="code hl_function" href="group__core__io.html#ga4a0e5436dae38def5b10b26c9d4b6512">Socket_dup2</a>(socket, 3);</div>
<div class="line"><span class="keywordflow">if</span> (fork() == 0) {</div>
<div class="line">    <span class="comment">// Child: fd 3 is the socket</span></div>
<div class="line">    execl(<span class="stringliteral">&quot;/usr/bin/handler&quot;</span>, <span class="stringliteral">&quot;handler&quot;</span>, NULL);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock_on_fd3);</div>
<div class="ttc" id="agroup__core__io_html_ga4a0e5436dae38def5b10b26c9d4b6512"><div class="ttname"><a href="group__core__io.html#ga4a0e5436dae38def5b10b26c9d4b6512">Socket_dup2</a></div><div class="ttdeci">Socket_T Socket_dup2(Socket_T socket, int target_fd)</div><div class="ttdoc">Duplicate socket fd to a specific file descriptor number.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>target_fd is closed if already open (like dup2 behavior) </dd>
<dd>
Original socket is unchanged</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaa1bcd57fc9784fa9863a2fc659df0de1" title="Duplicate a socket (creates new Socket_T sharing same fd).">Socket_dup()</a> for simple duplication </dd></dl>

</div>
</div>
<a id="ga8517adf0df2e5331a952fb713ec314f9" name="ga8517adf0df2e5331a952fb713ec314f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8517adf0df2e5331a952fb713ec314f9">&#9670;&#160;</a></span>Socket_error_is_retryable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_error_is_retryable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an errno indicates a retryable error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>errno value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if retryable, 0 if not. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> for getting current errno. </dd>
<dd>
<a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0" title="General socket operation failure exception.">Socket_Failed</a> exception for when this is used.</dd></dl>
<p>This is a convenience wrapper around <a class="el" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163" title="SocketError_is_retryable_errno - Check if errno indicates retryable error.">SocketError_is_retryable_errno()</a> for socket-specific error handling.</p>
<p>Retryable errors (return 1):</p><ul>
<li>ECONNREFUSED: Server not listening, may start later</li>
<li>ECONNRESET: <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> dropped, can reconnect</li>
<li>ETIMEDOUT: Timeout, may succeed on retry</li>
<li>ENETUNREACH: Network route may recover</li>
<li>EHOSTUNREACH: Host may become reachable</li>
<li>EAGAIN/EWOULDBLOCK: Resource temporarily unavailable</li>
<li>EINTR: Interrupted by signal</li>
</ul>
<p>Fatal errors (return 0):</p><ul>
<li>EACCES: Permission denied (won't change)</li>
<li>EADDRINUSE: Address in use (won't change)</li>
<li>EBADF: Bad file descriptor (programming error)</li>
<li>EINVAL: Invalid argument (programming error)</li>
<li>ENOMEM: Out of memory (system issue)</li>
<li>EMFILE/ENFILE: Too many open files (system limit)</li>
</ul>
<p>Usage: TRY Socket_connect(sock, host, port); <a class="el" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e" title="Catch a specific exception type within a TRY block.">EXCEPT(Socket_Failed)</a> if (Socket_error_is_retryable(Socket_geterrno())) // Schedule retry with backoff else // Log error and give up END_TRY; </p>

</div>
</div>
<a id="ga4d727948c677509eec04746585819877" name="ga4d727948c677509eec04746585819877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d727948c677509eec04746585819877">&#9670;&#160;</a></span>Socket_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_fd </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get underlying file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File descriptor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gae7c6b82ec5bf6be8131532de9ade5caf" title="Create Socket_T from existing file descriptor.">Socket_new_from_fd()</a> for creating sockets from file descriptors. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga74ad7a9bb8deaf499c59d90d6e411f37" name="ga74ad7a9bb8deaf499c59d90d6e411f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ad7a9bb8deaf499c59d90d6e411f37">&#9670;&#160;</a></span>Socket_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_free </td>
          <td>(</td>
          <td class="paramtype">Socket_T *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispose of a socket instance and close the underlying file descriptor. </p>
<p>Closes the socket's file descriptor using close(2) and frees all associated resources including internal state, buffers, and timers. The pointer *socket is set to NULL after successful cleanup to prevent use-after-free.</p>
<p>This function is idempotent: calling on NULL does nothing. It handles partial cleanup if socket is in inconsistent state (e.g., after exception).</p>
<p>IMPORTANT: Always pass pointer to socket (&amp;sock) so it can be nulled. Failing to do so may lead to use-after-free bugs.</p>
<p>For testing, use <a class="el" href="group__core__io.html#gaa8cacd863c275e6e12f7c63b65708e1b" title="Get number of live socket instances (test-only).">Socket_debug_live_count()</a> to ensure all sockets freed.</p>
<p>Edge cases:</p><ul>
<li>Already freed socket (NULL): no-op</li>
<li>Socket in connect/bind state: aborts operations gracefully</li>
<li>TLS-enabled socket: performs TLS shutdown if connected</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">socket</td><td>Pointer to Socket_T (set to NULL on success)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- errors during close are logged but not raised (Socket_Failed would be swallowed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - per-socket cleanup, no shared state modification</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md412"></a>
Basic Usage</h2>
<div class="fragment"><div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><span class="comment">// ... use sock ...</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);  <span class="comment">// Pass address to nullify</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md413"></a>
In TRY/EXCEPT Block</h2>
<div class="fragment"><div class="line">Socket_T sock = NULL;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <span class="comment">// Operations that may fail</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// Error handling</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);  <span class="comment">// Safe even if sock NULL</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__foundation_html_ga0e2a75478cd44f1666a6aca626c5c50b"><div class="ttname"><a href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a></div><div class="ttdeci">#define FINALLY</div><div class="ttdoc">Define cleanup code that executes regardless of exceptions.</div><div class="ttdef"><b>Definition</b> <a href="Except_8h_source.html#l01326">Except.h:1326</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Always use &amp;sock in Socket_free(&amp;sock) to enable nulling. </dd>
<dd>
For pooled sockets, use <a class="el" href="group__connection__mgmt.html#gacdffcf1802367df60db15c649fc7072d" title="Remove socket from pool.">SocketPool_remove()</a> before free. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access socket after free - undefined behavior. </dd>
<dd>
In multithreaded code, ensure no other thread uses socket during free.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - close(2) call plus resource cleanup</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1" title="Create a new socket with specified domain, type, and protocol.">Socket_new()</a> for creation </dd>
<dd>
<a class="el" href="group__core__io.html#gaa8cacd863c275e6e12f7c63b65708e1b" title="Get number of live socket instances (test-only).">Socket_debug_live_count()</a> for leak detection in tests </dd>
<dd>
<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> for connection pooling alternatives </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga76b91bb032c977bc19df4dc0f3e4cff7" name="ga76b91bb032c977bc19df4dc0f3e4cff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76b91bb032c977bc19df4dc0f3e4cff7">&#9670;&#160;</a></span>Socket_get_cwnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Socket_get_cwnd </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current congestion window size. </p>
<p>Retrieves the TCP congestion window (cwnd) which limits how much unacknowledged data can be in flight. Useful for network diagnostics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected TCP socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Congestion window in segments, or -1 if unavailable</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md425"></a>
Example</h2>
<div class="fragment"><div class="line">int32_t cwnd = <a class="code hl_function" href="group__core__io.html#ga76b91bb032c977bc19df4dc0f3e4cff7">Socket_get_cwnd</a>(sock);</div>
<div class="line"><span class="keywordflow">if</span> (cwnd &gt;= 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Congestion window: %d segments\n&quot;</span>, cwnd);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga76b91bb032c977bc19df4dc0f3e4cff7"><div class="ttname"><a href="group__core__io.html#ga76b91bb032c977bc19df4dc0f3e4cff7">Socket_get_cwnd</a></div><div class="ttdeci">int32_t Socket_get_cwnd(Socket_T socket)</div><div class="ttdoc">Get current congestion window size.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Linux-specific; returns -1 on other platforms </dd>
<dd>
cwnd is dynamically adjusted by congestion control algorithm</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12" title="Retrieve TCP connection statistics (Linux-specific).">Socket_get_tcp_info()</a> for comprehensive TCP statistics (Linux) </dd></dl>

</div>
</div>
<a id="gaead54f56807d61df1827a49d94870490" name="gaead54f56807d61df1827a49d94870490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead54f56807d61df1827a49d94870490">&#9670;&#160;</a></span>Socket_get_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_get_error </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pending socket error (SO_ERROR). </p>
<p>Retrieves and clears the pending socket error via getsockopt(SO_ERROR). Useful after non-blocking connect() or to check for async errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no error, otherwise errno value (ECONNREFUSED, ETIMEDOUT, etc.)</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic getsockopt call</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md419"></a>
Common Error Values</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Error   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">No error    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ECONNREFUSED   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> refused by peer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ECONNRESET   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> reset by peer    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ETIMEDOUT   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> timed out    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENETUNREACH   </td><td class="markdownTableBodyNone">Network unreachable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EHOSTUNREACH   </td><td class="markdownTableBodyNone">Host unreachable   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md420"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// After non-blocking connect, poll for writability, then:</span></div>
<div class="line"><span class="keywordtype">int</span> error = <a class="code hl_function" href="group__core__io.html#gaead54f56807d61df1827a49d94870490">Socket_get_error</a>(sock);</div>
<div class="line"><span class="keywordflow">if</span> (error != 0) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Connect failed: %s\n&quot;</span>, strerror(error));</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Connected successfully\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gaead54f56807d61df1827a49d94870490"><div class="ttname"><a href="group__core__io.html#gaead54f56807d61df1827a49d94870490">Socket_get_error</a></div><div class="ttdeci">int Socket_get_error(Socket_T socket)</div><div class="ttdoc">Get pending socket error (SO_ERROR).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>SO_ERROR is cleared after retrieval (per POSIX)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gafefcba126efabd940ff1e7e3259ee7d8" title="Probe if a connection is still alive.">Socket_probe()</a> for comprehensive health check </dd>
<dd>
<a class="el" href="group__core__io.html#gab85e4ae7965fc1334bbc547642dcdd42" title="Initiate non-blocking connect (no DNS, IP address only).">Socket_connect_nonblocking()</a> for async connect usage </dd></dl>

</div>
</div>
<a id="gaddc4637d1e6e996b0f52d553ec884098" name="gaddc4637d1e6e996b0f52d553ec884098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc4637d1e6e996b0f52d553ec884098">&#9670;&#160;</a></span>Socket_get_rtt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Socket_get_rtt </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current RTT (round-trip time) estimate. </p>
<p>Retrieves the TCP stack's smoothed RTT estimate for the connection. On Linux, uses TCP_INFO; on other platforms, may return -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected TCP socket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTT in microseconds, or -1 if unavailable</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md424"></a>
Example</h2>
<div class="fragment"><div class="line">int32_t rtt = <a class="code hl_function" href="group__core__io.html#gaddc4637d1e6e996b0f52d553ec884098">Socket_get_rtt</a>(sock);</div>
<div class="line"><span class="keywordflow">if</span> (rtt &gt;= 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;RTT: %.2f ms\n&quot;</span>, rtt / 1000.0);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;RTT unavailable on this platform\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gaddc4637d1e6e996b0f52d553ec884098"><div class="ttname"><a href="group__core__io.html#gaddc4637d1e6e996b0f52d553ec884098">Socket_get_rtt</a></div><div class="ttdeci">int32_t Socket_get_rtt(Socket_T socket)</div><div class="ttdoc">Get current RTT (round-trip time) estimate.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>TCP stack updates RTT based on ACK timing; may not reflect current </dd>
<dd>
For UDP, always returns -1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12" title="Retrieve TCP connection statistics (Linux-specific).">Socket_get_tcp_info()</a> for comprehensive TCP statistics (Linux) </dd>
<dd>
<a class="el" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164" title="Retrieve current statistics for a socket.">Socket_getstats()</a> for <a class="el" href="group__core__io.html#structSocketStats__T" title="Per-socket I/O statistics structure.">SocketStats_T</a> with rtt_us field </dd></dl>

</div>
</div>
<a id="ga326db6a48e839e56bd1599fc3a651723" name="ga326db6a48e839e56bd1599fc3a651723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga326db6a48e839e56bd1599fc3a651723">&#9670;&#160;</a></span>socket_get_ssl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SSL * socket_get_ssl </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get SSL object from socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SSL object or NULL if TLS not enabled </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only access to socket state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gabc70395a3d965153d4502752c496544e" title="Check if socket has TLS enabled.">socket_is_tls_enabled()</a> to check TLS status before calling. </dd>
<dd>
<a class="el" href="group__core__io.html#ga10ddc2a7b61b559013a79f7d1297d409" title="Validate TLS is ready for I/O.">socket_validate_tls_ready()</a> to ensure TLS readiness for I/O. </dd>
<dd>
<a class="el" href="group__core__io.html#ga92f7b61974c6adb4ac454b4fb671c6b8" title="Helper to handle SSL error codes.">socket_handle_ssl_error()</a> for handling errors with the SSL object. </dd>
<dd>
<a class="el" href="group__security.html">Security Module</a> for TLS integration. </dd></dl>

</div>
</div>
<a id="gaf553d73a7db296859dc7a1a92c0f6b12" name="gaf553d73a7db296859dc7a1a92c0f6b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf553d73a7db296859dc7a1a92c0f6b12">&#9670;&#160;</a></span>Socket_get_tcp_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_get_tcp_info </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketTCPInfo">SocketTCPInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve TCP connection statistics (Linux-specific). </p>
<p>Retrieves detailed TCP stack information via getsockopt(TCP_INFO). Provides RTT measurements, congestion window, MSS, retransmission counts, and other TCP internals useful for diagnostics and monitoring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected TCP socket </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Output structure for TCP information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (errno set)</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic getsockopt call</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md423"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__core__io.html#structSocketTCPInfo">SocketTCPInfo</a> info;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12">Socket_get_tcp_info</a>(sock, &amp;info) == 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;RTT: %.2f ms (variance: %.2f ms)\n&quot;</span>,</div>
<div class="line">           info.<a class="code hl_variable" href="group__core__io.html#aab4ba2040044e6dfcd4b96fc186126a0">rtt_us</a> / 1000.0, info.<a class="code hl_variable" href="group__core__io.html#a6766b0686666a67e35ab3fd4ac134d91">rttvar_us</a> / 1000.0);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Congestion window: %u segments\n&quot;</span>, info.<a class="code hl_variable" href="group__core__io.html#abc51ce63ef8aa4fc7c34bd7926460f6c">snd_cwnd</a>);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Retransmissions: %u\n&quot;</span>, info.<a class="code hl_variable" href="group__core__io.html#afc6256ec520cf71dff6ee7d713b7c798">total_retrans</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (info.<a class="code hl_variable" href="group__core__io.html#a6cf6fcadad72a1f6a26dfe613a230727">delivery_rate</a> &gt; 0) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Delivery rate: %.2f Mbps\n&quot;</span>,</div>
<div class="line">               info.<a class="code hl_variable" href="group__core__io.html#a6cf6fcadad72a1f6a26dfe613a230727">delivery_rate</a> * 8.0 / 1e6);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_a6766b0686666a67e35ab3fd4ac134d91"><div class="ttname"><a href="group__core__io.html#a6766b0686666a67e35ab3fd4ac134d91">SocketTCPInfo::rttvar_us</a></div><div class="ttdeci">uint32_t rttvar_us</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00973">Socket.h:973</a></div></div>
<div class="ttc" id="agroup__core__io_html_a6cf6fcadad72a1f6a26dfe613a230727"><div class="ttname"><a href="group__core__io.html#a6cf6fcadad72a1f6a26dfe613a230727">SocketTCPInfo::delivery_rate</a></div><div class="ttdeci">uint64_t delivery_rate</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l01003">Socket.h:1003</a></div></div>
<div class="ttc" id="agroup__core__io_html_aab4ba2040044e6dfcd4b96fc186126a0"><div class="ttname"><a href="group__core__io.html#aab4ba2040044e6dfcd4b96fc186126a0">SocketTCPInfo::rtt_us</a></div><div class="ttdeci">uint32_t rtt_us</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00972">Socket.h:972</a></div></div>
<div class="ttc" id="agroup__core__io_html_abc51ce63ef8aa4fc7c34bd7926460f6c"><div class="ttname"><a href="group__core__io.html#abc51ce63ef8aa4fc7c34bd7926460f6c">SocketTCPInfo::snd_cwnd</a></div><div class="ttdeci">uint32_t snd_cwnd</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00975">Socket.h:975</a></div></div>
<div class="ttc" id="agroup__core__io_html_afc6256ec520cf71dff6ee7d713b7c798"><div class="ttname"><a href="group__core__io.html#afc6256ec520cf71dff6ee7d713b7c798">SocketTCPInfo::total_retrans</a></div><div class="ttdeci">uint32_t total_retrans</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00983">Socket.h:983</a></div></div>
<div class="ttc" id="agroup__core__io_html_gaf553d73a7db296859dc7a1a92c0f6b12"><div class="ttname"><a href="group__core__io.html#gaf553d73a7db296859dc7a1a92c0f6b12">Socket_get_tcp_info</a></div><div class="ttdeci">int Socket_get_tcp_info(Socket_T socket, SocketTCPInfo *info)</div><div class="ttdoc">Retrieve TCP connection statistics (Linux-specific).</div></div>
<div class="ttc" id="agroup__core__io_html_structSocketTCPInfo"><div class="ttname"><a href="group__core__io.html#structSocketTCPInfo">SocketTCPInfo</a></div><div class="ttdoc">TCP connection information structure (Linux-specific).</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00936">Socket.h:937</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Linux-specific; not available on other platforms </dd>
<dd>
Some fields require newer kernel versions (noted in structure)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaddc4637d1e6e996b0f52d553ec884098" title="Get current RTT (round-trip time) estimate.">Socket_get_rtt()</a> for simple RTT query </dd>
<dd>
<a class="el" href="group__core__io.html#ga76b91bb032c977bc19df4dc0f3e4cff7" title="Get current congestion window size.">Socket_get_cwnd()</a> for congestion window query </dd>
<dd>
<a class="el" href="group__core__io.html#structSocketTCPInfo" title="TCP connection information structure (Linux-specific).">SocketTCPInfo</a> for field descriptions </dd></dl>

</div>
</div>
<a id="gae49a9ad4c524354506bef71ec6cffdf9" name="gae49a9ad4c524354506bef71ec6cffdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49a9ad4c524354506bef71ec6cffdf9">&#9670;&#160;</a></span>Socket_getbandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Socket_getbandwidth </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get bandwidth limit for socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bandwidth limit in bytes per second (0 if unlimited). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacab565f9a6e6c40c56d6d21df89b30a9" title="Set bandwidth limit for socket.">Socket_setbandwidth()</a> for setting bandwidth limit. </dd></dl>

</div>
</div>
<a id="gaebaf7f944985462e9198998a650f2b5c" name="gaebaf7f944985462e9198998a650f2b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebaf7f944985462e9198998a650f2b5c">&#9670;&#160;</a></span>Socket_getcongestion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getcongestion </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP congestion control algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
    <tr><td class="paramname">algorithm</td><td>Output buffer for algorithm name. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error or if not supported. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gae144a341a05e25011d95761368eefe13" title="Set TCP congestion control algorithm.">Socket_setcongestion()</a> for setting algorithm. </dd></dl>

</div>
</div>
<a id="ga80f9fc5782bf3caf5228e458d3f3c112" name="ga80f9fc5782bf3caf5228e458d3f3c112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80f9fc5782bf3caf5228e458d3f3c112">&#9670;&#160;</a></span>Socket_getdeferaccept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getdeferaccept </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP_DEFER_ACCEPT timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Listening socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current defer accept timeout in seconds, 0 if disabled. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab5b9e684faf1a8d5c1ccb9e231ef1354" title="Enable TCP_DEFER_ACCEPT.">Socket_setdeferaccept()</a> for setting defer accept. </dd></dl>

</div>
</div>
<a id="ga762ad6759e76f58f5a8f1fcb305387a8" name="ga762ad6759e76f58f5a8f1fcb305387a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762ad6759e76f58f5a8f1fcb305387a8">&#9670;&#160;</a></span>Socket_getfastopen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getfastopen </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP Fast Open setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if enabled, 0 if disabled, -1 on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaa7c1651e6f9e3e97ddab01d40ac1d39d" title="Enable TCP Fast Open.">Socket_setfastopen()</a> for enabling Fast Open. </dd></dl>

</div>
</div>
<a id="gacd2f2e66892b062079f4c0a1dd7f8bac" name="gacd2f2e66892b062079f4c0a1dd7f8bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2f2e66892b062079f4c0a1dd7f8bac">&#9670;&#160;</a></span>Socket_getkeepalive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_getkeepalive </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP keepalive configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
    <tr><td class="paramname">idle</td><td>Output - idle timeout in seconds. </td></tr>
    <tr><td class="paramname">interval</td><td>Output - interval between probes in seconds. </td></tr>
    <tr><td class="paramname">count</td><td>Output - number of probes before declaring dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf03ef2a81d1894713aeb96c12bb2389b" title="Enable TCP keepalive.">Socket_setkeepalive()</a> for setting keepalive parameters. </dd></dl>

</div>
</div>
<a id="ga04e55475bcedbc100767663e1e7d9de1" name="ga04e55475bcedbc100767663e1e7d9de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e55475bcedbc100767663e1e7d9de1">&#9670;&#160;</a></span>Socket_getlocaladdr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Socket_getlocaladdr </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IP address string (IPv4/IPv6) or "(unknown)" if unavailable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>String is owned by socket, valid until socket freed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3bdedaea9dac966d75343cdffa5d1f3e" title="Get local port number.">Socket_getlocalport()</a> for local port. </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding to addresses. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga3bdedaea9dac966d75343cdffa5d1f3e" name="ga3bdedaea9dac966d75343cdffa5d1f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bdedaea9dac966d75343cdffa5d1f3e">&#9670;&#160;</a></span>Socket_getlocalport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getlocalport </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get local port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Port number (1 to SOCKET_MAX_PORT) or 0 if unavailable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga04e55475bcedbc100767663e1e7d9de1" title="Get local IP address.">Socket_getlocaladdr()</a> for local address. </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding to ports. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga01aa484c370addf3f117cfdb4f9adb8a" name="ga01aa484c370addf3f117cfdb4f9adb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01aa484c370addf3f117cfdb4f9adb8a">&#9670;&#160;</a></span>Socket_getnodelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getnodelay </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP_NODELAY setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if Nagle's algorithm is disabled, 0 if enabled. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga55174d7f9aca0e94d25321540646e6b0" title="Disable Nagle&#39;s algorithm.">Socket_setnodelay()</a> for setting Nagle algorithm. </dd></dl>

</div>
</div>
<a id="gab0957f43694d0728e70b23364a89623c" name="gab0957f43694d0728e70b23364a89623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0957f43694d0728e70b23364a89623c">&#9670;&#160;</a></span>Socket_getpeeraddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Socket_getpeeraddr </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get peer IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IP address string (IPv4/IPv6) or "(unknown)" if unavailable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>String is owned by socket, valid until socket freed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga38d7e5845519867261a9f24dfe0e03db" title="Get peer port number.">Socket_getpeerport()</a> for peer port. </dd>
<dd>
<a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for establishing connections. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>, <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>, and <a class="el" href="connection__pool_8c_source.html#l00040">simulate_work_wrapper()</a>.</p>

</div>
</div>
<a id="ga64a5bd6dc33ef5f000b9f7d334a1fdfa" name="ga64a5bd6dc33ef5f000b9f7d334a1fdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64a5bd6dc33ef5f000b9f7d334a1fdfa">&#9670;&#160;</a></span>Socket_getpeergid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeergid </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get peer group ID (Linux only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peer group ID, or (gid_t)-1 if unavailable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaabc2fdbcfb3c619c05c7aa3c4c555382" title="Get peer process ID (Linux only).">Socket_getpeerpid()</a> for peer process ID. </dd>
<dd>
<a class="el" href="group__core__io.html#ga0bf945a195478ed5a85c881b0f163a08" title="Get peer user ID (Linux only).">Socket_getpeeruid()</a> for peer user ID. </dd></dl>

</div>
</div>
<a id="gaabc2fdbcfb3c619c05c7aa3c4c555382" name="gaabc2fdbcfb3c619c05c7aa3c4c555382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc2fdbcfb3c619c05c7aa3c4c555382">&#9670;&#160;</a></span>Socket_getpeerpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeerpid </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get peer process ID (Linux only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peer process ID, or -1 if unavailable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga0bf945a195478ed5a85c881b0f163a08" title="Get peer user ID (Linux only).">Socket_getpeeruid()</a> for peer user ID. </dd>
<dd>
<a class="el" href="group__core__io.html#ga64a5bd6dc33ef5f000b9f7d334a1fdfa" title="Get peer group ID (Linux only).">Socket_getpeergid()</a> for peer group ID. </dd></dl>

</div>
</div>
<a id="ga38d7e5845519867261a9f24dfe0e03db" name="ga38d7e5845519867261a9f24dfe0e03db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d7e5845519867261a9f24dfe0e03db">&#9670;&#160;</a></span>Socket_getpeerport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeerport </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get peer port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Port number (1 to SOCKET_MAX_PORT) or 0 if unavailable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c" title="Get peer IP address.">Socket_getpeeraddr()</a> for peer address. </dd>
<dd>
<a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for establishing connections. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>, <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>, and <a class="el" href="connection__pool_8c_source.html#l00040">simulate_work_wrapper()</a>.</p>

</div>
</div>
<a id="ga0bf945a195478ed5a85c881b0f163a08" name="ga0bf945a195478ed5a85c881b0f163a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf945a195478ed5a85c881b0f163a08">&#9670;&#160;</a></span>Socket_getpeeruid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeeruid </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get peer user ID (Linux only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peer user ID, or (uid_t)-1 if unavailable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaabc2fdbcfb3c619c05c7aa3c4c555382" title="Get peer process ID (Linux only).">Socket_getpeerpid()</a> for peer process ID. </dd>
<dd>
<a class="el" href="group__core__io.html#ga64a5bd6dc33ef5f000b9f7d334a1fdfa" title="Get peer group ID (Linux only).">Socket_getpeergid()</a> for peer group ID. </dd></dl>

</div>
</div>
<a id="ga73b2908934ed8757725da6e6d22ff60c" name="ga73b2908934ed8757725da6e6d22ff60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b2908934ed8757725da6e6d22ff60c">&#9670;&#160;</a></span>Socket_getrcvbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getrcvbuf </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get receive buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Receive buffer size in bytes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad59dc86a3f3728e75983daa0f5b34550" title="Set receive buffer size.">Socket_setrcvbuf()</a> for setting receive buffer size. </dd></dl>

</div>
</div>
<a id="ga23a3e2bbff42609e2e4089d5e6c55bbd" name="ga23a3e2bbff42609e2e4089d5e6c55bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23a3e2bbff42609e2e4089d5e6c55bbd">&#9670;&#160;</a></span>Socket_getsndbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getsndbuf </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get send buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Send buffer size in bytes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga430b3464f6e656f4d8884031deffa507" title="Set send buffer size.">Socket_setsndbuf()</a> for setting send buffer size. </dd></dl>

</div>
</div>
<a id="gafdfd3666a5d9779023f527c3afddf164" name="gafdfd3666a5d9779023f527c3afddf164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfd3666a5d9779023f527c3afddf164">&#9670;&#160;</a></span>Socket_getstats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_getstats </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketStats__T">SocketStats_T</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve current statistics for a socket. </p>
<p>Copies the current per-socket statistics to the provided structure. Statistics include cumulative bytes/packets transferred, error counts, and timing information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>Output structure for statistics (must not be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>if socket is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic snapshot of statistics</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md415"></a>
Example</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__core__io.html#structSocketStats__T">SocketStats_T</a> stats;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164">Socket_getstats</a>(sock, &amp;stats);</div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;Transfer: %zu bytes sent, %zu bytes received\n&quot;</span>,</div>
<div class="line">       (<span class="keywordtype">size_t</span>)stats.<a class="code hl_variable" href="group__core__io.html#a1a306a747a6858b1c2745deb7cbda232">bytes_sent</a>, (<span class="keywordtype">size_t</span>)stats.<a class="code hl_variable" href="group__core__io.html#a66852de9dd3886d61d34598a0987dde6">bytes_received</a>);</div>
<div class="line">printf(<span class="stringliteral">&quot;Packets: %zu sent, %zu received\n&quot;</span>,</div>
<div class="line">       (<span class="keywordtype">size_t</span>)stats.<a class="code hl_variable" href="group__core__io.html#ac1fc3da8e3224e5de2359d367092693b">packets_sent</a>, (<span class="keywordtype">size_t</span>)stats.<a class="code hl_variable" href="group__core__io.html#a78542783f1f4728ac202fc09f248d364">packets_received</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (stats.<a class="code hl_variable" href="group__core__io.html#a41a4f659a79cb76006eb875feb1ee5f4">rtt_us</a> &gt;= 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;RTT: %.2f ms\n&quot;</span>, stats.<a class="code hl_variable" href="group__core__io.html#a41a4f659a79cb76006eb875feb1ee5f4">rtt_us</a> / 1000.0);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_a41a4f659a79cb76006eb875feb1ee5f4"><div class="ttname"><a href="group__core__io.html#a41a4f659a79cb76006eb875feb1ee5f4">SocketStats_T::rtt_us</a></div><div class="ttdeci">int32_t rtt_us</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00689">Socket.h:689</a></div></div>
<div class="ttc" id="agroup__core__io_html_a66852de9dd3886d61d34598a0987dde6"><div class="ttname"><a href="group__core__io.html#a66852de9dd3886d61d34598a0987dde6">SocketStats_T::bytes_received</a></div><div class="ttdeci">uint64_t bytes_received</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00670">Socket.h:670</a></div></div>
<div class="ttc" id="agroup__core__io_html_a78542783f1f4728ac202fc09f248d364"><div class="ttname"><a href="group__core__io.html#a78542783f1f4728ac202fc09f248d364">SocketStats_T::packets_received</a></div><div class="ttdeci">uint64_t packets_received</div><div class="ttdef"><b>Definition</b> <a href="Socket_8h_source.html#l00674">Socket.h:674</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>RTT fields only populated on Linux via TCP_INFO; -1 on other platforms </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c" title="Reset statistics counters for a socket.">Socket_resetstats()</a> to reset counters </dd>
<dd>
<a class="el" href="group__core__io.html#structSocketStats__T" title="Per-socket I/O statistics structure.">SocketStats_T</a> for field descriptions </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gaa40c1cdc37abfc34cbc17cdcbf607241" name="gaa40c1cdc37abfc34cbc17cdcbf607241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40c1cdc37abfc34cbc17cdcbf607241">&#9670;&#160;</a></span>Socket_gettimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_gettimeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get socket timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout in seconds (0 if disabled). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga210cbf763685c0b201b0f5caa2dc0f06" title="Set socket timeout.">Socket_settimeout()</a> for setting timeout. </dd></dl>

</div>
</div>
<a id="ga2b81fe340e400d96d2552a65cfde5430" name="ga2b81fe340e400d96d2552a65cfde5430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b81fe340e400d96d2552a65cfde5430">&#9670;&#160;</a></span>Socket_getusertimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket_getusertimeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get TCP user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout in milliseconds, or 0 on error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gabfad0f5567b5f8720a4667e13e79f282" title="Set TCP user timeout.">Socket_setusertimeout()</a> for setting user timeout. </dd></dl>

</div>
</div>
<a id="ga92f7b61974c6adb4ac454b4fb671c6b8" name="ga92f7b61974c6adb4ac454b4fb671c6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f7b61974c6adb4ac454b4fb671c6b8">&#9670;&#160;</a></span>socket_handle_ssl_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_handle_ssl_error </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SSL *&#160;</td>
          <td class="paramname"><em>ssl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssl_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to handle SSL error codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
    <tr><td class="paramname">ssl</td><td>SSL object </td></tr>
    <tr><td class="paramname">ssl_result</td><td>Result from SSL operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (sets errno) </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Maps SSL error codes to errno values and updates socket state. </dd>
<dd>
Used by TLS-aware I/O functions for consistent error handling.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad65971e86ea8dcbaa79e4e457612d3a6" title="Internal send operation (TLS-aware)">socket_send_internal()</a> and <a class="el" href="group__core__io.html#ga12c16a6d184c96f82dd1185d315f29e2" title="Internal receive operation (TLS-aware)">socket_recv_internal()</a> for usage examples. </dd>
<dd>
SSL_get_error() OpenSSL documentation for error mapping details. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e">SocketTLS_Failed</a> for raised exceptions. </dd></dl>

</div>
</div>
<a id="ga410b67062c053c3af7e86531acc1620c" name="ga410b67062c053c3af7e86531acc1620c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410b67062c053c3af7e86531acc1620c">&#9670;&#160;</a></span>Socket_ignore_sigpipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_ignore_sigpipe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Globally ignore SIGPIPE signal. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error (sets errno). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - can be called from any thread, idempotent operation.</dt><dd></dd></dl>
<p>NOTE: This function is NOT required when using this library. The library handles SIGPIPE internally via:</p><ul>
<li>MSG_NOSIGNAL flag on send operations (Linux/FreeBSD)</li>
<li>SO_NOSIGPIPE socket option at creation (BSD/macOS)</li>
</ul>
<p>This convenience function is provided for:</p><ul>
<li>Legacy code migration (applications that previously handled SIGPIPE)</li>
<li>Applications mixing this library with raw socket code</li>
<li>Defense-in-depth preference</li>
</ul>
<p>Usage: // Optional - call once at program startup if desired <a class="el" href="group__core__io.html#ga410b67062c053c3af7e86531acc1620c" title="Globally ignore SIGPIPE signal.">Socket_ignore_sigpipe()</a>;</p>
<p>IMPORTANT: Do not call this if your application needs to handle SIGPIPE for other purposes (e.g., detecting broken pipes in shell pipelines).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for SIGPIPE-safe sending operations. </dd></dl>

</div>
</div>
<a id="ga3796b46a9d07c1be492e027eb9dfdee5" name="ga3796b46a9d07c1be492e027eb9dfdee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3796b46a9d07c1be492e027eb9dfdee5">&#9670;&#160;</a></span>Socket_is_readable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_is_readable </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket has data available to read without blocking. </p>
<p>Performs a quick check to see if recv() would return data immediately. Uses poll() with zero timeout to check POLLIN status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if data available, 0 if would block, -1 on error</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic poll call</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md421"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Check before blocking recv</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5">Socket_is_readable</a>(sock) &gt; 0) {</div>
<div class="line">    ssize_t n = <a class="code hl_function" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a>(sock, buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line">    <span class="comment">// Process data</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In select/poll alternative</span></div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5">Socket_is_readable</a>(sock) &gt; 0) {</div>
<div class="line">    process_incoming_data(sock);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga3796b46a9d07c1be492e027eb9dfdee5"><div class="ttname"><a href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5">Socket_is_readable</a></div><div class="ttdeci">int Socket_is_readable(Socket_T socket)</div><div class="ttdoc">Check if socket has data available to read without blocking.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Also returns 1 if peer has closed connection (recv will return 0) </dd>
<dd>
For more efficient I/O multiplexing, use SocketPoll</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga8acb19502c6d3adce7652e61070eee3c" title="Check if socket can accept writes without blocking.">Socket_is_writable()</a> for write readiness check </dd>
<dd>
SocketPoll for efficient event-driven I/O </dd></dl>

</div>
</div>
<a id="gabc70395a3d965153d4502752c496544e" name="gabc70395a3d965153d4502752c496544e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc70395a3d965153d4502752c496544e">&#9670;&#160;</a></span>socket_is_tls_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_is_tls_enabled </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket has TLS enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if TLS is enabled on the socket, 0 otherwise. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic read of socket state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__security.html#gab9a8fb788aa1f0d21b5773bc43a48d6f" title="Enable TLS on a socket using the provided context.">SocketTLS_enable()</a> to enable TLS on a socket. </dd>
<dd>
<a class="el" href="group__core__io.html#ga665b41107ebf850f631386135fa58791" title="Check if TLS wants to read more data for handshake or protocol.">socket_tls_want_read()</a> and <a class="el" href="group__core__io.html#gae7a7fe487c65b17fdea95a118bc98a97" title="Check if TLS wants to write more data for handshake or protocol.">socket_tls_want_write()</a> for checking TLS handshake needs. </dd>
<dd>
group__security for TLS module documentation. </dd></dl>

</div>
</div>
<a id="ga8acb19502c6d3adce7652e61070eee3c" name="ga8acb19502c6d3adce7652e61070eee3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8acb19502c6d3adce7652e61070eee3c">&#9670;&#160;</a></span>Socket_is_writable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_is_writable </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket can accept writes without blocking. </p>
<p>Performs a quick check to see if send() would succeed immediately. Uses poll() with zero timeout to check POLLOUT status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if write ready, 0 if would block, -1 on error</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic poll call</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md422"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Check before potentially blocking send</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#ga8acb19502c6d3adce7652e61070eee3c">Socket_is_writable</a>(sock) &gt; 0) {</div>
<div class="line">    ssize_t n = <a class="code hl_function" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b">Socket_send</a>(sock, buf, len);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Buffer full, queue for later</span></div>
<div class="line">    queue_pending_write(buf, len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga8acb19502c6d3adce7652e61070eee3c"><div class="ttname"><a href="group__core__io.html#ga8acb19502c6d3adce7652e61070eee3c">Socket_is_writable</a></div><div class="ttdeci">int Socket_is_writable(Socket_T socket)</div><div class="ttdoc">Check if socket can accept writes without blocking.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Returns 1 if send buffer has space; doesn't guarantee all data fits </dd>
<dd>
For non-blocking connect, writable means connect completed (check error)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5" title="Check if socket has data available to read without blocking.">Socket_is_readable()</a> for read readiness check </dd>
<dd>
<a class="el" href="group__core__io.html#gaead54f56807d61df1827a49d94870490" title="Get pending socket error (SO_ERROR).">Socket_get_error()</a> to check after non-blocking connect </dd></dl>

</div>
</div>
<a id="ga1710f1e1251df44fb4f82c60ff199a76" name="ga1710f1e1251df44fb4f82c60ff199a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1710f1e1251df44fb4f82c60ff199a76">&#9670;&#160;</a></span>Socket_isbound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_isbound </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket is bound to an address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if bound, 0 if not bound. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding sockets. </dd>
<dd>
<a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a> for checking connection state. </dd></dl>

</div>
</div>
<a id="ga10d49f774ed335cf4e42f77c07948119" name="ga10d49f774ed335cf4e42f77c07948119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d49f774ed335cf4e42f77c07948119">&#9670;&#160;</a></span>Socket_isconnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_isconnected </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if connected, 0 if not connected. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for establishing connections. </dd>
<dd>
<a class="el" href="group__core__io.html#ga1710f1e1251df44fb4f82c60ff199a76" title="Check if socket is bound to an address.">Socket_isbound()</a> for checking binding state. </dd></dl>

</div>
</div>
<a id="gab693dfb51bcfe2b284969a5f1db14a84" name="gab693dfb51bcfe2b284969a5f1db14a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab693dfb51bcfe2b284969a5f1db14a84">&#9670;&#160;</a></span>Socket_islistening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_islistening </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket is listening for connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if listening, 0 if not listening. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> for setting up listening sockets. </dd>
<dd>
<a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for accepting connections. </dd></dl>

</div>
</div>
<a id="gab24b026bc4c69e6f766211f44675e189" name="gab24b026bc4c69e6f766211f44675e189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab24b026bc4c69e6f766211f44675e189">&#9670;&#160;</a></span>Socket_listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_listen </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Listen for incoming connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Bound socket. </td></tr>
    <tr><td class="paramname">backlog</td><td>Maximum pending connections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding sockets. </dd>
<dd>
<a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for accepting connections. </dd></dl>

<p class="reference">Referenced by <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gabf72952b9d7d0e4fc8255de6c92fbe11" name="gabf72952b9d7d0e4fc8255de6c92fbe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf72952b9d7d0e4fc8255de6c92fbe11">&#9670;&#160;</a></span>Socket_listen_tcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_listen_tcp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a listening TCP server socket in one call. </p>
<p>Convenience function that combines <a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1" title="Create a new socket with specified domain, type, and protocol.">Socket_new()</a>, <a class="el" href="group__core__io.html#ga2c6f352cec920859c71206898ed135fc" title="Enable address reuse.">Socket_setreuseaddr()</a>, <a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a>, and <a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> into a single call. Creates a ready-to-accept TCP server socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Local address to bind (NULL or "" for INADDR_ANY/all interfaces) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Local port to bind (1-65535) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Maximum pending connections (use SOMAXCONN for system max)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New listening socket ready for <a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on socket creation, bind, or listen failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates new socket instance</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md443"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T server = <a class="code hl_function" href="group__core__io.html#gabf72952b9d7d0e4fc8255de6c92fbe11">Socket_listen_tcp</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, 8080, 128);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    Socket_T client = <a class="code hl_function" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a>(server);</div>
<div class="line">    <span class="keywordflow">if</span> (client) handle_client(client);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;server);</div>
<div class="ttc" id="agroup__core__io_html_ga32b67d95639513cd6a602f6175b48f15"><div class="ttname"><a href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a></div><div class="ttdeci">Socket_T Socket_accept(Socket_T socket)</div><div class="ttdoc">Accept incoming connection.</div></div>
<div class="ttc" id="agroup__core__io_html_gabf72952b9d7d0e4fc8255de6c92fbe11"><div class="ttname"><a href="group__core__io.html#gabf72952b9d7d0e4fc8255de6c92fbe11">Socket_listen_tcp</a></div><div class="ttdeci">Socket_T Socket_listen_tcp(const char *host, int port, int backlog)</div><div class="ttdoc">Create a listening TCP server socket in one call.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Socket is created with SO_REUSEADDR enabled </dd>
<dd>
For IPv6, use "::" as host for dual-stack binding</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for accepting connections </dd>
<dd>
<a class="el" href="group__core__io.html#ga295887e87b95de840e1a5c5ad4d7f530" title="Create a listening Unix domain socket in one call.">Socket_listen_unix()</a> for Unix domain sockets </dd></dl>

</div>
</div>
<a id="ga295887e87b95de840e1a5c5ad4d7f530" name="ga295887e87b95de840e1a5c5ad4d7f530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga295887e87b95de840e1a5c5ad4d7f530">&#9670;&#160;</a></span>Socket_listen_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_listen_unix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a listening Unix domain socket in one call. </p>
<p>Convenience function that combines Socket_new(AF_UNIX), <a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e" title="Bind to Unix domain socket path.">Socket_bind_unix()</a>, and <a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> into a single call. Creates a ready-to-accept Unix domain socket server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Socket file path (max ~108 bytes, or '@' prefix for abstract) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backlog</td><td>Maximum pending connections</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New listening Unix domain socket ready for <a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketUnix_Failed</td><td>on creation, bind, or listen failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates new socket instance</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md447"></a>
Example</h2>
<div class="fragment"><div class="line">Socket_T server = <a class="code hl_function" href="group__core__io.html#ga295887e87b95de840e1a5c5ad4d7f530">Socket_listen_unix</a>(<span class="stringliteral">&quot;/var/run/myapp.sock&quot;</span>, 128);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    Socket_T client = <a class="code hl_function" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15">Socket_accept</a>(server);</div>
<div class="line">    <span class="keywordflow">if</span> (client) handle_client(client);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;server);</div>
<div class="line">unlink(<span class="stringliteral">&quot;/var/run/myapp.sock&quot;</span>);  <span class="comment">// Clean up socket file</span></div>
<div class="ttc" id="agroup__core__io_html_ga295887e87b95de840e1a5c5ad4d7f530"><div class="ttname"><a href="group__core__io.html#ga295887e87b95de840e1a5c5ad4d7f530">Socket_listen_unix</a></div><div class="ttdeci">Socket_T Socket_listen_unix(const char *path, int backlog)</div><div class="ttdoc">Create a listening Unix domain socket in one call.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Existing socket file at path will cause EADDRINUSE - remove first </dd>
<dd>
Abstract sockets (Linux): prefix path with '@' (no file created)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gabf72952b9d7d0e4fc8255de6c92fbe11" title="Create a listening TCP server socket in one call.">Socket_listen_tcp()</a> for TCP sockets </dd>
<dd>
<a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e" title="Bind to Unix domain socket path.">Socket_bind_unix()</a> for more control </dd></dl>

</div>
</div>
<a id="ga6212fb2b6eefa567592a59f55c25a6f1" name="ga6212fb2b6eefa567592a59f55c25a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6212fb2b6eefa567592a59f55c25a6f1">&#9670;&#160;</a></span>Socket_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new socket with specified domain, type, and protocol. </p>
<p>Creates and initializes a new socket instance using the socket(2) system call. The socket is created in blocking mode by default. SIGPIPE is automatically handled internally via platform-specific mechanisms (MSG_NOSIGNAL on Linux, SO_NOSIGPIPE on BSD/macOS). The library sets reasonable default socket options including close-on-exec and non-SIGPIPE behavior.</p>
<p>Supported domains: AF_INET (IPv4), AF_INET6 (IPv6), AF_UNIX (Unix domain). Supported types: SOCK_STREAM (TCP), SOCK_DGRAM (UDP), SOCK_SEQPACKET (SCTP). Protocol is usually 0 to select default for the domain/type combination.</p>
<p>Edge cases:</p><ul>
<li>Invalid domain/type/protocol combinations raise Socket_Failed immediately.</li>
<li>Resource limits (EMFILE, ENFILE) raise Socket_Failed.</li>
<li>Permission issues (EACCES) raise Socket_Failed.</li>
</ul>
<p>For UDP, use <a class="el" href="group__socket__dgram.html#gad6902c87ab5883f155dab2adfa950c52" title="Create a new UDP/datagram socket with specified domain and protocol.">SocketDgram_new()</a> instead for datagram-specific features.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Address family (AF_INET, AF_INET6, AF_UNIX) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type (SOCK_STREAM for TCP, SOCK_DGRAM for UDP) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol number (0 for default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Socket_T instance on success, raises exception on failure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>System call failed (EACCES permission denied, EMFILE/ENFILE too many files, ENOMEM out of memory, EINVAL invalid arguments)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent instance safe from concurrent calls</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md408"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"><span class="comment">// Create TCP IPv4 socket</span></div>
<div class="line">Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;example.com&quot;</span>, 80);</div>
<div class="line"><span class="comment">// ... use socket ...</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md409"></a>
With Error Handling and Options</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET6, SOCK_STREAM, 0);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga2c6f352cec920859c71206898ed135fc">Socket_setreuseaddr</a>(sock);  <span class="comment">// Allow address reuse</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4">Socket_setnonblocking</a>(sock);  <span class="comment">// Non-blocking mode</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98">Socket_bind</a>(sock, <span class="stringliteral">&quot;::&quot;</span>, 8080);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189">Socket_listen</a>(sock, 128);</div>
<div class="line">    <span class="comment">// Server loop...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Socket creation failed: %s\n&quot;</span>, <a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>());</div>
<div class="line">    <span class="comment">// Handle error (e.g., retry or exit)</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_ga2c6f352cec920859c71206898ed135fc"><div class="ttname"><a href="group__core__io.html#ga2c6f352cec920859c71206898ed135fc">Socket_setreuseaddr</a></div><div class="ttdeci">void Socket_setreuseaddr(Socket_T socket)</div><div class="ttdoc">Enable address reuse.</div></div>
<div class="ttc" id="agroup__foundation_html_gac71a25566cdc9e11eaecb16c966081db"><div class="ttname"><a href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a></div><div class="ttdeci">const char * Socket_GetLastError(void)</div><div class="ttdoc">Socket_GetLastError - Retrieve the most recent formatted error message.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Socket is blocking by default; use <a class="el" href="group__core__io.html#ga35309677a1760480783d5f0c294d0db4" title="Enable non-blocking mode.">Socket_setnonblocking()</a> for async I/O. </dd>
<dd>
For Unix domain sockets, use AF_UNIX domain. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Ensure proper cleanup with <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> to avoid fd leaks. </dd>
<dd>
SOCK_DGRAM with this function creates basic UDP socket; use <a class="el" href="group__socket__dgram.html#gad6902c87ab5883f155dab2adfa950c52" title="Create a new UDP/datagram socket with specified domain and protocol.">SocketDgram_new()</a> for full UDP features like multicast.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single socket(2) system call plus option setup</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> for resource cleanup </dd>
<dd>
<a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for client connections </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> and <a class="el" href="group__core__io.html#gab24b026bc4c69e6f766211f44675e189" title="Listen for incoming connections.">Socket_listen()</a> for servers </dd>
<dd>
<a class="el" href="group__socket__dgram.html#gad6902c87ab5883f155dab2adfa950c52" title="Create a new UDP/datagram socket with specified domain and protocol.">SocketDgram_new()</a> for UDP/datagram sockets </dd>
<dd>
<a class="el" href="group__core__io.html#gae7c6b82ec5bf6be8131532de9ade5caf" title="Create Socket_T from existing file descriptor.">Socket_new_from_fd()</a> for wrapping existing fds </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for non-blocking patterns </dd></dl>

<p class="reference">Referenced by <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gae7c6b82ec5bf6be8131532de9ade5caf" name="gae7c6b82ec5bf6be8131532de9ade5caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c6b82ec5bf6be8131532de9ade5caf">&#9670;&#160;</a></span>Socket_new_from_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T Socket_new_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create Socket_T from existing file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor (must be valid socket, will be set to non-blocking). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New Socket_T instance or NULL on failure. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - returns new instance without modifying shared state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1" title="Create a new socket with specified domain, type, and protocol.">Socket_new()</a> for creating new sockets. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877" title="Get underlying file descriptor.">Socket_fd()</a> for getting file descriptors from Socket_T instances. </dd></dl>

</div>
</div>
<a id="gaa999775c5490710cbb8b455060bc1145" name="gaa999775c5490710cbb8b455060bc1145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa999775c5490710cbb8b455060bc1145">&#9670;&#160;</a></span>Socket_peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_peek </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at incoming data without consuming it. </p>
<p>Reads data from the socket receive buffer without removing it. Subsequent recv() calls will return the same data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer for peeked data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum bytes to peek</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes peeked (&gt; 0), 0 if no data available, or raises</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for same socket with proper synchronization</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md439"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Peek at protocol header to determine message type</span></div>
<div class="line"><span class="keywordtype">char</span> header[4];</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#gaa999775c5490710cbb8b455060bc1145">Socket_peek</a>(sock, header, <span class="keyword">sizeof</span>(header)) &gt;= 4) {</div>
<div class="line">    <span class="keywordtype">int</span> msg_type = header[0];</div>
<div class="line">    <span class="keywordtype">int</span> msg_len = (header[1] &lt;&lt; 16) | (header[2] &lt;&lt; 8) | header[3];</div>
<div class="line">    <span class="comment">// Now read full message</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b">Socket_recvall</a>(sock, buffer, msg_len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga18ea888b05b09714cc010463b8cead4b"><div class="ttname"><a href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b">Socket_recvall</a></div><div class="ttdeci">ssize_t Socket_recvall(Socket_T socket, void *buf, size_t len)</div><div class="ttdoc">Receive all requested data (handles partial receives).</div></div>
<div class="ttc" id="agroup__core__io_html_gaa999775c5490710cbb8b455060bc1145"><div class="ttname"><a href="group__core__io.html#gaa999775c5490710cbb8b455060bc1145">Socket_peek</a></div><div class="ttdeci">ssize_t Socket_peek(Socket_T socket, void *buf, size_t len)</div><div class="ttdoc">Peek at incoming data without consuming it.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Useful for protocol detection and message framing </dd>
<dd>
Non-blocking sockets return 0 if no data available</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for consuming data </dd>
<dd>
<a class="el" href="group__core__io.html#ga3796b46a9d07c1be492e027eb9dfdee5" title="Check if socket has data available to read without blocking.">Socket_is_readable()</a> for checking data availability </dd></dl>

</div>
</div>
<a id="gafefcba126efabd940ff1e7e3259ee7d8" name="gafefcba126efabd940ff1e7e3259ee7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafefcba126efabd940ff1e7e3259ee7d8">&#9670;&#160;</a></span>Socket_probe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_probe </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Probe if a connection is still alive. </p>
<p>Performs a non-destructive check to determine if the connection is still valid. Uses a combination of:</p><ol type="1">
<li>SO_ERROR check for pending socket errors</li>
<li>Zero-byte MSG_PEEK recv to detect closed connections</li>
<li>Optional write probe (if enabled)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket to probe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Maximum time to wait for response (-1 for non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if connection appears healthy, 0 if connection is dead/error</dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only probe</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md417"></a>
Return Values</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Return   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> healthy (no errors detected)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> dead, reset, or error pending   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md418"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Quick health check before expensive operation</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__core__io.html#gafefcba126efabd940ff1e7e3259ee7d8">Socket_probe</a>(sock, 0)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Connection lost, reconnecting...\n&quot;</span>);</div>
<div class="line">    reconnect(sock);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With timeout for more thorough check</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__core__io.html#gafefcba126efabd940ff1e7e3259ee7d8">Socket_probe</a>(sock, 100)) {  <span class="comment">// 100ms probe</span></div>
<div class="line">    handle_disconnect();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gafefcba126efabd940ff1e7e3259ee7d8"><div class="ttname"><a href="group__core__io.html#gafefcba126efabd940ff1e7e3259ee7d8">Socket_probe</a></div><div class="ttdeci">int Socket_probe(Socket_T socket, int timeout_ms)</div><div class="ttdoc">Probe if a connection is still alive.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is a best-effort check; TCP half-open states may not be detected </dd>
<dd>
For TCP, a true liveness check requires application-level heartbeats</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaead54f56807d61df1827a49d94870490" title="Get pending socket error (SO_ERROR).">Socket_get_error()</a> for retrieving specific error codes </dd>
<dd>
<a class="el" href="group__core__io.html#ga10d49f774ed335cf4e42f77c07948119" title="Check if socket is connected.">Socket_isconnected()</a> for basic connection state check </dd></dl>

</div>
</div>
<a id="ga95db343f47445925cecd6b20054518e9" name="ga95db343f47445925cecd6b20054518e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95db343f47445925cecd6b20054518e9">&#9670;&#160;</a></span>Socket_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recv </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer for received data. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer size (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b" title="Receive all requested data (handles partial receives).">Socket_recvall()</a> for guaranteed complete reception. </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for sending data. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>, and <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga12c16a6d184c96f82dd1185d315f29e2" name="ga12c16a6d184c96f82dd1185d315f29e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c16a6d184c96f82dd1185d315f29e2">&#9670;&#160;</a></span>socket_recv_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t socket_recv_internal </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal receive operation (TLS-aware) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer for received data </td></tr>
    <tr><td class="paramname">len</td><td>Buffer size </td></tr>
    <tr><td class="paramname">flags</td><td>Receive flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes received, or 0 if would block (EAGAIN/EWOULDBLOCK) or EOF (connection closed). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on underlying socket errors such as invalid file descriptor or network issues. </td></tr>
    <tr><td class="paramname">SocketTLS_Failed</td><td>on TLS decryption or read failures (#if SOCKET_HAS_TLS). </td></tr>
    <tr><td class="paramname">Socket_Closed</td><td>on connection closure detected by recv returning 0 or ECONNRESET. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Routes through SSL_read() if TLS is enabled, otherwise uses recv(). </dd>
<dd>
Maps SSL errors to errno (EAGAIN for WANT_READ/WRITE).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for the public synchronous receive interface. </dd>
<dd>
<a class="el" href="group__core__io.html#gad65971e86ea8dcbaa79e4e457612d3a6" title="Internal send operation (TLS-aware)">socket_send_internal()</a> for the corresponding send operation. </dd>
<dd>
<a class="el" href="group__core__io.html#gaa7fc21bc639d4077480b1d2b7c2bef7e" title="Internal scatter/gather receive (TLS-aware)">socket_recvv_internal()</a> for scatter-gather receive support. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e" title="General TLS operation failure.">SocketTLS_Failed</a> exception for TLS-specific errors. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2db3d742dcea3f39ad2eb37d4fb1e453">Socket_Closed</a> on EOF detection. </dd></dl>

</div>
</div>
<a id="ga6839d0b5738d2764b47de35bf7e16430" name="ga6839d0b5738d2764b47de35bf7e16430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6839d0b5738d2764b47de35bf7e16430">&#9670;&#160;</a></span>Socket_recv_limited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recv_limited </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data with bandwidth limiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer for received data. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer size (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes received (&gt; 0), 0 if rate limited or would block, or raises. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses per-socket bandwidth limiter with internal locking.</dt><dd></dd></dl>
<p>Like <a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> but respects bandwidth limit set by <a class="el" href="group__core__io.html#gacab565f9a6e6c40c56d6d21df89b30a9" title="Set bandwidth limit for socket.">Socket_setbandwidth()</a>. If bandwidth limiting is disabled (0), behaves like <a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga274b6782b2029d2d8aa33579ad60a4c1" title="Send data with bandwidth limiting.">Socket_send_limited()</a> for bandwidth-limited sending. </dd></dl>

</div>
</div>
<a id="ga18ea888b05b09714cc010463b8cead4b" name="ga18ea888b05b09714cc010463b8cead4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ea888b05b09714cc010463b8cead4b">&#9670;&#160;</a></span>Socket_recvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvall </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive all requested data (handles partial receives). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer for received data. </td></tr>
    <tr><td class="paramname">len</td><td>Buffer size (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received (always equals len on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for partial receive operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb" title="Send all data (handles partial sends).">Socket_sendall()</a> for sending all data. </dd></dl>

</div>
</div>
<a id="ga61028bd16150564ea59c7f4c350ca9d4" name="ga61028bd16150564ea59c7f4c350ca9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61028bd16150564ea59c7f4c350ca9d4">&#9670;&#160;</a></span>Socket_recvall_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvall_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive all requested data with timeout. </p>
<p>Like <a class="el" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b" title="Receive all requested data (handles partial receives).">Socket_recvall()</a> but with a timeout. Ensures all requested data is received or times out. Partial receives are possible on timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer for received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout, -1 = block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received on success (may be &lt; len on timeout)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for same socket with proper synchronization</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md434"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> buf[1024];</div>
<div class="line">ssize_t n = <a class="code hl_function" href="group__core__io.html#ga61028bd16150564ea59c7f4c350ca9d4">Socket_recvall_timeout</a>(sock, buf, <span class="keyword">sizeof</span>(buf), 5000);</div>
<div class="line"><span class="keywordflow">if</span> (n &lt; (ssize_t)<span class="keyword">sizeof</span>(buf)) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Only received %zd bytes (timeout or EOF)\n&quot;</span>, n);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga61028bd16150564ea59c7f4c350ca9d4"><div class="ttname"><a href="group__core__io.html#ga61028bd16150564ea59c7f4c350ca9d4">Socket_recvall_timeout</a></div><div class="ttdeci">ssize_t Socket_recvall_timeout(Socket_T socket, void *buf, size_t len, int timeout_ms)</div><div class="ttdoc">Receive all requested data with timeout.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b" title="Receive all requested data (handles partial receives).">Socket_recvall()</a> for blocking receive </dd>
<dd>
<a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for single receive operation </dd></dl>

</div>
</div>
<a id="gad1236a73c0cac828b3079b74d1b0996d" name="gad1236a73c0cac828b3079b74d1b0996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1236a73c0cac828b3079b74d1b0996d">&#9670;&#160;</a></span>Socket_recvfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_recvfd </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fd_received</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a file descriptor over Unix domain socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket (AF_UNIX). </td></tr>
    <tr><td class="paramname">fd_received</td><td>Output pointer for received file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error, Socket_Closed on disconnect.</td></tr>
  </table>
  </dd>
</dl>
<p>Receives a file descriptor from the peer process via SCM_RIGHTS. The received fd is owned by this process and must be closed when done.</p>
<p>OWNERSHIP: Caller takes ownership of the received fd and MUST close it.</p>
<dl class="section user"><dt>Thread Safety\n Yes - uses thread-local error buffers for safe concurrent</dt><dd>operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga001e932180b059a805ca53a8edbeef15" title="Send a file descriptor over Unix domain socket.">Socket_sendfd()</a> for sending file descriptors. </dd>
<dd>
<a class="el" href="group__core__io.html#gab806cbdac1b78ff644c4f841151cf3a8" title="Receive multiple file descriptors.">Socket_recvfds()</a> for receiving multiple descriptors. </dd></dl>

</div>
</div>
<a id="gab806cbdac1b78ff644c4f841151cf3a8" name="gab806cbdac1b78ff644c4f841151cf3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab806cbdac1b78ff644c4f841151cf3a8">&#9670;&#160;</a></span>Socket_recvfds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_recvfds </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>received_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive multiple file descriptors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket (AF_UNIX). </td></tr>
    <tr><td class="paramname">fds</td><td>Output array for received descriptors (must have max_count capacity). </td></tr>
    <tr><td class="paramname">max_count</td><td>Maximum descriptors to receive. </td></tr>
    <tr><td class="paramname">received_count</td><td>Output for actual count received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error, Socket_Closed on disconnect.</td></tr>
  </table>
  </dd>
</dl>
<p>Receives multiple file descriptors from a single message. On success, *received_count contains the number of fds received.</p>
<p>OWNERSHIP: Caller takes ownership of all received fds and MUST close them.</p>
<dl class="section user"><dt>Thread Safety\n Yes - uses thread-local error buffers for safe concurrent</dt><dd>operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga70c2f94b87d307842c7d11de0b6a2bce" title="Send multiple file descriptors.">Socket_sendfds()</a> for sending multiple descriptors. </dd>
<dd>
<a class="el" href="group__core__io.html#gad1236a73c0cac828b3079b74d1b0996d" title="Receive a file descriptor over Unix domain socket.">Socket_recvfd()</a> for receiving single descriptor. </dd></dl>

</div>
</div>
<a id="ga92c972ba69ef189d5d802e4d1889a9c6" name="ga92c972ba69ef189d5d802e4d1889a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92c972ba69ef189d5d802e4d1889a9c6">&#9670;&#160;</a></span>Socket_recvmsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvmsg </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive message with ancillary data (recvmsg wrapper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">msg</td><td>Message structure for data, address, and ancillary data. </td></tr>
    <tr><td class="paramname">flags</td><td>Message flags (MSG_DONTWAIT, MSG_PEEK, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received (&gt; 0) or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaeb12f81392f3c1fb21255bf44521e20c" title="Send message with ancillary data (sendmsg wrapper).">Socket_sendmsg()</a> for sending messages with ancillary data. </dd>
<dd>
<a class="el" href="group__core__io.html#gad1236a73c0cac828b3079b74d1b0996d" title="Receive a file descriptor over Unix domain socket.">Socket_recvfd()</a> for receiving file descriptors. </dd></dl>

</div>
</div>
<a id="gabb1c8e39587d4ea5e3ffe4b06dcaca0f" name="gabb1c8e39587d4ea5e3ffe4b06dcaca0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1c8e39587d4ea5e3ffe4b06dcaca0f">&#9670;&#160;</a></span>Socket_recvv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvv </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather receive (readv wrapper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt; 0, &lt;= IOV_MAX). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received (&gt; 0) or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3472c67c78cd29944a87783e09247f9a" title="Scatter/gather receive all (handles partial receives).">Socket_recvvall()</a> for guaranteed complete scatter/gather receive. </dd>
<dd>
<a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a" title="Scatter/gather send (writev wrapper).">Socket_sendv()</a> for scatter/gather send. </dd></dl>

</div>
</div>
<a id="gaa7fc21bc639d4077480b1d2b7c2bef7e" name="gaa7fc21bc639d4077480b1d2b7c2bef7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7fc21bc639d4077480b1d2b7c2bef7e">&#9670;&#160;</a></span>socket_recvv_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t socket_recvv_internal </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal scatter/gather receive (TLS-aware) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramname">flags</td><td>Receive flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes received into iov buffers, or 0 if would block or EOF. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on underlying socket or vectored I/O errors. </td></tr>
    <tr><td class="paramname">SocketTLS_Failed</td><td>on TLS read failures (#if SOCKET_HAS_TLS). </td></tr>
    <tr><td class="paramname">Socket_Closed</td><td>on connection closure detected by readv returning 0 or ECONNRESET. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For TLS: Calls SSL_read() into first iov, advances manually. </dd>
<dd>
For non-TLS: Uses readv() directly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gabb1c8e39587d4ea5e3ffe4b06dcaca0f" title="Scatter/gather receive (readv wrapper).">Socket_recvv()</a> for public vectored receive interface. </dd>
<dd>
<a class="el" href="group__core__io.html#ga12c16a6d184c96f82dd1185d315f29e2" title="Internal receive operation (TLS-aware)">socket_recv_internal()</a> for simple buffer receive. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2db3d742dcea3f39ad2eb37d4fb1e453">Socket_Closed</a> on connection EOF. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e">SocketTLS_Failed</a> for TLS errors. </dd></dl>

</div>
</div>
<a id="gace4c3a8cc81d7b66ebc2cc84bce51e8e" name="gace4c3a8cc81d7b66ebc2cc84bce51e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace4c3a8cc81d7b66ebc2cc84bce51e8e">&#9670;&#160;</a></span>Socket_recvv_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvv_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather receive with timeout. </p>
<p>Like <a class="el" href="group__core__io.html#gabb1c8e39587d4ea5e3ffe4b06dcaca0f" title="Scatter/gather receive (readv wrapper).">Socket_recvv()</a> but with a timeout. May perform partial receives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iov</td><td>Array of iovec structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout, -1 = block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received (&gt; 0), 0 if would block/timeout, or raises</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for same socket with proper synchronization</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3472c67c78cd29944a87783e09247f9a" title="Scatter/gather receive all (handles partial receives).">Socket_recvvall()</a> for guaranteed complete receive (no timeout) </dd>
<dd>
<a class="el" href="group__core__io.html#ga7224aed85b1b920cc62fea881ae6f056" title="Scatter/gather send with timeout.">Socket_sendv_timeout()</a> for scatter/gather send with timeout </dd></dl>

</div>
</div>
<a id="ga3472c67c78cd29944a87783e09247f9a" name="ga3472c67c78cd29944a87783e09247f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3472c67c78cd29944a87783e09247f9a">&#9670;&#160;</a></span>Socket_recvvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvvall </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather receive all (handles partial receives). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt; 0, &lt;= IOV_MAX). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes received (always equals sum of all iov_len on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on peer close or ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gabb1c8e39587d4ea5e3ffe4b06dcaca0f" title="Scatter/gather receive (readv wrapper).">Socket_recvv()</a> for partial scatter/gather receive. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf6d033a04d5041249950fa2f54a8d9fd" title="Scatter/gather send all (handles partial sends).">Socket_sendvall()</a> for sending all scatter/gather data. </dd></dl>

</div>
</div>
<a id="ga79e5b410845cb71d636f9fbf34771e9c" name="ga79e5b410845cb71d636f9fbf34771e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e5b410845cb71d636f9fbf34771e9c">&#9670;&#160;</a></span>Socket_resetstats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_resetstats </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset statistics counters for a socket. </p>
<p>Resets all per-socket statistics counters to zero except for create_time_ms which preserves the original creation timestamp. Useful for interval-based monitoring where you want to track stats per time period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Socket to reset</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>if socket is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - atomic reset</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md416"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Log stats every minute</span></div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_variable" href="connection__pool_8c.html#af1f449cc09f8d36befcce07bc38c29c0">running</a>) {</div>
<div class="line">    sleep(60);</div>
<div class="line">    <a class="code hl_struct" href="group__core__io.html#structSocketStats__T">SocketStats_T</a> stats;</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164">Socket_getstats</a>(sock, &amp;stats);</div>
<div class="line">    log_stats(&amp;stats);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga79e5b410845cb71d636f9fbf34771e9c">Socket_resetstats</a>(sock);  <span class="comment">// Reset for next interval</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gafdfd3666a5d9779023f527c3afddf164" title="Retrieve current statistics for a socket.">Socket_getstats()</a> to retrieve statistics </dd>
<dd>
<a class="el" href="group__core__io.html#structSocketStats__T" title="Per-socket I/O statistics structure.">SocketStats_T</a> for field descriptions </dd></dl>

</div>
</div>
<a id="ga23ace6e065fe4b9a01db8caa6513515b" name="ga23ace6e065fe4b9a01db8caa6513515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ace6e065fe4b9a01db8caa6513515b">&#9670;&#160;</a></span>Socket_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_send </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Data to send. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb" title="Send all data (handles partial sends).">Socket_sendall()</a> for guaranteed complete transmission. </dd>
<dd>
<a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for receiving data. </dd></dl>

</div>
</div>
<a id="gad65971e86ea8dcbaa79e4e457612d3a6" name="gad65971e86ea8dcbaa79e4e457612d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65971e86ea8dcbaa79e4e457612d3a6">&#9670;&#160;</a></span>socket_send_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t socket_send_internal </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal send operation (TLS-aware) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
    <tr><td class="paramname">buf</td><td>Data to send </td></tr>
    <tr><td class="paramname">len</td><td>Length of data </td></tr>
    <tr><td class="paramname">flags</td><td>Send flags (MSG_NOSIGNAL, etc.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes sent, or 0 if operation would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on underlying socket errors such as invalid file descriptor or network issues. </td></tr>
    <tr><td class="paramname">SocketTLS_Failed</td><td>on TLS encryption or write failures (#if SOCKET_HAS_TLS). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Routes through SSL_write() if TLS is enabled, otherwise uses send(). </dd>
<dd>
Handles partial sends and EAGAIN mapping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for the public synchronous send interface. </dd>
<dd>
<a class="el" href="group__core__io.html#ga12c16a6d184c96f82dd1185d315f29e2" title="Internal receive operation (TLS-aware)">socket_recv_internal()</a> for the corresponding receive operation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga714a501a951663d0248972ef6cc75818" title="Internal scatter/gather send (TLS-aware)">socket_sendv_internal()</a> for scatter-gather send support. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e">SocketTLS_Failed</a> exception for TLS-specific errors. </dd></dl>

</div>
</div>
<a id="ga274b6782b2029d2d8aa33579ad60a4c1" name="ga274b6782b2029d2d8aa33579ad60a4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga274b6782b2029d2d8aa33579ad60a4c1">&#9670;&#160;</a></span>Socket_send_limited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_send_limited </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data with bandwidth limiting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Data to send. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes sent (&gt; 0), 0 if rate limited (try again later), or raises. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses per-socket bandwidth limiter with internal locking.</dt><dd></dd></dl>
<p>Like <a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> but respects bandwidth limit set by <a class="el" href="group__core__io.html#gacab565f9a6e6c40c56d6d21df89b30a9" title="Set bandwidth limit for socket.">Socket_setbandwidth()</a>. If bandwidth limiting is disabled (0), behaves like <a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a>. If rate limited, returns 0 and caller should wait before retrying. Use <a class="el" href="group__core__io.html#ga89643e52780099fe0012e2fa22725e07" title="Get wait time until bandwidth available.">Socket_bandwidth_wait_ms()</a> to get recommended wait time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6839d0b5738d2764b47de35bf7e16430" title="Receive data with bandwidth limiting.">Socket_recv_limited()</a> for bandwidth-limited receiving. </dd>
<dd>
<a class="el" href="group__core__io.html#ga89643e52780099fe0012e2fa22725e07" title="Get wait time until bandwidth available.">Socket_bandwidth_wait_ms()</a> for wait time calculation. </dd></dl>

</div>
</div>
<a id="ga6ea9ad33d78c50d327c9677b52849bcb" name="ga6ea9ad33d78c50d327c9677b52849bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea9ad33d78c50d327c9677b52849bcb">&#9670;&#160;</a></span>Socket_sendall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendall </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send all data (handles partial sends). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">buf</td><td>Data to send. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent (always equals len on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for partial send operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga18ea888b05b09714cc010463b8cead4b" title="Receive all requested data (handles partial receives).">Socket_recvall()</a> for receiving all data. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>, and <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="gaea9384979b83066a7a6fa1418a5862d2" name="gaea9384979b83066a7a6fa1418a5862d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea9384979b83066a7a6fa1418a5862d2">&#9670;&#160;</a></span>Socket_sendall_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendall_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send all data with timeout. </p>
<p>Like <a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb" title="Send all data (handles partial sends).">Socket_sendall()</a> but with a timeout. Ensures all data is sent or times out. Partial sends are possible on timeout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data (&gt; 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout, -1 = block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent on success (may be &lt; len on timeout)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for same socket with proper synchronization</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md432"></a>
Return Values</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Return   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">len   </td><td class="markdownTableBodyNone">All data sent successfully    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0 &lt; n &lt; len   </td><td class="markdownTableBodyNone">Partial send (timeout expired)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-1   </td><td class="markdownTableBodyNone">Error (exception raised)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md433"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Send with 5 second timeout</span></div>
<div class="line">ssize_t sent = <a class="code hl_function" href="group__core__io.html#gaea9384979b83066a7a6fa1418a5862d2">Socket_sendall_timeout</a>(sock, data, len, 5000);</div>
<div class="line"><span class="keywordflow">if</span> (sent &lt; (ssize_t)len) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Only sent %zd of %zu bytes (timeout)\n&quot;</span>, sent, len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gaea9384979b83066a7a6fa1418a5862d2"><div class="ttname"><a href="group__core__io.html#gaea9384979b83066a7a6fa1418a5862d2">Socket_sendall_timeout</a></div><div class="ttdeci">ssize_t Socket_sendall_timeout(Socket_T socket, const void *buf, size_t len, int timeout_ms)</div><div class="ttdoc">Send all data with timeout.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb" title="Send all data (handles partial sends).">Socket_sendall()</a> for blocking send </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for single send operation </dd></dl>

</div>
</div>
<a id="ga001e932180b059a805ca53a8edbeef15" name="ga001e932180b059a805ca53a8edbeef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga001e932180b059a805ca53a8edbeef15">&#9670;&#160;</a></span>Socket_sendfd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_sendfd </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd_to_pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a file descriptor over Unix domain socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket (AF_UNIX). </td></tr>
    <tr><td class="paramname">fd_to_pass</td><td>File descriptor to pass (must be &gt;= 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error, Socket_Closed on disconnect.</td></tr>
  </table>
  </dd>
</dl>
<p>Passes a single file descriptor to the peer process using SCM_RIGHTS. The receiving process gets a new fd referring to the same kernel object.</p>
<p>PLATFORM REQUIREMENTS:</p><ul>
<li>POSIX-compliant Unix domain socket (AF_UNIX)</li>
<li>NOT available on Windows</li>
</ul>
<p>SECURITY NOTES:</p><ul>
<li>Only works with connected Unix domain sockets</li>
<li>Receiving process should validate the fd type before use</li>
</ul>
<dl class="section user"><dt>Thread Safety\n Yes - uses thread-local error buffers for safe concurrent</dt><dd>operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad1236a73c0cac828b3079b74d1b0996d" title="Receive a file descriptor over Unix domain socket.">Socket_recvfd()</a> for receiving file descriptors. </dd>
<dd>
<a class="el" href="group__core__io.html#ga70c2f94b87d307842c7d11de0b6a2bce" title="Send multiple file descriptors.">Socket_sendfds()</a> for sending multiple descriptors. </dd></dl>

</div>
</div>
<a id="ga70c2f94b87d307842c7d11de0b6a2bce" name="ga70c2f94b87d307842c7d11de0b6a2bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c2f94b87d307842c7d11de0b6a2bce">&#9670;&#160;</a></span>Socket_sendfds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_sendfds </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send multiple file descriptors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected Unix domain socket (AF_UNIX). </td></tr>
    <tr><td class="paramname">fds</td><td>Array of file descriptors to pass (all must be &gt;= 0). </td></tr>
    <tr><td class="paramname">count</td><td>Number of descriptors (1 to SOCKET_MAX_FDS_PER_MSG). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success, 0 if would block (EAGAIN/EWOULDBLOCK). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error, Socket_Closed on disconnect.</td></tr>
  </table>
  </dd>
</dl>
<p>Passes multiple file descriptors atomically in a single message. All descriptors are either sent together or none are sent.</p>
<dl class="section user"><dt>Thread Safety\n Yes - uses thread-local error buffers for safe concurrent</dt><dd>operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab806cbdac1b78ff644c4f841151cf3a8" title="Receive multiple file descriptors.">Socket_recvfds()</a> for receiving multiple descriptors. </dd>
<dd>
<a class="el" href="group__core__io.html#ga001e932180b059a805ca53a8edbeef15" title="Send a file descriptor over Unix domain socket.">Socket_sendfd()</a> for sending single descriptor. </dd></dl>

</div>
</div>
<a id="gad1003c289820587894dbfcad9b567c43" name="gad1003c289820587894dbfcad9b567c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1003c289820587894dbfcad9b567c43">&#9670;&#160;</a></span>Socket_sendfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendfile </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-copy file-to-socket transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket to send to. </td></tr>
    <tr><td class="paramname">file_fd</td><td>File descriptor to read from (must be a regular file). </td></tr>
    <tr><td class="paramname">offset</td><td>File offset to start reading from (NULL for current position). </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to transfer (0 for entire file from offset). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes transferred (&gt; 0) or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6262f6ab4c927347abc0fb3c105a0575" title="Zero-copy file-to-socket transfer (handles partial transfers).">Socket_sendfileall()</a> for guaranteed complete transfer. </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for buffer-based sending. </dd></dl>

</div>
</div>
<a id="ga6262f6ab4c927347abc0fb3c105a0575" name="ga6262f6ab4c927347abc0fb3c105a0575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6262f6ab4c927347abc0fb3c105a0575">&#9670;&#160;</a></span>Socket_sendfileall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendfileall </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-copy file-to-socket transfer (handles partial transfers). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket to send to. </td></tr>
    <tr><td class="paramname">file_fd</td><td>File descriptor to read from (must be a regular file). </td></tr>
    <tr><td class="paramname">offset</td><td>File offset to start reading from (NULL for current position). </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to transfer (0 for entire file from offset). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes transferred (always equals count on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad1003c289820587894dbfcad9b567c43" title="Zero-copy file-to-socket transfer.">Socket_sendfile()</a> for partial transfer operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb" title="Send all data (handles partial sends).">Socket_sendall()</a> for buffer-based guaranteed sending. </dd></dl>

</div>
</div>
<a id="gaeb12f81392f3c1fb21255bf44521e20c" name="gaeb12f81392f3c1fb21255bf44521e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb12f81392f3c1fb21255bf44521e20c">&#9670;&#160;</a></span>Socket_sendmsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendmsg </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send message with ancillary data (sendmsg wrapper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">msg</td><td>Message structure with data, address, and ancillary data. </td></tr>
    <tr><td class="paramname">flags</td><td>Message flags (MSG_NOSIGNAL, MSG_DONTWAIT, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent (&gt; 0) or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga92c972ba69ef189d5d802e4d1889a9c6" title="Receive message with ancillary data (recvmsg wrapper).">Socket_recvmsg()</a> for receiving messages with ancillary data. </dd>
<dd>
<a class="el" href="group__core__io.html#ga001e932180b059a805ca53a8edbeef15" title="Send a file descriptor over Unix domain socket.">Socket_sendfd()</a> for sending file descriptors. </dd></dl>

</div>
</div>
<a id="gadb50371f84b2c796c4e57a34d41f180a" name="gadb50371f84b2c796c4e57a34d41f180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb50371f84b2c796c4e57a34d41f180a">&#9670;&#160;</a></span>Socket_sendv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendv </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather send (writev wrapper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt; 0, &lt;= IOV_MAX). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent (&gt; 0) or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf6d033a04d5041249950fa2f54a8d9fd" title="Scatter/gather send all (handles partial sends).">Socket_sendvall()</a> for guaranteed complete scatter/gather send. </dd>
<dd>
<a class="el" href="group__core__io.html#gabb1c8e39587d4ea5e3ffe4b06dcaca0f" title="Scatter/gather receive (readv wrapper).">Socket_recvv()</a> for scatter/gather receive. </dd></dl>

</div>
</div>
<a id="ga714a501a951663d0248972ef6cc75818" name="ga714a501a951663d0248972ef6cc75818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga714a501a951663d0248972ef6cc75818">&#9670;&#160;</a></span>socket_sendv_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t socket_sendv_internal </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal scatter/gather send (TLS-aware) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramname">flags</td><td>Send flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes sent from iov buffers, or 0 if would block. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on underlying socket or vectored I/O errors. </td></tr>
    <tr><td class="paramname">SocketTLS_Failed</td><td>on TLS write failures or buffer allocation issues (#if SOCKET_HAS_TLS). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For TLS: Copies iov to temp buffer, calls SSL_write(). </dd>
<dd>
For non-TLS: Uses writev() directly. </dd>
<dd>
Allocates temp buffer via socket-&gt;arena if needed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a" title="Scatter/gather send (writev wrapper).">Socket_sendv()</a> for public vectored send interface. </dd>
<dd>
<a class="el" href="group__core__io.html#gad65971e86ea8dcbaa79e4e457612d3a6" title="Internal send operation (TLS-aware)">socket_send_internal()</a> for simple buffer send. </dd>
<dd>
<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> for memory allocation details. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e">SocketTLS_Failed</a> for TLS errors. </dd></dl>

</div>
</div>
<a id="ga7224aed85b1b920cc62fea881ae6f056" name="ga7224aed85b1b920cc62fea881ae6f056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7224aed85b1b920cc62fea881ae6f056">&#9670;&#160;</a></span>Socket_sendv_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendv_timeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather send with timeout. </p>
<p>Like <a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a" title="Scatter/gather send (writev wrapper).">Socket_sendv()</a> but with a timeout. May perform partial sends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket</td><td>Connected socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iov</td><td>Array of iovec structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = no timeout, -1 = block)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent (&gt; 0), 0 if would block/timeout, or raises</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for same socket with proper synchronization</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf6d033a04d5041249950fa2f54a8d9fd" title="Scatter/gather send all (handles partial sends).">Socket_sendvall()</a> for guaranteed complete send (no timeout) </dd>
<dd>
<a class="el" href="group__core__io.html#gace4c3a8cc81d7b66ebc2cc84bce51e8e" title="Scatter/gather receive with timeout.">Socket_recvv_timeout()</a> for scatter/gather receive with timeout </dd></dl>

</div>
</div>
<a id="gaf6d033a04d5041249950fa2f54a8d9fd" name="gaf6d033a04d5041249950fa2f54a8d9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d033a04d5041249950fa2f54a8d9fd">&#9670;&#160;</a></span>Socket_sendvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendvall </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter/gather send all (handles partial sends). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt; 0, &lt;= IOV_MAX). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes sent (always equals sum of all iov_len on success). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on EPIPE/ECONNRESET, Socket_Failed on other errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gadb50371f84b2c796c4e57a34d41f180a" title="Scatter/gather send (writev wrapper).">Socket_sendv()</a> for partial scatter/gather send. </dd>
<dd>
<a class="el" href="group__core__io.html#ga3472c67c78cd29944a87783e09247f9a" title="Scatter/gather receive all (handles partial receives).">Socket_recvvall()</a> for receiving all scatter/gather data. </dd></dl>

</div>
</div>
<a id="gacab565f9a6e6c40c56d6d21df89b30a9" name="gacab565f9a6e6c40c56d6d21df89b30a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacab565f9a6e6c40c56d6d21df89b30a9">&#9670;&#160;</a></span>Socket_setbandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setbandwidth </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_per_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set bandwidth limit for socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">bytes_per_sec</td><td>Maximum bytes per second (0 to disable limiting). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - uses internal mutex for synchronization.</dt><dd></dd></dl>
<p>Enables bandwidth throttling using a token bucket algorithm. The burst capacity is set to bytes_per_sec (1 second of data). Use <a class="el" href="group__core__io.html#ga274b6782b2029d2d8aa33579ad60a4c1" title="Send data with bandwidth limiting.">Socket_send_limited()</a> for rate-limited sending.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gae49a9ad4c524354506bef71ec6cffdf9" title="Get bandwidth limit for socket.">Socket_getbandwidth()</a> for retrieving current limit. </dd>
<dd>
<a class="el" href="group__core__io.html#ga274b6782b2029d2d8aa33579ad60a4c1" title="Send data with bandwidth limiting.">Socket_send_limited()</a> for rate-limited operations. </dd></dl>

</div>
</div>
<a id="ga18ad1f92bb3233c463ea4067b69f73c2" name="ga18ad1f92bb3233c463ea4067b69f73c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ad1f92bb3233c463ea4067b69f73c2">&#9670;&#160;</a></span>Socket_setcloexec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setcloexec </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control close-on-exec flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable CLOEXEC, 0 to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>By default, sockets have CLOEXEC enabled. </dd></dl>

</div>
</div>
<a id="gae144a341a05e25011d95761368eefe13" name="gae144a341a05e25011d95761368eefe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae144a341a05e25011d95761368eefe13">&#9670;&#160;</a></span>Socket_setcongestion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setcongestion </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set TCP congestion control algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">algorithm</td><td>Algorithm name (e.g., "cubic", "reno", "bbr"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error or if not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available on Linux 2.6.13+. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaebaf7f944985462e9198998a650f2b5c" title="Get TCP congestion control algorithm.">Socket_getcongestion()</a> for retrieving current algorithm. </dd></dl>

</div>
</div>
<a id="gab5b9e684faf1a8d5c1ccb9e231ef1354" name="gab5b9e684faf1a8d5c1ccb9e231ef1354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b9e684faf1a8d5c1ccb9e231ef1354">&#9670;&#160;</a></span>Socket_setdeferaccept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setdeferaccept </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable TCP_DEFER_ACCEPT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Listening socket. </td></tr>
    <tr><td class="paramname">timeout_sec</td><td>Seconds to wait for data before completing accept (0 to disable, max platform-specific).</td></tr>
  </table>
  </dd>
</dl>
<p>Delays accept() completion until client sends data, preventing</p>
<p>SYN-only connections from consuming application resources. This is a key defense against SYN flood attacks.</p>
<p>Linux: Uses TCP_DEFER_ACCEPT socket option BSD/macOS: Uses SO_ACCEPTFILTER with "dataready" filter</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error or if unsupported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga80f9fc5782bf3caf5228e458d3f3c112" title="Get TCP_DEFER_ACCEPT timeout.">Socket_getdeferaccept()</a> for retrieving current setting. </dd>
<dd>
<a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for accepting connections. </dd></dl>

</div>
</div>
<a id="gaa7c1651e6f9e3e97ddab01d40ac1d39d" name="gaa7c1651e6f9e3e97ddab01d40ac1d39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c1651e6f9e3e97ddab01d40ac1d39d">&#9670;&#160;</a></span>Socket_setfastopen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setfastopen </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable TCP Fast Open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable, 0 to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error or if not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga762ad6759e76f58f5a8f1fcb305387a8" title="Get TCP Fast Open setting.">Socket_getfastopen()</a> for retrieving Fast Open setting. </dd></dl>

</div>
</div>
<a id="gaf03ef2a81d1894713aeb96c12bb2389b" name="gaf03ef2a81d1894713aeb96c12bb2389b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf03ef2a81d1894713aeb96c12bb2389b">&#9670;&#160;</a></span>Socket_setkeepalive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setkeepalive </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable TCP keepalive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">idle</td><td>Seconds before sending keepalive probes. </td></tr>
    <tr><td class="paramname">interval</td><td>Interval between keepalive probes. </td></tr>
    <tr><td class="paramname">count</td><td>Number of probes before declaring dead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacd2f2e66892b062079f4c0a1dd7f8bac" title="Get TCP keepalive configuration.">Socket_getkeepalive()</a> for retrieving keepalive settings. </dd></dl>

</div>
</div>
<a id="ga55174d7f9aca0e94d25321540646e6b0" name="ga55174d7f9aca0e94d25321540646e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55174d7f9aca0e94d25321540646e6b0">&#9670;&#160;</a></span>Socket_setnodelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setnodelay </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable Nagle's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">nodelay</td><td>1 to disable Nagle, 0 to enable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga01aa484c370addf3f117cfdb4f9adb8a" title="Get TCP_NODELAY setting.">Socket_getnodelay()</a> for retrieving Nagle setting. </dd></dl>

</div>
</div>
<a id="ga35309677a1760480783d5f0c294d0db4" name="ga35309677a1760480783d5f0c294d0db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35309677a1760480783d5f0c294d0db4">&#9670;&#160;</a></span>Socket_setnonblocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setnonblocking </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga32b67d95639513cd6a602f6175b48f15" title="Accept incoming connection.">Socket_accept()</a> for non-blocking accept behavior. </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for non-blocking send behavior. </dd></dl>

<p class="reference">Referenced by <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="gad59dc86a3f3728e75983daa0f5b34550" name="gad59dc86a3f3728e75983daa0f5b34550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59dc86a3f3728e75983daa0f5b34550">&#9670;&#160;</a></span>Socket_setrcvbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setrcvbuf </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set receive buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">size</td><td>Buffer size in bytes (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga73b2908934ed8757725da6e6d22ff60c" title="Get receive buffer size.">Socket_getrcvbuf()</a> for retrieving receive buffer size. </dd></dl>

</div>
</div>
<a id="ga2c6f352cec920859c71206898ed135fc" name="ga2c6f352cec920859c71206898ed135fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c6f352cec920859c71206898ed135fc">&#9670;&#160;</a></span>Socket_setreuseaddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setreuseaddr </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable address reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2126127d2fa85fb5de27587e0d41a466" title="Enable port reuse across sockets.">Socket_setreuseport()</a> for port reuse. </dd></dl>

<p class="reference">Referenced by <a class="el" href="tcp__echo__server_8c_source.html#l00039">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga2126127d2fa85fb5de27587e0d41a466" name="ga2126127d2fa85fb5de27587e0d41a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2126127d2fa85fb5de27587e0d41a466">&#9670;&#160;</a></span>Socket_setreuseport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setreuseport </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable port reuse across sockets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error (or if SO_REUSEPORT unsupported). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga2c6f352cec920859c71206898ed135fc" title="Enable address reuse.">Socket_setreuseaddr()</a> for address reuse. </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> for binding operations. </dd></dl>

</div>
</div>
<a id="ga430b3464f6e656f4d8884031deffa507" name="ga430b3464f6e656f4d8884031deffa507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga430b3464f6e656f4d8884031deffa507">&#9670;&#160;</a></span>Socket_setsndbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setsndbuf </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set send buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">size</td><td>Buffer size in bytes (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga23a3e2bbff42609e2e4089d5e6c55bbd" title="Get send buffer size.">Socket_getsndbuf()</a> for retrieving send buffer size. </dd></dl>

</div>
</div>
<a id="ga210cbf763685c0b201b0f5caa2dc0f06" name="ga210cbf763685c0b201b0f5caa2dc0f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga210cbf763685c0b201b0f5caa2dc0f06">&#9670;&#160;</a></span>Socket_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_settimeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set socket timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">timeout_sec</td><td>Timeout in seconds (0 to disable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Sets both send and receive timeouts. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaa40c1cdc37abfc34cbc17cdcbf607241" title="Get socket timeout.">Socket_gettimeout()</a> for retrieving current timeout. </dd></dl>

</div>
</div>
<a id="gabfad0f5567b5f8720a4667e13e79f282" name="gabfad0f5567b5f8720a4667e13e79f282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfad0f5567b5f8720a4667e13e79f282">&#9670;&#160;</a></span>Socket_setusertimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setusertimeout </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set TCP user timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (&gt; 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error or if not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available on Linux 2.6.37+. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga2b81fe340e400d96d2552a65cfde5430" title="Get TCP user timeout.">Socket_getusertimeout()</a> for retrieving user timeout. </dd></dl>

</div>
</div>
<a id="ga559b1aaebbe5d0ca69ec99e15b1c7e68" name="ga559b1aaebbe5d0ca69ec99e15b1c7e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559b1aaebbe5d0ca69ec99e15b1c7e68">&#9670;&#160;</a></span>Socket_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_shutdown </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable further sends and/or receives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Connected socket. </td></tr>
    <tr><td class="paramname">how</td><td>Shutdown mode (SHUT_RD, SHUT_WR, or SHUT_RDWR). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Socket_close() for full connection teardown. </dd></dl>

<p class="reference">Referenced by <a class="el" href="tcp__echo__client_8c_source.html#l00025">main()</a>.</p>

</div>
</div>
<a id="ga06c26a5a5989a15050513a8a3721f7ea" name="ga06c26a5a5989a15050513a8a3721f7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c26a5a5989a15050513a8a3721f7ea">&#9670;&#160;</a></span>Socket_splice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_splice </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-copy socket-to-socket transfer (Linux splice). </p>
<p>Transfers data between two sockets using the kernel's splice() system call, avoiding copies between kernel and user space. Significantly more efficient for proxying and data forwarding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">socket_in</td><td>Source socket to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socket_out</td><td>Destination socket to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum bytes to transfer (0 for default chunk size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bytes transferred (&gt; 0), 0 if would block, -1 if not supported</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Closed</td><td>on connection closed </td></tr>
    <tr><td class="paramname">Socket_Failed</td><td>on other errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - for distinct socket pairs</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md435"></a>
Platform Support</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Platform   </th><th class="markdownTableHeadNone">Support    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linux 2.6.17+   </td><td class="markdownTableBodyNone">Full (via splice())    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Other   </td><td class="markdownTableBodyNone">Returns -1 (use Socket_recv/Socket_send fallback)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md436"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Proxy data from client to upstream</span></div>
<div class="line"><span class="keywordflow">while</span> ((n = <a class="code hl_function" href="group__core__io.html#ga06c26a5a5989a15050513a8a3721f7ea">Socket_splice</a>(client, upstream, 0)) &gt; 0) {</div>
<div class="line">    total += n;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (n == 0) {</div>
<div class="line">    <span class="comment">// Would block - use poll</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; 0) {</div>
<div class="line">    <span class="comment">// Not supported - fallback to recv/send</span></div>
<div class="line">    <span class="keywordtype">char</span> buf[4096];</div>
<div class="line">    <span class="keywordflow">while</span> ((n = <a class="code hl_function" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9">Socket_recv</a>(client, buf, <span class="keyword">sizeof</span>(buf))) &gt; 0) {</div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga6ea9ad33d78c50d327c9677b52849bcb">Socket_sendall</a>(upstream, buf, n);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga06c26a5a5989a15050513a8a3721f7ea"><div class="ttname"><a href="group__core__io.html#ga06c26a5a5989a15050513a8a3721f7ea">Socket_splice</a></div><div class="ttdeci">ssize_t Socket_splice(Socket_T socket_in, Socket_T socket_out, size_t len)</div><div class="ttdoc">Zero-copy socket-to-socket transfer (Linux splice).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Requires both sockets to be in compatible state </dd>
<dd>
For file-to-socket, use <a class="el" href="group__core__io.html#gad1003c289820587894dbfcad9b567c43" title="Zero-copy file-to-socket transfer.">Socket_sendfile()</a> instead</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad1003c289820587894dbfcad9b567c43" title="Zero-copy file-to-socket transfer.">Socket_sendfile()</a> for file-to-socket zero-copy </dd></dl>

</div>
</div>
<a id="ga5fa0449e34ebfb141da236023da3edb7" name="ga5fa0449e34ebfb141da236023da3edb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa0449e34ebfb141da236023da3edb7">&#9670;&#160;</a></span>Socket_timeouts_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_get </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve per-socket timeout configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance. </td></tr>
    <tr><td class="paramname">timeouts</td><td>Output timeout structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f" title="Set per-socket timeout configuration.">Socket_timeouts_set()</a> for setting timeouts. </dd>
<dd>
<a class="el" href="group__core__io.html#gacfcc79428e54b0284cc7cad257d56adf" title="Get global default timeouts.">Socket_timeouts_getdefaults()</a> for global defaults. </dd></dl>

</div>
</div>
<a id="ga4affc77e30721f266acfc9ba7870dff5" name="ga4affc77e30721f266acfc9ba7870dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4affc77e30721f266acfc9ba7870dff5">&#9670;&#160;</a></span>Socket_timeouts_get_extended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_get_extended </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structSocketTimeouts__Extended__T">SocketTimeouts_Extended_T</a> *&#160;</td>
          <td class="paramname"><em>extended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve per-socket extended timeout configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to query. </td></tr>
    <tr><td class="paramname">extended</td><td>Output structure for extended timeouts.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the current extended timeout configuration. If extended timeouts haven't been set, returns the basic timeouts mapped to the extended structure.</p>
<dl class="section user"><dt>Thread Safety\n No - caller must ensure exclusive access to socket.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad663873fbc8f0846c092a380f64b1f52" title="Set per-socket extended timeout configuration.">Socket_timeouts_set_extended()</a> for setting extended timeouts. </dd></dl>

</div>
</div>
<a id="gacfcc79428e54b0284cc7cad257d56adf" name="gacfcc79428e54b0284cc7cad257d56adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfcc79428e54b0284cc7cad257d56adf">&#9670;&#160;</a></span>Socket_timeouts_getdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_getdefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get global default timeouts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeouts</td><td>Output timeout structure containing current defaults. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga0385e87c51740c37c9d90ff5bba1eced" title="Set global default timeouts.">Socket_timeouts_setdefaults()</a> for changing defaults. </dd>
<dd>
<a class="el" href="group__core__io.html#ga5fa0449e34ebfb141da236023da3edb7" title="Retrieve per-socket timeout configuration.">Socket_timeouts_get()</a> for per-socket timeouts. </dd></dl>

</div>
</div>
<a id="ga3e3b95a49618f5a56869606adeeda58f" name="ga3e3b95a49618f5a56869606adeeda58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e3b95a49618f5a56869606adeeda58f">&#9670;&#160;</a></span>Socket_timeouts_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_set </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set per-socket timeout configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance. </td></tr>
    <tr><td class="paramname">timeouts</td><td>Timeout configuration (NULL to reset to defaults). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga5fa0449e34ebfb141da236023da3edb7" title="Retrieve per-socket timeout configuration.">Socket_timeouts_get()</a> for retrieving timeouts. </dd>
<dd>
<a class="el" href="group__core__io.html#ga0385e87c51740c37c9d90ff5bba1eced" title="Set global default timeouts.">Socket_timeouts_setdefaults()</a> for changing global defaults. </dd></dl>

</div>
</div>
<a id="gad663873fbc8f0846c092a380f64b1f52" name="gad663873fbc8f0846c092a380f64b1f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad663873fbc8f0846c092a380f64b1f52">&#9670;&#160;</a></span>Socket_timeouts_set_extended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_set_extended </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#structSocketTimeouts__Extended__T">SocketTimeouts_Extended_T</a> *&#160;</td>
          <td class="paramname"><em>extended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set per-socket extended timeout configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket to modify. </td></tr>
    <tr><td class="paramname">extended</td><td>Extended per-phase timeout configuration.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets granular per-phase timeouts for advanced use cases. The extended timeouts provide finer control than <a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a>, allowing different timeouts for DNS, connect, TLS, and request phases.</p>
<p>Values of 0 in the extended structure mean "inherit from basic timeouts". Values of -1 mean "no timeout (infinite)".</p>
<dl class="section user"><dt>Thread Safety\n No - caller must ensure exclusive access to socket.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4affc77e30721f266acfc9ba7870dff5" title="Retrieve per-socket extended timeout configuration.">Socket_timeouts_get_extended()</a> for retrieving extended timeouts. </dd>
<dd>
<a class="el" href="group__foundation.html#structSocketTimeouts__Extended__T" title="Extended per-phase timeout configuration structure.">SocketTimeouts_Extended_T</a> for timeout structure details. </dd></dl>

</div>
</div>
<a id="ga0385e87c51740c37c9d90ff5bba1eced" name="ga0385e87c51740c37c9d90ff5bba1eced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0385e87c51740c37c9d90ff5bba1eced">&#9670;&#160;</a></span>Socket_timeouts_setdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_setdefaults </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global default timeouts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeouts</td><td>New default timeout configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacfcc79428e54b0284cc7cad257d56adf" title="Get global default timeouts.">Socket_timeouts_getdefaults()</a> for retrieving defaults. </dd>
<dd>
<a class="el" href="group__core__io.html#ga3e3b95a49618f5a56869606adeeda58f" title="Set per-socket timeout configuration.">Socket_timeouts_set()</a> for per-socket overrides. </dd></dl>

</div>
</div>
<a id="ga665b41107ebf850f631386135fa58791" name="ga665b41107ebf850f631386135fa58791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665b41107ebf850f631386135fa58791">&#9670;&#160;</a></span>socket_tls_want_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_tls_want_read </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if TLS wants to read more data for handshake or protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>TLS-enabled socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if TLS needs more input data, 0 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used in event loops to determine if POLL_READ should be enabled for TLS sockets. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only access to TLS state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__security.html#gaeaa77dd7852b535baf17b53ee2518454" title="Perform non-blocking TLS handshake.">SocketTLS_handshake()</a> for performing TLS handshake. </dd>
<dd>
<a class="el" href="group__core__io.html#gae7a7fe487c65b17fdea95a118bc98a97" title="Check if TLS wants to write more data for handshake or protocol.">socket_tls_want_write()</a> for write readiness. </dd>
<dd>
<a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> for event system integration. </dd>
<dd>
group__security for TLS details. </dd></dl>

</div>
</div>
<a id="gae7a7fe487c65b17fdea95a118bc98a97" name="gae7a7fe487c65b17fdea95a118bc98a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a7fe487c65b17fdea95a118bc98a97">&#9670;&#160;</a></span>socket_tls_want_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socket_tls_want_write </td>
          <td>(</td>
          <td class="paramtype">const Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if TLS wants to write more data for handshake or protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>TLS-enabled socket to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if TLS needs to output data, 0 otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used in event loops to determine if POLL_WRITE should be enabled for TLS sockets. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only access to TLS state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__security.html#gaeaa77dd7852b535baf17b53ee2518454" title="Perform non-blocking TLS handshake.">SocketTLS_handshake()</a> for performing TLS handshake. </dd>
<dd>
<a class="el" href="group__core__io.html#ga665b41107ebf850f631386135fa58791" title="Check if TLS wants to read more data for handshake or protocol.">socket_tls_want_read()</a> for read readiness. </dd>
<dd>
<a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a> for event system integration. </dd>
<dd>
group__security for TLS details. </dd></dl>

</div>
</div>
<a id="ga10ddc2a7b61b559013a79f7d1297d409" name="ga10ddc2a7b61b559013a79f7d1297d409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ddc2a7b61b559013a79f7d1297d409">&#9670;&#160;</a></span>socket_validate_tls_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SSL * socket_validate_tls_ready </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate TLS is ready for I/O. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Socket instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SSL* pointer if TLS is fully ready for I/O operations. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>if socket is invalid or TLS not enabled. </td></tr>
    <tr><td class="paramname">SocketTLS_HandshakeFailed</td><td>if TLS handshake is not complete or failed (#if SOCKET_HAS_TLS). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates on single socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Shared helper for TLS I/O functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad65971e86ea8dcbaa79e4e457612d3a6" title="Internal send operation (TLS-aware)">socket_send_internal()</a> and similar for TLS readiness check. </dd>
<dd>
<a class="el" href="group__security.html#gaeaa77dd7852b535baf17b53ee2518454" title="Perform non-blocking TLS handshake.">SocketTLS_handshake()</a> if manual handshake needed. </dd>
<dd>
<a class="el" href="group__security.html#gabc011202dd4f2e080b6ea8eb0f24287e">SocketTLS_Failed</a> or <a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a> on error. </dd></dl>

</div>
</div>
<a id="gae819168ebf1a49f132758d251e14958c" name="gae819168ebf1a49f132758d251e14958c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae819168ebf1a49f132758d251e14958c">&#9670;&#160;</a></span>SocketBase_arena()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> SocketBase_arena </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the memory arena associated with the socket base. </p>
<p>Returns the per-socket Arena_T used for all allocations related to this socket instance, ensuring consistent lifecycle management and avoiding leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Socket base instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Arena_T used for this socket's allocations</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if no concurrent arena modification</dt><dd>(typically read-only) </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct field return</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__core__io.html#gae819168ebf1a49f132758d251e14958c">SocketBase_arena</a>(base);</div>
<div class="line"><span class="keywordtype">char</span> *endpoint = <a class="code hl_define" href="group__foundation.html#ga7897b95c53808a539b0f7a18587a9b54">ALLOC</a>(arena, strlen(host) + 1);</div>
<div class="line">strcpy(endpoint, host);  <span class="comment">// Arena-managed allocation</span></div>
<div class="ttc" id="agroup__core__io_html_gae819168ebf1a49f132758d251e14958c"><div class="ttname"><a href="group__core__io.html#gae819168ebf1a49f132758d251e14958c">SocketBase_arena</a></div><div class="ttdeci">Arena_T SocketBase_arena(SocketBase_T base)</div><div class="ttdoc">Get the memory arena associated with the socket base.</div></div>
<div class="ttc" id="agroup__foundation_html_ga7897b95c53808a539b0f7a18587a9b54"><div class="ttname"><a href="group__foundation.html#ga7897b95c53808a539b0f7a18587a9b54">ALLOC</a></div><div class="ttdeci">#define ALLOC(arena, nbytes)</div><div class="ttdoc">Convenience macro for Arena_alloc with automatic source location tracking.</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00502">Arena.h:502</a></div></div>
<div class="ttc" id="agroup__foundation_html_gac1ed22b9df4eff7a3398cac608c090cc"><div class="ttname"><a href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a></div><div class="ttdeci">struct Arena_T * Arena_T</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00080">Arena.h:80</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All socket-related allocations (buffers, endpoint strings) should use this arena. </dd>
<dd>
Arena lifetime tied to socket base; dispose via <a class="el" href="group__core__io.html#gaaeb641ee1edaa618b8680babae9a98c6" title="Free a socket base structure.">SocketCommon_free_base()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Arena_8h.html" title="Arena-based memory allocator for efficient bulk memory management.">core/Arena.h</a> for arena API and <a class="el" href="group__foundation.html#ga7897b95c53808a539b0f7a18587a9b54" title="Convenience macro for Arena_alloc with automatic source location tracking.">ALLOC()</a>/CALLOC() macros </dd>
<dd>
<a class="el" href="group__foundation.html">Foundation Module Group</a> for memory management details </dd>
<dd>
<a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> for arena role in resource management </dd></dl>

</div>
</div>
<a id="gaa16683bd3c975d0bc23a0ebf7df57767" name="gaa16683bd3c975d0bc23a0ebf7df57767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16683bd3c975d0bc23a0ebf7df57767">&#9670;&#160;</a></span>SocketBase_domain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBase_domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address domain (family) of the socket. </p>
<p>Returns the address family used when creating the socket, determining supported address types (IPv4, IPv6, Unix domain).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Socket base instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Domain constant (AF_INET, AF_INET6, AF_UNIX, etc.)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - immutable after creation, no lock needed</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct field access</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Set during socket creation; immutable throughout lifetime. </dd>
<dd>
Used internally for address validation, option setting, resolution hints.</dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> domain = <a class="code hl_function" href="group__core__io.html#gaa16683bd3c975d0bc23a0ebf7df57767">SocketBase_domain</a>(base);</div>
<div class="line"><span class="keywordflow">if</span> (domain == AF_INET) {</div>
<div class="line">    <span class="comment">// IPv4-specific handling</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (domain == AF_INET6) {</div>
<div class="line">    <span class="comment">// IPv6-specific handling</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gaa16683bd3c975d0bc23a0ebf7df57767"><div class="ttname"><a href="group__core__io.html#gaa16683bd3c975d0bc23a0ebf7df57767">SocketBase_domain</a></div><div class="ttdeci">int SocketBase_domain(SocketBase_T base)</div><div class="ttdoc">Get the address domain (family) of the socket.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>getaddrinfo(3) for address resolution using domain </dd>
<dd>
AF_* constants in &lt;sys/socket.h&gt; </dd>
<dd>
<a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> in <a class="el" href="SocketCommon_8h.html" title="Common utilities shared between Socket and SocketDgram modules.">SocketCommon.h</a> for domain-aware resolution </dd></dl>

</div>
</div>
<a id="ga7094c29ef2257e271eb2e6be911dd2ab" name="ga7094c29ef2257e271eb2e6be911dd2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7094c29ef2257e271eb2e6be911dd2ab">&#9670;&#160;</a></span>SocketBase_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBase_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the socket file descriptor from the base structure. </p>
<p>Provides access to the underlying file descriptor for low-level system calls like poll(2), epoll_ctl(2), or direct read/write operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Socket base instance (non-NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File descriptor (int fd, -1 if closed/invalid)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if no concurrent modification to base (fd</dt><dd>typically read-only after init) </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct field access</dt><dd></dd></dl>
<p>Usage</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__core__io.html#ga7094c29ef2257e271eb2e6be911dd2ab">SocketBase_fd</a>(base);</div>
<div class="line"><span class="keywordflow">if</span> (fd &gt;= 0) {</div>
<div class="line">    <span class="comment">// Use fd for poll or epoll</span></div>
<div class="line">    <span class="keyword">struct </span>pollfd pfd = { .fd = fd, .events = POLLIN };</div>
<div class="line">    poll(&amp;pfd, 1, timeout);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga7094c29ef2257e271eb2e6be911dd2ab"><div class="ttname"><a href="group__core__io.html#ga7094c29ef2257e271eb2e6be911dd2ab">SocketBase_fd</a></div><div class="ttdeci">int SocketBase_fd(SocketBase_T base)</div><div class="ttdoc">Retrieve the socket file descriptor from the base structure.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Direct fd access bypasses library wrappers; prefer high-level Socket_* functions. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>fd is owned by base; do NOT close(2) directly - use <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>socket(2), close(2) </dd>
<dd>
<a class="el" href="SocketCommon_8h.html" title="Common utilities shared between Socket and SocketDgram modules.">SocketCommon.h</a> for public API equivalents like <a class="el" href="group__core__io.html#ga4d727948c677509eec04746585819877" title="Get underlying file descriptor.">Socket_fd()</a> </dd></dl>

</div>
</div>
<a id="gad581bb396e7b4577cafb85f46586c307" name="gad581bb396e7b4577cafb85f46586c307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad581bb396e7b4577cafb85f46586c307">&#9670;&#160;</a></span>SocketBase_remoteaddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char * SocketBase_remoteaddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get cached remote address string representation. </p>
<p>Returns the pre-cached string representation of the remote peer's address, formatted as numeric IP (IPv4/IPv6) or Unix domain path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Socket base instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to arena-allocated string, or NULL if unset, unconnected, or invalid</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Conditional - acquire base-&gt;mutex if concurrent modification to</dt><dd>endpoints possible </dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - direct pointer return</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *remote_ip = <a class="code hl_function" href="group__core__io.html#gad581bb396e7b4577cafb85f46586c307">SocketBase_remoteaddr</a>(base);</div>
<div class="line"><span class="keywordflow">if</span> (remote_ip) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Connected to %s&quot;</span>, remote_ip);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;No remote address available&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aSocketUtil_8h_html_a9fe70c7ab8b971af2971f3a102b82819"><div class="ttname"><a href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_INFO_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00540">SocketUtil.h:540</a></div></div>
<div class="ttc" id="aSocketUtil_8h_html_ae560ccd4aef66d44e8ecbd256844059c"><div class="ttname"><a href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_WARN_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00544">SocketUtil.h:544</a></div></div>
<div class="ttc" id="agroup__core__io_html_gad581bb396e7b4577cafb85f46586c307"><div class="ttname"><a href="group__core__io.html#gad581bb396e7b4577cafb85f46586c307">SocketBase_remoteaddr</a></div><div class="ttdeci">static char * SocketBase_remoteaddr(SocketBase_T base)</div><div class="ttdoc">Get cached remote address string representation.</div><div class="ttdef"><b>Definition</b> <a href="SocketCommon-private_8h_source.html#l00328">SocketCommon-private.h:328</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>String allocated in base.arena; valid until base disposal or recaching. </dd>
<dd>
Cached via <a class="el" href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4" title="Extract and cache human-readable numeric address and port from sockaddr structure.">SocketCommon_cache_endpoint()</a> after connect/accept. </dd>
<dd>
Format: "192.168.1.1" (IPv4), "[::1]" (IPv6), "/tmp/socket" (Unix) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not free() the returned string - managed by arena.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga61536a3bd580b6f1321a38fa7098387c" title="Get remote peer port number.">SocketBase_remoteport()</a> for companion port getter </dd>
<dd>
<a class="el" href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4" title="Extract and cache human-readable numeric address and port from sockaddr structure.">SocketCommon_cache_endpoint()</a> for caching mechanism details </dd>
<dd>
<a class="el" href="group__core__io.html#gab0957f43694d0728e70b23364a89623c" title="Get peer IP address.">Socket_getpeeraddr()</a> public wrapper in <a class="el" href="Socket_8h.html" title="High-level TCP/IP and Unix domain socket interface.">Socket.h</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon-private_8h_source.html#l00328">328</a> of file <a class="el" href="SocketCommon-private_8h_source.html">SocketCommon-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon-private_8h_source.html#l00160">SocketBase_T::remoteaddr</a>.</p>

</div>
</div>
<a id="ga61536a3bd580b6f1321a38fa7098387c" name="ga61536a3bd580b6f1321a38fa7098387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61536a3bd580b6f1321a38fa7098387c">&#9670;&#160;</a></span>SocketBase_remoteport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketBase_remoteport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remote peer port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Remote port (0 if unknown/unconnected). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - acquire base-&gt;mutex if concurrent access possible.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad581bb396e7b4577cafb85f46586c307" title="Get cached remote address string representation.">SocketBase_remoteaddr()</a> </dd>
<dd>
<a class="el" href="group__core__io.html#ga38d7e5845519867261a9f24dfe0e03db" title="Get peer port number.">Socket_getpeerport()</a> public wrapper. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon-private_8h_source.html#l00344">344</a> of file <a class="el" href="SocketCommon-private_8h_source.html">SocketCommon-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon-private_8h_source.html#l00162">SocketBase_T::remoteport</a>.</p>

</div>
</div>
<a id="ga65d501b6ffc63a265a180b903abb26ef" name="ga65d501b6ffc63a265a180b903abb26ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d501b6ffc63a265a180b903abb26ef">&#9670;&#160;</a></span>SocketBase_set_timeouts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBase_set_timeouts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set timeouts configuration in the socket base structure. </p>
<p>Copies timeout values from source to base.timeouts, applying to subsequent operations like connect(), send/recv, DNS resolution. NULL source uses global defaults. Safe no-op if base or source NULL.</p>
<p>Timeout Structure (<a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a>)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Purpose   </th><th class="markdownTableHeadNone">Default    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">connect_ms   </td><td class="markdownTableBodyNone"><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> establishment   </td><td class="markdownTableBodyNone">30000 ms    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">send_ms   </td><td class="markdownTableBodyNone">Send operations   </td><td class="markdownTableBodyNone">0 (no timeout)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">recv_ms   </td><td class="markdownTableBodyNone">Receive operations   </td><td class="markdownTableBodyNone">0 (no timeout)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dns_ms   </td><td class="markdownTableBodyNone">DNS resolution   </td><td class="markdownTableBodyNone">Global default   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Socket base instance to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeouts</td><td>Source configuration to copy (NULL = global defaults)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- defensive against NULL inputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - caller must lock base-&gt;mutex to prevent concurrent access</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - structure copy</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line">pthread_mutex_lock(&amp;base-&gt;mutex);</div>
<div class="line"><a class="code hl_struct" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> custom = { .connect_ms = 5000, .send_ms = 10000 };</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga65d501b6ffc63a265a180b903abb26ef">SocketBase_set_timeouts</a>(base, &amp;custom);</div>
<div class="line">pthread_mutex_unlock(&amp;base-&gt;mutex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or use defaults</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga65d501b6ffc63a265a180b903abb26ef">SocketBase_set_timeouts</a>(base, NULL);</div>
<div class="ttc" id="agroup__core__io_html_ga65d501b6ffc63a265a180b903abb26ef"><div class="ttname"><a href="group__core__io.html#ga65d501b6ffc63a265a180b903abb26ef">SocketBase_set_timeouts</a></div><div class="ttdeci">void SocketBase_set_timeouts(SocketBase_T base, const SocketTimeouts_T *timeouts)</div><div class="ttdoc">Set timeouts configuration in the socket base structure.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Copies values; source ownership unchanged. Updates apply immediately to new operations. </dd>
<dd>
Global defaults via <a class="el" href="group__core__io.html#gad2318fb3606f6a71c2a11e247ff876d5" title="Get global default timeouts.">SocketCommon_timeouts_getdefaults()</a>; modifiable via <a class="el" href="group__core__io.html#ga98a87ba229cdf264bec87129ce8918f5" title="Set global default timeouts.">SocketCommon_timeouts_setdefaults()</a>. </dd>
<dd>
For socket-level SO_SNDTIMEO/SO_RCVTIMEO, use <a class="el" href="SocketCommon-private_8h.html#a3ed109beae3f198d1714566573eb7366" title="Set socket-level timeout for I/O operations.">SocketCommon_settimeout()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Without mutex, race conditions may corrupt timeouts during concurrent sets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketCommon-private_8h.html#a75b80d3b0bff70285f02d3abec60cdcc" title="Get pointer to timeouts configuration structure.">SocketBase_timeouts()</a> for direct pointer access (lock required) </dd>
<dd>
<a class="el" href="group__core__io.html#gad2318fb3606f6a71c2a11e247ff876d5" title="Get global default timeouts.">SocketCommon_timeouts_getdefaults()</a> for copying global defaults </dd>
<dd>
<a class="el" href="group__core__io.html#ga98a87ba229cdf264bec87129ce8918f5" title="Set global default timeouts.">SocketCommon_timeouts_setdefaults()</a> for setting globals </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html#a3ed109beae3f198d1714566573eb7366" title="Set socket-level timeout for I/O operations.">SocketCommon_settimeout()</a> for low-level socket option timeouts </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">core/SocketConfig.h</a> for <a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a> definition </dd>
<dd>
docs/TIMEOUTS.md for timeout best practices </dd></dl>

</div>
</div>
<a id="ga4f350e096708c438bc2002909325b143" name="ga4f350e096708c438bc2002909325b143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f350e096708c438bc2002909325b143">&#9670;&#160;</a></span>SocketBuf_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_available </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the number of bytes available for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes currently stored in the buffer (0 if empty). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Constant time query; no side effects. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only query, safe concurrently.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> for available write space. </dd>
<dd>
<a class="el" href="group__core__io.html#ga886e91e5cdff04cbc06b2d99eb887808" title="Check if the buffer contains no data.">SocketBuf_empty()</a> for boolean emptiness check. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> or <a class="el" href="group__core__io.html#ga55cfa577b17ee4e2ea965a841deccab0" title="Peek at data without removing it from the buffer.">SocketBuf_peek()</a> to access data. </dd></dl>

</div>
</div>
<a id="ga884735923c2cf7dbe7def9d9062ac512" name="ga884735923c2cf7dbe7def9d9062ac512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884735923c2cf7dbe7def9d9062ac512">&#9670;&#160;</a></span>SocketBuf_check_invariants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SocketBuf_check_invariants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate internal buffer consistency without assertions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to validate (const, read-only access). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all invariants hold (e.g., pointers valid, no overflow), false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Intended for debugging, fuzzing, or production integrity checks. </dd>
<dd>
Does not modify buffer; suitable for periodic health checks. </dd>
<dd>
Performance: O(1) typically, may scan in debug modes. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - const inspection only.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> which internally validates invariants. </dd>
<dd>
<a class="el" href="group__utilities.html">Utilities</a> for metrics and monitoring integration. </dd></dl>

</div>
</div>
<a id="ga61b062261e8e954240edf8d3a6a01fb8" name="ga61b062261e8e954240edf8d3a6a01fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b062261e8e954240edf8d3a6a01fb8">&#9670;&#160;</a></span>SocketBuf_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset buffer to empty state without zeroing memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only updates read/write pointers; memory contents may remain until overwritten. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not suitable for sensitive data - use <a class="el" href="group__core__io.html#gaf0f12ab9bbed33398141c41561c1fcb7" title="Securely erase all data by zeroing memory contents.">SocketBuf_secureclear()</a> to prevent leakage. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(1) - no memory operations. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies buffer state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf0f12ab9bbed33398141c41561c1fcb7" title="Securely erase all data by zeroing memory contents.">SocketBuf_secureclear()</a> for zeroing sensitive data. </dd>
<dd>
<a class="el" href="group__core__io.html#gad11c3dede8563afbb1a3e9b9f4e936e6" title="Discard data from the front of the buffer without reading it.">SocketBuf_consume()</a> for partial discard. </dd>
<dd>
<a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97" title="Write data into the buffer.">SocketBuf_write()</a> to repopulate after clear. </dd>
<dd>
<a class="el" href="group__security.html">Security Modules</a> for <a class="el" href="group__security.html" title="Comprehensive security protections for network applications.">Security Modules</a> best practices with buffers. </dd></dl>

</div>
</div>
<a id="ga42d28ec4481d1f695ddda98a9cf069dc" name="ga42d28ec4481d1f695ddda98a9cf069dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d28ec4481d1f695ddda98a9cf069dc">&#9670;&#160;</a></span>SocketBuf_compact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_compact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move data to front of buffer, maximizing contiguous write space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to compact.</td></tr>
  </table>
  </dd>
</dl>
<p>Moves all readable data to the beginning of the buffer (head=0). This maximizes contiguous write space for zero-copy operations. Useful before large writes or when writeptr() returns less than space().</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n) where n = bytes in buffer (memmove). </dd>
<dd>
No-op if buffer is empty or already compacted. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies buffer internals.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md490"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> space;</div>
<div class="line"><span class="keywordtype">void</span> *ptr = <a class="code hl_function" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc">SocketBuf_writeptr</a>(buf, &amp;space);</div>
<div class="line"><span class="keywordflow">if</span> (space &lt; needed) {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga42d28ec4481d1f695ddda98a9cf069dc">SocketBuf_compact</a>(buf);  <span class="comment">// Make space contiguous</span></div>
<div class="line">    ptr = <a class="code hl_function" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc">SocketBuf_writeptr</a>(buf, &amp;space);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga0d845ceca49625b8c317310a757ad9dc"><div class="ttname"><a href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc">SocketBuf_writeptr</a></div><div class="ttdeci">void * SocketBuf_writeptr(SocketBuf_T buf, size_t *len)</div><div class="ttdoc">Obtain a direct pointer for zero-copy writing into the buffer.</div></div>
<div class="ttc" id="agroup__core__io_html_ga42d28ec4481d1f695ddda98a9cf069dc"><div class="ttname"><a href="group__core__io.html#ga42d28ec4481d1f695ddda98a9cf069dc">SocketBuf_compact</a></div><div class="ttdeci">void SocketBuf_compact(SocketBuf_T buf)</div><div class="ttdoc">Move data to front of buffer, maximizing contiguous write space.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc" title="Obtain a direct pointer for zero-copy writing into the buffer.">SocketBuf_writeptr()</a> for zero-copy writes. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> to check total available space. </dd></dl>

</div>
</div>
<a id="gad11c3dede8563afbb1a3e9b9f4e936e6" name="gad11c3dede8563afbb1a3e9b9f4e936e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11c3dede8563afbb1a3e9b9f4e936e6">&#9670;&#160;</a></span>SocketBuf_consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discard data from the front of the buffer without reading it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to modify. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to discard. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid or len &gt; available data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior undefined (assert in debug) if len &gt; SocketBuf_available(buf). </dd>
<dd>
Efficient for skipping known-length headers or invalid data. </dd>
<dd>
Performance: O(1) - only updates internal pointers. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies shared state; requires locking for concurrency.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143" title="Query the number of bytes available for reading.">SocketBuf_available()</a> to verify sufficient data before consuming. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for read-and-discard operation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga61b062261e8e954240edf8d3a6a01fb8" title="Reset buffer to empty state without zeroing memory.">SocketBuf_clear()</a> for discarding all data. </dd></dl>

</div>
</div>
<a id="ga886e91e5cdff04cbc06b2d99eb887808" name="ga886e91e5cdff04cbc06b2d99eb887808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga886e91e5cdff04cbc06b2d99eb887808">&#9670;&#160;</a></span>SocketBuf_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBuf_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer contains no data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero (true) if empty, zero (false) otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to SocketBuf_available(buf) == 0. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only query.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143" title="Query the number of bytes available for reading.">SocketBuf_available()</a> for exact count. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8ae7a3d2576f6d28c91511e10790e99a" title="Check if the buffer has no space for writing.">SocketBuf_full()</a> for full buffer check. </dd>
<dd>
<a class="el" href="group__core__io.html#ga61b062261e8e954240edf8d3a6a01fb8" title="Reset buffer to empty state without zeroing memory.">SocketBuf_clear()</a> to make buffer empty. </dd></dl>

</div>
</div>
<a id="ga474df61426f231015e3efbf1afd0687d" name="ga474df61426f231015e3efbf1afd0687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474df61426f231015e3efbf1afd0687d">&#9670;&#160;</a></span>SocketBuf_ensure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBuf_ensure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure minimum write space is available, resizing if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to ensure space in. </td></tr>
    <tr><td class="paramname">min_space</td><td>Minimum required write space in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if space is available, 0 on failure.</dd></dl>
<p>Combines compact and reserve operations. First attempts to compact (move data to front), then resizes if still insufficient.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if resize fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n) for compact or resize, O(1) if already sufficient. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - may modify buffer.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md491"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#ga474df61426f231015e3efbf1afd0687d">SocketBuf_ensure</a>(buf, 1024)) {</div>
<div class="line">    <span class="comment">// Guaranteed at least 1024 bytes of write space</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97">SocketBuf_write</a>(buf, data, 1024);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga474df61426f231015e3efbf1afd0687d"><div class="ttname"><a href="group__core__io.html#ga474df61426f231015e3efbf1afd0687d">SocketBuf_ensure</a></div><div class="ttdeci">int SocketBuf_ensure(SocketBuf_T buf, size_t min_space)</div><div class="ttdoc">Ensure minimum write space is available, resizing if necessary.</div></div>
<div class="ttc" id="agroup__core__io_html_gabad296e666bf8d65669ab7c71d6b8d97"><div class="ttname"><a href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97">SocketBuf_write</a></div><div class="ttdeci">size_t SocketBuf_write(SocketBuf_T buf, const void *data, size_t len)</div><div class="ttdoc">Write data into the buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> for resize without compact. </dd>
<dd>
<a class="el" href="group__core__io.html#ga42d28ec4481d1f695ddda98a9cf069dc" title="Move data to front of buffer, maximizing contiguous write space.">SocketBuf_compact()</a> for compact without resize. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> to check current space. </dd></dl>

</div>
</div>
<a id="ga600c7d30acf5132a0e790140aacba506" name="ga600c7d30acf5132a0e790140aacba506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga600c7d30acf5132a0e790140aacba506">&#9670;&#160;</a></span>SocketBuf_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketBuf_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needle_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for a byte sequence in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to search. </td></tr>
    <tr><td class="paramname">needle</td><td>Pointer to byte sequence to find. </td></tr>
    <tr><td class="paramname">needle_len</td><td>Length of needle in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset from head where needle starts, or -1 if not found.</dd></dl>
<p>Searches the readable portion of the buffer for the needle sequence. Handles circular buffer wraparound transparently.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer invalid or needle NULL with len &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n*m) worst case (n=buffer size, m=needle length). </dd>
<dd>
Empty needle (len=0) returns 0. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if buffer not mutated during search.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md492"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Find end of HTTP headers</span></div>
<div class="line">ssize_t pos = <a class="code hl_function" href="group__core__io.html#ga600c7d30acf5132a0e790140aacba506">SocketBuf_find</a>(buf, <span class="stringliteral">&quot;\r\n\r\n&quot;</span>, 4);</div>
<div class="line"><span class="keywordflow">if</span> (pos &gt;= 0) {</div>
<div class="line">    <span class="keywordtype">size_t</span> header_len = pos + 4;</div>
<div class="line">    <span class="keywordtype">char</span> headers[8192];</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42">SocketBuf_read</a>(buf, headers, header_len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga4aacfb9008833f24abec18b1d65d0d42"><div class="ttname"><a href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42">SocketBuf_read</a></div><div class="ttdeci">size_t SocketBuf_read(SocketBuf_T buf, void *data, size_t len)</div><div class="ttdoc">Read and remove data from the buffer.</div></div>
<div class="ttc" id="agroup__core__io_html_ga600c7d30acf5132a0e790140aacba506"><div class="ttname"><a href="group__core__io.html#ga600c7d30acf5132a0e790140aacba506">SocketBuf_find</a></div><div class="ttdeci">ssize_t SocketBuf_find(SocketBuf_T buf, const void *needle, size_t needle_len)</div><div class="ttdoc">Search for a byte sequence in the buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga3da1d72bb58c67433db7e075b833a47b" title="Read a line (up to and including newline) from the buffer.">SocketBuf_readline()</a> for line-oriented reading. </dd>
<dd>
<a class="el" href="group__core__io.html#ga55cfa577b17ee4e2ea965a841deccab0" title="Peek at data without removing it from the buffer.">SocketBuf_peek()</a> to examine data without searching. </dd></dl>

</div>
</div>
<a id="ga8ae7a3d2576f6d28c91511e10790e99a" name="ga8ae7a3d2576f6d28c91511e10790e99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae7a3d2576f6d28c91511e10790e99a">&#9670;&#160;</a></span>SocketBuf_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBuf_full </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer has no space for writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero (true) if full, zero (false) otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to SocketBuf_space(buf) == 0. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> for exact free space. </dd>
<dd>
<a class="el" href="group__core__io.html#ga886e91e5cdff04cbc06b2d99eb887808" title="Check if the buffer contains no data.">SocketBuf_empty()</a> for empty check. </dd>
<dd>
<a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> to expand capacity if full. </dd></dl>

</div>
</div>
<a id="gac82b13f33ba79d9fa97582a64654e8ef" name="gac82b13f33ba79d9fa97582a64654e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac82b13f33ba79d9fa97582a64654e8ef">&#9670;&#160;</a></span>SocketBuf_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> SocketBuf_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new circular buffer with specified initial capacity. </p>
<p>Allocates and initializes a circular buffer instance using the provided arena. The buffer starts empty with the given capacity. Capacity can grow dynamically via <a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Arena for all buffer memory allocations (must not be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Initial buffer size in bytes (must be &gt; 0; power-of-2 recommended for alignment).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly created buffer instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>If arena allocation fails (ENOMEM), capacity &lt;= 0, or arena NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - safe to call from any thread; returns independent</dt><dd>instance.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single allocation via arena; O(capacity) for initial</dt><dd>zeroing if implemented.</dd></dl>
<h2><a class="anchor" id="autotoc_md488"></a>
Basic Usage</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> arena = <a class="code hl_function" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a>();</div>
<div class="line"><a class="code hl_typedef" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> buf = NULL;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    buf = <a class="code hl_function" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef">SocketBuf_new</a>(arena, 4096);  <span class="comment">// 4KB buffer</span></div>
<div class="line">    <span class="comment">// Use buf...</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga246f86a3226316f3922ee9eba0436777">SocketBuf_Failed</a>) {</div>
<div class="line">    <span class="comment">// Allocation failed - handle error</span></div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Failed to create buffer: %s\n&quot;</span>,</div>
<div class="line">Except_message(<a class="code hl_variable" href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a>));</div>
<div class="line">    <span class="comment">// buf remains NULL</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#ga0e2a75478cd44f1666a6aca626c5c50b">FINALLY</a> {</div>
<div class="line">    <span class="keywordflow">if</span> (buf) <a class="code hl_function" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a>(&amp;buf);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a>(&amp;arena);</div>
<div class="ttc" id="agroup__core__io_html_ga246f86a3226316f3922ee9eba0436777"><div class="ttname"><a href="group__core__io.html#ga246f86a3226316f3922ee9eba0436777">SocketBuf_Failed</a></div><div class="ttdeci">const Except_T SocketBuf_Failed</div><div class="ttdoc">Exception indicating failure in buffer operations such as allocation or resize errors.</div></div>
<div class="ttc" id="agroup__core__io_html_ga7e38c8dbadd8bd771d70ec98eda9f448"><div class="ttname"><a href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448">SocketBuf_release</a></div><div class="ttdeci">void SocketBuf_release(SocketBuf_T *buf)</div><div class="ttdoc">Release the buffer handle and invalidate the pointer.</div></div>
<div class="ttc" id="agroup__core__io_html_gac82b13f33ba79d9fa97582a64654e8ef"><div class="ttname"><a href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef">SocketBuf_new</a></div><div class="ttdeci">SocketBuf_T SocketBuf_new(Arena_T arena, size_t capacity)</div><div class="ttdoc">Create a new circular buffer with specified initial capacity.</div></div>
<div class="ttc" id="agroup__core__io_html_gad4b3ec10874282833e1b15760efa1b6c"><div class="ttname"><a href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a></div><div class="ttdeci">struct SocketBuf_T * SocketBuf_T</div><div class="ttdoc">Opaque handle to a circular buffer instance.</div><div class="ttdef"><b>Definition</b> <a href="SocketBuf_8h_source.html#l00115">SocketBuf.h:115</a></div></div>
<div class="ttc" id="agroup__foundation_html_ga3d38c6361ecf1c4873bbcb2de8a50874"><div class="ttname"><a href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a></div><div class="ttdeci">Except_Frame * Except_stack</div><div class="ttdoc">Thread-local exception stack for TRY/EXCEPT/FINALLY blocks.</div></div>
<div class="ttc" id="agroup__foundation_html_ga6842e66018614df08139e67826cf3e0d"><div class="ttname"><a href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d">Arena_dispose</a></div><div class="ttdeci">void Arena_dispose(Arena_T *ap)</div><div class="ttdoc">Dispose of an arena and all its allocations, freeing underlying memory chunks.</div></div>
<div class="ttc" id="agroup__foundation_html_ga6a6d6890eb6ed1248ae1a5f0c677c7a4"><div class="ttname"><a href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4">Arena_new</a></div><div class="ttdeci">Arena_T Arena_new(void)</div><div class="ttdoc">Create a new memory arena with initial capacity and thread-safe protection.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md489"></a>
In Connection Pools</h2>
<p>Buffers are commonly created per-connection in <a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a>:</p>
<div class="fragment"><div class="line">Connection_T conn = <a class="code hl_function" href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494">SocketPool_add</a>(pool, socket);</div>
<div class="line"><a class="code hl_typedef" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> inbuf = <a class="code hl_function" href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf">Connection_inbuf</a>(conn);  <span class="comment">// Pool-managed buffer</span></div>
<div class="ttc" id="agroup__connection__mgmt_html_ga24170577512ce3a19fe195ab9c3576bf"><div class="ttname"><a href="group__connection__mgmt.html#ga24170577512ce3a19fe195ab9c3576bf">Connection_inbuf</a></div><div class="ttdeci">SocketBuf_T Connection_inbuf(const Connection_T conn)</div><div class="ttdoc">Get connection's input buffer.</div></div>
<div class="ttc" id="agroup__connection__mgmt_html_gac7720c7b7d679624fa95bdefe9a38494"><div class="ttname"><a href="group__connection__mgmt.html#gac7720c7b7d679624fa95bdefe9a38494">SocketPool_add</a></div><div class="ttdeci">Connection_T SocketPool_add(SocketPool_T pool, Socket_T socket)</div><div class="ttdoc">Add a connected socket to the pool, creating a Connection_T wrapper.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Buffer lifecycle tied to arena - dispose arena to free all buffers at once. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Capacity=0 or very small may lead to frequent resizes; choose appropriately. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> for dynamic growth. </dd>
<dd>
<a class="el" href="group__core__io.html#ga7e38c8dbadd8bd771d70ec98eda9f448" title="Release the buffer handle and invalidate the pointer.">SocketBuf_release()</a> for handle invalidation (not memory free). </dd>
<dd>
<a class="el" href="group__foundation.html#ga6a6d6890eb6ed1248ae1a5f0c677c7a4" title="Create a new memory arena with initial capacity and thread-safe protection.">Arena_new()</a> / <a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> in <a class="el" href="group__foundation.html">Core Foundation Modules</a> for arena lifecycle. </dd>
<dd>
SocketPool_T for integrated usage. </dd></dl>

</div>
</div>
<a id="ga55cfa577b17ee4e2ea965a841deccab0" name="ga55cfa577b17ee4e2ea965a841deccab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55cfa577b17ee4e2ea965a841deccab0">&#9670;&#160;</a></span>SocketBuf_peek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at data without removing it from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The source buffer. </td></tr>
    <tr><td class="paramname">data</td><td>Destination for peeked data. </td></tr>
    <tr><td class="paramname">len</td><td>Maximum bytes to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes copied to data (&lt;= len); 0 if empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid or data is NULL with len &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Non-destructive: data remains available for subsequent reads. </dd>
<dd>
Useful for protocol parsing without consuming stream. </dd>
<dd>
Performance: O(n) time where n = bytes peeked. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if no concurrent modifications.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for consuming data after peeking. </dd>
<dd>
<a class="el" href="group__core__io.html#gae4d5d95ed126030f6414b7f607cd555e" title="Obtain a direct pointer to readable data for zero-copy access.">SocketBuf_readptr()</a> for zero-copy peeking. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143" title="Query the number of bytes available for reading.">SocketBuf_available()</a> to query readable data length. </dd></dl>

</div>
</div>
<a id="ga4aacfb9008833f24abec18b1d65d0d42" name="ga4aacfb9008833f24abec18b1d65d0d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aacfb9008833f24abec18b1d65d0d42">&#9670;&#160;</a></span>SocketBuf_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read and remove data from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The source buffer. </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for read data. </td></tr>
    <tr><td class="paramname">len</td><td>Maximum bytes to read into data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read and removed (&lt;= len); 0 if empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid or data is NULL with len &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Partial reads possible if less data available. </dd>
<dd>
Data is removed from buffer after successful read. </dd>
<dd>
Performance: O(n) time where n = bytes read. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - concurrent reads/writes require external synchronization.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga55cfa577b17ee4e2ea965a841deccab0" title="Peek at data without removing it from the buffer.">SocketBuf_peek()</a> for non-destructive read. </dd>
<dd>
<a class="el" href="group__core__io.html#gae4d5d95ed126030f6414b7f607cd555e" title="Obtain a direct pointer to readable data for zero-copy access.">SocketBuf_readptr()</a> for zero-copy read access. </dd>
<dd>
<a class="el" href="group__core__io.html#gad11c3dede8563afbb1a3e9b9f4e936e6" title="Discard data from the front of the buffer without reading it.">SocketBuf_consume()</a> to remove data without copying. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143" title="Query the number of bytes available for reading.">SocketBuf_available()</a> to check readable bytes. </dd>
<dd>
<a class="el" href="group__core__io.html#ga886e91e5cdff04cbc06b2d99eb887808" title="Check if the buffer contains no data.">SocketBuf_empty()</a> to check if no data available. </dd></dl>

</div>
</div>
<a id="ga3da1d72bb58c67433db7e075b833a47b" name="ga3da1d72bb58c67433db7e075b833a47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da1d72bb58c67433db7e075b833a47b">&#9670;&#160;</a></span>SocketBuf_readline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketBuf_readline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a line (up to and including newline) from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">line</td><td>Destination buffer for the line. </td></tr>
    <tr><td class="paramname">max_len</td><td>Maximum bytes to read (including null terminator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read (excluding null), or -1 if no newline found.</dd></dl>
<p>Reads up to and including the first newline ('<br  />
') or until max_len-1. The output is null-terminated. Handles both LF and CRLF line endings. Does NOT consume data if no complete line found (returns -1).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer invalid or line NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n) where n = line length. </dd>
<dd>
Returns -1 if no '<br  />
' found in available data. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - reads and consumes data.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md493"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> line[256];</div>
<div class="line">ssize_t len;</div>
<div class="line"><span class="keywordflow">while</span> ((len = <a class="code hl_function" href="group__core__io.html#ga3da1d72bb58c67433db7e075b833a47b">SocketBuf_readline</a>(buf, line, <span class="keyword">sizeof</span>(line))) &gt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Line: %s&quot;</span>, line);  <span class="comment">// line includes &#39;\n&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga3da1d72bb58c67433db7e075b833a47b"><div class="ttname"><a href="group__core__io.html#ga3da1d72bb58c67433db7e075b833a47b">SocketBuf_readline</a></div><div class="ttdeci">ssize_t SocketBuf_readline(SocketBuf_T buf, char *line, size_t max_len)</div><div class="ttdoc">Read a line (up to and including newline) from the buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga600c7d30acf5132a0e790140aacba506" title="Search for a byte sequence in the buffer.">SocketBuf_find()</a> for searching without reading. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for length-based reading. </dd></dl>

</div>
</div>
<a id="gae4d5d95ed126030f6414b7f607cd555e" name="gae4d5d95ed126030f6414b7f607cd555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4d5d95ed126030f6414b7f607cd555e">&#9670;&#160;</a></span>SocketBuf_readptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * SocketBuf_readptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a direct pointer to readable data for zero-copy access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Output parameter: number of contiguous bytes available at *return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to start of readable data, or NULL if buffer empty. The pointed data is valid until next write/consume operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Guarantees contiguous block; may be less than available() due to wraparound. </dd>
<dd>
Caller must not retain pointer across mutating calls (write, consume, etc.). </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - pointer invalidates on concurrent mutation.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad11c3dede8563afbb1a3e9b9f4e936e6" title="Discard data from the front of the buffer without reading it.">SocketBuf_consume()</a> to advance past the read data. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for copying alternative. </dd>
<dd>
<a class="el" href="group__core__io.html#ga55cfa577b17ee4e2ea965a841deccab0" title="Peek at data without removing it from the buffer.">SocketBuf_peek()</a> for size-limited copy-based peek. </dd>
<dd>
send() system call for zero-copy socket transmission. </dd></dl>

</div>
</div>
<a id="gaaaf29683accb04578c0fb3869d31ba1d" name="gaaaf29683accb04578c0fb3869d31ba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf29683accb04578c0fb3869d31ba1d">&#9670;&#160;</a></span>SocketBuf_readv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketBuf_readv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter read from buffer into multiple iovecs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures to scatter data into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes read, or -1 on error.</dd></dl>
<p>Reads data from the buffer and scatters it across multiple memory regions. Consumes data from buffer after successful read. Handles wraparound.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer invalid or iov NULL with iovcnt &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n) where n = total bytes read. </dd>
<dd>
Partial fills possible if buffer has less data than iov capacity. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies buffer state.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md494"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>header hdr;</div>
<div class="line"><span class="keywordtype">char</span> body[1024];</div>
<div class="line"><span class="keyword">struct </span>iovec iov[2] = {</div>
<div class="line">    {.iov_base = &amp;hdr, .iov_len = <span class="keyword">sizeof</span>(hdr)},</div>
<div class="line">    {.iov_base = body, .iov_len = <span class="keyword">sizeof</span>(body)}</div>
<div class="line">};</div>
<div class="line">ssize_t n = <a class="code hl_function" href="group__core__io.html#gaaaf29683accb04578c0fb3869d31ba1d">SocketBuf_readv</a>(buf, iov, 2);</div>
<div class="ttc" id="agroup__core__io_html_gaaaf29683accb04578c0fb3869d31ba1d"><div class="ttname"><a href="group__core__io.html#gaaaf29683accb04578c0fb3869d31ba1d">SocketBuf_readv</a></div><div class="ttdeci">ssize_t SocketBuf_readv(SocketBuf_T buf, const struct iovec *iov, int iovcnt)</div><div class="ttdoc">Scatter read from buffer into multiple iovecs.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga315c19dd862a58b89ca13f3fb1165d09" title="Gather write from multiple iovecs into buffer.">SocketBuf_writev()</a> for gather write. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for single-buffer read. </dd>
<dd>
readv(2) system call for analogous operation. </dd></dl>

</div>
</div>
<a id="ga7e38c8dbadd8bd771d70ec98eda9f448" name="ga7e38c8dbadd8bd771d70ec98eda9f448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e38c8dbadd8bd771d70ec98eda9f448">&#9670;&#160;</a></span>SocketBuf_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the buffer handle and invalidate the pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the buffer handle (set to NULL on success).</td></tr>
  </table>
  </dd>
</dl>
<p>This function nullifies the buffer pointer but does not free the underlying memory, as it is managed by the arena. It prevents use-after-free or dangling pointer issues.</p>
<dl class="section note"><dt>Note</dt><dd>Arena-managed memory persists until <a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> or <a class="el" href="group__foundation.html#ga0af0c54c1c64ff88ad43aadd48ce3ebe" title="Reset the arena by invalidating all current allocations while preserving the arena for reuse.">Arena_clear()</a>. </dd>
<dd>
No exception thrown; idempotent if *buf is already NULL. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - safe to call concurrently if no overlapping access to</dt><dd>*buf.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef" title="Create a new circular buffer with specified initial capacity.">SocketBuf_new()</a> for buffer creation. </dd>
<dd>
<a class="el" href="group__foundation.html#ga6842e66018614df08139e67826cf3e0d" title="Dispose of an arena and all its allocations, freeing underlying memory chunks.">Arena_dispose()</a> in <a class="el" href="group__foundation.html">Core Foundation Modules</a> for full memory cleanup. </dd>
<dd>
<a class="el" href="group__foundation.html">Foundation</a> group for memory management principles. </dd></dl>

</div>
</div>
<a id="ga77d70e899c26ac30bad4aac232505f1e" name="ga77d70e899c26ac30bad4aac232505f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d70e899c26ac30bad4aac232505f1e">&#9670;&#160;</a></span>SocketBuf_reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamically resize buffer to ensure at least min_space available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to potentially resize. </td></tr>
    <tr><td class="paramname">min_space</td><td>Required minimum free space after operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if reallocation fails or arithmetic overflow occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strategy: doubles capacity or sets to max(current, min_space); copies data. </dd>
<dd>
May trigger on write if space insufficient (configurable?). </dd>
<dd>
Validates internal invariants post-resize. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - concurrent resize undefined; serialize access.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> to check current space without resize. </dd>
<dd>
<a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef" title="Create a new circular buffer with specified initial capacity.">SocketBuf_new()</a> specify initial capacity to avoid frequent resizes. </dd>
<dd>
Arena for underlying memory source. </dd></dl>

</div>
</div>
<a id="gaf0f12ab9bbed33398141c41561c1fcb7" name="gaf0f12ab9bbed33398141c41561c1fcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0f12ab9bbed33398141c41561c1fcb7">&#9670;&#160;</a></span>SocketBuf_secureclear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_secureclear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Securely erase all data by zeroing memory contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing potentially sensitive data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Overwrites entire buffer capacity with zeros before resetting pointers. </dd>
<dd>
Essential for cryptographic keys, credentials, or PII to mitigate timing attacks or memory dumps. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Performance: O(n) where n = current capacity; slower than clear(). </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - writes to shared memory; lock before use in multi-thread.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga61b062261e8e954240edf8d3a6a01fb8" title="Reset buffer to empty state without zeroing memory.">SocketBuf_clear()</a> for non-secure fast reset. </dd>
<dd>
<a class="el" href="group__security.html">Security Module</a> for TLS/crypto integration. </dd>
<dd>
<a class="el" href="SocketPool-private_8h.html#structSocketPool__T">SocketPool_T</a> in <a class="el" href="group__connection__mgmt.html">Connection Management Modules</a> for connection buffer secure cleanup. </dd>
<dd>
<a class="el" href="group__security.html#gabdb38e692dde58bbec4ab905eeb8b3aa" title="Send data over TLS-encrypted connection.">SocketTLS_send()</a> in <a class="el" href="group__security.html">Security Modules</a> for secure I/O patterns. </dd></dl>

</div>
</div>
<a id="ga4f511809edb33ba3ff3a051544bff0d1" name="ga4f511809edb33ba3ff3a051544bff0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f511809edb33ba3ff3a051544bff0d1">&#9670;&#160;</a></span>SocketBuf_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the number of bytes available for writing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Free space in bytes (capacity - available data; 0 if full). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Constant time; no modification to buffer state. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only, concurrent safe.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f350e096708c438bc2002909325b143" title="Query the number of bytes available for reading.">SocketBuf_available()</a> for symmetric read query. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8ae7a3d2576f6d28c91511e10790e99a" title="Check if the buffer has no space for writing.">SocketBuf_full()</a> for boolean full check. </dd>
<dd>
<a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97" title="Write data into the buffer.">SocketBuf_write()</a> to add data if space &gt; 0. </dd>
<dd>
<a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> to ensure minimum space. </dd></dl>

</div>
</div>
<a id="gabad296e666bf8d65669ab7c71d6b8d97" name="gabad296e666bf8d65669ab7c71d6b8d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad296e666bf8d65669ab7c71d6b8d97">&#9670;&#160;</a></span>SocketBuf_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketBuf_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The target buffer. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to data to append. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes successfully written (&lt;= len); 0 if full. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid or data is NULL with len &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Writes as much as possible; partial writes possible if space limited. </dd>
<dd>
Handles internal wraparound transparently. </dd>
<dd>
Performance: O(n) time where n = bytes written, due to potential memcpy. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - concurrent writes may corrupt buffer; use locks externally.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga4f511809edb33ba3ff3a051544bff0d1" title="Query the number of bytes available for writing.">SocketBuf_space()</a> to check available write space before writing. </dd>
<dd>
<a class="el" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc" title="Obtain a direct pointer for zero-copy writing into the buffer.">SocketBuf_writeptr()</a> for zero-copy alternative. </dd>
<dd>
<a class="el" href="group__core__io.html#ga4aacfb9008833f24abec18b1d65d0d42" title="Read and remove data from the buffer.">SocketBuf_read()</a> for symmetric read operation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8ae7a3d2576f6d28c91511e10790e99a" title="Check if the buffer has no space for writing.">SocketBuf_full()</a> to check if buffer is full. </dd></dl>

</div>
</div>
<a id="ga0d845ceca49625b8c317310a757ad9dc" name="ga0d845ceca49625b8c317310a757ad9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d845ceca49625b8c317310a757ad9dc">&#9670;&#160;</a></span>SocketBuf_writeptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SocketBuf_writeptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a direct pointer for zero-copy writing into the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Output: maximum contiguous bytes that can be written at *return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to write location, or NULL if no space available. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After writing up to *len bytes, call SocketBuf_written(actual_len). </dd>
<dd>
May return less than space() due to wraparound; buffer handles it. </dd>
<dd>
Pointer invalid after any other buffer operation. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - concurrent writes corrupt buffer.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga2e4e93aa0feab70464515b0ef3a57186" title="Commit bytes written via direct write pointer.">SocketBuf_written()</a> to commit the written bytes. </dd>
<dd>
<a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97" title="Write data into the buffer.">SocketBuf_write()</a> for safe copying alternative. </dd>
<dd>
recv() system call integration for zero-copy receive. </dd></dl>

</div>
</div>
<a id="ga315c19dd862a58b89ca13f3fb1165d09" name="ga315c19dd862a58b89ca13f3fb1165d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315c19dd862a58b89ca13f3fb1165d09">&#9670;&#160;</a></span>SocketBuf_writev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t SocketBuf_writev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather write from multiple iovecs into buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write to. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec structures containing data to gather. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes written, or -1 on error.</dd></dl>
<p>Gathers data from multiple memory regions and writes into the buffer. Handles circular buffer wraparound transparently.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer invalid or iov NULL with iovcnt &gt; 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Performance: O(n) where n = total bytes written. </dd>
<dd>
Partial writes possible if buffer space insufficient. </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - modifies buffer state.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md495"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>header hdr = {...};</div>
<div class="line"><span class="keywordtype">char</span> body[] = <span class="stringliteral">&quot;Hello, World!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span>iovec iov[2] = {</div>
<div class="line">    {.iov_base = &amp;hdr, .iov_len = <span class="keyword">sizeof</span>(hdr)},</div>
<div class="line">    {.iov_base = body, .iov_len = strlen(body)}</div>
<div class="line">};</div>
<div class="line">ssize_t n = <a class="code hl_function" href="group__core__io.html#ga315c19dd862a58b89ca13f3fb1165d09">SocketBuf_writev</a>(buf, iov, 2);</div>
<div class="ttc" id="agroup__core__io_html_ga315c19dd862a58b89ca13f3fb1165d09"><div class="ttname"><a href="group__core__io.html#ga315c19dd862a58b89ca13f3fb1165d09">SocketBuf_writev</a></div><div class="ttdeci">ssize_t SocketBuf_writev(SocketBuf_T buf, const struct iovec *iov, int iovcnt)</div><div class="ttdoc">Gather write from multiple iovecs into buffer.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaaaf29683accb04578c0fb3869d31ba1d" title="Scatter read from buffer into multiple iovecs.">SocketBuf_readv()</a> for scatter read. </dd>
<dd>
<a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97" title="Write data into the buffer.">SocketBuf_write()</a> for single-buffer write. </dd>
<dd>
writev(2) system call for analogous operation. </dd></dl>

</div>
</div>
<a id="ga2e4e93aa0feab70464515b0ef3a57186" name="ga2e4e93aa0feab70464515b0ef3a57186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e4e93aa0feab70464515b0ef3a57186">&#9670;&#160;</a></span>SocketBuf_written()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketBuf_written </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gad4b3ec10874282833e1b15760efa1b6c">SocketBuf_T</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commit bytes written via direct write pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer where data was written. </td></tr>
    <tr><td class="paramname">len</td><td>Exact number of bytes written at the pointer from writeptr(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketBuf_Failed</td><td>if buffer is invalid or len &gt; available space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must match or be &lt;= the len from corresponding <a class="el" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc" title="Obtain a direct pointer for zero-copy writing into the buffer.">SocketBuf_writeptr()</a> call. </dd>
<dd>
Behavior undefined (assert in debug) if len exceeds available space. </dd>
<dd>
Updates internal write position and available space. </dd>
<dd>
Performance: O(1). </dd></dl>
<dl class="section user"><dt>Thread Safety\n No - must be called by same thread/lock holder as writeptr().</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga0d845ceca49625b8c317310a757ad9dc" title="Obtain a direct pointer for zero-copy writing into the buffer.">SocketBuf_writeptr()</a> to obtain write location and space. </dd>
<dd>
<a class="el" href="group__core__io.html#gabad296e666bf8d65669ab7c71d6b8d97" title="Write data into the buffer.">SocketBuf_write()</a> for alternative non-zero-copy write. </dd>
<dd>
<a class="el" href="group__core__io.html">Core I/O</a> for zero-copy patterns with sockets. </dd></dl>

</div>
</div>
<a id="ga33af6b6698782c490ff383bb37c197e7" name="ga33af6b6698782c490ff383bb37c197e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33af6b6698782c490ff383bb37c197e7">&#9670;&#160;</a></span>SocketCommon_advance_iov()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_advance_iov </td>
          <td>(</td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance iovec array past sent/received bytes (modifies in place) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>Array of iovec structures to advance </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramname">bytes</td><td>Bytes to advance (must &lt;= total iov len) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Behavior: Sets advanced iovs to len=0/base=NULL, partial to offset/len reduced </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketCommon_Failed</td><td>if bytes &gt; total iov len or invalid params </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (local ops) </dd>
<dd>
Unifies duplicated advance logic for sendvall/recvvall </dd></dl>

</div>
</div>
<a id="ga0ccd95f99962c7a6631b93bf9adfea4d" name="ga0ccd95f99962c7a6631b93bf9adfea4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ccd95f99962c7a6631b93bf9adfea4d">&#9670;&#160;</a></span>SocketCommon_alloc_iov_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct iovec * SocketCommon_alloc_iov_copy </td>
          <td>(</td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and copy iovec array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>Source iovec array to copy </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt;0, &lt;=IOV_MAX) </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception type to raise on allocation failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly allocated copy of iovec array (caller must free) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exc_type</td><td>on allocation failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd>
<dd>
Common helper for sendvall/recvvall implementations. Consolidates duplicate calloc+memcpy patterns across Socket and SocketDgram modules. </dd></dl>

</div>
</div>
<a id="gadfc31bff834af43e2a6ee2facd9951d4" name="gadfc31bff834af43e2a6ee2facd9951d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc31bff834af43e2a6ee2facd9951d4">&#9670;&#160;</a></span>SocketCommon_cache_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_cache_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>addr_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract and cache human-readable numeric address and port from sockaddr structure. </p>
<p>Converts a binary sockaddr (from getsockname, getpeername, etc.) to numeric string representation (IP:port) allocated from the provided arena. Uses getnameinfo() with NI_NUMERICHOST and NI_NUMERICSERV flags for numeric-only output (no reverse DNS).</p>
<p>Purpose: Facilitates logging, metrics, debugging by providing string form of endpoints without repeated formatting or temporary allocations. Arena allocation ties lifetime to owning object (e.g., socket base).</p>
<p>Supported families: AF_INET, AF_INET6, AF_UNIX (for Unix, addr_str may be path, port=0). On failure, outputs unchanged, error logged via SocketLog, errno not set.</p>
<p>Edge cases:</p><ul>
<li>Invalid addr/addrlen: Logs error, returns -1</li>
<li>Arena allocation fail: Returns -1, addr_out unchanged</li>
<li>Unsupported family: getnameinfo fails, returns -1</li>
<li>Unix domain: port=0, addr_str = socket path (if available)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arena</td><td>Arena_T for allocating the address string copy. Must be valid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>const sockaddr* to format (IPv4, IPv6, Unix supported). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>socklen_t length of addr structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr_out</td><td>char** set to arena-allocated numeric address string (e.g., "127.0.0.1" or "[::1]"). Unchanged on failure. Caller does not free - arena-managed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_out</td><td>int* set to extracted port number (host byte order, 0 if not available e.g., Unix).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (outputs populated), -1 on failure (getnameinfo or alloc error). On failure, error details logged via SOCKET_ERROR_MSG; check <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- returns error code instead of raising.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - local buffers, getnameinfo thread-safe on modern systems.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md504"></a>
Usage Example (After getsockname)</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>sockaddr_storage local_addr;</div>
<div class="line">socklen_t len = <span class="keyword">sizeof</span>(local_addr);</div>
<div class="line">getsockname(fd, (<span class="keyword">struct</span> sockaddr*)&amp;local_addr, &amp;len);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *cached_addr;</div>
<div class="line"><span class="keywordtype">int</span> cached_port;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4">SocketCommon_cache_endpoint</a>(arena, (<span class="keyword">struct</span> sockaddr*)&amp;local_addr, len,</div>
<div class="line">                                &amp;cached_addr, &amp;cached_port) == 0) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a9fe70c7ab8b971af2971f3a102b82819">SOCKET_LOG_INFO_MSG</a>(<span class="stringliteral">&quot;Bound to %s:%d&quot;</span>, cached_addr, cached_port);</div>
<div class="line">    <span class="comment">// cached_addr lifetime = arena</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;Failed to cache local endpoint&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_gadfc31bff834af43e2a6ee2facd9951d4"><div class="ttname"><a href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4">SocketCommon_cache_endpoint</a></div><div class="ttdeci">int SocketCommon_cache_endpoint(Arena_T arena, const struct sockaddr *addr, socklen_t addrlen, char **addr_out, int *port_out)</div><div class="ttdoc">Extract and cache human-readable numeric address and port from sockaddr structure.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md505"></a>
Peer Address Caching</h2>
<div class="fragment"><div class="line"><span class="comment">// After accept or connect</span></div>
<div class="line"><span class="keyword">struct </span>sockaddr_storage peer;</div>
<div class="line">socklen_t peer_len = <span class="keyword">sizeof</span>(peer);</div>
<div class="line">getpeername(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;peer, &amp;peer_len);</div>
<div class="line"><span class="keywordtype">char</span> *peer_ip;</div>
<div class="line"><span class="keywordtype">int</span> peer_port;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gadfc31bff834af43e2a6ee2facd9951d4">SocketCommon_cache_endpoint</a>(<a class="code hl_function" href="group__core__io.html#gae819168ebf1a49f132758d251e14958c">SocketBase_arena</a>(base), (<span class="keyword">struct</span> sockaddr*)&amp;peer,</div>
<div class="line">peer_len, &amp;peer_ip, &amp;peer_port);</div>
<div class="line"><span class="comment">// Use for logging: &quot;Peer %s:%d connected&quot;, peer_ip, peer_port</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>String format: IPv4 "x.x.x.x", IPv6 "[xxxx::xxxx]" per getnameinfo numeric. </dd>
<dd>
Port parsing from service string; fails gracefully to 0 if invalid. </dd>
<dd>
For Unix domain, addr_str may be path up to NI_MAXHOST length. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Buffers internally sized to NI_MAXHOST/NI_MAXSERV - truncation possible but rare.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - getnameinfo bounded time, arena alloc constant.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>getnameinfo(3) for numeric formatting details </dd>
<dd>
<a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> local/remote endpoint caching which uses this </dd>
<dd>
Socket_getlocaladdr/port, Socket_getpeeraddr/port public wrappers </dd>
<dd>
<a class="el" href="Arena_8h.html" title="Arena-based memory allocator for efficient bulk memory management.">core/Arena.h</a> for allocation management </dd></dl>

</div>
</div>
<a id="gabb36ce89ba4091b0a1bee148506d586b" name="gabb36ce89ba4091b0a1bee148506d586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb36ce89ba4091b0a1bee148506d586b">&#9670;&#160;</a></span>SocketCommon_calculate_total_iov_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SocketCommon_calculate_total_iov_len </td>
          <td>(</td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate total length of iovec array with overflow protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>Array of iovec structures </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures (&gt;0, &lt;=IOV_MAX) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total bytes across all iov_len </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketCommon_Failed</td><td>on integer overflow during summation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd>
<dd>
Unifies duplicated calculation loops across modules </dd></dl>

</div>
</div>
<a id="ga7a0c8010b4e1cb65941a1c9be090742c" name="ga7a0c8010b4e1cb65941a1c9be090742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0c8010b4e1cb65941a1c9be090742c">&#9670;&#160;</a></span>SocketCommon_check_bound_by_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketCommon_check_bound_by_family </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if socket is bound based on family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>sockaddr_storage containing address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if bound, 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01043">1043</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon_8h_source.html#l01004">SocketCommon_check_bound_ipv4()</a>, <a class="el" href="SocketCommon_8h_source.html#l01017">SocketCommon_check_bound_ipv6()</a>, and <a class="el" href="SocketCommon_8h_source.html#l01030">SocketCommon_check_bound_unix()</a>.</p>

</div>
</div>
<a id="ga37fb698963ebcc4f8f1d86d03b2ba3b7" name="ga37fb698963ebcc4f8f1d86d03b2ba3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fb698963ebcc4f8f1d86d03b2ba3b7">&#9670;&#160;</a></span>SocketCommon_check_bound_ipv4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketCommon_check_bound_ipv4 </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if IPv4 socket is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>sockaddr_storage containing address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if bound (port != 0), 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01004">1004</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketCommon_8h_source.html#l01043">SocketCommon_check_bound_by_family()</a>.</p>

</div>
</div>
<a id="ga560dfe8bbb25d43c0ade5b295e20e1a7" name="ga560dfe8bbb25d43c0ade5b295e20e1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga560dfe8bbb25d43c0ade5b295e20e1a7">&#9670;&#160;</a></span>SocketCommon_check_bound_ipv6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketCommon_check_bound_ipv6 </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if IPv6 socket is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>sockaddr_storage containing address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if bound (port != 0), 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01017">1017</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketCommon_8h_source.html#l01043">SocketCommon_check_bound_by_family()</a>.</p>

</div>
</div>
<a id="ga06bdea854665ec5ea7e4578b316092a4" name="ga06bdea854665ec5ea7e4578b316092a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06bdea854665ec5ea7e4578b316092a4">&#9670;&#160;</a></span>SocketCommon_check_bound_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketCommon_check_bound_unix </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr_storage *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if Unix socket is bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>sockaddr_storage containing address (unused) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 (Unix domain sockets are bound if getsockname succeeds) </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01030">1030</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketCommon_8h_source.html#l01043">SocketCommon_check_bound_by_family()</a>.</p>

</div>
</div>
<a id="ga5584b123bcf71749129a64c8312d0023" name="ga5584b123bcf71749129a64c8312d0023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5584b123bcf71749129a64c8312d0023">&#9670;&#160;</a></span>SocketCommon_cidr_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_cidr_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cidr_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if IP address matches CIDR range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_str</td><td>IP address string to check </td></tr>
    <tr><td class="paramname">cidr_str</td><td>CIDR notation string (e.g., "192.168.1.0/24" or "2001:db8::/32") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if IP matches CIDR range, 0 if not, -1 on error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd>
<dd>
Supports both IPv4 and IPv6 CIDR notation. </dd>
<dd>
Returns -1 if IP or CIDR string is invalid. </dd></dl>

</div>
</div>
<a id="ga1d98c31897344c8c2e6e6cde65045f09" name="ga1d98c31897344c8c2e6e6cde65045f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d98c31897344c8c2e6e6cde65045f09">&#9670;&#160;</a></span>SocketCommon_copy_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct addrinfo * SocketCommon_copy_addrinfo </td>
          <td>(</td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy of addrinfo linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source chain to copy (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>malloc-allocated deep copy, or NULL on error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Deep copies the entire chain including ai_addr and ai_canonname fields. </dd>
<dd>
Caller takes ownership and MUST free with <a class="el" href="group__core__io.html#ga6c73595d93eeee7b21ad12b980770f5a" title="Free addrinfo chain created by copy_addrinfo.">SocketCommon_free_addrinfo()</a>. </dd>
<dd>
Do NOT use freeaddrinfo() on the result - it's undefined behavior. </dd>
<dd>
No exceptions raised; returns NULL on malloc failure or src==NULL. </dd>
<dd>
Thread-safe: Yes </dd></dl>

</div>
</div>
<a id="ga64fef3c801aa2661b32ec73f368458f0" name="ga64fef3c801aa2661b32ec73f368458f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64fef3c801aa2661b32ec73f368458f0">&#9670;&#160;</a></span>SocketCommon_create_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_create_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new socket file descriptor with error handling and CLOEXEC setup. </p>
<p>Low-level wrapper around socket(2) system call that creates a new file descriptor, sets FD_CLOEXEC flag, disables SIGPIPE generation (platform-specific), and raises specified exception on failure. Used during socket instance creation before base init.</p>
<p>Error Conditions</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">errno   </th><th class="markdownTableHeadNone">Meaning   </th><th class="markdownTableHeadNone">Retryable    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EACCES   </td><td class="markdownTableBodyNone">Permission denied   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EMFILE   </td><td class="markdownTableBodyNone">Per-process fd limit   </td><td class="markdownTableBodyNone">Yes (after close)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENFILE   </td><td class="markdownTableBodyNone">System-wide fd limit   </td><td class="markdownTableBodyNone">Yes (system resource)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EAFNOSUPPORT   </td><td class="markdownTableBodyNone">Address family unsupported   </td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENOBUFS   </td><td class="markdownTableBodyNone">No buffer space   </td><td class="markdownTableBodyNone">Yes (transient)   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Address family (AF_INET, AF_INET6, AF_UNIX) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type (SOCK_STREAM, SOCK_DGRAM) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol (usually 0 for default) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exc_type</td><td>Exception type to raise on failure (e.g., Socket_Failed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New non-negative file descriptor on success, -1 on error (raises exc_type)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exc_type</td><td>on socket(2) failure with formatted message including errno</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - no shared state or globals modified</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single system call + flag setup</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <span class="keywordtype">int</span> fd = <a class="code hl_function" href="group__core__io.html#ga64fef3c801aa2661b32ec73f368458f0">SocketCommon_create_fd</a>(AF_INET, SOCK_STREAM, 0, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);</div>
<div class="line">    <a class="code hl_struct" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base = <a class="code hl_define" href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934">CALLOC</a>(NULL, 1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code hl_struct" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>));</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d">SocketCommon_init_base</a>(base, fd, AF_INET, SOCK_STREAM, 0,</div>
<div class="line"><a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);</div>
<div class="line">    <span class="comment">// Now embed base in subtype struct</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Failed to create socket: %s&quot;</span>,</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>()); <span class="keywordflow">return</span> -1; } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="aSocketUtil_8h_html_a16642c35dec627aeb4976538671b1552"><div class="ttname"><a href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a></div><div class="ttdeci">#define SOCKET_LOG_ERROR_MSG(fmt,...)</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l00548">SocketUtil.h:548</a></div></div>
<div class="ttc" id="agroup__core__io_html_ga1aa5d2cb4d591e902973e55dc9f1282d"><div class="ttname"><a href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d">SocketCommon_init_base</a></div><div class="ttdeci">void SocketCommon_init_base(SocketBase_T base, int fd, int domain, int type, int protocol, Except_T exc_type)</div><div class="ttdoc">Initialize pre-allocated SocketBase_T with FD and parameters.</div></div>
<div class="ttc" id="agroup__core__io_html_ga64fef3c801aa2661b32ec73f368458f0"><div class="ttname"><a href="group__core__io.html#ga64fef3c801aa2661b32ec73f368458f0">SocketCommon_create_fd</a></div><div class="ttdeci">int SocketCommon_create_fd(int domain, int type, int protocol, Except_T exc_type)</div><div class="ttdoc">Create a new socket file descriptor with error handling and CLOEXEC setup.</div></div>
<div class="ttc" id="agroup__foundation_html_gaf5249a1778cd6cf5db0e2e410b292934"><div class="ttname"><a href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934">CALLOC</a></div><div class="ttdeci">#define CALLOC(arena, count, nbytes)</div><div class="ttdoc">Convenience macro for zero-initialized multi-element allocation with source tracking.</div><div class="ttdef"><b>Definition</b> <a href="Arena_8h_source.html#l00551">Arena.h:551</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Automatically sets FD_CLOEXEC to prevent fd inheritance on execve(2). </dd>
<dd>
Handles platform-specific SIGPIPE suppression (SO_NOSIGPIPE or MSG_NOSIGNAL policy). </dd>
<dd>
Caller responsible for closing fd on error paths before raising. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not use directly in application code; internal library use only.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>socket(2) for underlying system call </dd>
<dd>
<a class="el" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d" title="Initialize pre-allocated SocketBase_T with FD and parameters.">SocketCommon_init_base()</a> for initializing <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> with returned fd </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html#aea794adfcbc6ada8bf713a09c15b6ed4" title="Set FD_CLOEXEC flag with error handling.">SocketCommon_setcloexec_with_error()</a> for explicit CLOEXEC handling </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html#a7c16d8b6692dec008bc24fb81b6e0212" title="Disable SIGPIPE generation on send (platform-specific).">SocketCommon_disable_sigpipe()</a> for SIGPIPE details </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a>#file-descriptor-leaks for CLOEXEC importance </dd></dl>

</div>
</div>
<a id="ga0b9037b75f684ba9a4fda235b0bf0ca0" name="ga0b9037b75f684ba9a4fda235b0bf0ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b9037b75f684ba9a4fda235b0bf0ca0">&#9670;&#160;</a></span>SocketCommon_find_active_iov()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct iovec * SocketCommon_find_active_iov </td>
          <td>(</td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>active_iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find first non-empty iovec in array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iov</td><td>Array of iovec structures to search </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
    <tr><td class="paramname">active_iovcnt</td><td>Output for count of remaining iovecs from active position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first iovec with iov_len &gt; 0, or NULL if all empty </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (read-only operation) </dd>
<dd>
Used by sendvall/recvvall to find the next active buffer segment after partial I/O operations have consumed some of the iovec array. </dd></dl>

</div>
</div>
<a id="gae1c533bda5b245453885e07e2a7b4e83" name="gae1c533bda5b245453885e07e2a7b4e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c533bda5b245453885e07e2a7b4e83">&#9670;&#160;</a></span>SocketCommon_format_bind_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_format_bind_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format descriptive bind error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Host string (NULL defaults to "any") </td></tr>
    <tr><td class="paramname">port</td><td>Port number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Formats error in socket_error_buf based on errno (EADDRINUSE, EACCES, etc.) </dd>
<dd>
Consolidated helper for Socket and SocketDgram bind error handling. </dd>
<dd>
Does not raise - caller should raise after calling this. </dd></dl>

</div>
</div>
<a id="ga6c73595d93eeee7b21ad12b980770f5a" name="ga6c73595d93eeee7b21ad12b980770f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c73595d93eeee7b21ad12b980770f5a">&#9670;&#160;</a></span>SocketCommon_free_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_free_addrinfo </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>ai</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free addrinfo chain created by copy_addrinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ai</td><td>Chain to free (may be NULL, safe no-op) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Frees all nodes in the chain including ai_addr and ai_canonname fields. </dd>
<dd>
Use this instead of freeaddrinfo() for chains from SocketCommon_copy_addrinfo. </dd>
<dd>
Thread-safe: Yes </dd></dl>

</div>
</div>
<a id="gaaeb641ee1edaa618b8680babae9a98c6" name="gaaeb641ee1edaa618b8680babae9a98c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb641ee1edaa618b8680babae9a98c6">&#9670;&#160;</a></span>SocketCommon_free_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_free_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> *&#160;</td>
          <td class="paramname"><em>base_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free a socket base structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_ptr</td><td>Pointer to socket base (will be set to NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cleans up all resources associated with the socket base. </dd></dl>

</div>
</div>
<a id="ga70954c6e125769d15ffd6c3e31c89b75" name="ga70954c6e125769d15ffd6c3e31c89b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70954c6e125769d15ffd6c3e31c89b75">&#9670;&#160;</a></span>SocketCommon_get_dns_resolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a> SocketCommon_get_dns_resolver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get global DNS resolver instance. </p>
<dl class="section return"><dt>Returns</dt><dd>Global DNS resolver (lazily initialized on first call) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes - uses pthread_once for initialization </dd>
<dd>
The global DNS resolver is shared across all Socket and SocketDgram operations. It provides timeout guarantees for DNS resolution. </dd></dl>

</div>
</div>
<a id="ga4abf1412f29d6cec69326ca2a10e9e21" name="ga4abf1412f29d6cec69326ca2a10e9e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4abf1412f29d6cec69326ca2a10e9e21">&#9670;&#160;</a></span>SocketCommon_get_dns_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_get_dns_timeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current global DNS timeout. </p>
<dl class="section return"><dt>Returns</dt><dd>Current timeout in milliseconds (0 = infinite) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd></dl>

</div>
</div>
<a id="gab555c6739c1f1582b1d1aebfb008897e" name="gab555c6739c1f1582b1d1aebfb008897e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab555c6739c1f1582b1d1aebfb008897e">&#9670;&#160;</a></span>SocketCommon_get_socket_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_get_socket_family </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get socket's address family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Socket family or AF_UNSPEC on error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses SO_DOMAIN on Linux, falls back to getsockname() on other platforms. </dd></dl>

</div>
</div>
<a id="ga229de2f12f6169d6817195fb6490267d" name="ga229de2f12f6169d6817195fb6490267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga229de2f12f6169d6817195fb6490267d">&#9670;&#160;</a></span>SocketCommon_getoption_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_getoption_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get integer socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor </td></tr>
    <tr><td class="paramname">level</td><td>Option level (SOL_SOCKET, IPPROTO_TCP, etc.) </td></tr>
    <tr><td class="paramname">optname</td><td>Option name (SO_KEEPALIVE, TCP_NODELAY, etc.) </td></tr>
    <tr><td class="paramname">value</td><td>Output pointer for option value </td></tr>
    <tr><td class="paramname">exception_type</td><td>Exception type to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Specified</td><td>exception type on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (operates on single fd) </dd></dl>

</div>
</div>
<a id="ga5c81dabc2c964625f56fd02b0a4f9c93" name="ga5c81dabc2c964625f56fd02b0a4f9c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c81dabc2c964625f56fd02b0a4f9c93">&#9670;&#160;</a></span>SocketCommon_getoption_timeval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_getoption_timeval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timeval socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor </td></tr>
    <tr><td class="paramname">level</td><td>Option level (SOL_SOCKET) </td></tr>
    <tr><td class="paramname">optname</td><td>Option name (SO_RCVTIMEO, SO_SNDTIMEO) </td></tr>
    <tr><td class="paramname">tv</td><td>Output pointer for timeval structure </td></tr>
    <tr><td class="paramname">exception_type</td><td>Exception type to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Specified</td><td>exception type on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (operates on single fd) </dd></dl>

</div>
</div>
<a id="gab28feafa0784876f732f4b79e03dcc8b" name="gab28feafa0784876f732f4b79e03dcc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28feafa0784876f732f4b79e03dcc8b">&#9670;&#160;</a></span>SocketCommon_handle_bind_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_handle_bind_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log and raise bind error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>errno from bind </td></tr>
    <tr><td class="paramname">addr_str</td><td>Addr string for log </td></tr>
    <tr><td class="paramname">exc_type</td><td>Type to raise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Graceful for non-fatal (e.g., EADDRINUSE log warn return -1), fatal raise </dd></dl>

</div>
</div>
<a id="ga5641340520942ec7ba2412f3d50f3f12" name="ga5641340520942ec7ba2412f3d50f3f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5641340520942ec7ba2412f3d50f3f12">&#9670;&#160;</a></span>SocketCommon_has_cloexec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_has_cloexec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if close-on-exec flag is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if CLOEXEC is set, 0 if not set, -1 on error </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (operates on single fd) </dd></dl>

</div>
</div>
<a id="ga1aa5d2cb4d591e902973e55dc9f1282d" name="ga1aa5d2cb4d591e902973e55dc9f1282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa5d2cb4d591e902973e55dc9f1282d">&#9670;&#160;</a></span>SocketCommon_init_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_init_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize pre-allocated <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> with FD and parameters. </p>
<p>Performs full initialization of a pre-allocated base structure: sets fields, creates per-socket arena, initializes mutex, sets CLOEXEC flag, disables SIGPIPE, caches initial endpoints if possible, initializes timeouts and metrics to defaults. Used when creating sockets from existing FDs (e.g., accept(2), dup(2), or raw socket()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">base</td><td>Pre-allocated base structure (must be zeroed or from CALLOC) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor to associate (must be valid socket FD) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>Address family matching FD (AF_INET, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type matching FD (SOCK_STREAM, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Protocol matching FD (usually 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exc_type</td><td>Exception type for any initialization failures</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exc_type</td><td>on failures: arena alloc, mutex init, fcntl CLOEXEC, getsockname cache</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - assumes exclusive access to base and FD</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - fixed operations + potential getsockname(2)</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <span class="keywordtype">int</span> fd = accept(server_fd, NULL, 0);  <span class="comment">// Or socket(), etc.</span></div>
<div class="line">    <span class="keywordflow">if</span> (fd &gt;= 0) {</div>
<div class="line">        <a class="code hl_struct" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> base = <a class="code hl_define" href="group__foundation.html#gaf5249a1778cd6cf5db0e2e410b292934">CALLOC</a>(arena, 1, <span class="keyword">sizeof</span>(*base));</div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga1aa5d2cb4d591e902973e55dc9f1282d">SocketCommon_init_base</a>(base, fd, AF_INET, SOCK_STREAM, 0,</div>
<div class="line"><a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);</div>
<div class="line">        <span class="comment">// Embed base in Socket_T or SocketDgram_T</span></div>
<div class="line">        <span class="comment">// Update endpoints post-accept via getsockname/getpeername</span></div>
<div class="line">    }</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    close(fd);  <span class="comment">// Cleanup on error</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Takes ownership of fd; closes on error paths via exception handling. </dd>
<dd>
Arena created internally; all subsequent allocations use it. </dd>
<dd>
Mutex initialized to PTHREAD_MUTEX_DEFAULT; recursive locks possible but discouraged. </dd>
<dd>
Endpoints cached if possible (getsockname success); otherwise lazy. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>base must not be used before init; post-init, follow lock protocol. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Alternative to <a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914" title="Create a new socket base structure.">SocketCommon_new_base()</a> when FD pre-exists.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gae9498d7bdb363435a4efce0f32011914" title="Create a new socket base structure.">SocketCommon_new_base()</a> for allocation + init in one step </dd>
<dd>
<a class="el" href="group__core__io.html#ga64fef3c801aa2661b32ec73f368458f0" title="Create a new socket file descriptor with error handling and CLOEXEC setup.">SocketCommon_create_fd()</a> for creating FD prior to init </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html#aea794adfcbc6ada8bf713a09c15b6ed4" title="Set FD_CLOEXEC flag with error handling.">SocketCommon_setcloexec_with_error()</a> internal CLOEXEC call </dd>
<dd>
<a class="el" href="group__core__io.html#gae2e1b3e6d9c494062a97bcc88a0e6a97" title="Update local endpoint information from getsockname.">SocketCommon_update_local_endpoint()</a> for post-bind endpoint refresh </dd>
<dd>
docs/ERROR_HANDLING.md for TRY/EXCEPT patterns with FD cleanup </dd></dl>

</div>
</div>
<a id="ga59068eaf0e0e017bb7492f2804a342b5" name="ga59068eaf0e0e017bb7492f2804a342b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59068eaf0e0e017bb7492f2804a342b5">&#9670;&#160;</a></span>SocketCommon_join_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_join_multicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join multicast group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base with fd (must be datagram for standard use) </td></tr>
    <tr><td class="paramname">group</td><td>Multicast group string (e.g., "239.0.0.1" or "ff02::1") </td></tr>
    <tr><td class="paramname">interface</td><td>Interface IP or NULL for default </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Resolves group, joins via setsockopt based on family (IPv4/IPv6) </dd>
<dd>
Handles resolution, interface setup, family-specific mreq </dd>
<dd>
Thread-safe for own fd </dd></dl>

</div>
</div>
<a id="ga1c4923693d222515c078f6bcfbf9d0f5" name="ga1c4923693d222515c078f6bcfbf9d0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c4923693d222515c078f6bcfbf9d0f5">&#9670;&#160;</a></span>SocketCommon_leave_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_leave_multicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leave multicast group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base with fd </td></tr>
    <tr><td class="paramname">group</td><td>Multicast group string </td></tr>
    <tr><td class="paramname">interface</td><td>Interface IP or NULL </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Symmetric to join; drops membership via setsockopt </dd></dl>

</div>
</div>
<a id="gae9498d7bdb363435a4efce0f32011914" name="gae9498d7bdb363435a4efce0f32011914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9498d7bdb363435a4efce0f32011914">&#9670;&#160;</a></span>SocketCommon_new_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a> SocketCommon_new_base </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new socket base structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Address family (AF_INET, AF_INET6, AF_UNIX). </td></tr>
    <tr><td class="paramname">type</td><td>Socket type (SOCK_STREAM, SOCK_DGRAM). </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol (usually 0 for default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New socket base instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketCommon_Failed</td><td>on allocation failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68b10ea8fcfd5f154b54d81a8000c827" name="ga68b10ea8fcfd5f154b54d81a8000c827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68b10ea8fcfd5f154b54d81a8000c827">&#9670;&#160;</a></span>SocketCommon_normalize_wildcard_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketCommon_normalize_wildcard_host </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize wildcard/any-address host strings to NULL for internal use. </p>
<p>Converts common wildcard address strings to NULL, which is the canonical representation for "bind/connect to any interface" in socket operations. This simplifies internal logic in bind/connect where NULL host means INADDR_ANY.</p>
<p>Recognized wildcards:</p><ul>
<li>NULL input -&gt; NULL (already canonical)</li>
<li>"0.0.0.0" -&gt; NULL (IPv4 any)</li>
<li>"::" -&gt; NULL (IPv6 any) Other strings returned unchanged (caller responsible for resolution).</li>
</ul>
<p>Does not perform DNS resolution or validation - pure string comparison. Case-sensitive match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>Host string to normalize (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if input represents wildcard/any, otherwise original host string (const). Return value is always either NULL or the input pointer (no allocation).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - read-only string comparison, no shared state.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md502"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *effective_host =</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga68b10ea8fcfd5f154b54d81a8000c827">SocketCommon_normalize_wildcard_host</a>(<span class="stringliteral">&quot;0.0.0.0&quot;</span>);</div>
<div class="line"><span class="comment">// effective_host == NULL</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534">SocketCommon_resolve_address</a>(effective_host, 8080, &amp;hints, &amp;res, ...);  <span class="comment">//</span></div>
<div class="line">Resolves to any local addr</div>
<div class="ttc" id="agroup__core__io_html_ga68b10ea8fcfd5f154b54d81a8000c827"><div class="ttname"><a href="group__core__io.html#ga68b10ea8fcfd5f154b54d81a8000c827">SocketCommon_normalize_wildcard_host</a></div><div class="ttdeci">const char * SocketCommon_normalize_wildcard_host(const char *host)</div><div class="ttdoc">Normalize wildcard/any-address host strings to NULL for internal use.</div></div>
<div class="ttc" id="agroup__core__io_html_ga7fc66958f42deef2824a80188baf4534"><div class="ttname"><a href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534">SocketCommon_resolve_address</a></div><div class="ttdeci">int SocketCommon_resolve_address(const char *host, int port, const struct addrinfo *hints, struct addrinfo **res, Except_T exception_type, int socket_family, int use_exceptions)</div><div class="ttdoc">Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md503"></a>
Non-Wildcard</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *host = <span class="stringliteral">&quot;192.168.1.1&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *norm = <a class="code hl_function" href="group__core__io.html#ga68b10ea8fcfd5f154b54d81a8000c827">SocketCommon_normalize_wildcard_host</a>(host);</div>
<div class="line"><span class="comment">// norm == host (unchanged)</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> and <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> for canonical handling. </dd>
<dd>
Does not handle other wildcard forms like "any" or "*" - only numeric any addresses. </dd>
<dd>
For IPv6, only "::" recognized; full "::0" or others not normalized here.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) average - fixed string comparisons</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> which uses this for wildcard handling </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> and <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> consumers </dd></dl>

</div>
</div>
<a id="gaf8d4b6a3c291b6ebbb73c13743304b42" name="gaf8d4b6a3c291b6ebbb73c13743304b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d4b6a3c291b6ebbb73c13743304b42">&#9670;&#160;</a></span>SocketCommon_parse_ip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_parse_ip </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>family</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate and parse IP address string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_str</td><td>IP address string to validate </td></tr>
    <tr><td class="paramname">family</td><td>Output pointer for address family (AF_INET or AF_INET6), can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if valid IP address, 0 if invalid </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd>
<dd>
Validates both IPv4 and IPv6 addresses. Sets family to AF_INET for IPv4, AF_INET6 for IPv6, or AF_UNSPEC if invalid. </dd></dl>

</div>
</div>
<a id="ga7fc66958f42deef2824a80188baf4534" name="ga7fc66958f42deef2824a80188baf4534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc66958f42deef2824a80188baf4534">&#9670;&#160;</a></span>SocketCommon_resolve_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_resolve_address </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve hostname/port to addrinfo structure using getaddrinfo wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname or IP address (NULL for wildcard/any). </td></tr>
    <tr><td class="paramname">port</td><td>Port number (1 to SOCKET_MAX_PORT). </td></tr>
    <tr><td class="paramname">hints</td><td>Addrinfo hints structure (prepared via <a class="el" href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b" title="Initialize addrinfo hints structure for address resolution operations.">SocketCommon_setup_hints()</a>). </td></tr>
    <tr><td class="paramname">res</td><td>Output pointer to resolved addrinfo list (caller must free with freeaddrinfo()). </td></tr>
    <tr><td class="paramname">exception_type</td><td>Exception type to raise on failure. </td></tr>
    <tr><td class="paramname">socket_family</td><td>Preferred socket family to match (AF_UNSPEC for any). </td></tr>
    <tr><td class="paramname">use_exceptions</td><td>If true, raise exceptions on failure; if false, return error codes and set errno. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (if not using exceptions). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Specified</td><td>exception_type on resolution failure (getaddrinfo errors, invalid port, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses global DNS resolver (<a class="el" href="group__core__io.html#ga70954c6e125769d15ffd6c3e31c89b75" title="Get global DNS resolver instance.">SocketCommon_get_dns_resolver()</a>) for timeout guarantees if hostname provided. </dd>
<dd>
Filters resolved addresses to match socket_family if specified (e.g., AF_INET only). </dd>
<dd>
Caller responsible for validating and freeing the addrinfo chain. </dd>
<dd>
Thread-safe: Yes (uses thread-local error buffers). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b" title="Initialize addrinfo hints structure for address resolution operations.">SocketCommon_setup_hints()</a> for preparing hints structure. </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> and <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> which use this internally. </dd>
<dd>
<a class="el" href="group__core__io.html#ga70954c6e125769d15ffd6c3e31c89b75" title="Get global DNS resolver instance.">SocketCommon_get_dns_resolver()</a> for global DNS timeout configuration. </dd>
<dd>
<a class="el" href="group__core__io.html#ga1d98c31897344c8c2e6e6cde65045f09" title="Deep copy of addrinfo linked list.">SocketCommon_copy_addrinfo()</a> for duplicating resolved chains. </dd>
<dd>
freeaddrinfo(3) for cleaning up resolved structures. </dd>
<dd>
docs/ERROR_HANDLING.md for exception patterns in network code. </dd></dl>

</div>
</div>
<a id="ga19eb14b9730f57df54eb5db71e1f5489" name="ga19eb14b9730f57df54eb5db71e1f5489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19eb14b9730f57df54eb5db71e1f5489">&#9670;&#160;</a></span>SocketCommon_reverse_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_reverse_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>hostlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>serv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>servlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform reverse DNS lookup (getnameinfo wrapper) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Socket address to look up </td></tr>
    <tr><td class="paramname">addrlen</td><td>Length of socket address </td></tr>
    <tr><td class="paramname">host</td><td>Output buffer for hostname (NULL to skip) </td></tr>
    <tr><td class="paramname">hostlen</td><td>Size of host buffer </td></tr>
    <tr><td class="paramname">serv</td><td>Output buffer for service/port (NULL to skip) </td></tr>
    <tr><td class="paramname">servlen</td><td>Size of service buffer </td></tr>
    <tr><td class="paramname">flags</td><td>getnameinfo flags (NI_NUMERICHOST, NI_NAMEREQD, etc.) </td></tr>
    <tr><td class="paramname">exception_type</td><td>Exception type to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Specified</td><td>exception type on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd>
<dd>
Wrapper around getnameinfo() for reverse DNS lookups. </dd>
<dd>
Use NI_NUMERICHOST flag to get numeric IP address instead of hostname. </dd></dl>

</div>
</div>
<a id="gac37fe3d789eae0e522f29fca1ec49956" name="gac37fe3d789eae0e522f29fca1ec49956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac37fe3d789eae0e522f29fca1ec49956">&#9670;&#160;</a></span>socketcommon_sanitize_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketcommon_sanitize_timeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sanitize raw timeout value, applying library policy for valid range. </p>
<p>Clamps and normalizes timeout milliseconds to prevent invalid or overflow values in socket operations. Library policy:</p><ul>
<li>Negative: Treated as 0 (no timeout/infinite)</li>
<li>Zero: No timeout</li>
<li>Positive huge (&gt;INT_MAX): Clamped to INT_MAX</li>
<li>Invalid input (e.g., NaN if float cast): -1 error</li>
</ul>
<p>Used defensively in all timeout setters (connect_ms, send_ms, etc.) to ensure safe values before applying to base.timeouts or SO_*TIMEO options.</p>
<p>Input/Output Mapping</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Input (ms)   </th><th class="markdownTableHeadNone">Output (ms)   </th><th class="markdownTableHeadNone">Behavior    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">&lt; 0   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Infinite/no timeout    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">No timeout    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1..INT_MAX   </td><td class="markdownTableBodyNone">unchanged   </td><td class="markdownTableBodyNone">Valid timeout    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">&gt; INT_MAX   </td><td class="markdownTableBodyNone">INT_MAX   </td><td class="markdownTableBodyNone">Clamped max    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Invalid   </td><td class="markdownTableBodyNone">-1   </td><td class="markdownTableBodyNone">Error (caller handles)   </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Raw timeout value from config or user input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sanitized timeout (&gt;=0 valid, -1 error)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- returns error code instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no state</dt><dd></dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - simple comparisons and clamps</dt><dd></dd></dl>
<p>Usage Example</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> safe_timeout = <a class="code hl_function" href="group__core__io.html#gac37fe3d789eae0e522f29fca1ec49956">socketcommon_sanitize_timeout</a>(user_config-&gt;connect_ms);</div>
<div class="line"><span class="keywordflow">if</span> (safe_timeout &lt; 0) {</div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;Invalid timeout; using default&quot;</span>);</div>
<div class="line">    safe_timeout = <a class="code hl_define" href="group__foundation.html#gaaa099b2101176b12abb25299a6ac5bd1">SOCKET_DEFAULT_CONNECT_TIMEOUT_MS</a>;</div>
<div class="line">}</div>
<div class="line">base-&gt;timeouts.connect_ms = safe_timeout;</div>
<div class="ttc" id="agroup__core__io_html_gac37fe3d789eae0e522f29fca1ec49956"><div class="ttname"><a href="group__core__io.html#gac37fe3d789eae0e522f29fca1ec49956">socketcommon_sanitize_timeout</a></div><div class="ttdeci">int socketcommon_sanitize_timeout(int timeout_ms)</div><div class="ttdoc">Sanitize raw timeout value, applying library policy for valid range.</div></div>
<div class="ttc" id="agroup__foundation_html_gaaa099b2101176b12abb25299a6ac5bd1"><div class="ttname"><a href="group__foundation.html#gaaa099b2101176b12abb25299a6ac5bd1">SOCKET_DEFAULT_CONNECT_TIMEOUT_MS</a></div><div class="ttdeci">#define SOCKET_DEFAULT_CONNECT_TIMEOUT_MS</div><div class="ttdoc">Default connect timeout.</div><div class="ttdef"><b>Definition</b> <a href="SocketConfig_8h_source.html#l01379">SocketConfig.h:1379</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Prevents signed overflow in time calculations (e.g., SocketTimeout_deadline_ms). </dd>
<dd>
Consistent policy across all timeout fields in <a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callers must check return &lt;0 and fallback to defaults. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="group__core__io.html#ga65d501b6ffc63a265a180b903abb26ef" title="Set timeouts configuration in the socket base structure.">SocketBase_set_timeouts()</a> and option setters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#structSocketTimeouts__T" title="Basic timeout configuration structure for socket operations.">SocketTimeouts_T</a> fields (connect_ms, send_ms, recv_ms, dns_ms) </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html#a3ed109beae3f198d1714566573eb7366" title="Set socket-level timeout for I/O operations.">SocketCommon_settimeout()</a> for applying to SO_SNDTIMEO/SO_RCVTIMEO </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">core/SocketConfig.h</a> for default timeout constants </dd>
<dd>
docs/TIMEOUTS.md for timeout configuration guide </dd></dl>

</div>
</div>
<a id="gac32f45a0216c1be50d0a411459bc426c" name="gac32f45a0216c1be50d0a411459bc426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32f45a0216c1be50d0a411459bc426c">&#9670;&#160;</a></span>SocketCommon_set_cloexec_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_set_cloexec_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set close-on-exec flag on fd (unifies dups) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor </td></tr>
    <tr><td class="paramname">enable</td><td>True to enable FD_CLOEXEC </td></tr>
    <tr><td class="paramname">exc_type</td><td>Raise on fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses fcntl F_SETFD; called after socket()/socketpair()/accept() fallback </dd></dl>

</div>
</div>
<a id="ga8df045c4215eb7538ad543cd9368864c" name="ga8df045c4215eb7538ad543cd9368864c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8df045c4215eb7538ad543cd9368864c">&#9670;&#160;</a></span>SocketCommon_set_dns_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_set_dns_timeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global DNS resolution timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds (0 = infinite, -1 = use default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes - protected by mutex </dd>
<dd>
Affects all subsequent hostname resolution via Socket/SocketDgram APIs. </dd>
<dd>
Default: SOCKET_DEFAULT_DNS_TIMEOUT_MS (5000ms) </dd>
<dd>
Setting timeout_ms to 0 disables timeout (infinite wait). </dd>
<dd>
Setting timeout_ms to -1 resets to default. </dd></dl>

</div>
</div>
<a id="gaff179c5fc64896d364008582e755a8c4" name="gaff179c5fc64896d364008582e755a8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff179c5fc64896d364008582e755a8c4">&#9670;&#160;</a></span>SocketCommon_set_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_set_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base with fd </td></tr>
    <tr><td class="paramname">enable</td><td>True to enable non-block </td></tr>
    <tr><td class="paramname">exc_type</td><td>Raise on fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unifies duplicated fcntl calls for O_NONBLOCK </dd></dl>

</div>
</div>
<a id="ga0a2e7917d36f5e23eab8c1238433dfba" name="ga0a2e7917d36f5e23eab8c1238433dfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2e7917d36f5e23eab8c1238433dfba">&#9670;&#160;</a></span>SocketCommon_set_option_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_set_option_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set integer socket option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base with fd </td></tr>
    <tr><td class="paramname">level</td><td>Option level (SOL_SOCKET, IPPROTO_TCP, etc.) </td></tr>
    <tr><td class="paramname">optname</td><td>Option name (SO_REUSEADDR, TCP_NODELAY, etc.) </td></tr>
    <tr><td class="paramname">value</td><td>Value to set </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception to raise on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Generic setter for standard socket options, unifies duplicated setsockopt calls </dd>
<dd>
Thread-safe: Yes for own resources </dd></dl>

</div>
</div>
<a id="ga1eab30cecc7dae2a4c02efd95c5feae5" name="ga1eab30cecc7dae2a4c02efd95c5feae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eab30cecc7dae2a4c02efd95c5feae5">&#9670;&#160;</a></span>SocketCommon_set_ttl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_set_ttl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set TTL or hop limit based on family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base with fd </td></tr>
    <tr><td class="paramname">family</td><td>AF_INET or AF_INET6 </td></tr>
    <tr><td class="paramname">ttl</td><td>TTL value </td></tr>
    <tr><td class="paramname">exc_type</td><td>Raise on fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unifies set_ipv4_ttl and set_ipv6_hop_limit </dd></dl>

</div>
</div>
<a id="gad3eb3f6fe09b2b58693a7044631916d8" name="gad3eb3f6fe09b2b58693a7044631916d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3eb3f6fe09b2b58693a7044631916d8">&#9670;&#160;</a></span>SocketCommon_setcloexec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_setcloexec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or clear the close-on-exec (CLOEXEC) flag on a file descriptor. </p>
<p>Modifies the FD_CLOEXEC file descriptor flag using fcntl(F_SETFD) to control whether the file descriptor is automatically closed across execve() calls (e.g., fork+exec).</p>
<p>Enabling CLOEXEC (enable=1) is a security best practice to prevent unintended FD leakage to child processes in multi-process applications. Disabling (enable=0) is rarely needed but supported for compatibility.</p>
<p>This function is called automatically after socket(), accept(), etc., to ensure library sockets have CLOEXEC set by default (configurable via SocketConfig).</p>
<p>On failure, sets errno to EBADF (invalid fd) or EINVAL (invalid flag).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor to modify (must be valid open FD). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Non-zero to set FD_CLOEXEC, 0 to clear it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure (errno set).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>- uses return code/errno convention.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - fcntl operates on single FD atomically.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md506"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Enable CLOEXEC on newly created socket FD</span></div>
<div class="line"><span class="keywordtype">int</span> sock_fd = socket(AF_INET, SOCK_STREAM, 0);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#gad3eb3f6fe09b2b58693a7044631916d8">SocketCommon_setcloexec</a>(sock_fd, 1) &lt; 0) {</div>
<div class="line">    close(sock_fd);</div>
<div class="line">    perror(<span class="stringliteral">&quot;Failed to set CLOEXEC&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Now safe for exec after fork</span></div>
<div class="ttc" id="agroup__core__io_html_gad3eb3f6fe09b2b58693a7044631916d8"><div class="ttname"><a href="group__core__io.html#gad3eb3f6fe09b2b58693a7044631916d8">SocketCommon_setcloexec</a></div><div class="ttdeci">int SocketCommon_setcloexec(int fd, int enable)</div><div class="ttdoc">Set or clear the close-on-exec (CLOEXEC) flag on a file descriptor.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md507"></a>
Disable for Specific FD</h2>
<div class="fragment"><div class="line"><span class="comment">// Rare: clear CLOEXEC (e.g., for FD passing)</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gad3eb3f6fe09b2b58693a7044631916d8">SocketCommon_setcloexec</a>(fd, 0);  <span class="comment">// Allows FD to survive exec</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Automatically called by library after socket creation for security hardening. </dd>
<dd>
Equivalent to fcntl(fd, F_SETFD, enable ? FD_CLOEXEC : 0) </dd>
<dd>
On failure, check errno: EBADF invalid fd, EINVAL bad flag value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Always enable CLOEXEC unless FD inheritance is explicitly needed (security risk).</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single fcntl system call</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga5641340520942ec7ba2412f3d50f3f12" title="Check if close-on-exec flag is set.">SocketCommon_has_cloexec()</a> to query current flag state </dd>
<dd>
fcntl(2) F_SETFD/F_GETFD for POSIX details </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> for FD leakage prevention best practices </dd></dl>

</div>
</div>
<a id="ga47abb5d32959260cc8251419d652de1b" name="ga47abb5d32959260cc8251419d652de1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47abb5d32959260cc8251419d652de1b">&#9670;&#160;</a></span>SocketCommon_setup_hints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_setup_hints </td>
          <td>(</td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socktype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize addrinfo hints structure for address resolution operations. </p>
<p>Prepares a struct addrinfo hints for use with getaddrinfo() or <a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a>. This function ensures dual-stack IPv4/IPv6 support by setting ai_family to AF_UNSPEC, and configures the socket type and additional resolution flags. The hints structure must be zero-initialized before calling this function to avoid garbage data.</p>
<p>Important notes:</p><ul>
<li>Always zero the hints structure first with memset(hints, 0,
sizeof(*hints))</li>
<li>ai_protocol remains 0 (default protocol for socktype)</li>
<li>For binding operations, use AI_PASSIVE | AI_ADDRCONFIG flags</li>
<li>For connecting/sending, use AI_ADDRCONFIG for preferring configured interfaces</li>
<li>This setup enables Happy Eyeballs (RFC 6555) compatible resolution when used with SocketDNS</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hints</td><td>Pointer to addrinfo structure to initialize. Must point to valid memory. The structure will be zeroed and configured with standard values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">socktype</td><td>Socket type: SOCK_STREAM for TCP, SOCK_DGRAM for UDP. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Resolution flags: e.g., AI_PASSIVE for bind, 0 for connect/sendto. Common combinations: AI_PASSIVE | AI_ADDRCONFIG for servers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None (void function)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - operates only on caller-provided structure, no shared</dt><dd>state.</dd></dl>
<h2><a class="anchor" id="autotoc_md496"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// For TCP server bind (passive mode)</span></div>
<div class="line"><span class="keyword">struct </span>addrinfo hints, *res;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b">SocketCommon_setup_hints</a>(&amp;hints, SOCK_STREAM, AI_PASSIVE | AI_ADDRCONFIG);</div>
<div class="line"><span class="keywordtype">int</span> rv = getaddrinfo(<span class="stringliteral">&quot;0.0.0.0&quot;</span>, <span class="stringliteral">&quot;8080&quot;</span>, &amp;hints, &amp;res);</div>
<div class="line"><span class="keywordflow">if</span> (rv == 0) {</div>
<div class="line">    <span class="comment">// Use res for binding</span></div>
<div class="line">    freeaddrinfo(res);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__io_html_ga47abb5d32959260cc8251419d652de1b"><div class="ttname"><a href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b">SocketCommon_setup_hints</a></div><div class="ttdeci">void SocketCommon_setup_hints(struct addrinfo *hints, int socktype, int flags)</div><div class="ttdoc">Initialize addrinfo hints structure for address resolution operations.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md497"></a>
Client Connection Setup</h2>
<div class="fragment"><div class="line"><span class="comment">// For TCP client connect</span></div>
<div class="line"><span class="keyword">struct </span>addrinfo hints;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga47abb5d32959260cc8251419d652de1b">SocketCommon_setup_hints</a>(&amp;hints, SOCK_STREAM, AI_ADDRCONFIG);</div>
<div class="line"><span class="keyword">struct </span>addrinfo *res;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534">SocketCommon_resolve_address</a>(<span class="stringliteral">&quot;example.com&quot;</span>, 80, &amp;hints, &amp;res, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>,</div>
<div class="line">AF_UNSPEC, 1);</div>
<div class="line"><span class="comment">// Use res...</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga6c73595d93eeee7b21ad12b980770f5a">SocketCommon_free_addrinfo</a>(res);  <span class="comment">// If copied, use this instead of</span></div>
<div class="line">freeaddrinfo</div>
<div class="ttc" id="agroup__core__io_html_ga6c73595d93eeee7b21ad12b980770f5a"><div class="ttname"><a href="group__core__io.html#ga6c73595d93eeee7b21ad12b980770f5a">SocketCommon_free_addrinfo</a></div><div class="ttdeci">void SocketCommon_free_addrinfo(struct addrinfo *ai)</div><div class="ttdoc">Free addrinfo chain created by copy_addrinfo.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Always pair with <a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> for exception-safe resolution. </dd>
<dd>
For Unix domain sockets, set ai_family = AF_UNIX manually after this call. </dd>
<dd>
This function does not set ai_protocol; it defaults to 0 (auto-select).</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - constant time memory operations</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> for complete resolution with error handling </dd>
<dd>
getaddrinfo(3) for POSIX specification </dd>
<dd>
<a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a> and <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> which use similar setup internally </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for advanced resolution patterns with SocketDNS </dd></dl>

</div>
</div>
<a id="gab2a42dead580007f2f04aac09eabf7a4" name="gab2a42dead580007f2f04aac09eabf7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a42dead580007f2f04aac09eabf7a4">&#9670;&#160;</a></span>SocketCommon_shutdown_globals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_shutdown_globals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown global resources (e.g., DNS resolver) to prevent leaks in testsCall at program exit after all operations complete. </p>
<dl class="section user"><dt>Thread Safety\n Yes - but call from main thread only.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Frees global DNS resolver and other static resources. </dd></dl>

</div>
</div>
<a id="gaad5b4b92ce57c8168a7cb4462ee73d99" name="gaad5b4b92ce57c8168a7cb4462ee73d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad5b4b92ce57c8168a7cb4462ee73d99">&#9670;&#160;</a></span>SocketCommon_sync_iov_progress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_sync_iov_progress </td>
          <td>(</td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sync original iovec with working copy progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>Original iovec array to update </td></tr>
    <tr><td class="paramname">copy</td><td>Working copy that has been advanced </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of iovec structures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Updates the original iovec array to reflect progress made in the copy. </dd>
<dd>
Used when recvvall needs to update caller's iovec on partial completion. </dd>
<dd>
Thread-safe: Yes (local ops) </dd></dl>

</div>
</div>
<a id="gad2318fb3606f6a71c2a11e247ff876d5" name="gad2318fb3606f6a71c2a11e247ff876d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2318fb3606f6a71c2a11e247ff876d5">&#9670;&#160;</a></span>SocketCommon_timeouts_getdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_timeouts_getdefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get global default timeouts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeouts</td><td>Output pointer for timeout structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (uses mutex protection) </dd></dl>

</div>
</div>
<a id="ga98a87ba229cdf264bec87129ce8918f5" name="ga98a87ba229cdf264bec87129ce8918f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a87ba229cdf264bec87129ce8918f5">&#9670;&#160;</a></span>SocketCommon_timeouts_setdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_timeouts_setdefaults </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#structSocketTimeouts__T">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global default timeouts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeouts</td><td>Timeout values to set as defaults </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (uses mutex protection) </dd></dl>

</div>
</div>
<a id="gaecff13e4edc3230da4141714e2e9297f" name="gaecff13e4edc3230da4141714e2e9297f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecff13e4edc3230da4141714e2e9297f">&#9670;&#160;</a></span>SocketCommon_try_bind_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_try_bind_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try bind fd to address (extracted from Socket.c) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base with fd </td></tr>
    <tr><td class="paramname">addr</td><td>Address to bind </td></tr>
    <tr><td class="paramname">addrlen</td><td>Addr length </td></tr>
    <tr><td class="paramname">exc_type</td><td>Raise on fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success, -1 fail (raises on error) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Integrates with base endpoints if success (caller handles) </dd></dl>

</div>
</div>
<a id="gae257e8500385dffd243e9be383ade862" name="gae257e8500385dffd243e9be383ade862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae257e8500385dffd243e9be383ade862">&#9670;&#160;</a></span>SocketCommon_try_bind_resolved_addresses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCommon_try_bind_resolved_addresses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try bind to resolved addrinfo list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base with fd </td></tr>
    <tr><td class="paramname">res</td><td>addrinfo list from resolve </td></tr>
    <tr><td class="paramname">family</td><td>Preferred family (AF_INET etc) </td></tr>
    <tr><td class="paramname">exc_type</td><td>Raise on all fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 success (bound to first successful), -1 fail </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Loops addresses, calls try_bind_address, sets base local endpoint on success </dd>
<dd>
Handles dual-stack, reuseaddr hints via set_option_int </dd></dl>

</div>
</div>
<a id="gae2e1b3e6d9c494062a97bcc88a0e6a97" name="gae2e1b3e6d9c494062a97bcc88a0e6a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e1b3e6d9c494062a97bcc88a0e6a97">&#9670;&#160;</a></span>SocketCommon_update_local_endpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_update_local_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update local endpoint information from getsockname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Socket base to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Non-raising helper for updating local address/port after bind. </dd></dl>

</div>
</div>
<a id="ga552530543d655ce8871dcfe96a6675fb" name="ga552530543d655ce8871dcfe96a6675fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552530543d655ce8871dcfe96a6675fb">&#9670;&#160;</a></span>SocketCommon_validate_host_not_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_validate_host_not_null </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate host is not NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Host string to validate </td></tr>
    <tr><td class="paramname">exception_type</td><td>Exception type to raise on NULL host </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Specified</td><td>exception type if host is NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes </dd></dl>

</div>
</div>
<a id="gab782ed7ac027b9d3c92cb4bef1b20b4a" name="gab782ed7ac027b9d3c92cb4bef1b20b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab782ed7ac027b9d3c92cb4bef1b20b4a">&#9670;&#160;</a></span>SocketCommon_validate_hostname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_validate_hostname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that a hostname string is not excessively long for system buffers. </p>
<p>Checks the length of the hostname string against the maximum allowed for system network functions (typically NI_MAXHOST or 255 bytes). Too long hostnames can cause failures in getaddrinfo(), getnameinfo(), etc. Raises exception with details on failure.</p>
<p>This validation prevents buffer overflows or truncation in underlying system calls. Does not perform DNS resolution or syntax validation - only length check. NULL host is considered invalid (use SocketCommon_validate_host_not_null for that).</p>
<p>Defined max length: SOCKET_MAX_HOSTNAME_LEN (from <a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a>, usually 255)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host</td><td>C-string hostname to validate (non-NULL expected). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_type</td><td><a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> to raise if length exceeds limit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None (void) - raises on failure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception_type</td><td>with message detailing the length violation and max allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads only, no shared state.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md501"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *hostname = <span class="stringliteral">&quot;example.com&quot;</span>;</div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gab782ed7ac027b9d3c92cb4bef1b20b4a">SocketCommon_validate_hostname</a>(hostname, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);</div>
<div class="line">    <span class="comment">// Safe to use in resolve_address or connect</span></div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534">SocketCommon_resolve_address</a>(hostname, 80, &amp;hints, &amp;res, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>,</div>
<div class="line">AF_UNSPEC, 1); } <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) { <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Hostname too</span></div>
<div class="line"><span class="stringliteral">long: %s&quot;</span>, hostname); } <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_gab782ed7ac027b9d3c92cb4bef1b20b4a"><div class="ttname"><a href="group__core__io.html#gab782ed7ac027b9d3c92cb4bef1b20b4a">SocketCommon_validate_hostname</a></div><div class="ttdeci">void SocketCommon_validate_hostname(const char *host, Except_T exception_type)</div><div class="ttdoc">Validate that a hostname string is not excessively long for system buffers.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Call before resolution to catch early. </dd>
<dd>
For IP addresses, length check still applies but usually pass. </dd>
<dd>
Does not check for valid hostname format (use regex or library if needed).</dd></dl>
<dl class="section user"><dt>Complexity\n O(n) where n=strlen(host) - linear scan for length.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804" title="Validate that a port number is within the valid range for socket operations.">SocketCommon_validate_port()</a> companion function </dd>
<dd>
<a class="el" href="group__core__io.html#ga552530543d655ce8871dcfe96a6675fb" title="Validate host is not NULL.">SocketCommon_validate_host_not_null()</a> for NULL check </dd>
<dd>
<a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> internal caller </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> SOCKET_MAX_HOSTNAME_LEN constant </dd></dl>

</div>
</div>
<a id="gac849aa92d4bd728b61c37b6e63e2a804" name="gac849aa92d4bd728b61c37b6e63e2a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac849aa92d4bd728b61c37b6e63e2a804">&#9670;&#160;</a></span>SocketCommon_validate_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketCommon_validate_port </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exception_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that a port number is within the valid range for socket operations. </p>
<p>Ensures the provided port is between 0 and 65535 inclusive. Port 0 is allowed for cases where the OS assigns an ephemeral port (e.g., during bind for outgoing connections). Invalid ports trigger an immediate exception raise with a descriptive message including the invalid value.</p>
<p>This function is used internally by resolution and bind/connect operations to catch invalid port parameters early. It does not perform any system calls or allocations.</p>
<p>Edge cases:</p><ul>
<li>port &lt; 0: Invalid, raises exception</li>
<li>port == 0: Valid (ephemeral)</li>
<li>port &gt; 65535: Invalid, raises exception</li>
<li>Non-integer ports: Caller responsibility (port is int param)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port number to validate (int value). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exception_type</td><td><a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> type to raise on validation failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None (void function) - raises exception on failure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception_type</td><td>with message "Invalid port number: %d (must be
0-65535, 0 = OS-assigned)" where d is the invalid port value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - no shared state or system calls, pure validation.</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md498"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// In connect or bind preparation</span></div>
<div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804">SocketCommon_validate_port</a>(8080, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);</div>
<div class="line">    <span class="comment">// Proceed with bind/connect using port 8080</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// This won&#39;t trigger for valid port</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_gac849aa92d4bd728b61c37b6e63e2a804"><div class="ttname"><a href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804">SocketCommon_validate_port</a></div><div class="ttdeci">void SocketCommon_validate_port(int port, Except_T exception_type)</div><div class="ttdoc">Validate that a port number is within the valid range for socket operations.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md499"></a>
With Ephemeral Port</h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ephemeral_port = 0;  <span class="comment">// OS assign</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804">SocketCommon_validate_port</a>(ephemeral_port, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);  <span class="comment">// Valid, no</span></div>
<div class="line">exception</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md500"></a>
Invalid Port Handling</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804">SocketCommon_validate_port</a>(70000, <a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>);  <span class="comment">// Raises exception</span></div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="comment">// Caught here with detailed message</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = Except_message(<a class="code hl_variable" href="group__foundation.html#ga3d38c6361ecf1c4873bbcb2de8a50874">Except_stack</a>);  <span class="comment">// Access error details</span></div>
<div class="line">    <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Port validation failed: %s&quot;</span>, msg);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Commonly called before getaddrinfo(), <a class="el" href="group__core__io.html#gacb65d693d8c93e2a1fe6411dd0d0af98" title="Bind a socket to a local IP address and port.">Socket_bind()</a>, <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a>. </dd>
<dd>
For string ports, validate after parsing with strtol() or similar. </dd>
<dd>
Does not check privileged ports (&lt;1024) - that's OS permission check.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - simple integer comparison</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gab782ed7ac027b9d3c92cb4bef1b20b4a" title="Validate that a hostname string is not excessively long for system buffers.">SocketCommon_validate_hostname()</a> for host validation </dd>
<dd>
<a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> which calls this internally </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> for port <a class="el" href="group__security.html" title="Comprehensive security protections for network applications.">Security Modules</a> considerations </dd>
<dd>
<a class="el" href="SocketConfig_8h.html" title="Compile-time and runtime configuration constants, limits, and platform adaptations.">SocketConfig.h</a> for <a class="el" href="group__core__io.html#ga5d3af7fc5447a76f5f64430362d6dfcf" title="Maximum TCP/UDP port number.">SOCKET_MAX_PORT</a> definition (usually 65535) </dd></dl>

</div>
</div>
<a id="ga9ed3e966870af6d524f8956253594ef4" name="ga9ed3e966870af6d524f8956253594ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed3e966870af6d524f8956253594ef4">&#9670;&#160;</a></span>socketio_is_connection_closed_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int socketio_is_connection_closed_recv </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if recv error indicates closed connection. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if ECONNRESET, 0 otherwise </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads errno (thread-local in POSIX).</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use after recv() failure to check for connection close.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacc6b10100f449aef91c884fcebc9f9a5" title="Check if errno indicates operation would block.">socketio_is_wouldblock()</a> for non-blocking checks. </dd>
<dd>
<a class="el" href="group__core__io.html#ga74bde3935e0a14d633eb374dada531d1" title="Check if send error indicates closed connection.">socketio_is_connection_closed_send()</a> for send counterpart. </dd>
<dd>
ECONNRESET in &lt;errno.h&gt;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketIO_8h_source.html#l00279">279</a> of file <a class="el" href="SocketIO_8h_source.html">SocketIO.h</a>.</p>

</div>
</div>
<a id="ga74bde3935e0a14d633eb374dada531d1" name="ga74bde3935e0a14d633eb374dada531d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74bde3935e0a14d633eb374dada531d1">&#9670;&#160;</a></span>socketio_is_connection_closed_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int socketio_is_connection_closed_send </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if send error indicates closed connection. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if EPIPE/ECONNRESET, 0 otherwise </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads errno (thread-local in POSIX).</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use after send() failure to check for connection close.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gacc6b10100f449aef91c884fcebc9f9a5" title="Check if errno indicates operation would block.">socketio_is_wouldblock()</a> for non-blocking checks. </dd>
<dd>
<a class="el" href="group__core__io.html#ga9ed3e966870af6d524f8956253594ef4" title="Check if recv error indicates closed connection.">socketio_is_connection_closed_recv()</a> for recv counterpart. </dd>
<dd>
EPIPE and ECONNRESET in &lt;errno.h&gt;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketIO_8h_source.html#l00262">262</a> of file <a class="el" href="SocketIO_8h_source.html">SocketIO.h</a>.</p>

</div>
</div>
<a id="gacc6b10100f449aef91c884fcebc9f9a5" name="gacc6b10100f449aef91c884fcebc9f9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc6b10100f449aef91c884fcebc9f9a5">&#9670;&#160;</a></span>socketio_is_wouldblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int socketio_is_wouldblock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if errno indicates operation would block. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if EAGAIN/EWOULDBLOCK, 0 otherwise </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - reads errno (thread-local in POSIX).</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this instead of inline errno checks for consistency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga74bde3935e0a14d633eb374dada531d1" title="Check if send error indicates closed connection.">socketio_is_connection_closed_send()</a> and <a class="el" href="group__core__io.html#ga9ed3e966870af6d524f8956253594ef4" title="Check if recv error indicates closed connection.">socketio_is_connection_closed_recv()</a> for related error checks. </dd>
<dd>
EAGAIN and EWOULDBLOCK in &lt;errno.h&gt; for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketIO_8h_source.html#l00245">245</a> of file <a class="el" href="SocketIO_8h_source.html">SocketIO.h</a>.</p>

</div>
</div>
<a id="ga433d928caa9de0b29ab9f2d48e166c5c" name="ga433d928caa9de0b29ab9f2d48e166c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433d928caa9de0b29ab9f2d48e166c5c">&#9670;&#160;</a></span>SocketLiveCount_decrement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SocketLiveCount_decrement </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *&#160;</td>
          <td class="paramname"><em>tracker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement live count (thread-safe) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>Live count tracker </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01112">1112</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon_8h_source.html#l01071">SocketLiveCount::count</a>, and <a class="el" href="SocketCommon_8h_source.html#l01072">SocketLiveCount::mutex</a>.</p>

</div>
</div>
<a id="ga02b16726c7750c470af8a59ffe041098" name="ga02b16726c7750c470af8a59ffe041098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02b16726c7750c470af8a59ffe041098">&#9670;&#160;</a></span>SocketLiveCount_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SocketLiveCount_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *&#160;</td>
          <td class="paramname"><em>tracker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current live count (thread-safe) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>Live count tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current count value </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01127">1127</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon_8h_source.html#l01071">SocketLiveCount::count</a>, and <a class="el" href="SocketCommon_8h_source.html#l01072">SocketLiveCount::mutex</a>.</p>

</div>
</div>
<a id="ga93d46dcf1a875ef525eb96d5f2271fb3" name="ga93d46dcf1a875ef525eb96d5f2271fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d46dcf1a875ef525eb96d5f2271fb3">&#9670;&#160;</a></span>SocketLiveCount_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SocketLiveCount_increment </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__core__io.html#structSocketLiveCount">SocketLiveCount</a> *&#160;</td>
          <td class="paramname"><em>tracker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment live count (thread-safe) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>Live count tracker </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SocketCommon_8h_source.html#l01099">1099</a> of file <a class="el" href="SocketCommon_8h_source.html">SocketCommon.h</a>.</p>

<p class="reference">References <a class="el" href="SocketCommon_8h_source.html#l01071">SocketLiveCount::count</a>, and <a class="el" href="SocketCommon_8h_source.html#l01072">SocketLiveCount::mutex</a>.</p>

</div>
</div>
<a id="ga1290da3d1c546b8c550a59e138f722b8" name="ga1290da3d1c546b8c550a59e138f722b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1290da3d1c546b8c550a59e138f722b8">&#9670;&#160;</a></span>SocketPair_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPair_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T *&#160;</td>
          <td class="paramname"><em>socket1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_T *&#160;</td>
          <td class="paramname"><em>socket2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pair of connected Unix domain sockets for inter-process communication. </p>
<p>Creates two connected Unix domain sockets using socketpair(2) system call. The sockets are of the specified type (SOCK_STREAM or SOCK_DGRAM) and are immediately connected to each other. No bind() or connect() is needed. Both sockets are created in blocking mode with default options (CLOEXEC, no SIGPIPE). This is useful for parent-child process communication after fork(), or for thread-to-thread IPC without network stack overhead.</p>
<p>Supported types: SOCK_STREAM (reliable byte stream), SOCK_DGRAM (datagrams). Domain is always AF_UNIX internally.</p>
<p>Edge cases:</p><ul>
<li>Unsupported type raises Socket_Failed (EINVAL)</li>
<li>Resource limits raise Socket_Failed (EMFILE, ENFILE)</li>
<li>On success, both *socket1 and *socket2 are non-NULL and connected.</li>
</ul>
<p>After use, free both sockets with <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Socket type (SOCK_STREAM or SOCK_DGRAM) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">socket1</td><td>First socket of the pair (set to new Socket_T or NULL on error) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">socket2</td><td>Second socket of the pair (set to new Socket_T or NULL on error)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Socket_Failed</td><td>System call failed (EINVAL invalid type, EMFILE/ENFILE too many files, ENOMEM, EAFNOSUPPORT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent socket pair safe from concurrent calls</dt><dd></dd></dl>
<h2><a class="anchor" id="autotoc_md410"></a>
Basic Usage</h2>
<div class="fragment"><div class="line">Socket_T sock1, sock2;</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga1290da3d1c546b8c550a59e138f722b8">SocketPair_new</a>(SOCK_STREAM, &amp;sock1, &amp;sock2);</div>
<div class="line"><span class="comment">// Now sock1 and sock2 are connected</span></div>
<div class="line"><span class="comment">// Send from sock1, receive on sock2, etc.</span></div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock1);</div>
<div class="line"><a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;sock2);</div>
<div class="ttc" id="agroup__core__io_html_ga1290da3d1c546b8c550a59e138f722b8"><div class="ttname"><a href="group__core__io.html#ga1290da3d1c546b8c550a59e138f722b8">SocketPair_new</a></div><div class="ttdeci">void SocketPair_new(int type, Socket_T *socket1, Socket_T *socket2)</div><div class="ttdoc">Create a pair of connected Unix domain sockets for inter-process communication.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md411"></a>
With Error Handling for Fork IPC</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    Socket_T parent_sock, child_sock;</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#ga1290da3d1c546b8c550a59e138f722b8">SocketPair_new</a>(SOCK_STREAM, &amp;parent_sock, &amp;child_sock);</div>
<div class="line">    pid_t pid = fork();</div>
<div class="line">    <span class="keywordflow">if</span> (pid == 0) {  <span class="comment">// Child</span></div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;parent_sock);  <span class="comment">// Close unused</span></div>
<div class="line">        <span class="comment">// Use child_sock for IPC</span></div>
<div class="line">    } <span class="keywordflow">else</span> {  <span class="comment">// Parent</span></div>
<div class="line">        <a class="code hl_function" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37">Socket_free</a>(&amp;child_sock);</div>
<div class="line">        <span class="comment">// Use parent_sock for IPC</span></div>
<div class="line">    }</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    perror(<span class="stringliteral">&quot;Socket pair creation failed&quot;</span>);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Sockets are bidirectional: data sent on one can be received on the other. </dd>
<dd>
For DGRAM type, it's like connected UDP - sendto not needed. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Always free both sockets to avoid fd leaks. </dd>
<dd>
After fork(), close the unused socket in both parent and child to avoid deadlocks.</dd></dl>
<dl class="section user"><dt>Complexity\n O(1) - single socketpair(2) call</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1" title="Create a new socket with specified domain, type, and protocol.">Socket_new()</a> for single socket creation </dd>
<dd>
<a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> for cleanup </dd>
<dd>
<a class="el" href="group__core__io.html#ga001e932180b059a805ca53a8edbeef15" title="Send a file descriptor over Unix domain socket.">Socket_sendfd()</a> for passing fds over Unix sockets </dd>
<dd>
man socketpair(2) for low-level details </dd></dl>

</div>
</div>
<a id="ga197242786615adf218d849747bc0fd67" name="ga197242786615adf218d849747bc0fd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197242786615adf218d849747bc0fd67">&#9670;&#160;</a></span>SocketProxy_config_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketProxy_config_defaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize proxy configuration with safe default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to configuration structure to populate.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets type to SOCKET_PROXY_NONE, clears strings and headers to NULL, sets default ports implicitly via type, and applies module default timeouts. For HTTPS proxies, tls_ctx remains NULL (uses secure defaults if needed).</p>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no shared state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy.html#structSocketProxy__Config" title="Configuration structure for proxy connections.">SocketProxy_Config</a> for field details. </dd>
<dd>
<a class="el" href="group__core__io.html#gae16c20e1d43f38171ccaad8408598490" title="Parse proxy URL string into configuration structure.">SocketProxy_parse_url()</a> for URL-based initialization. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for configuration best practices. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga2853a36e933b9ac3803173169b1b159e" name="ga2853a36e933b9ac3803173169b1b159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2853a36e933b9ac3803173169b1b159e">&#9670;&#160;</a></span>SocketProxy_Conn_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketProxy_Conn_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel ongoing proxy connection and cleanup resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>Immediately aborts operation: closes socket, cancels DNS/timers, transitions to PROXY_STATE_CANCELLED and PROXY_ERROR_CANCELLED. Safe to call from any state; idempotent.</p>
<p>Use to gracefully stop long-running operations or handle app shutdown. After cancel, <a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> will return true; result is CANCELLED. <a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a> returns NULL.</p>
<dl class="section user"><dt>Thread Safety\n No - modifies connection state and closes shared socket.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Does not block; asynchronous cleanup via poll if needed. </dd>
<dd>
Resources freed on next process or free; call free soon after. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Cancelling mid-handshake may leave proxy in inconsistent state.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9" title="Release proxy connection context and associated resources.">SocketProxy_Conn_free()</a> for complete cleanup (auto-cancels if pending). </dd>
<dd>
<a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> will return <a class="el" href="group__core__io.html#ggae980e6a437316380a792464ce32a595ea15fe5e5fc15227e92086cc3c76e468d8">PROXY_ERROR_CANCELLED</a>. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for cancellation patterns in event loops. </dd></dl>

</div>
</div>
<a id="ga93a495a98a7efa7ecc9d42ce838d4a3e" name="ga93a495a98a7efa7ecc9d42ce838d4a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a495a98a7efa7ecc9d42ce838d4a3e">&#9670;&#160;</a></span>SocketProxy_Conn_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketProxy_Conn_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve human-readable error description for failed operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context in FAILED state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const string describing failure (e.g., "Authentication failed"), or NULL if not in FAILED state or no specific message. String allocated from internal arena; valid until <a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9" title="Release proxy connection context and associated resources.">SocketProxy_Conn_free()</a>.</dd></dl>
<p>Provides diagnostic details beyond <a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> code, including protocol responses, system errors, or timeout reasons. Intended for logging; not for programmatic error handling (use result code).</p>
<dl class="section user"><dt>Thread Safety\n No - borrowed reference to internal string buffer.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>String may be truncated for long errors; use for display/logging. </dd>
<dd>
Cleared on cancel or success; check state first. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not free or modify returned string; internal ownership.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> for structured error code. </dd>
<dd>
<a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040" title="Retrieve current state of proxy connection.">SocketProxy_Conn_state()</a> to confirm FAILED state. </dd>
<dd>
<a class="el" href="group__foundation.html#ga1364e85e147f0f6d43c82b4ce3e326c1" title="Emit a log message.">SocketLog_emit()</a> for logging this error. </dd>
<dd>
docs/LOGGING.md for error logging best practices. </dd></dl>

</div>
</div>
<a id="ga8d7492a46210e78249073e289c556ea8" name="ga8d7492a46210e78249073e289c556ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7492a46210e78249073e289c556ea8">&#9670;&#160;</a></span>SocketProxy_Conn_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SocketProxy_Conn_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get poll event mask for current connection phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitmask of SocketPoll_Events (POLL_READ | POLL_WRITE | POLL_ERROR) required for current state (e.g., READ for response, WRITE for request). 0 if no polling needed (terminal states).</dd></dl>
<p>Dynamically updates based on state: e.g., WRITE during send phases, READ during recv. Use with <a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> to update registration.</p>
<dl class="section user"><dt>Thread Safety\n No - reflects current I/O direction.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Compatible with SocketPoll events. </dd>
<dd>
Call before/after state changes or process to refresh mask. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Incorrect events may stall or error the handshake.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga9d1139d24bcabc22e6e2b07762e8f753" title="Get underlying file descriptor for poll integration.">SocketProxy_Conn_fd()</a> to get FD for registration. </dd>
<dd>
<a class="el" href="group__event__system.html#ga3755cc4d5ed8838ce2261f0efd1d5d85" title="Update event monitoring and/or user data for a registered socket.">SocketPoll_mod()</a> for updating event mask. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System</a> for polling mechanics. </dd></dl>

</div>
</div>
<a id="ga9d1139d24bcabc22e6e2b07762e8f753" name="ga9d1139d24bcabc22e6e2b07762e8f753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d1139d24bcabc22e6e2b07762e8f753">&#9670;&#160;</a></span>SocketProxy_Conn_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketProxy_Conn_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get underlying file descriptor for poll integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Socket FD to monitor with <a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a>, or -1 if no active socket (init, completed, or failed state).</dd></dl>
<p>For custom poll loops: add this FD with <a class="el" href="group__core__io.html#ga8d7492a46210e78249073e289c556ea8" title="Get poll event mask for current connection phase.">SocketProxy_Conn_events()</a> mask. Context auto-manages registration if using internal poll, but expose for external or multi-poll scenarios. FD valid while in progress states; deregister on completion/cancel.</p>
<dl class="section user"><dt>Thread Safety\n No - FD may change or close concurrently.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>FD is non-blocking after initial connect. </dd>
<dd>
Use Socket_get_fd() on extracted socket post-success for app polling. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not close or modify FD directly; use conn methods.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga8d7492a46210e78249073e289c556ea8" title="Get poll event mask for current connection phase.">SocketProxy_Conn_events()</a> for required event mask. </dd>
<dd>
<a class="el" href="group__event__system.html#ga6c9f3f1a23dd85dd2d44ff9b0ced4e1e" title="Register a socket for I/O event monitoring within the poll instance.">SocketPoll_add()</a> for registration example. </dd>
<dd>
<a class="el" href="group__event__system.html">Poll module</a> for FD management. </dd></dl>

</div>
</div>
<a id="gafee164cf3e979f5cfe745a33366812d9" name="gafee164cf3e979f5cfe745a33366812d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee164cf3e979f5cfe745a33366812d9">&#9670;&#160;</a></span>SocketProxy_Conn_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketProxy_Conn_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release proxy connection context and associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Pointer to <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T" title="Opaque proxy connection context for managing tunneling negotiation.">SocketProxy_Conn_T</a> (set to NULL on success).</td></tr>
  </table>
  </dd>
</dl>
<p>Frees all allocated resources: socket, internal buffers, timers, DNS requests. If operation pending, auto-cancels first (closes socket, signals completion). Idempotent and null-safe: handles NULL pointer or already-freed context.</p>
<p>Call after successful socket extraction or on error/cancel. For internal resources (from <a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a>), fully self-contained. For external (<a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a>), does not free user-provided dns/poll.</p>
<dl class="section user"><dt>Thread Safety\n No - frees shared state; avoid concurrent access.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Follows Arena-managed pattern but uses internal arena for most allocs. </dd>
<dd>
Socket ownership: If not extracted via <a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a>, socket auto-closed here. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not access conn after free; undefined behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a> before free to transfer socket ownership. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2853a36e933b9ac3803173169b1b159e" title="Cancel ongoing proxy connection and cleanup resources.">SocketProxy_Conn_cancel()</a> for explicit abort without full free. </dd>
<dd>
<a class="el" href="group__foundation.html">Arena module</a> for memory management context. </dd>
<dd>
docs/MEMORY_MANAGEMENT.md for resource lifecycle guidelines. </dd></dl>

</div>
</div>
<a id="ga6d17fac3f6b21b9905aa7c4b0d7d47f7" name="ga6d17fac3f6b21b9905aa7c4b0d7d47f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d17fac3f6b21b9905aa7c4b0d7d47f7">&#9670;&#160;</a></span>SocketProxy_Conn_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> SocketProxy_Conn_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create proxy connection context with blocking proxy connect, async handshake. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Proxy configuration (copied; strings borrowed). </td></tr>
    <tr><td class="paramname">target_host</td><td>Target hostname or IP for tunneling. </td></tr>
    <tr><td class="paramname">target_port</td><td>Target port (1-65535).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T" title="Opaque proxy connection context for managing tunneling negotiation.">SocketProxy_Conn_T</a> on success, NULL on failure. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketProxy_Failed</td><td>on config validation or initial resource allocation failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates isolated instance with internal resources.</dt><dd></dd></dl>
<p>Convenience wrapper for simpler async integration: performs blocking TCP connect and DNS resolution to proxy server (up to connect_timeout_ms), then switches to non-blocking mode for handshake, TLS, auth via internal poll/timer/DNS instances.</p>
<p>Unlike <a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a>, this blocks briefly for proxy reachability but allows event-driven completion of protocol negotiation.</p>
<p>Post-init usage same as async API:</p><ul>
<li>Poll loop: process events  <a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977" title="Advance asynchronous proxy connection state machine.">SocketProxy_Conn_process()</a>  check completion</li>
<li>On done: <a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a> transfers ownership, then free conn</li>
</ul>
<p>Internal resources auto-managed; no external dns/poll required from caller.</p>
<dl class="section note"><dt>Note</dt><dd>Blocks only for proxy connect phase; handshake fully async. </dd>
<dd>
Suitable for apps with existing event loops but wanting quick proxy validation. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Still requires poll integration for full non-blocking after connect. </dd>
<dd>
Internal poll uses epoll/kqueue; ensure compatible with app loop.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a> for fully non-blocking from start (requires external resources). </dd>
<dd>
<a class="el" href="group__core__io.html#gaad72c8e58d88ee4bbc975c9163266ef0" title="Establish synchronous connection to target via proxy tunnel.">SocketProxy_connect()</a> for fully synchronous end-to-end. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977" title="Advance asynchronous proxy connection state machine.">SocketProxy_Conn_process()</a> and friends for runtime management. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System</a> for poll backend details. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a>#hybrid-api for hybrid sync/async patterns. </dd></dl>

</div>
</div>
<a id="gaf64af0e87ee1735152783f2b7fd132c9" name="gaf64af0e87ee1735152783f2b7fd132c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf64af0e87ee1735152783f2b7fd132c9">&#9670;&#160;</a></span>SocketProxy_Conn_next_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketProxy_Conn_next_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate milliseconds until next internal timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Positive: ms until timeout expiry (use for poll timeout). 0: Immediate timeout pending (process urgently). -1: No timeout active (poll indefinitely or use defaults).</dd></dl>
<p>Accounts for connect_timeout_ms, handshake_timeout_ms, and internal timers. Decrements in real-time; call periodically in loop for accuracy. Helps prevent unnecessary busy-polling while respecting deadlines.</p>
<dl class="section user"><dt>Thread Safety\n No - based on volatile monotonic time.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses <a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf" title="Socket_get_monotonic_ms - Get current monotonic time in milliseconds.">Socket_get_monotonic_ms()</a> for precise timing. </dd>
<dd>
Negative values indicate expired timeout (error imminent). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Stale calls may lead to missed deadlines; refresh often.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a> - pass this value as timeout param. </dd>
<dd>
SocketTimeout <a class="el" href="group__utilities.html" title="Helper modules for rate limiting, retry logic, and metrics.">Utilities</a> in SocketUtil for advanced timing. </dd>
<dd>
docs/TIMEOUTS.md for timeout configuration and behavior. </dd></dl>

</div>
</div>
<a id="gac12fc736c9952313a4846dd50380bc3f" name="gac12fc736c9952313a4846dd50380bc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12fc736c9952313a4846dd50380bc3f">&#9670;&#160;</a></span>SocketProxy_Conn_poll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketProxy_Conn_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query if proxy operation has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if operation finished (CONNECTED, FAILED, or CANCELLED state), 0 if still in progress.</dd></dl>
<p>Call after <a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977" title="Advance asynchronous proxy connection state machine.">SocketProxy_Conn_process()</a> in event loop to detect completion. On true, check <a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040" title="Retrieve current state of proxy connection.">SocketProxy_Conn_state()</a> or <a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> for outcome.</p>
<dl class="section user"><dt>Thread Safety\n No - reads shared connection state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040" title="Retrieve current state of proxy connection.">SocketProxy_Conn_state()</a> for detailed status. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> for error/success code. </dd>
<dd>
<a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a> to retrieve tunneled socket on success. </dd></dl>

</div>
</div>
<a id="gaf45ecd7d9e7c6214e6bfcc6b2a42f977" name="gaf45ecd7d9e7c6214e6bfcc6b2a42f977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45ecd7d9e7c6214e6bfcc6b2a42f977">&#9670;&#160;</a></span>SocketProxy_Conn_process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketProxy_Conn_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance asynchronous proxy connection state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context to process.</td></tr>
  </table>
  </dd>
</dl>
<p>Call this after detecting events on <a class="el" href="group__core__io.html#ga9d1139d24bcabc22e6e2b07762e8f753" title="Get underlying file descriptor for poll integration.">SocketProxy_Conn_fd()</a> via your poll loop. Performs non-blocking I/O: reads/writes protocol messages, handles timeouts, advances through handshake phases (TLS, auth, connect response).</p>
<p>May transition state and potentially complete operation; always follow with <a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> to check.</p>
<p>Does nothing if no events pending or in terminal state.</p>
<dl class="section user"><dt>Thread Safety\n No - modifies connection state and socket buffers.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Integrates with SocketPoll; deregisters FD on completion/close. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Must call promptly after events to avoid protocol timeouts. </dd>
<dd>
Not for synchronous use; pair with event-driven polling.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga9d1139d24bcabc22e6e2b07762e8f753" title="Get underlying file descriptor for poll integration.">SocketProxy_Conn_fd()</a> and <a class="el" href="group__core__io.html#ga8d7492a46210e78249073e289c556ea8" title="Get poll event mask for current connection phase.">SocketProxy_Conn_events()</a> for poll setup. </dd>
<dd>
<a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> to check post-process completion. </dd>
<dd>
<a class="el" href="group__event__system.html">Poll module</a> for event handling examples. </dd></dl>

</div>
</div>
<a id="gaf191ce0cae571b057d5ea278392bdf24" name="gaf191ce0cae571b057d5ea278392bdf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf191ce0cae571b057d5ea278392bdf24">&#9670;&#160;</a></span>SocketProxy_Conn_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a> SocketProxy_Conn_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get final result code after operation completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Completed proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SocketProxy_Result indicating outcome (PROXY_OK on success, error code on failure).</dd></dl>
<p>Valid only after <a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> returns 1 (terminal state). Provides protocol-specific error mapping for debugging and retry logic. On success, socket available via <a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a>.</p>
<dl class="section user"><dt>Thread Safety\n No - reads result stored in connection state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e" title="Result codes for proxy operations.">SocketProxy_Result</a> for code meanings. </dd>
<dd>
<a class="el" href="group__core__io.html#ga2a0ac262c4e03ed00c5eeb2aa8d210bd" title="Convert SocketProxy_Result code to descriptive string.">SocketProxy_result_string()</a> for descriptive strings. </dd>
<dd>
<a class="el" href="group__core__io.html#ga93a495a98a7efa7ecc9d42ce838d4a3e" title="Retrieve human-readable error description for failed operations.">SocketProxy_Conn_error()</a> for additional error details. </dd>
<dd>
docs/ERROR_HANDLING.md for error categorization and recovery. </dd></dl>

</div>
</div>
<a id="gaff1d539486b8b250489938c4b71c89a9" name="gaff1d539486b8b250489938c4b71c89a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff1d539486b8b250489938c4b71c89a9">&#9670;&#160;</a></span>SocketProxy_Conn_socket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketProxy_Conn_socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract successfully tunneled socket from completed context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context (must be in CONNECTED state).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success (PROXY_OK and CONNECTED): Socket_T tunneled to target. Ownership transferred to caller; must <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> after use. Otherwise: NULL (failed, cancelled, or pending).</dd></dl>
<p>Call only after <a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> returns true and result is PROXY_OK. Detaches socket from context; subsequent calls return NULL. Socket is non-blocking, connected, and ready for app I/O or TLS handshake.</p>
<dl class="section user"><dt>Thread Safety\n No - transfers ownership and clears internal reference.</dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Socket retains proxy tunnel; transparent to application. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling on non-success states leaks no resources but returns NULL. </dd>
<dd>
Free context after extraction to avoid double-free.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> to verify success before extraction. </dd>
<dd>
<a class="el" href="group__core__io.html#gafee164cf3e979f5cfe745a33366812d9" title="Release proxy connection context and associated resources.">SocketProxy_Conn_free()</a> after successful socket transfer. </dd>
<dd>
<a class="el" href="Socket_8h.html" title="High-level TCP/IP and Unix domain socket interface.">Socket.h</a> for socket operations post-tunnel. </dd>
<dd>
<a class="el" href="group__security.html">TLS module</a> for HTTPS target handshakes. </dd></dl>

</div>
</div>
<a id="ga5f6fd1cde0a54b41805862ce002f6f97" name="ga5f6fd1cde0a54b41805862ce002f6f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6fd1cde0a54b41805862ce002f6f97">&#9670;&#160;</a></span>SocketProxy_Conn_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> SocketProxy_Conn_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dns.html#structSocketDNS__T">SocketDNS_T</a>&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__poll__private.html#structSocketPoll__T">SocketPoll_T</a>&#160;</td>
          <td class="paramname"><em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize and start fully asynchronous proxy tunneling operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dns</td><td>Caller-provided <a class="el" href="group__dns.html#structSocketDNS__T" title="Async DNS resolver structure.">SocketDNS_T</a> instance for proxy server resolution. Must remain valid and operational during entire operation. </td></tr>
    <tr><td class="paramname">poll</td><td>Caller-provided <a class="el" href="group__poll__private.html#structSocketPoll__T" title="Opaque internal state structure for SocketPoll instance.">SocketPoll_T</a> for event notifications. <a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> FD auto-registered; must not be freed prematurely. </td></tr>
    <tr><td class="paramname">proxy</td><td>Proxy configuration (copied internally; strings borrowed). </td></tr>
    <tr><td class="paramname">target_host</td><td>Target hostname or IP to tunnel connection to. </td></tr>
    <tr><td class="paramname">target_port</td><td>Target TCP port number (1-65535).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T" title="Opaque proxy connection context for managing tunneling negotiation.">SocketProxy_Conn_T</a> context on success, NULL on init failure. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketProxy_Failed</td><td>on invalid config or resource allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - context tied to specific dns/poll instances; single-thread</dt><dd>use.</dd></dl>
<p>This low-level API provides complete control for integrating proxy tunneling into custom event loops. It uses provided DNS for non-blocking resolution and poll for I/O events. No blocking calls after initialization.</p>
<p>Integration pattern:</p><ul>
<li>Register conn-&gt;fd with poll if not auto-registered.</li>
<li>Loop: <a class="el" href="group__event__system.html#gaa3d47365dd18329d50ee636284839738" title="Block and wait for I/O events or timeout on registered sockets.">SocketPoll_wait()</a>  <a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977" title="Advance asynchronous proxy connection state machine.">SocketProxy_Conn_process()</a>  check <a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a></li>
<li>On completion: Extract socket with <a class="el" href="group__core__io.html#gaff1d539486b8b250489938c4b71c89a9" title="Extract successfully tunneled socket from completed context.">SocketProxy_Conn_socket()</a>, then free conn.</li>
<li>Cleanup: <a class="el" href="group__core__io.html#ga2853a36e933b9ac3803173169b1b159e" title="Cancel ongoing proxy connection and cleanup resources.">SocketProxy_Conn_cancel()</a> or free during progress.</li>
</ul>
<p>Handles: DNS resolution, TCP connect (HappyEyeballs), TLS (HTTPS), handshake, auth, error recovery within timeouts.</p>
<dl class="section note"><dt>Note</dt><dd>dns and poll ownership remains with caller; conn does not free them. </dd>
<dd>
Context internally manages timers via poll; no external SocketTimer needed. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Failure to process events promptly may cause timeouts or stalls. </dd>
<dd>
Cancel or free during active state closes underlying socket.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf45ecd7d9e7c6214e6bfcc6b2a42f977" title="Advance asynchronous proxy connection state machine.">SocketProxy_Conn_process()</a> for advancing state machine. </dd>
<dd>
<a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> for completion check. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf64af0e87ee1735152783f2b7fd132c9" title="Calculate milliseconds until next internal timeout.">SocketProxy_Conn_next_timeout_ms()</a> for poll timeout calculation. </dd>
<dd>
<a class="el" href="group__event__system.html">Event System</a> for poll integration examples. </dd>
<dd>
<a class="el" href="group__dns.html">DNS module</a> for async resolution details. </dd>
<dd>
<a class="el" href="ASYNC__IO_8md.html">docs/ASYNC_IO.md</a> for full event loop patterns. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a>#async-api for advanced async features. </dd></dl>

</div>
</div>
<a id="ga1ee518c3b280abda4ae21871fae53040" name="ga1ee518c3b280abda4ae21871fae53040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee518c3b280abda4ae21871fae53040">&#9670;&#160;</a></span>SocketProxy_Conn_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a> SocketProxy_Conn_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a>&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve current state of proxy connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current SocketProxy_State (e.g., CONNECTING_PROXY, CONNECTED).</dd></dl>
<p>Use for logging, UI updates, or conditional logic during async progress. Valid states reflect real-time progress through connection phases.</p>
<dl class="section user"><dt>Thread Safety\n No - reads volatile internal state.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be" title="States in the proxy connection state machine.">SocketProxy_State</a> enumeration for state details and transitions. </dd>
<dd>
<a class="el" href="group__core__io.html#gac12fc736c9952313a4846dd50380bc3f" title="Query if proxy operation has completed.">SocketProxy_Conn_poll()</a> to check if terminal state reached. </dd>
<dd>
<a class="el" href="group__core__io.html#ga6340dd7fd6f41c692c0a2f770dbd5877" title="Convert SocketProxy_State to descriptive string.">SocketProxy_state_string()</a> for human-readable state name. </dd></dl>

</div>
</div>
<a id="gaad72c8e58d88ee4bbc975c9163266ef0" name="gaad72c8e58d88ee4bbc975c9163266ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad72c8e58d88ee4bbc975c9163266ef0">&#9670;&#160;</a></span>SocketProxy_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Socket_T SocketProxy_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establish synchronous connection to target via proxy tunnel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>Configuration specifying proxy type, server, auth, etc. </td></tr>
    <tr><td class="paramname">target_host</td><td>Target hostname or IP address to tunnel to. </td></tr>
    <tr><td class="paramname">target_port</td><td>Target TCP port (valid range: 1-65535).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success: new Socket_T connected through proxy to target. Caller must <a class="el" href="group__core__io.html#ga74ad7a9bb8deaf499c59d90d6e411f37" title="Dispose of a socket instance and close the underlying file descriptor.">Socket_free()</a> when done. On failure: NULL, with SocketProxy_Failed raised.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketProxy_Failed</td><td>on proxy connection, handshake, or auth failure. Specific causes available via last error if using async variant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n Yes - creates independent socket and resources.</dt><dd></dd></dl>
<p>This convenience function handles full lifecycle:</p><ol type="1">
<li>Socket creation (TCP)</li>
<li>DNS resolution and connection to proxy (via HappyEyeballs for speed)</li>
<li>Optional TLS to proxy (HTTPS proxy type)</li>
<li>Protocol handshake (CONNECT or SOCKS)</li>
<li>Returns tunneled socket ready for immediate use.</li>
</ol>
<p>Blocking behavior: May block up to config timeouts for connect + handshake. For non-blocking, use <a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a> or <a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a>.</p>
<p>Post-success: Socket is in connected state to target; application can immediately perform <a class="el" href="group__security.html#gaeaa77dd7852b535baf17b53ee2518454" title="Perform non-blocking TLS handshake.">SocketTLS_handshake()</a> for HTTPS targets or send data.</p>
<dl class="section warning"><dt>Warning</dt><dd>Config strings must outlive the returned socket. </dd>
<dd>
No connection reuse or pooling; new socket per call.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga58fac7f1a89c5921c7152e393dd8ad36" title="Perform proxy handshake on pre-connected socket to establish tunnel.">SocketProxy_tunnel()</a> for existing socket tunneling. </dd>
<dd>
<a class="el" href="group__core__io.html#ga6d17fac3f6b21b9905aa7c4b0d7d47f7" title="Create proxy connection context with blocking proxy connect, async handshake.">SocketProxy_Conn_new()</a> for async version. </dd>
<dd>
<a class="el" href="group__async__io.html">Async I/O module</a> for event-driven alternatives. </dd>
<dd>
<a class="el" href="group__dns.html">DNS module</a> for resolution details. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for proxy-specific behaviors and limitations. </dd>
<dd>
<a class="el" href="SECURITY_8md.html">docs/SECURITY.md</a> for TLS and auth <a class="el" href="group__security.html" title="Comprehensive security protections for network applications.">Security Modules</a> considerations. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="gab87758fdfc1cbbf3af9740989da246fd" name="gab87758fdfc1cbbf3af9740989da246fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab87758fdfc1cbbf3af9740989da246fd">&#9670;&#160;</a></span>socketproxy_do_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketproxy_do_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive protocol data into conn-&gt;recv_buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses Socket_recv or SocketTLS_recv to fill recv_buf from recv_offset, handles partial receives. Appends to existing data.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 bytes received, 0 EOF, -1 error (EAGAIN returns -1 but ok, check errno).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Updates recv_len, handles TLS if enabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy__private.html#a614ffa636c6ca6f92b39f8af950c50a3">SocketProxy_Conn_T::recv_buf</a>, ::recv_len, ::recv_offset </dd>
<dd>
<a class="el" href="group__proxy__private.html#gada1416d62b5113240c93bd3020dc4b68" title="Internal state machine functions for proxy negotiation.">socketproxy_advance_state()</a> after successful recv. </dd></dl>

</div>
</div>
<a id="ga71e6170ecb08801fd53c849e1456e83c" name="ga71e6170ecb08801fd53c849e1456e83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e6170ecb08801fd53c849e1456e83c">&#9670;&#160;</a></span>socketproxy_do_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketproxy_do_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__proxy__private.html#structSocketProxy__Conn__T">SocketProxy_Conn_T</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send pending protocol data from conn-&gt;send_buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Proxy connection context.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses Socket_send or SocketTLS_send (if TLS) to send remaining bytes, updates send_offset. Handles partial sends (non-blocking).</p>
<dl class="section return"><dt>Returns</dt><dd>0 all sent, 1 partial (EAGAIN), -1 error (sets errno, may raise).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles TLS if conn-&gt;tls_enabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy__private.html#a64870d3e5ff24323c4d1566bc1fb06c6">SocketProxy_Conn_T::send_buf</a>, ::send_len, ::send_offset </dd>
<dd>
<a class="el" href="group__proxy__private.html#gada1416d62b5113240c93bd3020dc4b68" title="Internal state machine functions for proxy negotiation.">socketproxy_advance_state()</a> called after full send. </dd></dl>

</div>
</div>
<a id="gaed6f15d7cead4ae400033b6811f283e6" name="gaed6f15d7cead4ae400033b6811f283e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6f15d7cead4ae400033b6811f283e6">&#9670;&#160;</a></span>socketproxy_elapsed_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t socketproxy_elapsed_ms </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate elapsed time since start in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ms</td><td>Start time from <a class="el" href="group__core__io.html#ga89a14153269ffab409e6ebfaf6deebdd" title="Get current monotonic time in milliseconds.">socketproxy_get_time_ms()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Computes current time - start_ms, clamping to 0 if negative (clock issues).</p>
<dl class="section return"><dt>Returns</dt><dd>Non-negative elapsed milliseconds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes, as it calls thread-safe functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga89a14153269ffab409e6ebfaf6deebdd" title="Get current monotonic time in milliseconds.">socketproxy_get_time_ms()</a> for obtaining timestamps. </dd>
<dd>
<a class="el" href="group__foundation.html#ga264bfa9d1cf07aa22446a4df6c4936bf" title="Socket_get_monotonic_ms - Get current monotonic time in milliseconds.">Socket_get_monotonic_ms()</a> alternative in <a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketProxy-private_8h_source.html#l00718">718</a> of file <a class="el" href="SocketProxy-private_8h_source.html">SocketProxy-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketProxy-private_8h_source.html#l00692">socketproxy_get_time_ms()</a>.</p>

</div>
</div>
<a id="ga89a14153269ffab409e6ebfaf6deebdd" name="ga89a14153269ffab409e6ebfaf6deebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a14153269ffab409e6ebfaf6deebdd">&#9670;&#160;</a></span>socketproxy_get_time_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int64_t socketproxy_get_time_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current monotonic time in milliseconds. </p>
<p>Uses CLOCK_MONOTONIC for reliable, non-decreasing time suitable for timeouts.</p>
<dl class="section return"><dt>Returns</dt><dd>Monotonic time since some unspecified point (ms), or 0 on clock failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes, clock_gettime is atomic. </dd>
<dd>
Prefer over gettimeofday() to avoid system time changes affecting timeouts.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaed6f15d7cead4ae400033b6811f283e6" title="Calculate elapsed time since start in milliseconds.">socketproxy_elapsed_ms()</a> for elapsed time calculation. </dd>
<dd>
<a class="el" href="SocketUtil_8h.html" title="Consolidated utility header for logging, metrics, events, and error handling.">SocketUtil.h</a> "Timeout Utilities" for related functions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketProxy-private_8h_source.html#l00692">692</a> of file <a class="el" href="SocketProxy-private_8h_source.html">SocketProxy-private.h</a>.</p>

<p class="reference">References <a class="el" href="SocketProxy-private_8h_source.html#l00178">SOCKET_PROXY_MS_PER_SEC</a>, and <a class="el" href="SocketProxy-private_8h_source.html#l00191">SOCKET_PROXY_NS_PER_MS</a>.</p>

<p class="reference">Referenced by <a class="el" href="SocketProxy-private_8h_source.html#l00718">socketproxy_elapsed_ms()</a>.</p>

</div>
</div>
<a id="gaa11b9c1ecceaca495ac3a397682a3dc0" name="gaa11b9c1ecceaca495ac3a397682a3dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11b9c1ecceaca495ac3a397682a3dc0">&#9670;&#160;</a></span>socketproxy_parse_hostport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketproxy_parse_hostport </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>consumed_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse [host]:port from URL, handling IPv6 literals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of host/port section (after userinfo@). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">config</td><td>Output, sets proxy_host and proxy_port (default per type). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arena</td><td>Arena for host copy; NULL uses static. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">consumed_out</td><td>Optional: bytes parsed (including port).</td></tr>
  </table>
  </dd>
</dl>
<p>Parses host (domain/IPv4/IPv6), optional :port (defaults: 1080 socks, 8080 http). Validates port range, copies host to arena or static buf.</p>
<dl class="section return"><dt>Returns</dt><dd>0 success, -1 invalid host/port.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>IPv6 requires [] brackets. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>SocketProxy_Config::proxy_host, ::proxy_port </dd>
<dd>
<a class="el" href="group__foundation.html#ga1af76425187cb52fda8d569dcc931e2d" title="Duplicate string into arena.">socket_util_arena_strdup()</a> for copying. </dd></dl>

</div>
</div>
<a id="gab2907aa0b8b21056fcf6c9ba35337ed3" name="gab2907aa0b8b21056fcf6c9ba35337ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2907aa0b8b21056fcf6c9ba35337ed3">&#9670;&#160;</a></span>socketproxy_parse_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketproxy_parse_scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper functions for parsing proxy URLs. </p>
<p>Parses proxy://userinfo@host:port format into config. Supports socks4://, socks5://, <a href="http://">http://</a> schemes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy.html#structSocketProxy__Config" title="Configuration structure for proxy connections.">SocketProxy_Config</a> for output structure. </dd>
<dd>
<a class="el" href="group__core__io.html#gab2907aa0b8b21056fcf6c9ba35337ed3" title="Helper functions for parsing proxy URLs.">socketproxy_parse_scheme()</a>, parse_userinfo(), parse_hostport().</dd></dl>
<p>Parse proxy URL scheme and set type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">url</td><td>Input URL string (e.g., "socks5://proxy.example.com"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">config</td><td>Output config, sets type based on scheme. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>Pointer after parsed scheme:// (for next parse step).</td></tr>
  </table>
  </dd>
</dl>
<p>Recognizes "socks4", "socks5", "http"; sets SOCKET_PROXY_SOCKS4 etc.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on unknown scheme (sets errno EINVAL).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132" title="Enumeration of supported proxy protocol types.">SocketProxyType</a> enum values. </dd>
<dd>
<a class="el" href="group__proxy.html#aa04cfa88d52d6c1f889f9f936a141141" title="Proxy protocol type (e.g., SOCKET_PROXY_SOCKS5).">SocketProxy_Config::type</a> </dd></dl>

</div>
</div>
<a id="gae16c20e1d43f38171ccaad8408598490" name="gae16c20e1d43f38171ccaad8408598490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16c20e1d43f38171ccaad8408598490">&#9670;&#160;</a></span>SocketProxy_parse_url()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketProxy_parse_url </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse proxy URL string into configuration structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Null-terminated proxy URL string. </td></tr>
    <tr><td class="paramname">config</td><td>Output: populated configuration structure. </td></tr>
    <tr><td class="paramname">arena</td><td>Optional arena for allocating parsed strings (host, user, pass). If NULL, uses thread-local static buffer (overwritten on next call).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful parse, -1 on invalid URL format or allocation failure.</dd></dl>
<p>Supported schemes (case-insensitive):</p><ul>
<li><a href="http://">http://</a>[user:pass@]host[:port] (HTTP CONNECT)</li>
<li><a href="https://">https://</a>[user:pass@]host[:port] (HTTPS CONNECT, requires TLS)</li>
<li>socks4://host[:port] (SOCKS4)</li>
<li>socks4a://host[:port] (SOCKS4a)</li>
<li>socks5://[user:pass@]host[:port] (SOCKS5)</li>
<li>socks5h://[user:pass@]host[:port](SOCKS5 hostname resolution)</li>
</ul>
<p>Port defaults: HTTP/HTTPS=8080, SOCKS=1080. Userinfo parsing supports % encoding; passwords securely handled. Does not support IPv6 literals in URL (use hostname or SocketDNS).</p>
<p>Thread safety: Conditional. Safe if arena provided and thread-safe; static buffer is per-thread if no arena.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga197242786615adf218d849747bc0fd67" title="Initialize proxy configuration with safe default values.">SocketProxy_config_defaults()</a> for manual initialization. </dd>
<dd>
<a class="el" href="group__proxy.html#structSocketProxy__Config" title="Configuration structure for proxy connections.">SocketProxy_Config</a> for field ownership rules. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a>#url-format for extended URL features. </dd>
<dd>
<a class="el" href="group__foundation.html">Arena module</a> for memory management. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="ga4284e6c37f6f115b2099885ae0f5622c" name="ga4284e6c37f6f115b2099885ae0f5622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4284e6c37f6f115b2099885ae0f5622c">&#9670;&#160;</a></span>socketproxy_parse_userinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socketproxy_parse_userinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse optional [user[:pass]@] from URL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>Start of potential userinfo (after scheme://). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">config</td><td>Output, sets username/password if present. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arena</td><td>Arena for strdup copies; NULL uses static buffer (non-thread-safe). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>Updated to after @ or start if none.</td></tr>
  </table>
  </dd>
</dl>
<p>Supports basic auth parsing; URL-decodes if needed? (simple colon split).</p>
<dl class="section return"><dt>Returns</dt><dd>0 success (found or not), -1 parse error (long creds).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__proxy.html#a579714517d79e28bb9b03190d67158d5" title="Optional authentication credentials for SOCKS5 or HTTP Basic auth.">SocketProxy_Config::username</a>, ::password </dd>
<dd>
<a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a> for memory management. </dd></dl>

</div>
</div>
<a id="ga2a0ac262c4e03ed00c5eeb2aa8d210bd" name="ga2a0ac262c4e03ed00c5eeb2aa8d210bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a0ac262c4e03ed00c5eeb2aa8d210bd">&#9670;&#160;</a></span>SocketProxy_result_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketProxy_result_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert SocketProxy_Result code to descriptive string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Result code to stringify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Static const char* (e.g., "PROXY_OK", "PROXY_ERROR_AUTH_FAILED"). Never NULL; valid for all valid codes.</dd></dl>
<p>Utility for logging, debugging, or user-facing error messages. Strings are interned static; no allocation.</p>
<dl class="section user"><dt>Thread Safety\n Yes - static read-only strings.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> for runtime result retrieval. </dd>
<dd>
<a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e" title="Result codes for proxy operations.">SocketProxy_Result</a> enum for code list. </dd>
<dd>
docs/LOGGING.md for integration with SocketLog. </dd></dl>

</div>
</div>
<a id="ga6340dd7fd6f41c692c0a2f770dbd5877" name="ga6340dd7fd6f41c692c0a2f770dbd5877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6340dd7fd6f41c692c0a2f770dbd5877">&#9670;&#160;</a></span>SocketProxy_state_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketProxy_state_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be">SocketProxy_State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert SocketProxy_State to descriptive string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>State enum value to stringify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Static const char* (e.g., "PROXY_STATE_CONNECTED", "PROXY_STATE_FAILED"). Never NULL; covers all states.</dd></dl>
<p>For debugging, logging, or state machine visualization. Compact format suitable for trace output.</p>
<dl class="section user"><dt>Thread Safety\n Yes - static constants.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga1ee518c3b280abda4ae21871fae53040" title="Retrieve current state of proxy connection.">SocketProxy_Conn_state()</a> to get current state. </dd>
<dd>
<a class="el" href="group__core__io.html#gaf9f1c72bfcb303aa9ee5dae6d903b9be" title="States in the proxy connection state machine.">SocketProxy_State</a> enum for state documentation. </dd></dl>

</div>
</div>
<a id="ga58fac7f1a89c5921c7152e393dd8ad36" name="ga58fac7f1a89c5921c7152e393dd8ad36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58fac7f1a89c5921c7152e393dd8ad36">&#9670;&#160;</a></span>SocketProxy_tunnel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e">SocketProxy_Result</a> SocketProxy_tunnel </td>
          <td>(</td>
          <td class="paramtype">Socket_T&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__proxy.html#structSocketProxy__Config">SocketProxy_Config</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target_host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gac1ed22b9df4eff7a3398cac608c090cc">Arena_T</a>&#160;</td>
          <td class="paramname"><em>arena</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform proxy handshake on pre-connected socket to establish tunnel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Pre-connected Socket_T to proxy server (non-blocking recommended). </td></tr>
    <tr><td class="paramname">proxy</td><td>Proxy configuration (type, auth, headers, timeouts). Host/port must match socket connection. </td></tr>
    <tr><td class="paramname">target_host</td><td>Target hostname/IP to request tunnel for (sent to proxy). </td></tr>
    <tr><td class="paramname">target_port</td><td>Target port to request (1-65535). </td></tr>
    <tr><td class="paramname">arena</td><td>Optional arena for temporary allocations (e.g., TLS context, buffers). If NULL, uses internal arena (limited lifetime).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PROXY_OK on success (tunnel established), other SocketProxy_Result on failure. Socket remains owned by caller; state updated for tunneling.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">SocketProxy_Failed</td><td>on handshake, auth, or protocol errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety\n No - modifies socket state and uses shared internal resources.</dt><dd></dd></dl>
<p>Use this for custom connection flows (e.g., connection pooling, custom DNS). Assumes socket already connected to proxy-&gt;host:proxy-&gt;port via <a class="el" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e" title="Establish a connection to a remote host and port.">Socket_connect()</a> or equivalent. Performs:</p><ul>
<li>Optional TLS handshake (HTTPS proxy)</li>
<li>Protocol-specific handshake (CONNECT, SOCKS request/response)</li>
<li>Authentication subnegotiation (SOCKS5)</li>
</ul>
<p>For HTTPS proxies: If proxy-&gt;tls_ctx NULL and arena provided, auto-creates secure TLS context. Without arena or tls_ctx, fails with PROXY_ERROR.</p>
<p>On success: Socket ready for read/write to target (proxy-transparent). On failure: Socket may be closed; check SocketProxy_Result for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>Socket must not be shared across threads during call. </dd>
<dd>
Config and arena must outlive the operation. </dd>
<dd>
For async, use <a class="el" href="group__core__io.html#ga5f6fd1cde0a54b41805862ce002f6f97" title="Initialize and start fully asynchronous proxy tunneling operation.">SocketProxy_Conn_start()</a> with external poll/DNS.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaad72c8e58d88ee4bbc975c9163266ef0" title="Establish synchronous connection to target via proxy tunnel.">SocketProxy_connect()</a> for full synchronous connection (socket creation included). </dd>
<dd>
<a class="el" href="group__proxy.html#structSocketProxy__Config" title="Configuration structure for proxy connections.">SocketProxy_Config</a> for TLS and timeout config. </dd>
<dd>
<a class="el" href="group__security.html">Security module</a> for HTTPS <a class="el" href="group__proxy.html" title="Transparent TCP proxy support with sync/async APIs.">Proxy Tunneling Module</a> TLS requirements. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a>#custom-socket for advanced usage examples. </dd></dl>

</div>
</div>
<a id="ga50b7d727085605b2f6bc620118462b13" name="ga50b7d727085605b2f6bc620118462b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b7d727085605b2f6bc620118462b13">&#9670;&#160;</a></span>SocketProxy_type_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * SocketProxy_type_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132">SocketProxyType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert proxy type enum to protocol name string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>SocketProxyType enum value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Static const char* describing protocol (e.g., "HTTP CONNECT", "SOCKS5", "none"). Never NULL; user-friendly for logs/UI.</dd></dl>
<p>Examples:</p><ul>
<li>SOCKET_PROXY_HTTP  "HTTP CONNECT"</li>
<li>SOCKET_PROXY_SOCKS5  "SOCKS5"</li>
<li>SOCKET_PROXY_NONE  "direct"</li>
</ul>
<dl class="section user"><dt>Thread Safety\n Yes - static strings.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaaa33f7bdae951cc7b53a2fb049e89132" title="Enumeration of supported proxy protocol types.">SocketProxyType</a> enum for supported types. </dd>
<dd>
<a class="el" href="group__proxy.html#aa04cfa88d52d6c1f889f9f936a141141" title="Proxy protocol type (e.g., SOCKET_PROXY_SOCKS5).">SocketProxy_Config::type</a> for runtime configuration. </dd>
<dd>
<a class="el" href="PROXY_8md.html">docs/PROXY.md</a> for type-specific protocol details. </dd></dl>

</div>
</div>
<a id="gad12cd27d2531c8ea2b762e0ab4659d63" name="gad12cd27d2531c8ea2b762e0ab4659d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12cd27d2531c8ea2b762e0ab4659d63">&#9670;&#160;</a></span>SocketUnix_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketUnix_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind Unix domain socket to a filesystem path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The socket base structure containing the file descriptor and domain. </td></tr>
    <tr><td class="paramname">path</td><td>Null-terminated string specifying the Unix socket path. </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception type to raise on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exc_type</td><td>On bind errors such as EADDRINUSE, ENOENT, or EACCES.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal helper function that performs Unix domain socket binding. Validates the path and calls bind(2) system call. Supports both filesystem paths and abstract sockets (Linux).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad85ee4be563a1006b7518645995ab65e" title="Bind to Unix domain socket path.">Socket_bind_unix()</a> for the public high-level interface. </dd>
<dd>
<a class="el" href="group__core__io.html#gafadda7c72f287b85c490f04aec8623e1" title="Connect Unix domain socket to a filesystem path.">SocketUnix_connect()</a> for the connect counterpart. </dd>
<dd>
<a class="el" href="group__core__io.html#ga039fc234ac9f3aa259ea01e22218e442" title="Validate a Unix domain socket path.">SocketUnix_validate_unix_path()</a> for path validation. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if base fd is not shared across threads</dt><dd>without locking. </dd></dl>

</div>
</div>
<a id="gafadda7c72f287b85c490f04aec8623e1" name="gafadda7c72f287b85c490f04aec8623e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafadda7c72f287b85c490f04aec8623e1">&#9670;&#160;</a></span>SocketUnix_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketUnix_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__io.html#structSocketBase__T">SocketBase_T</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#structExcept__T">Except_T</a>&#160;</td>
          <td class="paramname"><em>exc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect Unix domain socket to a filesystem path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The socket base structure containing the file descriptor and domain. </td></tr>
    <tr><td class="paramname">path</td><td>Null-terminated string specifying the remote Unix socket path. </td></tr>
    <tr><td class="paramname">exc_type</td><td>Exception type to raise on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exc_type</td><td>On connect errors such as ECONNREFUSED, ENOENT, or EACCES.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal helper function that performs Unix domain socket connection. Validates the path and calls connect(2) system call. Supports both filesystem paths and abstract sockets (Linux).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad353c95a8994569af7b650f1fda7036f" title="Connect to Unix domain socket path.">Socket_connect_unix()</a> for the public high-level interface. </dd>
<dd>
<a class="el" href="group__core__io.html#gad12cd27d2531c8ea2b762e0ab4659d63" title="Bind Unix domain socket to a filesystem path.">SocketUnix_bind()</a> for the bind counterpart. </dd>
<dd>
<a class="el" href="group__core__io.html#ga039fc234ac9f3aa259ea01e22218e442" title="Validate a Unix domain socket path.">SocketUnix_validate_unix_path()</a> for path validation. </dd></dl>
<dl class="section user"><dt>Thread Safety\n Conditional - safe if base fd is not shared across threads</dt><dd>without locking. </dd></dl>

</div>
</div>
<a id="ga039fc234ac9f3aa259ea01e22218e442" name="ga039fc234ac9f3aa259ea01e22218e442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039fc234ac9f3aa259ea01e22218e442">&#9670;&#160;</a></span>SocketUnix_validate_unix_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SocketUnix_validate_unix_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>path_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate a Unix domain socket path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path string to validate. </td></tr>
    <tr><td class="paramname">path_len</td><td>Length of the path string (excluding null terminator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the path is valid for Unix socket operations, 0 otherwise.</dd></dl>
<p>Checks path constraints:</p><ul>
<li>Length &lt;= UNIX_PATH_MAX (typically 108 bytes)</li>
<li>Not empty</li>
<li>Supports abstract socket prefix (\0 on Linux)</li>
</ul>
<p>Used by bind and connect helpers to ensure valid paths before system calls.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gad12cd27d2531c8ea2b762e0ab4659d63" title="Bind Unix domain socket to a filesystem path.">SocketUnix_bind()</a> </dd>
<dd>
<a class="el" href="group__core__io.html#gafadda7c72f287b85c490f04aec8623e1" title="Connect Unix domain socket to a filesystem path.">SocketUnix_connect()</a> </dd></dl>
<dl class="section user"><dt>Thread Safety\n Yes - pure function, no side effects.</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaaaca3ee3e0d6c13e6ea304edba0e47ce" name="gaaaca3ee3e0d6c13e6ea304edba0e47ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaca3ee3e0d6c13e6ea304edba0e47ce">&#9670;&#160;</a></span>base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SocketDgram_T::base</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Private structure for <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a> opaque type.</p>
<p>Private structure for <a class="el" href="SocketDgram-private_8h.html#structSocketDgram__T" title="Opaque type representing a datagram socket instance.">SocketDgram_T</a> opaque type.</p>
<p>Embeds <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> for common socket fields (fd, arena, endpoints, timeouts, metrics). Includes conditional DTLS fields when #SOCKET_HAS_TLS is enabled, providing support for secure datagram encryption parallel to TLS in Socket_T.</p>
<p>Common base structure shared with other socket types. Contains file descriptor, memory arena, local/remote addresses, timeouts, and metrics tracking.</p>
<dl class="section note"><dt>Note</dt><dd>This structure is not part of the public API and may change without notice. Additional datagram-specific fields (e.g., multicast state) can be added here.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDgram_8h.html" title="High-level UDP/datagram socket interface with multicast and broadcast support.">SocketDgram.h</a> for public interface. </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html" title="Private declarations for SocketCommon module providing shared socket infrastructure.">SocketCommon-private.h</a> for <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> details. </dd>
<dd>
<a class="el" href="Socket-private_8h.html" title="Private implementation details for Socket module: internal structure and shared utilities....">Socket-private.h</a> for stream socket equivalent. </dd>
<dd>
<a class="el" href="SocketDTLS_8h.html" title="Core DTLS API for secure UDP sockets.">SocketDTLS.h</a> for DTLS fields usage (if enabled).  </dd></dl>
<p>Embeds <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> for common socket fields (fd, arena, endpoints, timeouts, metrics). Includes conditional DTLS fields when #SOCKET_HAS_TLS is enabled, providing support for secure datagram encryption parallel to TLS in Socket_T.</p>
<p>Common base structure shared with other socket types. Contains file descriptor, memory arena, local/remote addresses, timeouts, and metrics tracking.</p>
<dl class="section note"><dt>Note</dt><dd>This structure is not part of the public API and may change without notice. Additional datagram-specific fields (e.g., multicast state) can be added here.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDgram_8h.html" title="High-level UDP/datagram socket interface with multicast and broadcast support.">SocketDgram.h</a> for public interface. </dd>
<dd>
<a class="el" href="SocketCommon-private_8h.html" title="Private declarations for SocketCommon module providing shared socket infrastructure.">SocketCommon-private.h</a> for <a class="el" href="group__core__io.html#structSocketBase__T" title="Internal implementation of SocketBase_T opaque type.">SocketBase_T</a> details. </dd>
<dd>
<a class="el" href="Socket-private_8h.html" title="Private implementation details for Socket module: internal structure and shared utilities....">Socket-private.h</a> for stream socket equivalent. </dd>
<dd>
<a class="el" href="SocketDTLS_8h.html" title="Core DTLS API for secure UDP sockets.">SocketDTLS.h</a> for DTLS fields usage (if enabled). </dd></dl>

<p class="definition">Definition at line <a class="el" href="SocketDgram-private_8h_source.html#l00045">45</a> of file <a class="el" href="SocketDgram-private_8h_source.html">SocketDgram-private.h</a>.</p>

</div>
</div>
<a id="ga2db3d742dcea3f39ad2eb37d4fb1e453" name="ga2db3d742dcea3f39ad2eb37d4fb1e453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2db3d742dcea3f39ad2eb37d4fb1e453">&#9670;&#160;</a></span>Socket_Closed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> Socket_Closed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> closed by peer exception. </p>
<p>Category: NETWORK Retryable: Yes - indicates graceful close or reset, reconnect may succeed</p>
<p>Raised when:</p><ul>
<li>recv() returns 0 (graceful close)</li>
<li>ECONNRESET during I/O (connection reset)</li>
<li>EPIPE during send (broken pipe)</li>
</ul>
<p>This is a normal condition for connection-oriented sockets.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga95db343f47445925cecd6b20054518e9" title="Receive data.">Socket_recv()</a> for read operations that may raise this. </dd>
<dd>
<a class="el" href="group__core__io.html#ga23ace6e065fe4b9a01db8caa6513515b" title="Send data.">Socket_send()</a> for write operations that may raise this. </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>.</p>

</div>
</div>
<a id="ga225f4a8fd657fd52a05146c6fc4f58b0" name="ga225f4a8fd657fd52a05146c6fc4f58b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga225f4a8fd657fd52a05146c6fc4f58b0">&#9670;&#160;</a></span>Socket_Failed <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> Socket_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General socket operation failure exception. </p>
<p>Indicates failure in any socket-related system call or library operation. This is the primary exception for most Socket_T API errors.</p>
<p>Error Category:</p><ul>
<li>NETWORK: Transient issues like timeouts, resets, unreachable hosts</li>
<li>PROTOCOL: Invalid configuration or state (e.g., bind on used port)</li>
<li>SYSTEM: Resource exhaustion or permission issues</li>
</ul>
<p>Retryability: Use Socket_error_is_retryable(Socket_geterrno()) to determine if safe to retry the operation. Examples:</p><ul>
<li>Retryable: ECONNREFUSED, ETIMEDOUT, EAGAIN</li>
<li>Non-retryable: EACCES, EINVAL, EMFILE</li>
</ul>
<p>Always check <a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> and <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a> in EXCEPT block for details.</p>
<p>Common triggers:</p><ul>
<li>socket(2), bind(2), listen(2), accept(4), connect(2) failures</li>
<li>send(2), recv(2), sendmsg(2), recvmsg(2) errors</li>
<li>setsockopt(2), getsockopt(2) failures</li>
<li>Internal allocation failures (ENOMEM)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> to retrieve errno value </dd>
<dd>
<a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a> for human-readable error string </dd>
<dd>
<a class="el" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9" title="Check if an errno indicates a retryable error.">Socket_error_is_retryable()</a> to check if operation can be retried</dd></dl>
<h2><a class="anchor" id="autotoc_md407"></a>
Handling Example</h2>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__foundation.html#gad2746371528bdf15c3910b7bf217dac0">TRY</a> {</div>
<div class="line">    Socket_T sock = <a class="code hl_function" href="group__core__io.html#ga6212fb2b6eefa567592a59f55c25a6f1">Socket_new</a>(AF_INET, SOCK_STREAM, 0);</div>
<div class="line">    <a class="code hl_function" href="group__core__io.html#gac14390090ee26136c1f7a816fc08406e">Socket_connect</a>(sock, <span class="stringliteral">&quot;invalid-host&quot;</span>, 80);</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gab5e72fc2bd41014c75e0ace4feabfe8e">EXCEPT</a>(<a class="code hl_variable" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0">Socket_Failed</a>) {</div>
<div class="line">    <span class="keywordtype">int</span> err = <a class="code hl_function" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5">Socket_geterrno</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9">Socket_error_is_retryable</a>(err)) {</div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#ae560ccd4aef66d44e8ecbd256844059c">SOCKET_LOG_WARN_MSG</a>(<span class="stringliteral">&quot;Retryable socket error %d: %s&quot;</span>, err,</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>());</div>
<div class="line">        <span class="comment">// Implement backoff and retry logic</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <a class="code hl_define" href="SocketUtil_8h.html#a16642c35dec627aeb4976538671b1552">SOCKET_LOG_ERROR_MSG</a>(<span class="stringliteral">&quot;Fatal socket error %d: %s&quot;</span>, err,</div>
<div class="line"><a class="code hl_function" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db">Socket_GetLastError</a>());</div>
<div class="line">        <span class="comment">// Abort or fallback</span></div>
<div class="line">    }</div>
<div class="line">} <a class="code hl_define" href="group__foundation.html#gae6628ac788ad213363b89dba9868420b">END_TRY</a>;</div>
<div class="ttc" id="agroup__core__io_html_ga8517adf0df2e5331a952fb713ec314f9"><div class="ttname"><a href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9">Socket_error_is_retryable</a></div><div class="ttdeci">int Socket_error_is_retryable(int err)</div><div class="ttdoc">Check if an errno indicates a retryable error.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>errno is preserved thread-locally; safe in multithreaded contexts </dd>
<dd>
Use <a class="el" href="group__foundation.html#ga481ecfe6b9e5c83515c92d1808e4b2f9" title="Provides a thread-safe and bounds-checked implementation of strerror().">Socket_safe_strerror()</a> for safe strerror() wrapper </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not assume all Socket_Failed are network errors - check errno </dd>
<dd>
In non-blocking mode, EAGAIN may not raise exception (returns 0 instead)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga2db3d742dcea3f39ad2eb37d4fb1e453" title="Connection closed by peer exception.">Socket_Closed</a> for peer disconnection cases </dd>
<dd>
<a class="el" href="group__core__io.html#gab05e641cc9abed67180036e51a1dc633" title="Unix domain socket operation failure.">SocketUnix_Failed</a> for Unix-specific errors </dd></dl>

<p class="reference">Referenced by <a class="el" href="graceful__shutdown_8c_source.html#l00199">handle_client_data()</a>, <a class="el" href="connection__pool_8c_source.html#l00065">main()</a>, and <a class="el" href="graceful__shutdown_8c_source.html#l00242">main()</a>.</p>

</div>
</div>
<a id="ga225f4a8fd657fd52a05146c6fc4f58b0" name="ga225f4a8fd657fd52a05146c6fc4f58b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga225f4a8fd657fd52a05146c6fc4f58b0">&#9670;&#160;</a></span>Socket_Failed <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> Socket_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Module Exception Forward Declarations. </p>
<p>Forward declarations of module-specific exception types (<a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a>) for use in internal implementations. Enables consistent error raising across Socket, SocketDgram, and common utilities without per-file definitions.</p>
<p>These exceptions are also exposed publicly in <a class="el" href="SocketCommon_8h.html" title="Common utilities shared between Socket and SocketDgram modules.">SocketCommon.h</a> for application-level TRY/EXCEPT handling. Definitions provided in respective .c source files.</p>
<p>Exception Usage Pattern</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="SocketUtil_8h.html#a9a80f14591d4cdb7347af54b5f66e766">SOCKET_DECLARE_MODULE_EXCEPTION</a>(SocketCommon);  <span class="comment">// In .c file</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Raising</span></div>
<div class="line"><a class="code hl_define" href="SocketUtil_8h.html#ad3f0d856a8ffbd9d81975ccacb7ff6d8">SOCKET_RAISE_FMT</a>(SocketCommon, <a class="code hl_variable" href="group__core__io.html#ga4218ae116e8def59908f76fd1e9dbe3e">SocketCommon_Failed</a>, <span class="stringliteral">&quot;resolve failed: %s&quot;</span>,</div>
<div class="line">gai_strerror(err));</div>
<div class="ttc" id="aSocketUtil_8h_html_a9a80f14591d4cdb7347af54b5f66e766"><div class="ttname"><a href="SocketUtil_8h.html#a9a80f14591d4cdb7347af54b5f66e766">SOCKET_DECLARE_MODULE_EXCEPTION</a></div><div class="ttdeci">#define SOCKET_DECLARE_MODULE_EXCEPTION(module_name)</div><div class="ttdoc">SOCKET_DECLARE_MODULE_EXCEPTION - Declare thread-local exception.</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l01678">SocketUtil.h:1678</a></div></div>
<div class="ttc" id="aSocketUtil_8h_html_ad3f0d856a8ffbd9d81975ccacb7ff6d8"><div class="ttname"><a href="SocketUtil_8h.html#ad3f0d856a8ffbd9d81975ccacb7ff6d8">SOCKET_RAISE_FMT</a></div><div class="ttdeci">#define SOCKET_RAISE_FMT(module_name, exception, fmt,...)</div><div class="ttdoc">SOCKET_RAISE_FMT - Format error with errno and raise exception in one step.</div><div class="ttdef"><b>Definition</b> <a href="SocketUtil_8h_source.html#l01716">SocketUtil.h:1716</a></div></div>
<div class="ttc" id="agroup__core__io_html_ga4218ae116e8def59908f76fd1e9dbe3e"><div class="ttname"><a href="group__core__io.html#ga4218ae116e8def59908f76fd1e9dbe3e">SocketCommon_Failed</a></div><div class="ttdeci">const Except_T SocketCommon_Failed</div><div class="ttdoc">Shared utility function failure exception.</div></div>
</div><!-- fragment --><p>Category and Retryability</p>
<p>All socket exceptions:</p><ul>
<li><b>Category</b>: NETWORK (system calls) or APPLICATION (validation)</li>
<li><b>Retryable</b>: Use SocketError_is_retryable_errno(Socket_geterrno()) to check</li>
<li><b>Details</b>: Available via <a class="el" href="group__foundation.html#gac71a25566cdc9e11eaecb16c966081db" title="Socket_GetLastError - Retrieve the most recent formatted error message.">Socket_GetLastError()</a>, <a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Thread-safe: Yes (<a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> is value type, stack-based) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Except_8h.html" title="Structured exception handling for C with TRY/EXCEPT/FINALLY blocks.">core/Except.h</a> for TRY/EXCEPT/FINALLY/END_TRY macros and <a class="el" href="group__foundation.html#structExcept__T" title="Exception structure for structured error handling.">Except_T</a> details </dd>
<dd>
<a class="el" href="SocketUtil_8h.html#a9a80f14591d4cdb7347af54b5f66e766" title="SOCKET_DECLARE_MODULE_EXCEPTION - Declare thread-local exception.">SOCKET_DECLARE_MODULE_EXCEPTION()</a> and SOCKET_RAISE_* macros in internal headers </dd>
<dd>
docs/ERROR_HANDLING.md for comprehensive exception patterns and best practices </dd>
<dd>
<a class="el" href="group__foundation.html#ga4b19847d604cdc5896376e694ee2a9c1" title="SocketError_categorize_errno - Classify errno into SocketErrorCategory.">SocketError_categorize_errno()</a> for automatic categorization</dd></dl>
<p>Generic socket operation failure exception. </p>
<p>Raised for core socket operations failures: socket(2), bind(2), connect(2), listen(2), accept(2), send/recv family, Unix domain ops, option setting.</p>
<p>Common Triggers</p><ul>
<li>System resource exhaustion (EMFILE, ENFILE, ENOBUFS)</li>
<li>Permission issues (EACCES, EPERM)</li>
<li>Address errors (EADDRINUSE, EADDRNOTAVAIL, EINVAL)</li>
<li><a class="el" href="group__connection__mgmt.html#structConnection" title="Internal structure representing a pooled connection slot.">Connection</a> issues (ECONNREFUSED, ETIMEDOUT, ECONNRESET)</li>
</ul>
<p>Category: NETWORK Retryable: Yes for transient errors (use <a class="el" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163" title="SocketError_is_retryable_errno - Check if errno indicates retryable error.">SocketError_is_retryable_errno()</a>)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Socket_8h.html" title="High-level TCP/IP and Unix domain socket interface.">Socket.h</a> for TCP-specific details </dd>
<dd>
<a class="el" href="SocketDgram_8h.html" title="High-level UDP/datagram socket interface with multicast and broadcast support.">SocketDgram.h</a> for UDP details </dd>
<dd>
<a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> for underlying errno </dd></dl>

</div>
</div>
<a id="ga225f4a8fd657fd52a05146c6fc4f58b0" name="ga225f4a8fd657fd52a05146c6fc4f58b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga225f4a8fd657fd52a05146c6fc4f58b0">&#9670;&#160;</a></span>Socket_Failed <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> Socket_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General TCP socket operation failure exception. </p>
<p>See <a class="el" href="Socket_8h.html" title="High-level TCP/IP and Unix domain socket interface.">Socket.h</a> for detailed documentation on when this is raised, retryability, and error categorization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga225f4a8fd657fd52a05146c6fc4f58b0" title="General TCP socket operation failure exception.">Socket_Failed</a> in <a class="el" href="Socket_8h.html">Socket.h</a> for full details. </dd></dl>

</div>
</div>
<a id="ga246f86a3226316f3922ee9eba0436777" name="ga246f86a3226316f3922ee9eba0436777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga246f86a3226316f3922ee9eba0436777">&#9670;&#160;</a></span>SocketBuf_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketBuf_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception indicating failure in buffer operations such as allocation or resize errors. </p>
<p>Raised when internal buffer operations fail due to memory exhaustion, invalid parameters, or other runtime errors.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gac82b13f33ba79d9fa97582a64654e8ef" title="Create a new circular buffer with specified initial capacity.">SocketBuf_new()</a> for allocation failure cases. </dd>
<dd>
<a class="el" href="group__core__io.html#ga77d70e899c26ac30bad4aac232505f1e" title="Dynamically resize buffer to ensure at least min_space available.">SocketBuf_reserve()</a> for resize failure cases. </dd>
<dd>
Except_T for exception handling framework. </dd>
<dd>
docs/ERROR_HANDLING.md for TRY/EXCEPT usage patterns. </dd></dl>

</div>
</div>
<a id="ga4218ae116e8def59908f76fd1e9dbe3e" name="ga4218ae116e8def59908f76fd1e9dbe3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4218ae116e8def59908f76fd1e9dbe3e">&#9670;&#160;</a></span>SocketCommon_Failed <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketCommon_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared utility function failure exception. </p>
<p>For errors in common utilities: address resolution (getaddrinfo), hostname/port validation, iovec calculations/advances, option setting helpers, endpoint caching.</p>
<p>Common Triggers</p><ul>
<li>DNS resolution timeouts/failures (gai errors)</li>
<li>Invalid input (bad port, too-long hostname, iov overflow)</li>
<li>Option setting failures (setsockopt EINVAL, ENOPROTOOPT)</li>
<li>Memory allocation in helpers (via Arena_Failed chaining)</li>
</ul>
<p>Category: NETWORK or APPLICATION Retryable: Yes for network transients, no for validation errors</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#ga7fc66958f42deef2824a80188baf4534" title="Resolve hostname/port to addrinfo structure using getaddrinfo wrapper.">SocketCommon_resolve_address()</a> for resolution errors </dd>
<dd>
<a class="el" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804" title="Validate that a port number is within the valid range for socket operations.">SocketCommon_validate_port()</a> and validate_hostname() for input validation </dd>
<dd>
<a class="el" href="group__core__io.html#gabb36ce89ba4091b0a1bee148506d586b" title="Calculate total length of iovec array with overflow protection.">SocketCommon_calculate_total_iov_len()</a> for iovec ops </dd></dl>

</div>
</div>
<a id="ga4218ae116e8def59908f76fd1e9dbe3e" name="ga4218ae116e8def59908f76fd1e9dbe3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4218ae116e8def59908f76fd1e9dbe3e">&#9670;&#160;</a></span>SocketCommon_Failed <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketCommon_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General failure in shared socket common utilities. </p>
<p>Category: NETWORK or APPLICATION Retryable: Depends on errno - use <a class="el" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9" title="Check if an errno indicates a retryable error.">Socket_error_is_retryable()</a> to check</p>
<p>Raised for errors in common functions such as:</p><ul>
<li>Address resolution failures (getaddrinfo errors)</li>
<li>Hostname/port validation failures</li>
<li>Socket option setting failures (setsockopt)</li>
<li>iovec manipulation errors (overflow, invalid parameters)</li>
<li>Bind/connect helper failures</li>
<li>Multicast join/leave errors</li>
</ul>
<p>Always check errno via <a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> for specific error details.</p>
<dl class="section see"><dt>See also</dt><dd>Socket_resolve_address() for address resolution that may raise this. </dd>
<dd>
<a class="el" href="group__core__io.html#gac849aa92d4bd728b61c37b6e63e2a804" title="Validate that a port number is within the valid range for socket operations.">SocketCommon_validate_port()</a> for port validation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga0a2e7917d36f5e23eab8c1238433dfba" title="Set integer socket option.">SocketCommon_set_option_int()</a> for option setting. </dd>
<dd>
<a class="el" href="group__core__io.html#gabb36ce89ba4091b0a1bee148506d586b" title="Calculate total length of iovec array with overflow protection.">SocketCommon_calculate_total_iov_len()</a> for iovec operations. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9" title="Check if an errno indicates a retryable error.">Socket_error_is_retryable()</a> for retry decisions. </dd>
<dd>
<a class="el" href="group__foundation.html#gaacd3ef2f86186c451f2eb90cd490eae5" title="Socket_geterrno - Retrieve the raw POSIX errno from the last system call error.Returns the errno valu...">Socket_geterrno()</a> for error code access. </dd>
<dd>
docs/ERROR_HANDLING.md for exception handling patterns. </dd></dl>

</div>
</div>
<a id="ga28354c49d1726c674932f420a57bb21d" name="ga28354c49d1726c674932f420a57bb21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28354c49d1726c674932f420a57bb21d">&#9670;&#160;</a></span>SocketDgram_Failed <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketDgram_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Datagram/UDP-specific operation failure exception. </p>
<p>Specific to UDP/SocketDgram operations: sendto(2)/recvfrom(2), multicast join/leave, broadcast enable, TTL setting, connected UDP mode.</p>
<p>Common Triggers</p><ul>
<li>Multicast errors (invalid group, permission denied)</li>
<li>Broadcast without SO_BROADCAST</li>
<li>TTL/hop limit out of range</li>
<li>Datagram too large (EMSGSIZE)</li>
</ul>
<p>Category: NETWORK Retryable: Depends on errno - check <a class="el" href="SocketUtil_8h.html#a78065a32bc90c30a5d062b0b9ac88163" title="SocketError_is_retryable_errno - Check if errno indicates retryable error.">SocketError_is_retryable_errno()</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDgram_8h.html" title="High-level UDP/datagram socket interface with multicast and broadcast support.">SocketDgram.h</a> for full UDP API documentation </dd>
<dd>
<a class="el" href="group__core__io.html#ga59068eaf0e0e017bb7492f2804a342b5" title="Join multicast group.">SocketCommon_join_multicast()</a> for multicast-specific errors </dd></dl>

<p class="reference">Referenced by <a class="el" href="udp__echo__client_8c_source.html#l00025">main()</a>.</p>

</div>
</div>
<a id="ga28354c49d1726c674932f420a57bb21d" name="ga28354c49d1726c674932f420a57bb21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28354c49d1726c674932f420a57bb21d">&#9670;&#160;</a></span>SocketDgram_Failed <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketDgram_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General UDP/datagram socket operation failure exception. </p>
<p>Raised for errors specific to datagram sockets such as:</p><ul>
<li>Invalid multicast group addresses</li>
<li>Broadcast permission failures</li>
<li>TTL/hop limit setting errors</li>
</ul>
<p>Category: NETWORK Retryable: Depends on errno</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="SocketDgram_8h.html" title="High-level UDP/datagram socket interface with multicast and broadcast support.">SocketDgram.h</a> for detailed documentation. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8517adf0df2e5331a952fb713ec314f9" title="Check if an errno indicates a retryable error.">Socket_error_is_retryable()</a> for retryability checking. </dd></dl>

</div>
</div>
<a id="ga8c1385083c8f3a50e20e1ce11faec7b1" name="ga8c1385083c8f3a50e20e1ce11faec7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1385083c8f3a50e20e1ce11faec7b1">&#9670;&#160;</a></span>SocketProxy_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketProxy_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exception raised on general proxy operation failures. </p>
<p>Thrown when proxy connection establishment, authentication, or handshake fails for any reason. For detailed error information in asynchronous operations, query <a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> after completion.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__io.html#gaf191ce0cae571b057d5ea278392bdf24" title="Get final result code after operation completion.">SocketProxy_Conn_result()</a> for specific <a class="el" href="group__core__io.html#gae980e6a437316380a792464ce32a595e" title="Result codes for proxy operations.">SocketProxy_Result</a> codes. </dd>
<dd>
<a class="el" href="group__core__io.html#ga8c1385083c8f3a50e20e1ce11faec7b1" title="Exception raised on general proxy operation failures.">SocketProxy_Failed</a> for common triggers like network errors, authentication failures, or protocol violations. </dd>
<dd>
docs/ERROR_HANDLING.md for exception handling guidelines. </dd></dl>

<p class="reference">Referenced by <a class="el" href="proxy__connect_8c_source.html#l00129">main()</a>.</p>

</div>
</div>
<a id="gab05e641cc9abed67180036e51a1dc633" name="gab05e641cc9abed67180036e51a1dc633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab05e641cc9abed67180036e51a1dc633">&#9670;&#160;</a></span>SocketUnix_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__foundation.html#structExcept__T">Except_T</a> SocketUnix_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unix domain socket operation failure. </p>
<p>Category: NETWORK or APPLICATION Retryable: Depends on errno</p>
<p>Raised for Unix domain socket specific errors:</p><ul>
<li>Path too long</li>
<li>Socket file doesn't exist (ENOENT)</li>
<li>Permission denied (EACCES) </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Custom footer for Tetsuo Pulse -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="footer" style="text-align: center; width: 100%;">
       <a href="https://tetsuocorp.com" target="_blank" rel="noopener">Tetsuo Corp</a>
    </li>
  </ul>
</div>
</body>
</html>
