<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Socket Library: Socket.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Socket Library<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance, exception-driven socket toolkit for POSIX systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Socket_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Socket.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Except_8h_source.html">core/Except.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SocketDNS_8h_source.html">dns/SocketDNS.h</a>&quot;</code><br />
</div>
<p><a href="Socket_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSocketTimeouts.html">SocketTimeouts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketTimeouts_T - Timeout configuration for socket operations @connect_timeout_ms: Connect timeout in milliseconds (0 = infinite) @dns_timeout_ms: DNS resolution timeout in milliseconds (0 = infinite) @operation_timeout_ms: General operation timeout in milliseconds (reserved for future use)  <a href="structSocketTimeouts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0acb682b8260ab1c60b918599864e2e5" id="r_a0acb682b8260ab1c60b918599864e2e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a0acb682b8260ab1c60b918599864e2e5">T</a>&#160;&#160;&#160;Socket_T</td></tr>
<tr class="memdesc:a0acb682b8260ab1c60b918599864e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket Abstraction Layer High-level, exception-based TCP/IP socket interface.  <br /></td></tr>
<tr class="separator:a0acb682b8260ab1c60b918599864e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a24514489b0962fafe8414bfae95aa268" id="r_a24514489b0962fafe8414bfae95aa268"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structT.html">T</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a24514489b0962fafe8414bfae95aa268">T</a></td></tr>
<tr class="separator:a24514489b0962fafe8414bfae95aa268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debcc5506f258fc65706fa6455f1a05" id="r_a3debcc5506f258fc65706fa6455f1a05"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSocketTimeouts.html">SocketTimeouts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a></td></tr>
<tr class="memdesc:a3debcc5506f258fc65706fa6455f1a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketTimeouts_T - Timeout configuration for socket operations @connect_timeout_ms: Connect timeout in milliseconds (0 = infinite) @dns_timeout_ms: DNS resolution timeout in milliseconds (0 = infinite) @operation_timeout_ms: General operation timeout in milliseconds (reserved for future use)  <br /></td></tr>
<tr class="separator:a3debcc5506f258fc65706fa6455f1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48a12cae4cd51b880e7927a22ab82641" id="r_a48a12cae4cd51b880e7927a22ab82641"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structT.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a48a12cae4cd51b880e7927a22ab82641">Socket_new</a> (int domain, int type, int protocol)</td></tr>
<tr class="separator:a48a12cae4cd51b880e7927a22ab82641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ea06a38e059da3259baf352f74bf15" id="r_a98ea06a38e059da3259baf352f74bf15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a98ea06a38e059da3259baf352f74bf15">SocketPair_new</a> (int type, <a class="el" href="structT.html">T</a> *socket1, <a class="el" href="structT.html">T</a> *socket2)</td></tr>
<tr class="memdesc:a98ea06a38e059da3259baf352f74bf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">SocketPair_new - Create a pair of connected Unix domain sockets @type: Socket type (SOCK_STREAM or SOCK_DGRAM) @socket1: Output - first socket of the pair @socket2: Output - second socket of the pair Raises: Socket_Failed on error Thread-safe: Yes (creates new sockets) Note: Creates two connected Unix domain sockets for IPC.  <br /></td></tr>
<tr class="separator:a98ea06a38e059da3259baf352f74bf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221d64c385da1687c988f7ffeb67697d" id="r_a221d64c385da1687c988f7ffeb67697d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a221d64c385da1687c988f7ffeb67697d">Socket_free</a> (<a class="el" href="structT.html">T</a> *socket)</td></tr>
<tr class="memdesc:a221d64c385da1687c988f7ffeb67697d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_free - Free a socket and close the connection @socket: Pointer to socket (will be set to NULL)  <br /></td></tr>
<tr class="separator:a221d64c385da1687c988f7ffeb67697d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cacd863c275e6e12f7c63b65708e1b" id="r_aa8cacd863c275e6e12f7c63b65708e1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aa8cacd863c275e6e12f7c63b65708e1b">Socket_debug_live_count</a> (void)</td></tr>
<tr class="memdesc:aa8cacd863c275e6e12f7c63b65708e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_debug_live_count - Get number of live socket instances (test-only) Returns: Current count of allocated Socket_T instances that have not been freed.  <br /></td></tr>
<tr class="separator:aa8cacd863c275e6e12f7c63b65708e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20213f48dd43a3129c9c9f3b03c9854" id="r_aa20213f48dd43a3129c9c9f3b03c9854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aa20213f48dd43a3129c9c9f3b03c9854">Socket_bind</a> (<a class="el" href="structT.html">T</a> socket, const char *host, int port)</td></tr>
<tr class="memdesc:aa20213f48dd43a3129c9c9f3b03c9854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_bind - Bind socket to address and port @socket: Socket to bind @host: IP address or NULL/"0.0.0.0" for any @port: Port number (1-65535) WARNING: May block 30+ seconds during DNS resolution if hostname provided.  <br /></td></tr>
<tr class="separator:aa20213f48dd43a3129c9c9f3b03c9854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9495f689b00ffc14f393d8173c98a4" id="r_afb9495f689b00ffc14f393d8173c98a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#afb9495f689b00ffc14f393d8173c98a4">Socket_listen</a> (<a class="el" href="structT.html">T</a> socket, int backlog)</td></tr>
<tr class="memdesc:afb9495f689b00ffc14f393d8173c98a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_listen - Listen for incoming connections @socket: Bound socket @backlog: Maximum pending connections Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:afb9495f689b00ffc14f393d8173c98a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21e0268831aeee010b41d28ac61b464" id="r_af21e0268831aeee010b41d28ac61b464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structT.html">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af21e0268831aeee010b41d28ac61b464">Socket_accept</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:af21e0268831aeee010b41d28ac61b464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_accept - Accept incoming connection @socket: Listening socket Returns: New socket or NULL if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Failed on error Note: Socket must be non-blocking for NULL return on EAGAIN/EWOULDBLOCK.  <br /></td></tr>
<tr class="separator:af21e0268831aeee010b41d28ac61b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6425897f52a2ee266a88f674de18ddd3" id="r_a6425897f52a2ee266a88f674de18ddd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a6425897f52a2ee266a88f674de18ddd3">Socket_connect</a> (<a class="el" href="structT.html">T</a> socket, const char *host, int port)</td></tr>
<tr class="memdesc:a6425897f52a2ee266a88f674de18ddd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_connect - Connect to remote host @socket: Socket to connect @host: Remote IP address or hostname @port: Remote port WARNING: May block 30+ seconds during DNS resolution if hostname provided.  <br /></td></tr>
<tr class="separator:a6425897f52a2ee266a88f674de18ddd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72bbc8824c7adf5aa55af88b784b9d0" id="r_ab72bbc8824c7adf5aa55af88b784b9d0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ab72bbc8824c7adf5aa55af88b784b9d0">Socket_send</a> (<a class="el" href="structT.html">T</a> socket, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ab72bbc8824c7adf5aa55af88b784b9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_send - Send data @socket: Connected socket @buf: Data to send @len: Length of data (&gt; 0) Returns: Bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET, Socket_Failed on other errors Note: May send less than requested.  <br /></td></tr>
<tr class="separator:ab72bbc8824c7adf5aa55af88b784b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec96ac4f3517384ca22c1ef50d646a" id="r_af5ec96ac4f3517384ca22c1ef50d646a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af5ec96ac4f3517384ca22c1ef50d646a">Socket_recv</a> (<a class="el" href="structT.html">T</a> socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:af5ec96ac4f3517384ca22c1ef50d646a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_recv - Receive data @socket: Connected socket @buf: Buffer for received data @len: Buffer size (&gt; 0) Returns: Bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Note: Return value 0 means would-block, NOT connection closed (raises exception)  <br /></td></tr>
<tr class="separator:af5ec96ac4f3517384ca22c1ef50d646a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bde7e1ab3130c4674e0c7bcb94ea8" id="r_afa7bde7e1ab3130c4674e0c7bcb94ea8"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#afa7bde7e1ab3130c4674e0c7bcb94ea8">Socket_sendall</a> (<a class="el" href="structT.html">T</a> socket, const void *buf, size_t len)</td></tr>
<tr class="memdesc:afa7bde7e1ab3130c4674e0c7bcb94ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendall - Send all data (handles partial sends) @socket: Connected socket @buf: Data to send @len: Length of data (&gt; 0) Returns: Total bytes sent (always equals len on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data is sent or an error occurs.  <br /></td></tr>
<tr class="separator:afa7bde7e1ab3130c4674e0c7bcb94ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21e86cdf39ae94b27c74b19e6c29c28" id="r_af21e86cdf39ae94b27c74b19e6c29c28"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af21e86cdf39ae94b27c74b19e6c29c28">Socket_recvall</a> (<a class="el" href="structT.html">T</a> socket, void *buf, size_t len)</td></tr>
<tr class="memdesc:af21e86cdf39ae94b27c74b19e6c29c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_recvall - Receive all requested data (handles partial receives) @socket: Connected socket @buf: Buffer for received data @len: Buffer size (&gt; 0) Returns: Total bytes received (always equals len on success) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until len bytes are received or an error occurs.  <br /></td></tr>
<tr class="separator:af21e86cdf39ae94b27c74b19e6c29c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab675b5c1dbc4531aa0c1fc289475823b" id="r_ab675b5c1dbc4531aa0c1fc289475823b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ab675b5c1dbc4531aa0c1fc289475823b">Socket_sendv</a> (<a class="el" href="structT.html">T</a> socket, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ab675b5c1dbc4531aa0c1fc289475823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendv - Scatter/gather send (writev wrapper) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Sends data from multiple buffers in a single system call.  <br /></td></tr>
<tr class="separator:ab675b5c1dbc4531aa0c1fc289475823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a76fbae389a57c9a0389a691f90766" id="r_af2a76fbae389a57c9a0389a691f90766"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af2a76fbae389a57c9a0389a691f90766">Socket_recvv</a> (<a class="el" href="structT.html">T</a> socket, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:af2a76fbae389a57c9a0389a691f90766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_recvv - Scatter/gather receive (readv wrapper) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Receives data into multiple buffers in a single system call.  <br /></td></tr>
<tr class="separator:af2a76fbae389a57c9a0389a691f90766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb71b00d768e2285da07038dd6144e8e" id="r_abb71b00d768e2285da07038dd6144e8e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#abb71b00d768e2285da07038dd6144e8e">Socket_sendvall</a> (<a class="el" href="structT.html">T</a> socket, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:abb71b00d768e2285da07038dd6144e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendvall - Scatter/gather send all (handles partial sends) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes sent (always equals sum of all iov_len on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data from all buffers is sent or an error occurs.  <br /></td></tr>
<tr class="separator:abb71b00d768e2285da07038dd6144e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac157beed03142752182021261a263671" id="r_ac157beed03142752182021261a263671"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac157beed03142752182021261a263671">Socket_recvvall</a> (<a class="el" href="structT.html">T</a> socket, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ac157beed03142752182021261a263671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_recvvall - Scatter/gather receive all (handles partial receives) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes received (always equals sum of all iov_len on success) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all requested data is received into all buffers or an error occurs.  <br /></td></tr>
<tr class="separator:ac157beed03142752182021261a263671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb117caeae8c8c1ce3b50a0568be35da" id="r_acb117caeae8c8c1ce3b50a0568be35da"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#acb117caeae8c8c1ce3b50a0568be35da">Socket_sendfile</a> (<a class="el" href="structT.html">T</a> socket, int file_fd, off_t *offset, size_t count)</td></tr>
<tr class="memdesc:acb117caeae8c8c1ce3b50a0568be35da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendfile - Zero-copy file-to-socket transfer @socket: Connected socket to send to @file_fd: File descriptor to read from (must be a regular file) @offset: File offset to start reading from (NULL for current position) @count: Number of bytes to transfer (0 for entire file from offset) Returns: Total bytes transferred (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Uses platform-specific zero-copy mechanism (sendfile/splice).  <br /></td></tr>
<tr class="separator:acb117caeae8c8c1ce3b50a0568be35da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618437cdccde7f979f09307b99ad2b73" id="r_a618437cdccde7f979f09307b99ad2b73"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a618437cdccde7f979f09307b99ad2b73">Socket_sendfileall</a> (<a class="el" href="structT.html">T</a> socket, int file_fd, off_t *offset, size_t count)</td></tr>
<tr class="memdesc:a618437cdccde7f979f09307b99ad2b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendfileall - Zero-copy file-to-socket transfer (handles partial transfers) @socket: Connected socket to send to @file_fd: File descriptor to read from (must be a regular file) @offset: File offset to start reading from (NULL for current position) @count: Number of bytes to transfer (0 for entire file from offset) Returns: Total bytes transferred (always equals count on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data is transferred or an error occurs.  <br /></td></tr>
<tr class="separator:a618437cdccde7f979f09307b99ad2b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76433dc005a43612f7ce752d01884e3" id="r_ab76433dc005a43612f7ce752d01884e3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ab76433dc005a43612f7ce752d01884e3">Socket_sendmsg</a> (<a class="el" href="structT.html">T</a> socket, const struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:ab76433dc005a43612f7ce752d01884e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_sendmsg - Send message with ancillary data (sendmsg wrapper) @socket: Connected socket @msg: Message structure with data, address, and ancillary data @flags: Message flags (MSG_NOSIGNAL, MSG_DONTWAIT, etc.) Returns: Total bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Allows sending data with control messages (CMSG) for advanced features like file descriptor passing, credentials, IP options, etc.  <br /></td></tr>
<tr class="separator:ab76433dc005a43612f7ce752d01884e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec26ecfd893efb26b95ec741c46656" id="r_a3aec26ecfd893efb26b95ec741c46656"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a3aec26ecfd893efb26b95ec741c46656">Socket_recvmsg</a> (<a class="el" href="structT.html">T</a> socket, struct msghdr *msg, int flags)</td></tr>
<tr class="memdesc:a3aec26ecfd893efb26b95ec741c46656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_recvmsg - Receive message with ancillary data (recvmsg wrapper) @socket: Connected socket @msg: Message structure for data, address, and ancillary data @flags: Message flags (MSG_DONTWAIT, MSG_PEEK, etc.) Returns: Total bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Allows receiving data with control messages (CMSG) for advanced features like file descriptor passing, credentials, IP options, etc.  <br /></td></tr>
<tr class="separator:a3aec26ecfd893efb26b95ec741c46656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08886d4588009f86d4e5778363fd379e" id="r_a08886d4588009f86d4e5778363fd379e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a08886d4588009f86d4e5778363fd379e">Socket_setnonblocking</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a08886d4588009f86d4e5778363fd379e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setnonblocking - Enable non-blocking mode @socket: Socket to modify Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:a08886d4588009f86d4e5778363fd379e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad5151bf257e772cf3cfb32f4b13bb" id="r_aa9ad5151bf257e772cf3cfb32f4b13bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aa9ad5151bf257e772cf3cfb32f4b13bb">Socket_setreuseaddr</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:aa9ad5151bf257e772cf3cfb32f4b13bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setreuseaddr - Enable address reuse @socket: Socket to modify Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:aa9ad5151bf257e772cf3cfb32f4b13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce3128becb062e541c093f2277f03fe" id="r_a0ce3128becb062e541c093f2277f03fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a0ce3128becb062e541c093f2277f03fe">Socket_setreuseport</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a0ce3128becb062e541c093f2277f03fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setreuseport - Enable port reuse across sockets @socket: Socket to modify Raises: Socket_Failed on error (or if SO_REUSEPORT unsupported)  <br /></td></tr>
<tr class="separator:a0ce3128becb062e541c093f2277f03fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e9038dc4c692fb378b28d221bf7236" id="r_a12e9038dc4c692fb378b28d221bf7236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a12e9038dc4c692fb378b28d221bf7236">Socket_settimeout</a> (<a class="el" href="structT.html">T</a> socket, int timeout_sec)</td></tr>
<tr class="memdesc:a12e9038dc4c692fb378b28d221bf7236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_settimeout - Set socket timeout @socket: Socket to modify @timeout_sec: Timeout in seconds (0 to disable) Sets both send and receive timeouts Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:a12e9038dc4c692fb378b28d221bf7236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168b58f8fb7cb65ddb1a417c79cf0d6c" id="r_a168b58f8fb7cb65ddb1a417c79cf0d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a168b58f8fb7cb65ddb1a417c79cf0d6c">Socket_setkeepalive</a> (<a class="el" href="structT.html">T</a> socket, int idle, int interval, int count)</td></tr>
<tr class="memdesc:a168b58f8fb7cb65ddb1a417c79cf0d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setkeepalive - Enable TCP keepalive @socket: Socket to modify @idle: Seconds before sending keepalive probes @interval: Interval between keepalive probes @count: Number of probes before declaring dead Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:a168b58f8fb7cb65ddb1a417c79cf0d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228f425d55147dafd5e29799d5c03af0" id="r_a228f425d55147dafd5e29799d5c03af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a228f425d55147dafd5e29799d5c03af0">Socket_setnodelay</a> (<a class="el" href="structT.html">T</a> socket, int nodelay)</td></tr>
<tr class="memdesc:a228f425d55147dafd5e29799d5c03af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setnodelay - Disable Nagle's algorithm @socket: Socket to modify @nodelay: 1 to disable Nagle, 0 to enable Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:a228f425d55147dafd5e29799d5c03af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2179b048d3749e7a8962f0863d5d9d0" id="r_ac2179b048d3749e7a8962f0863d5d9d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac2179b048d3749e7a8962f0863d5d9d0">Socket_gettimeout</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:ac2179b048d3749e7a8962f0863d5d9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_gettimeout - Get socket timeout @socket: Socket to query Returns: Timeout in seconds (0 if disabled) Raises: Socket_Failed on error Note: Returns receive timeout (send timeout may differ)  <br /></td></tr>
<tr class="separator:ac2179b048d3749e7a8962f0863d5d9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480a8c19b4cbdb1131da3c770cd4aa84" id="r_a480a8c19b4cbdb1131da3c770cd4aa84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a480a8c19b4cbdb1131da3c770cd4aa84">Socket_getkeepalive</a> (<a class="el" href="structT.html">T</a> socket, int *idle, int *interval, int *count)</td></tr>
<tr class="memdesc:a480a8c19b4cbdb1131da3c770cd4aa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getkeepalive - Get TCP keepalive configuration @socket: Socket to query @idle: Output - idle timeout in seconds @interval: Output - interval between probes in seconds @count: Output - number of probes before declaring dead Raises: Socket_Failed on error Note: Returns 0 for parameters not supported on this platform.  <br /></td></tr>
<tr class="separator:a480a8c19b4cbdb1131da3c770cd4aa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b7b670397c95fa75e613ecb593c8db" id="r_af0b7b670397c95fa75e613ecb593c8db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af0b7b670397c95fa75e613ecb593c8db">Socket_getnodelay</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:af0b7b670397c95fa75e613ecb593c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getnodelay - Get TCP_NODELAY setting @socket: Socket to query Returns: 1 if Nagle's algorithm is disabled, 0 if enabled Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:af0b7b670397c95fa75e613ecb593c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9262ae6cbe3a40b63967ba700a011016" id="r_a9262ae6cbe3a40b63967ba700a011016"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a9262ae6cbe3a40b63967ba700a011016">Socket_getrcvbuf</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a9262ae6cbe3a40b63967ba700a011016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getrcvbuf - Get receive buffer size @socket: Socket to query Returns: Receive buffer size in bytes Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:a9262ae6cbe3a40b63967ba700a011016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c1ac9908662a224b8c818e6d55f0ec" id="r_ad9c1ac9908662a224b8c818e6d55f0ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ad9c1ac9908662a224b8c818e6d55f0ec">Socket_getsndbuf</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:ad9c1ac9908662a224b8c818e6d55f0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getsndbuf - Get send buffer size @socket: Socket to query Returns: Send buffer size in bytes Raises: Socket_Failed on error.  <br /></td></tr>
<tr class="separator:ad9c1ac9908662a224b8c818e6d55f0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74d806db96f89a2e08338ddf59ad16a" id="r_ac74d806db96f89a2e08338ddf59ad16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac74d806db96f89a2e08338ddf59ad16a">Socket_setrcvbuf</a> (<a class="el" href="structT.html">T</a> socket, int size)</td></tr>
<tr class="memdesc:ac74d806db96f89a2e08338ddf59ad16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setrcvbuf - Set receive buffer size @socket: Socket to modify @size: Buffer size in bytes (&gt; 0) Raises: Socket_Failed on error Note: The kernel may adjust the value to be within system limits.  <br /></td></tr>
<tr class="separator:ac74d806db96f89a2e08338ddf59ad16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc754a971fa566e2b396d9025b961a" id="r_aeecc754a971fa566e2b396d9025b961a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aeecc754a971fa566e2b396d9025b961a">Socket_setsndbuf</a> (<a class="el" href="structT.html">T</a> socket, int size)</td></tr>
<tr class="memdesc:aeecc754a971fa566e2b396d9025b961a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setsndbuf - Set send buffer size @socket: Socket to modify @size: Buffer size in bytes (&gt; 0) Raises: Socket_Failed on error Note: The kernel may adjust the value to be within system limits.  <br /></td></tr>
<tr class="separator:aeecc754a971fa566e2b396d9025b961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914404cbf71b91e14240ae961b30df73" id="r_a914404cbf71b91e14240ae961b30df73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a914404cbf71b91e14240ae961b30df73">Socket_setcongestion</a> (<a class="el" href="structT.html">T</a> socket, const char *algorithm)</td></tr>
<tr class="memdesc:a914404cbf71b91e14240ae961b30df73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setcongestion - Set TCP congestion control algorithm @socket: Socket to modify @algorithm: Algorithm name (e.g., "cubic", "reno", "bbr") Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.13+.  <br /></td></tr>
<tr class="separator:a914404cbf71b91e14240ae961b30df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e65e3db5bd05c0ff61ba863b9b8732e" id="r_a4e65e3db5bd05c0ff61ba863b9b8732e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a4e65e3db5bd05c0ff61ba863b9b8732e">Socket_getcongestion</a> (<a class="el" href="structT.html">T</a> socket, char *algorithm, size_t len)</td></tr>
<tr class="memdesc:a4e65e3db5bd05c0ff61ba863b9b8732e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getcongestion - Get TCP congestion control algorithm @socket: Socket to query @algorithm: Output buffer for algorithm name @len: Buffer length Returns: 0 on success, -1 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.13+.  <br /></td></tr>
<tr class="separator:a4e65e3db5bd05c0ff61ba863b9b8732e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a60e026631198fa2ee225a74565afd5" id="r_a2a60e026631198fa2ee225a74565afd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a2a60e026631198fa2ee225a74565afd5">Socket_setfastopen</a> (<a class="el" href="structT.html">T</a> socket, int enable)</td></tr>
<tr class="memdesc:a2a60e026631198fa2ee225a74565afd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setfastopen - Enable TCP Fast Open @socket: Socket to modify @enable: 1 to enable, 0 to disable Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: TCP Fast Open allows sending data in SYN packet.  <br /></td></tr>
<tr class="separator:a2a60e026631198fa2ee225a74565afd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0734cbd1a3c15bd40d84878102f4cb3f" id="r_a0734cbd1a3c15bd40d84878102f4cb3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a0734cbd1a3c15bd40d84878102f4cb3f">Socket_getfastopen</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a0734cbd1a3c15bd40d84878102f4cb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getfastopen - Get TCP Fast Open setting @socket: Socket to query Returns: 1 if enabled, 0 if disabled, -1 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on platforms that support TCP Fast Open.  <br /></td></tr>
<tr class="separator:a0734cbd1a3c15bd40d84878102f4cb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4873c11dcc702d693ee8bc930e61387" id="r_af4873c11dcc702d693ee8bc930e61387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af4873c11dcc702d693ee8bc930e61387">Socket_setusertimeout</a> (<a class="el" href="structT.html">T</a> socket, unsigned int timeout_ms)</td></tr>
<tr class="memdesc:af4873c11dcc702d693ee8bc930e61387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setusertimeout - Set TCP user timeout @socket: Socket to modify @timeout_ms: Timeout in milliseconds (&gt; 0) Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: TCP user timeout controls how long to wait for ACK before closing connection.  <br /></td></tr>
<tr class="separator:af4873c11dcc702d693ee8bc930e61387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa721bd54b028d6e92cc459c76b96ef" id="r_a5fa721bd54b028d6e92cc459c76b96ef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a5fa721bd54b028d6e92cc459c76b96ef">Socket_getusertimeout</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a5fa721bd54b028d6e92cc459c76b96ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getusertimeout - Get TCP user timeout @socket: Socket to query Returns: Timeout in milliseconds, or 0 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.37+.  <br /></td></tr>
<tr class="separator:a5fa721bd54b028d6e92cc459c76b96ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c832b75a949f8716f52b2a25fa54071" id="r_a4c832b75a949f8716f52b2a25fa54071"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a4c832b75a949f8716f52b2a25fa54071">Socket_isconnected</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a4c832b75a949f8716f52b2a25fa54071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected, 0 if not connected Thread-safe: Yes (operates on single socket) Note: Uses getpeername() to determine connection state.  <br /></td></tr>
<tr class="separator:a4c832b75a949f8716f52b2a25fa54071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87607a3fb7bb47442e3ca5c8664cadf3" id="r_a87607a3fb7bb47442e3ca5c8664cadf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a87607a3fb7bb47442e3ca5c8664cadf3">Socket_isbound</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a87607a3fb7bb47442e3ca5c8664cadf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_isbound - Check if socket is bound to an address @socket: Socket to check Returns: 1 if bound, 0 if not bound Thread-safe: Yes (operates on single socket) Note: Uses getsockname() to determine binding state.  <br /></td></tr>
<tr class="separator:a87607a3fb7bb47442e3ca5c8664cadf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf51b653c9d3ad62e91c87ffb8977459" id="r_aaf51b653c9d3ad62e91c87ffb8977459"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aaf51b653c9d3ad62e91c87ffb8977459">Socket_islistening</a> (<a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:aaf51b653c9d3ad62e91c87ffb8977459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_islistening - Check if socket is listening for connections @socket: Socket to check Returns: 1 if listening, 0 if not listening Thread-safe: Yes (operates on single socket) Note: Checks if socket is bound and not connected.  <br /></td></tr>
<tr class="separator:aaf51b653c9d3ad62e91c87ffb8977459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb2a02d1e1cde1316ebb24bc6d33ee" id="r_a04bb2a02d1e1cde1316ebb24bc6d33ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a04bb2a02d1e1cde1316ebb24bc6d33ee">Socket_shutdown</a> (<a class="el" href="structT.html">T</a> socket, int how)</td></tr>
<tr class="memdesc:a04bb2a02d1e1cde1316ebb24bc6d33ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_shutdown - Disable further sends and/or receives @socket: Connected socket @how: Shutdown mode (SHUT_RD, SHUT_WR, or SHUT_RDWR) Raises: Socket_Failed on error Thread-safe: No (callers must synchronize concurrent access to the socket)  <br /></td></tr>
<tr class="separator:a04bb2a02d1e1cde1316ebb24bc6d33ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef76ca110b35a97542a01abd96b56d3" id="r_adef76ca110b35a97542a01abd96b56d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#adef76ca110b35a97542a01abd96b56d3">Socket_setcloexec</a> (<a class="el" href="structT.html">T</a> socket, int enable)</td></tr>
<tr class="memdesc:adef76ca110b35a97542a01abd96b56d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_setcloexec - Control close-on-exec flag @socket: Socket to modify @enable: 1 to enable CLOEXEC, 0 to disable Raises: Socket_Failed on error Thread-safe: Yes (operates on single socket) Note: By default, all sockets have CLOEXEC enabled.  <br /></td></tr>
<tr class="separator:adef76ca110b35a97542a01abd96b56d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590cc74ce83a3ed92afa6f50bb6de788" id="r_a590cc74ce83a3ed92afa6f50bb6de788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a590cc74ce83a3ed92afa6f50bb6de788">Socket_timeouts_get</a> (const <a class="el" href="structT.html">T</a> socket, <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:a590cc74ce83a3ed92afa6f50bb6de788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_timeouts_get - Retrieve per-socket timeout configuration @socket: Socket instance @timeouts: Output timeout structure Returns: Nothing.  <br /></td></tr>
<tr class="separator:a590cc74ce83a3ed92afa6f50bb6de788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617c15d23eeff4b6b91aca2d1993a407" id="r_a617c15d23eeff4b6b91aca2d1993a407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a617c15d23eeff4b6b91aca2d1993a407">Socket_timeouts_set</a> (<a class="el" href="structT.html">T</a> socket, const <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:a617c15d23eeff4b6b91aca2d1993a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_timeouts_set - Set per-socket timeout configuration @socket: Socket instance @timeouts: Timeout configuration (NULL to reset to defaults) Returns: Nothing.  <br /></td></tr>
<tr class="separator:a617c15d23eeff4b6b91aca2d1993a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc79428e54b0284cc7cad257d56adf" id="r_acfcc79428e54b0284cc7cad257d56adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#acfcc79428e54b0284cc7cad257d56adf">Socket_timeouts_getdefaults</a> (<a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:acfcc79428e54b0284cc7cad257d56adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_timeouts_getdefaults - Get global default timeouts @timeouts: Output timeout structure containing current defaults Returns: Nothing.  <br /></td></tr>
<tr class="separator:acfcc79428e54b0284cc7cad257d56adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385e87c51740c37c9d90ff5bba1eced" id="r_a0385e87c51740c37c9d90ff5bba1eced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a0385e87c51740c37c9d90ff5bba1eced">Socket_timeouts_setdefaults</a> (const <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *timeouts)</td></tr>
<tr class="memdesc:a0385e87c51740c37c9d90ff5bba1eced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_timeouts_setdefaults - Set global default timeouts @timeouts: New default timeout configuration Returns: Nothing.  <br /></td></tr>
<tr class="separator:a0385e87c51740c37c9d90ff5bba1eced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a53c77fcff7863928e76e3f1d853eb" id="r_ac3a53c77fcff7863928e76e3f1d853eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac3a53c77fcff7863928e76e3f1d853eb">Socket_fd</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:ac3a53c77fcff7863928e76e3f1d853eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_fd - Get underlying file descriptor @socket: Socket instance Returns: File descriptor.  <br /></td></tr>
<tr class="separator:ac3a53c77fcff7863928e76e3f1d853eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8058df51c22be9a27f033e320020226f" id="r_a8058df51c22be9a27f033e320020226f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a8058df51c22be9a27f033e320020226f">Socket_getpeeraddr</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a8058df51c22be9a27f033e320020226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getpeeraddr - Get peer IP address @socket: Connected socket Returns: IP address string (IPv4/IPv6) or "(unknown)" if unavailable Note: Returns "(unknown)" if address info unavailable during accept/connect.  <br /></td></tr>
<tr class="separator:a8058df51c22be9a27f033e320020226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4debb3b40b2e412f4e6d309d907870ec" id="r_a4debb3b40b2e412f4e6d309d907870ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a4debb3b40b2e412f4e6d309d907870ec">Socket_getpeerport</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a4debb3b40b2e412f4e6d309d907870ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getpeerport - Get peer port number @socket: Connected socket Returns: Port number (1-65535) or 0 if unavailable Note: Returns 0 if port info unavailable during accept/connect.  <br /></td></tr>
<tr class="separator:a4debb3b40b2e412f4e6d309d907870ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8781ea1a54f7f756e2b17ace876b0d82" id="r_a8781ea1a54f7f756e2b17ace876b0d82"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a8781ea1a54f7f756e2b17ace876b0d82">Socket_getlocaladdr</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a8781ea1a54f7f756e2b17ace876b0d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getlocaladdr - Get local IP address @socket: Socket instance Returns: IP address string (IPv4/IPv6) or "(unknown)" if unavailable Note: Returns "(unknown)" if address info unavailable.  <br /></td></tr>
<tr class="separator:a8781ea1a54f7f756e2b17ace876b0d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06481f8a3cb3d7bdf6c3f659d2b8f578" id="r_a06481f8a3cb3d7bdf6c3f659d2b8f578"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a06481f8a3cb3d7bdf6c3f659d2b8f578">Socket_getlocalport</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a06481f8a3cb3d7bdf6c3f659d2b8f578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getlocalport - Get local port number @socket: Socket instance Returns: Port number (1-65535) or 0 if unavailable.  <br /></td></tr>
<tr class="separator:a06481f8a3cb3d7bdf6c3f659d2b8f578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0950e48831143dd9b3915939e2ef345" id="r_af0950e48831143dd9b3915939e2ef345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#af0950e48831143dd9b3915939e2ef345">Socket_bind_unix</a> (<a class="el" href="structT.html">T</a> socket, const char *path)</td></tr>
<tr class="memdesc:af0950e48831143dd9b3915939e2ef345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_bind_unix - Bind to Unix domain socket path @socket: Socket to bind (AF_UNIX) @path: Socket file path Raises: Socket_Failed on error Note: Fails with EADDRINUSE if path exists.  <br /></td></tr>
<tr class="separator:af0950e48831143dd9b3915939e2ef345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9687684ea5825b2f45fae02f115db74d" id="r_a9687684ea5825b2f45fae02f115db74d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a9687684ea5825b2f45fae02f115db74d">Socket_connect_unix</a> (<a class="el" href="structT.html">T</a> socket, const char *path)</td></tr>
<tr class="memdesc:a9687684ea5825b2f45fae02f115db74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_connect_unix - Connect to Unix domain socket path @socket: Socket to connect (AF_UNIX) @path: Socket file path Raises: Socket_Failed on error Note: Supports abstract namespace sockets on Linux (path starting with '@').  <br /></td></tr>
<tr class="separator:a9687684ea5825b2f45fae02f115db74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12a023e06a98edb7ccb24a1dfb00a23" id="r_ac12a023e06a98edb7ccb24a1dfb00a23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac12a023e06a98edb7ccb24a1dfb00a23">Socket_getpeerpid</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:ac12a023e06a98edb7ccb24a1dfb00a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getpeerpid - Get peer process ID (Linux only) @socket: Connected Unix domain socket Returns: Peer process ID, or -1 if unavailable Note: Only works on Linux with SO_PEERCRED.  <br /></td></tr>
<tr class="separator:ac12a023e06a98edb7ccb24a1dfb00a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ebfd0c98dd5f04ce68019c730d03c9" id="r_a64ebfd0c98dd5f04ce68019c730d03c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a64ebfd0c98dd5f04ce68019c730d03c9">Socket_getpeeruid</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a64ebfd0c98dd5f04ce68019c730d03c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getpeeruid - Get peer user ID (Linux only) @socket: Connected Unix domain socket Returns: Peer user ID, or (uid_t)-1 if unavailable Note: Only works on Linux with SO_PEERCRED.  <br /></td></tr>
<tr class="separator:a64ebfd0c98dd5f04ce68019c730d03c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4f0341dee9e90eacb2bb242902999" id="r_a47d4f0341dee9e90eacb2bb242902999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a47d4f0341dee9e90eacb2bb242902999">Socket_getpeergid</a> (const <a class="el" href="structT.html">T</a> socket)</td></tr>
<tr class="memdesc:a47d4f0341dee9e90eacb2bb242902999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_getpeergid - Get peer group ID (Linux only) @socket: Connected Unix domain socket Returns: Peer group ID, or (gid_t)-1 if unavailable Note: Only works on Linux with SO_PEERCRED.  <br /></td></tr>
<tr class="separator:a47d4f0341dee9e90eacb2bb242902999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead803904d888461d2ae5f372ffd10c7" id="r_aead803904d888461d2ae5f372ffd10c7"><td class="memItemLeft" align="right" valign="top">SocketDNS_Request_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#aead803904d888461d2ae5f372ffd10c7">Socket_bind_async</a> (SocketDNS_T dns, <a class="el" href="structT.html">T</a> socket, const char *host, int port)</td></tr>
<tr class="memdesc:aead803904d888461d2ae5f372ffd10c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_bind_async - Start async DNS resolution for bind @dns: DNS resolver instance @socket: Socket to bind @host: IP address or hostname (NULL for any) @port: Port number (1-65535) Returns: DNS request handle Raises: Socket_Failed on error Starts async DNS resolution.  <br /></td></tr>
<tr class="separator:aead803904d888461d2ae5f372ffd10c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e2d6b94b41a45e9d9fb43f6122e489" id="r_ad6e2d6b94b41a45e9d9fb43f6122e489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ad6e2d6b94b41a45e9d9fb43f6122e489">Socket_bind_async_cancel</a> (SocketDNS_T dns, SocketDNS_Request_T req)</td></tr>
<tr class="memdesc:ad6e2d6b94b41a45e9d9fb43f6122e489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_bind_async_cancel - Cancel pending async bind resolution @dns: DNS resolver instance @req: Request handle returned by Socket_bind_async Returns: Nothing.  <br /></td></tr>
<tr class="separator:ad6e2d6b94b41a45e9d9fb43f6122e489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe9f97d6fd318de336ef8857532f602" id="r_abbe9f97d6fd318de336ef8857532f602"><td class="memItemLeft" align="right" valign="top">SocketDNS_Request_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#abbe9f97d6fd318de336ef8857532f602">Socket_connect_async</a> (SocketDNS_T dns, <a class="el" href="structT.html">T</a> socket, const char *host, int port)</td></tr>
<tr class="memdesc:abbe9f97d6fd318de336ef8857532f602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_connect_async - Start async DNS resolution for connect @dns: DNS resolver instance @socket: Socket to connect @host: Remote IP address or hostname @port: Remote port (1-65535) Returns: DNS request handle Raises: Socket_Failed on error Starts async DNS resolution.  <br /></td></tr>
<tr class="separator:abbe9f97d6fd318de336ef8857532f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac935e4853e90426e05722f6e54c2e7b9" id="r_ac935e4853e90426e05722f6e54c2e7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ac935e4853e90426e05722f6e54c2e7b9">Socket_connect_async_cancel</a> (SocketDNS_T dns, SocketDNS_Request_T req)</td></tr>
<tr class="memdesc:ac935e4853e90426e05722f6e54c2e7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_connect_async_cancel - Cancel pending async connect resolution @dns: DNS resolver instance @req: Request handle returned by Socket_connect_async Returns: Nothing.  <br /></td></tr>
<tr class="separator:ac935e4853e90426e05722f6e54c2e7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf837d398667975ee992c77abd3af593" id="r_adf837d398667975ee992c77abd3af593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#adf837d398667975ee992c77abd3af593">Socket_bind_with_addrinfo</a> (<a class="el" href="structT.html">T</a> socket, struct addrinfo *res)</td></tr>
<tr class="memdesc:adf837d398667975ee992c77abd3af593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_bind_with_addrinfo - Bind socket using resolved address @socket: Socket to bind @res: Resolved addrinfo result from DNS resolution Raises: Socket_Failed on error Performs bind operation using pre-resolved address.  <br /></td></tr>
<tr class="separator:adf837d398667975ee992c77abd3af593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae9a4a80d9034ea713f3e41c428131e" id="r_a4ae9a4a80d9034ea713f3e41c428131e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a4ae9a4a80d9034ea713f3e41c428131e">Socket_connect_with_addrinfo</a> (<a class="el" href="structT.html">T</a> socket, struct addrinfo *res)</td></tr>
<tr class="memdesc:a4ae9a4a80d9034ea713f3e41c428131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket_connect_with_addrinfo - Connect socket using resolved address @socket: Socket to connect @res: Resolved addrinfo result from DNS resolution Raises: Socket_Failed on error Performs connect operation using pre-resolved address.  <br /></td></tr>
<tr class="separator:a4ae9a4a80d9034ea713f3e41c428131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a84516221c8fd2d4bdfde8d05eaf42cc6" id="r_a84516221c8fd2d4bdfde8d05eaf42cc6"><td class="memItemLeft" align="right" valign="top">Except_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#a84516221c8fd2d4bdfde8d05eaf42cc6">Socket_Failed</a></td></tr>
<tr class="memdesc:a84516221c8fd2d4bdfde8d05eaf42cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">General socket operation failure.  <br /></td></tr>
<tr class="separator:a84516221c8fd2d4bdfde8d05eaf42cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae149a16c5ec76f277f565783bc39469e" id="r_ae149a16c5ec76f277f565783bc39469e"><td class="memItemLeft" align="right" valign="top">Except_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Socket_8h.html#ae149a16c5ec76f277f565783bc39469e">Socket_Closed</a></td></tr>
<tr class="memdesc:ae149a16c5ec76f277f565783bc39469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection closed by peer.  <br /></td></tr>
<tr class="separator:ae149a16c5ec76f277f565783bc39469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0acb682b8260ab1c60b918599864e2e5" name="a0acb682b8260ab1c60b918599864e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acb682b8260ab1c60b918599864e2e5">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="structT.html">T</a>&#160;&#160;&#160;Socket_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Socket Abstraction Layer High-level, exception-based TCP/IP socket interface. </p>
<p>PLATFORM REQUIREMENTS:</p><ul>
<li>POSIX-compliant system (Linux, BSD, macOS)</li>
<li>IPv6 support in kernel for dual-stack sockets</li>
<li>POSIX threads for thread-safe error reporting</li>
<li>NOT portable to Windows without Winsock adaptation CRITICAL: Applications MUST call signal(SIGPIPE, SIG_IGN) during initialization to prevent process termination on broken pipe errors (required on macOS/BSD). Error Handling:</li>
<li>Socket_Failed: General socket errors</li>
<li>Socket_Closed: Connection terminated by peer</li>
<li>Some functions return NULL/0 for non-blocking EAGAIN/EWOULDBLOCK Timeouts:</li>
<li>Global defaults configurable via <a class="el" href="Socket_8h.html#a0385e87c51740c37c9d90ff5bba1eced" title="Socket_timeouts_setdefaults - Set global default timeouts @timeouts: New default timeout configuratio...">Socket_timeouts_setdefaults()</a></li>
<li>Per-socket overrides via <a class="el" href="Socket_8h.html#a617c15d23eeff4b6b91aca2d1993a407" title="Socket_timeouts_set - Set per-socket timeout configuration @socket: Socket instance @timeouts: Timeou...">Socket_timeouts_set()</a></li>
<li>Applied to DNS resolution and blocking connect() paths </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Socket_8h_source.html#l00027">27</a> of file <a class="el" href="Socket_8h_source.html">Socket.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3debcc5506f258fc65706fa6455f1a05" name="a3debcc5506f258fc65706fa6455f1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debcc5506f258fc65706fa6455f1a05">&#9670;&#160;</a></span>SocketTimeouts_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSocketTimeouts.html">SocketTimeouts</a> <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SocketTimeouts_T - Timeout configuration for socket operations @connect_timeout_ms: Connect timeout in milliseconds (0 = infinite) @dns_timeout_ms: DNS resolution timeout in milliseconds (0 = infinite) @operation_timeout_ms: General operation timeout in milliseconds (reserved for future use) </p>

</div>
</div>
<a id="a24514489b0962fafe8414bfae95aa268" name="a24514489b0962fafe8414bfae95aa268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514489b0962fafe8414bfae95aa268">&#9670;&#160;</a></span>T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structT.html">T</a>* <a class="el" href="structT.html">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Socket_8h_source.html#l00028">28</a> of file <a class="el" href="Socket_8h_source.html">Socket.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af21e0268831aeee010b41d28ac61b464" name="af21e0268831aeee010b41d28ac61b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21e0268831aeee010b41d28ac61b464">&#9670;&#160;</a></span>Socket_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structT.html">T</a> Socket_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_accept - Accept incoming connection @socket: Listening socket Returns: New socket or NULL if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Failed on error Note: Socket must be non-blocking for NULL return on EAGAIN/EWOULDBLOCK. </p>

</div>
</div>
<a id="aa20213f48dd43a3129c9c9f3b03c9854" name="aa20213f48dd43a3129c9c9f3b03c9854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20213f48dd43a3129c9c9f3b03c9854">&#9670;&#160;</a></span>Socket_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_bind - Bind socket to address and port @socket: Socket to bind @host: IP address or NULL/"0.0.0.0" for any @port: Port number (1-65535) WARNING: May block 30+ seconds during DNS resolution if hostname provided. </p>
<p>Use IP addresses for non-blocking operation. Raises: Socket_Failed on error </p>

</div>
</div>
<a id="aead803904d888461d2ae5f372ffd10c7" name="aead803904d888461d2ae5f372ffd10c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead803904d888461d2ae5f372ffd10c7">&#9670;&#160;</a></span>Socket_bind_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketDNS_Request_T Socket_bind_async </td>
          <td>(</td>
          <td class="paramtype">SocketDNS_T&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_bind_async - Start async DNS resolution for bind @dns: DNS resolver instance @socket: Socket to bind @host: IP address or hostname (NULL for any) @port: Port number (1-65535) Returns: DNS request handle Raises: Socket_Failed on error Starts async DNS resolution. </p>
<p>Use <a class="el" href="SocketDNS_8h.html#a9bf4ce3f4cc95b946d7a3418a74da3df" title="SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handl...">SocketDNS_getresult()</a> to check completion, then call <a class="el" href="Socket_8h.html#adf837d398667975ee992c77abd3af593" title="Socket_bind_with_addrinfo - Bind socket using resolved address @socket: Socket to bind @res: Resolved...">Socket_bind_with_addrinfo()</a> to perform bind. For non-blocking operation with SocketPoll: SocketDNS_Request_T req = Socket_bind_async(dns, socket, host, port); // In event loop when DNS completes: struct addrinfo *res = SocketDNS_getresult(dns, req); if (res) Socket_bind_with_addrinfo(socket, res); </p>

</div>
</div>
<a id="ad6e2d6b94b41a45e9d9fb43f6122e489" name="ad6e2d6b94b41a45e9d9fb43f6122e489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e2d6b94b41a45e9d9fb43f6122e489">&#9670;&#160;</a></span>Socket_bind_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_async_cancel </td>
          <td>(</td>
          <td class="paramtype">SocketDNS_T&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SocketDNS_Request_T&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_bind_async_cancel - Cancel pending async bind resolution @dns: DNS resolver instance @req: Request handle returned by Socket_bind_async Returns: Nothing. </p>

</div>
</div>
<a id="af0950e48831143dd9b3915939e2ef345" name="af0950e48831143dd9b3915939e2ef345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0950e48831143dd9b3915939e2ef345">&#9670;&#160;</a></span>Socket_bind_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_unix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_bind_unix - Bind to Unix domain socket path @socket: Socket to bind (AF_UNIX) @path: Socket file path Raises: Socket_Failed on error Note: Fails with EADDRINUSE if path exists. </p>
<p>Max path length ~108 bytes. Supports abstract namespace sockets on Linux (path starting with '@'). </p>

</div>
</div>
<a id="adf837d398667975ee992c77abd3af593" name="adf837d398667975ee992c77abd3af593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf837d398667975ee992c77abd3af593">&#9670;&#160;</a></span>Socket_bind_with_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_bind_with_addrinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_bind_with_addrinfo - Bind socket using resolved address @socket: Socket to bind @res: Resolved addrinfo result from DNS resolution Raises: Socket_Failed on error Performs bind operation using pre-resolved address. </p>
<p>Tries each address in the result list until one succeeds. </p>

</div>
</div>
<a id="a6425897f52a2ee266a88f674de18ddd3" name="a6425897f52a2ee266a88f674de18ddd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6425897f52a2ee266a88f674de18ddd3">&#9670;&#160;</a></span>Socket_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_connect - Connect to remote host @socket: Socket to connect @host: Remote IP address or hostname @port: Remote port WARNING: May block 30+ seconds during DNS resolution if hostname provided. </p>
<p>Use IP addresses for non-blocking operation. Can be exploited for DoS attacks if untrusted hostnames are accepted. Raises: Socket_Failed on error </p>

</div>
</div>
<a id="abbe9f97d6fd318de336ef8857532f602" name="abbe9f97d6fd318de336ef8857532f602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe9f97d6fd318de336ef8857532f602">&#9670;&#160;</a></span>Socket_connect_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SocketDNS_Request_T Socket_connect_async </td>
          <td>(</td>
          <td class="paramtype">SocketDNS_T&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_connect_async - Start async DNS resolution for connect @dns: DNS resolver instance @socket: Socket to connect @host: Remote IP address or hostname @port: Remote port (1-65535) Returns: DNS request handle Raises: Socket_Failed on error Starts async DNS resolution. </p>
<p>Use <a class="el" href="SocketDNS_8h.html#a9bf4ce3f4cc95b946d7a3418a74da3df" title="SocketDNS_getresult - Get result of completed request @dns: DNS resolver instance @req: Request handl...">SocketDNS_getresult()</a> to check completion, then call <a class="el" href="Socket_8h.html#a4ae9a4a80d9034ea713f3e41c428131e" title="Socket_connect_with_addrinfo - Connect socket using resolved address @socket: Socket to connect @res:...">Socket_connect_with_addrinfo()</a> to perform connect. </p>

</div>
</div>
<a id="ac935e4853e90426e05722f6e54c2e7b9" name="ac935e4853e90426e05722f6e54c2e7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac935e4853e90426e05722f6e54c2e7b9">&#9670;&#160;</a></span>Socket_connect_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_async_cancel </td>
          <td>(</td>
          <td class="paramtype">SocketDNS_T&#160;</td>
          <td class="paramname"><em>dns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SocketDNS_Request_T&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_connect_async_cancel - Cancel pending async connect resolution @dns: DNS resolver instance @req: Request handle returned by Socket_connect_async Returns: Nothing. </p>

</div>
</div>
<a id="a9687684ea5825b2f45fae02f115db74d" name="a9687684ea5825b2f45fae02f115db74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9687684ea5825b2f45fae02f115db74d">&#9670;&#160;</a></span>Socket_connect_unix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_unix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_connect_unix - Connect to Unix domain socket path @socket: Socket to connect (AF_UNIX) @path: Socket file path Raises: Socket_Failed on error Note: Supports abstract namespace sockets on Linux (path starting with '@'). </p>

</div>
</div>
<a id="a4ae9a4a80d9034ea713f3e41c428131e" name="a4ae9a4a80d9034ea713f3e41c428131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae9a4a80d9034ea713f3e41c428131e">&#9670;&#160;</a></span>Socket_connect_with_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_connect_with_addrinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct addrinfo *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_connect_with_addrinfo - Connect socket using resolved address @socket: Socket to connect @res: Resolved addrinfo result from DNS resolution Raises: Socket_Failed on error Performs connect operation using pre-resolved address. </p>
<p>Tries each address in the result list until one succeeds. </p>

</div>
</div>
<a id="aa8cacd863c275e6e12f7c63b65708e1b" name="aa8cacd863c275e6e12f7c63b65708e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cacd863c275e6e12f7c63b65708e1b">&#9670;&#160;</a></span>Socket_debug_live_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_debug_live_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_debug_live_count - Get number of live socket instances (test-only) Returns: Current count of allocated Socket_T instances that have not been freed. </p>
<p>Notes: Intended for debugging and test instrumentation to detect leaks. </p>

</div>
</div>
<a id="ac3a53c77fcff7863928e76e3f1d853eb" name="ac3a53c77fcff7863928e76e3f1d853eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a53c77fcff7863928e76e3f1d853eb">&#9670;&#160;</a></span>Socket_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_fd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_fd - Get underlying file descriptor @socket: Socket instance Returns: File descriptor. </p>

</div>
</div>
<a id="a221d64c385da1687c988f7ffeb67697d" name="a221d64c385da1687c988f7ffeb67697d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221d64c385da1687c988f7ffeb67697d">&#9670;&#160;</a></span>Socket_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_free - Free a socket and close the connection @socket: Pointer to socket (will be set to NULL) </p>

</div>
</div>
<a id="a4e65e3db5bd05c0ff61ba863b9b8732e" name="a4e65e3db5bd05c0ff61ba863b9b8732e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e65e3db5bd05c0ff61ba863b9b8732e">&#9670;&#160;</a></span>Socket_getcongestion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getcongestion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getcongestion - Get TCP congestion control algorithm @socket: Socket to query @algorithm: Output buffer for algorithm name @len: Buffer length Returns: 0 on success, -1 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.13+. </p>
<p>The algorithm name is written to the provided buffer. </p>

</div>
</div>
<a id="a0734cbd1a3c15bd40d84878102f4cb3f" name="a0734cbd1a3c15bd40d84878102f4cb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0734cbd1a3c15bd40d84878102f4cb3f">&#9670;&#160;</a></span>Socket_getfastopen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getfastopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getfastopen - Get TCP Fast Open setting @socket: Socket to query Returns: 1 if enabled, 0 if disabled, -1 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on platforms that support TCP Fast Open. </p>

</div>
</div>
<a id="a480a8c19b4cbdb1131da3c770cd4aa84" name="a480a8c19b4cbdb1131da3c770cd4aa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480a8c19b4cbdb1131da3c770cd4aa84">&#9670;&#160;</a></span>Socket_getkeepalive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_getkeepalive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getkeepalive - Get TCP keepalive configuration @socket: Socket to query @idle: Output - idle timeout in seconds @interval: Output - interval between probes in seconds @count: Output - number of probes before declaring dead Raises: Socket_Failed on error Note: Returns 0 for parameters not supported on this platform. </p>

</div>
</div>
<a id="a8781ea1a54f7f756e2b17ace876b0d82" name="a8781ea1a54f7f756e2b17ace876b0d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8781ea1a54f7f756e2b17ace876b0d82">&#9670;&#160;</a></span>Socket_getlocaladdr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Socket_getlocaladdr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getlocaladdr - Get local IP address @socket: Socket instance Returns: IP address string (IPv4/IPv6) or "(unknown)" if unavailable Note: Returns "(unknown)" if address info unavailable. </p>
<p>String is owned by socket, must not be freed/modified. Valid until socket freed. </p>

</div>
</div>
<a id="a06481f8a3cb3d7bdf6c3f659d2b8f578" name="a06481f8a3cb3d7bdf6c3f659d2b8f578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06481f8a3cb3d7bdf6c3f659d2b8f578">&#9670;&#160;</a></span>Socket_getlocalport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getlocalport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getlocalport - Get local port number @socket: Socket instance Returns: Port number (1-65535) or 0 if unavailable. </p>

</div>
</div>
<a id="af0b7b670397c95fa75e613ecb593c8db" name="af0b7b670397c95fa75e613ecb593c8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b7b670397c95fa75e613ecb593c8db">&#9670;&#160;</a></span>Socket_getnodelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getnodelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getnodelay - Get TCP_NODELAY setting @socket: Socket to query Returns: 1 if Nagle's algorithm is disabled, 0 if enabled Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="a8058df51c22be9a27f033e320020226f" name="a8058df51c22be9a27f033e320020226f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8058df51c22be9a27f033e320020226f">&#9670;&#160;</a></span>Socket_getpeeraddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Socket_getpeeraddr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getpeeraddr - Get peer IP address @socket: Connected socket Returns: IP address string (IPv4/IPv6) or "(unknown)" if unavailable Note: Returns "(unknown)" if address info unavailable during accept/connect. </p>
<p>String is owned by socket, must not be freed/modified. Valid until socket freed. </p>

</div>
</div>
<a id="a47d4f0341dee9e90eacb2bb242902999" name="a47d4f0341dee9e90eacb2bb242902999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d4f0341dee9e90eacb2bb242902999">&#9670;&#160;</a></span>Socket_getpeergid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeergid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getpeergid - Get peer group ID (Linux only) @socket: Connected Unix domain socket Returns: Peer group ID, or (gid_t)-1 if unavailable Note: Only works on Linux with SO_PEERCRED. </p>
<p>Returns -1 on other platforms or non-Unix sockets. </p>

</div>
</div>
<a id="ac12a023e06a98edb7ccb24a1dfb00a23" name="ac12a023e06a98edb7ccb24a1dfb00a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12a023e06a98edb7ccb24a1dfb00a23">&#9670;&#160;</a></span>Socket_getpeerpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeerpid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getpeerpid - Get peer process ID (Linux only) @socket: Connected Unix domain socket Returns: Peer process ID, or -1 if unavailable Note: Only works on Linux with SO_PEERCRED. </p>
<p>Returns -1 on other platforms or non-Unix sockets. </p>

</div>
</div>
<a id="a4debb3b40b2e412f4e6d309d907870ec" name="a4debb3b40b2e412f4e6d309d907870ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4debb3b40b2e412f4e6d309d907870ec">&#9670;&#160;</a></span>Socket_getpeerport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeerport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getpeerport - Get peer port number @socket: Connected socket Returns: Port number (1-65535) or 0 if unavailable Note: Returns 0 if port info unavailable during accept/connect. </p>

</div>
</div>
<a id="a64ebfd0c98dd5f04ce68019c730d03c9" name="a64ebfd0c98dd5f04ce68019c730d03c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ebfd0c98dd5f04ce68019c730d03c9">&#9670;&#160;</a></span>Socket_getpeeruid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getpeeruid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getpeeruid - Get peer user ID (Linux only) @socket: Connected Unix domain socket Returns: Peer user ID, or (uid_t)-1 if unavailable Note: Only works on Linux with SO_PEERCRED. </p>
<p>Returns -1 on other platforms or non-Unix sockets. </p>

</div>
</div>
<a id="a9262ae6cbe3a40b63967ba700a011016" name="a9262ae6cbe3a40b63967ba700a011016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9262ae6cbe3a40b63967ba700a011016">&#9670;&#160;</a></span>Socket_getrcvbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getrcvbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getrcvbuf - Get receive buffer size @socket: Socket to query Returns: Receive buffer size in bytes Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="ad9c1ac9908662a224b8c818e6d55f0ec" name="ad9c1ac9908662a224b8c818e6d55f0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c1ac9908662a224b8c818e6d55f0ec">&#9670;&#160;</a></span>Socket_getsndbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_getsndbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getsndbuf - Get send buffer size @socket: Socket to query Returns: Send buffer size in bytes Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="ac2179b048d3749e7a8962f0863d5d9d0" name="ac2179b048d3749e7a8962f0863d5d9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2179b048d3749e7a8962f0863d5d9d0">&#9670;&#160;</a></span>Socket_gettimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_gettimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_gettimeout - Get socket timeout @socket: Socket to query Returns: Timeout in seconds (0 if disabled) Raises: Socket_Failed on error Note: Returns receive timeout (send timeout may differ) </p>

</div>
</div>
<a id="a5fa721bd54b028d6e92cc459c76b96ef" name="a5fa721bd54b028d6e92cc459c76b96ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa721bd54b028d6e92cc459c76b96ef">&#9670;&#160;</a></span>Socket_getusertimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Socket_getusertimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_getusertimeout - Get TCP user timeout @socket: Socket to query Returns: Timeout in milliseconds, or 0 on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.37+. </p>

</div>
</div>
<a id="a87607a3fb7bb47442e3ca5c8664cadf3" name="a87607a3fb7bb47442e3ca5c8664cadf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87607a3fb7bb47442e3ca5c8664cadf3">&#9670;&#160;</a></span>Socket_isbound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_isbound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_isbound - Check if socket is bound to an address @socket: Socket to check Returns: 1 if bound, 0 if not bound Thread-safe: Yes (operates on single socket) Note: Uses getsockname() to determine binding state. </p>
<p>A socket is bound if getsockname() succeeds and returns a valid address. Wildcard addresses (0.0.0.0 or ::) still count as bound. </p>

</div>
</div>
<a id="a4c832b75a949f8716f52b2a25fa54071" name="a4c832b75a949f8716f52b2a25fa54071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c832b75a949f8716f52b2a25fa54071">&#9670;&#160;</a></span>Socket_isconnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_isconnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected, 0 if not connected Thread-safe: Yes (operates on single socket) Note: Uses getpeername() to determine connection state. </p>
<p>For TCP sockets, checks if peer address is available. </p>

</div>
</div>
<a id="aaf51b653c9d3ad62e91c87ffb8977459" name="aaf51b653c9d3ad62e91c87ffb8977459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf51b653c9d3ad62e91c87ffb8977459">&#9670;&#160;</a></span>Socket_islistening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Socket_islistening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_islistening - Check if socket is listening for connections @socket: Socket to check Returns: 1 if listening, 0 if not listening Thread-safe: Yes (operates on single socket) Note: Checks if socket is bound and not connected. </p>
<p>A socket is listening if it's bound but has no peer address. </p>

</div>
</div>
<a id="afb9495f689b00ffc14f393d8173c98a4" name="afb9495f689b00ffc14f393d8173c98a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9495f689b00ffc14f393d8173c98a4">&#9670;&#160;</a></span>Socket_listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_listen - Listen for incoming connections @socket: Bound socket @backlog: Maximum pending connections Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="a48a12cae4cd51b880e7927a22ab82641" name="a48a12cae4cd51b880e7927a22ab82641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a12cae4cd51b880e7927a22ab82641">&#9670;&#160;</a></span>Socket_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structT.html">T</a> Socket_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ec96ac4f3517384ca22c1ef50d646a" name="af5ec96ac4f3517384ca22c1ef50d646a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ec96ac4f3517384ca22c1ef50d646a">&#9670;&#160;</a></span>Socket_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_recv - Receive data @socket: Connected socket @buf: Buffer for received data @len: Buffer size (&gt; 0) Returns: Bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Note: Return value 0 means would-block, NOT connection closed (raises exception) </p>

</div>
</div>
<a id="af21e86cdf39ae94b27c74b19e6c29c28" name="af21e86cdf39ae94b27c74b19e6c29c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21e86cdf39ae94b27c74b19e6c29c28">&#9670;&#160;</a></span>Socket_recvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_recvall - Receive all requested data (handles partial receives) @socket: Connected socket @buf: Buffer for received data @len: Buffer size (&gt; 0) Returns: Total bytes received (always equals len on success) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until len bytes are received or an error occurs. </p>
<p>For non-blocking sockets, returns 0 if would block (EAGAIN/EWOULDBLOCK). Use <a class="el" href="Socket_8h.html#a4c832b75a949f8716f52b2a25fa54071" title="Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected,...">Socket_isconnected()</a> to verify connection state before calling. </p>

</div>
</div>
<a id="a3aec26ecfd893efb26b95ec741c46656" name="a3aec26ecfd893efb26b95ec741c46656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aec26ecfd893efb26b95ec741c46656">&#9670;&#160;</a></span>Socket_recvmsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvmsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_recvmsg - Receive message with ancillary data (recvmsg wrapper) @socket: Connected socket @msg: Message structure for data, address, and ancillary data @flags: Message flags (MSG_DONTWAIT, MSG_PEEK, etc.) Returns: Total bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Allows receiving data with control messages (CMSG) for advanced features like file descriptor passing, credentials, IP options, etc. </p>
<p>May receive less than requested. Use Socket_recvmsgall() for guaranteed complete receive. </p>

</div>
</div>
<a id="af2a76fbae389a57c9a0389a691f90766" name="af2a76fbae389a57c9a0389a691f90766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a76fbae389a57c9a0389a691f90766">&#9670;&#160;</a></span>Socket_recvv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_recvv - Scatter/gather receive (readv wrapper) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes received (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Receives data into multiple buffers in a single system call. </p>
<p>May receive less than requested. Use <a class="el" href="Socket_8h.html#ac157beed03142752182021261a263671" title="Socket_recvvall - Scatter/gather receive all (handles partial receives) @socket: Connected socket @io...">Socket_recvvall()</a> for guaranteed complete receive. </p>

</div>
</div>
<a id="ac157beed03142752182021261a263671" name="ac157beed03142752182021261a263671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac157beed03142752182021261a263671">&#9670;&#160;</a></span>Socket_recvvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_recvvall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_recvvall - Scatter/gather receive all (handles partial receives) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes received (always equals sum of all iov_len on success) Raises: Socket_Closed on peer close (recv returns 0) or ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all requested data is received into all buffers or an error occurs. </p>
<p>For non-blocking sockets, returns partial progress if would block. Use <a class="el" href="Socket_8h.html#a4c832b75a949f8716f52b2a25fa54071" title="Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected,...">Socket_isconnected()</a> to verify connection state before calling. </p>

</div>
</div>
<a id="ab72bbc8824c7adf5aa55af88b784b9d0" name="ab72bbc8824c7adf5aa55af88b784b9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72bbc8824c7adf5aa55af88b784b9d0">&#9670;&#160;</a></span>Socket_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_send - Send data @socket: Connected socket @buf: Data to send @len: Length of data (&gt; 0) Returns: Bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET, Socket_Failed on other errors Note: May send less than requested. </p>
<p>Check return value. </p>

</div>
</div>
<a id="afa7bde7e1ab3130c4674e0c7bcb94ea8" name="afa7bde7e1ab3130c4674e0c7bcb94ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7bde7e1ab3130c4674e0c7bcb94ea8">&#9670;&#160;</a></span>Socket_sendall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendall - Send all data (handles partial sends) @socket: Connected socket @buf: Data to send @len: Length of data (&gt; 0) Returns: Total bytes sent (always equals len on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data is sent or an error occurs. </p>
<p>For non-blocking sockets, returns 0 if would block (EAGAIN/EWOULDBLOCK). Use <a class="el" href="Socket_8h.html#a4c832b75a949f8716f52b2a25fa54071" title="Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected,...">Socket_isconnected()</a> to verify connection state before calling. </p>

</div>
</div>
<a id="acb117caeae8c8c1ce3b50a0568be35da" name="acb117caeae8c8c1ce3b50a0568be35da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb117caeae8c8c1ce3b50a0568be35da">&#9670;&#160;</a></span>Socket_sendfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendfile - Zero-copy file-to-socket transfer @socket: Connected socket to send to @file_fd: File descriptor to read from (must be a regular file) @offset: File offset to start reading from (NULL for current position) @count: Number of bytes to transfer (0 for entire file from offset) Returns: Total bytes transferred (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Uses platform-specific zero-copy mechanism (sendfile/splice). </p>
<p>Falls back to read/write loop on platforms without sendfile support. May transfer less than requested. Use <a class="el" href="Socket_8h.html#a618437cdccde7f979f09307b99ad2b73" title="Socket_sendfileall - Zero-copy file-to-socket transfer (handles partial transfers) @socket: Connected...">Socket_sendfileall()</a> for guaranteed complete transfer. Platform support:</p><ul>
<li>Linux: Uses sendfile() system call</li>
<li>BSD/macOS: Uses sendfile() system call (different signature)</li>
<li>Other: Falls back to read/write loop </li>
</ul>

</div>
</div>
<a id="a618437cdccde7f979f09307b99ad2b73" name="a618437cdccde7f979f09307b99ad2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618437cdccde7f979f09307b99ad2b73">&#9670;&#160;</a></span>Socket_sendfileall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendfileall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendfileall - Zero-copy file-to-socket transfer (handles partial transfers) @socket: Connected socket to send to @file_fd: File descriptor to read from (must be a regular file) @offset: File offset to start reading from (NULL for current position) @count: Number of bytes to transfer (0 for entire file from offset) Returns: Total bytes transferred (always equals count on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data is transferred or an error occurs. </p>
<p>For non-blocking sockets, returns partial progress if would block. Uses platform-specific zero-copy mechanism when available. </p>

</div>
</div>
<a id="ab76433dc005a43612f7ce752d01884e3" name="ab76433dc005a43612f7ce752d01884e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76433dc005a43612f7ce752d01884e3">&#9670;&#160;</a></span>Socket_sendmsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendmsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct msghdr *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendmsg - Send message with ancillary data (sendmsg wrapper) @socket: Connected socket @msg: Message structure with data, address, and ancillary data @flags: Message flags (MSG_NOSIGNAL, MSG_DONTWAIT, etc.) Returns: Total bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Allows sending data with control messages (CMSG) for advanced features like file descriptor passing, credentials, IP options, etc. </p>
<p>May send less than requested. Use Socket_sendmsgall() for guaranteed complete send. </p>

</div>
</div>
<a id="ab675b5c1dbc4531aa0c1fc289475823b" name="ab675b5c1dbc4531aa0c1fc289475823b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab675b5c1dbc4531aa0c1fc289475823b">&#9670;&#160;</a></span>Socket_sendv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendv - Scatter/gather send (writev wrapper) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes sent (&gt; 0) or 0 if would block (EAGAIN/EWOULDBLOCK) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Sends data from multiple buffers in a single system call. </p>
<p>May send less than requested. Use <a class="el" href="Socket_8h.html#abb71b00d768e2285da07038dd6144e8e" title="Socket_sendvall - Scatter/gather send all (handles partial sends) @socket: Connected socket @iov: Arr...">Socket_sendvall()</a> for guaranteed complete send. </p>

</div>
</div>
<a id="abb71b00d768e2285da07038dd6144e8e" name="abb71b00d768e2285da07038dd6144e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb71b00d768e2285da07038dd6144e8e">&#9670;&#160;</a></span>Socket_sendvall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t Socket_sendvall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_sendvall - Scatter/gather send all (handles partial sends) @socket: Connected socket @iov: Array of iovec structures @iovcnt: Number of iovec structures (&gt; 0, &lt;= IOV_MAX) Returns: Total bytes sent (always equals sum of all iov_len on success) Raises: Socket_Closed on EPIPE/ECONNRESET Raises: Socket_Failed on other errors Thread-safe: Yes (operates on single socket) Note: Loops until all data from all buffers is sent or an error occurs. </p>
<p>For non-blocking sockets, returns partial progress if would block. Use <a class="el" href="Socket_8h.html#a4c832b75a949f8716f52b2a25fa54071" title="Socket_isconnected - Check if socket is connected @socket: Socket to check Returns: 1 if connected,...">Socket_isconnected()</a> to verify connection state before calling. </p>

</div>
</div>
<a id="adef76ca110b35a97542a01abd96b56d3" name="adef76ca110b35a97542a01abd96b56d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef76ca110b35a97542a01abd96b56d3">&#9670;&#160;</a></span>Socket_setcloexec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setcloexec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setcloexec - Control close-on-exec flag @socket: Socket to modify @enable: 1 to enable CLOEXEC, 0 to disable Raises: Socket_Failed on error Thread-safe: Yes (operates on single socket) Note: By default, all sockets have CLOEXEC enabled. </p>
<p>This function allows disabling it if you need to pass the socket to a child process. </p>

</div>
</div>
<a id="a914404cbf71b91e14240ae961b30df73" name="a914404cbf71b91e14240ae961b30df73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914404cbf71b91e14240ae961b30df73">&#9670;&#160;</a></span>Socket_setcongestion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setcongestion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setcongestion - Set TCP congestion control algorithm @socket: Socket to modify @algorithm: Algorithm name (e.g., "cubic", "reno", "bbr") Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: Only available on Linux 2.6.13+. </p>
<p>Common algorithms:</p><ul>
<li>"cubic" (default on many Linux systems)</li>
<li>"reno" (classic TCP)</li>
<li>"bbr" (Google BBR, Linux 4.9+)</li>
<li>"bbr2" (BBR v2, Linux 4.20+) Use <a class="el" href="Socket_8h.html#a4e65e3db5bd05c0ff61ba863b9b8732e" title="Socket_getcongestion - Get TCP congestion control algorithm @socket: Socket to query @algorithm: Outp...">Socket_getcongestion()</a> to query current algorithm. </li>
</ul>

</div>
</div>
<a id="a2a60e026631198fa2ee225a74565afd5" name="a2a60e026631198fa2ee225a74565afd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a60e026631198fa2ee225a74565afd5">&#9670;&#160;</a></span>Socket_setfastopen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setfastopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setfastopen - Enable TCP Fast Open @socket: Socket to modify @enable: 1 to enable, 0 to disable Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: TCP Fast Open allows sending data in SYN packet. </p>
<p>Only available on Linux 3.7+, FreeBSD 10.0+, macOS 10.11+. Must be set before connect() or listen(). Use <a class="el" href="Socket_8h.html#a0734cbd1a3c15bd40d84878102f4cb3f" title="Socket_getfastopen - Get TCP Fast Open setting @socket: Socket to query Returns: 1 if enabled,...">Socket_getfastopen()</a> to query current setting. </p>

</div>
</div>
<a id="a168b58f8fb7cb65ddb1a417c79cf0d6c" name="a168b58f8fb7cb65ddb1a417c79cf0d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168b58f8fb7cb65ddb1a417c79cf0d6c">&#9670;&#160;</a></span>Socket_setkeepalive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setkeepalive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setkeepalive - Enable TCP keepalive @socket: Socket to modify @idle: Seconds before sending keepalive probes @interval: Interval between keepalive probes @count: Number of probes before declaring dead Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="a228f425d55147dafd5e29799d5c03af0" name="a228f425d55147dafd5e29799d5c03af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228f425d55147dafd5e29799d5c03af0">&#9670;&#160;</a></span>Socket_setnodelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setnodelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setnodelay - Disable Nagle's algorithm @socket: Socket to modify @nodelay: 1 to disable Nagle, 0 to enable Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="a08886d4588009f86d4e5778363fd379e" name="a08886d4588009f86d4e5778363fd379e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08886d4588009f86d4e5778363fd379e">&#9670;&#160;</a></span>Socket_setnonblocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setnonblocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setnonblocking - Enable non-blocking mode @socket: Socket to modify Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="ac74d806db96f89a2e08338ddf59ad16a" name="ac74d806db96f89a2e08338ddf59ad16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74d806db96f89a2e08338ddf59ad16a">&#9670;&#160;</a></span>Socket_setrcvbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setrcvbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setrcvbuf - Set receive buffer size @socket: Socket to modify @size: Buffer size in bytes (&gt; 0) Raises: Socket_Failed on error Note: The kernel may adjust the value to be within system limits. </p>
<p>Use <a class="el" href="Socket_8h.html#a9262ae6cbe3a40b63967ba700a011016" title="Socket_getrcvbuf - Get receive buffer size @socket: Socket to query Returns: Receive buffer size in b...">Socket_getrcvbuf()</a> to verify the actual size set. </p>

</div>
</div>
<a id="aa9ad5151bf257e772cf3cfb32f4b13bb" name="aa9ad5151bf257e772cf3cfb32f4b13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ad5151bf257e772cf3cfb32f4b13bb">&#9670;&#160;</a></span>Socket_setreuseaddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setreuseaddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setreuseaddr - Enable address reuse @socket: Socket to modify Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="a0ce3128becb062e541c093f2277f03fe" name="a0ce3128becb062e541c093f2277f03fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce3128becb062e541c093f2277f03fe">&#9670;&#160;</a></span>Socket_setreuseport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setreuseport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setreuseport - Enable port reuse across sockets @socket: Socket to modify Raises: Socket_Failed on error (or if SO_REUSEPORT unsupported) </p>

</div>
</div>
<a id="aeecc754a971fa566e2b396d9025b961a" name="aeecc754a971fa566e2b396d9025b961a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc754a971fa566e2b396d9025b961a">&#9670;&#160;</a></span>Socket_setsndbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setsndbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setsndbuf - Set send buffer size @socket: Socket to modify @size: Buffer size in bytes (&gt; 0) Raises: Socket_Failed on error Note: The kernel may adjust the value to be within system limits. </p>
<p>Use <a class="el" href="Socket_8h.html#ad9c1ac9908662a224b8c818e6d55f0ec" title="Socket_getsndbuf - Get send buffer size @socket: Socket to query Returns: Send buffer size in bytes R...">Socket_getsndbuf()</a> to verify the actual size set. </p>

</div>
</div>
<a id="a12e9038dc4c692fb378b28d221bf7236" name="a12e9038dc4c692fb378b28d221bf7236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e9038dc4c692fb378b28d221bf7236">&#9670;&#160;</a></span>Socket_settimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_settimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_settimeout - Set socket timeout @socket: Socket to modify @timeout_sec: Timeout in seconds (0 to disable) Sets both send and receive timeouts Raises: Socket_Failed on error. </p>

</div>
</div>
<a id="af4873c11dcc702d693ee8bc930e61387" name="af4873c11dcc702d693ee8bc930e61387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4873c11dcc702d693ee8bc930e61387">&#9670;&#160;</a></span>Socket_setusertimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_setusertimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_setusertimeout - Set TCP user timeout @socket: Socket to modify @timeout_ms: Timeout in milliseconds (&gt; 0) Raises: Socket_Failed on error or if not supported Thread-safe: Yes (operates on single socket) Note: TCP user timeout controls how long to wait for ACK before closing connection. </p>
<p>Only available on Linux 2.6.37+. Use <a class="el" href="Socket_8h.html#a5fa721bd54b028d6e92cc459c76b96ef" title="Socket_getusertimeout - Get TCP user timeout @socket: Socket to query Returns: Timeout in millisecond...">Socket_getusertimeout()</a> to query current timeout. </p>

</div>
</div>
<a id="a04bb2a02d1e1cde1316ebb24bc6d33ee" name="a04bb2a02d1e1cde1316ebb24bc6d33ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb2a02d1e1cde1316ebb24bc6d33ee">&#9670;&#160;</a></span>Socket_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_shutdown - Disable further sends and/or receives @socket: Connected socket @how: Shutdown mode (SHUT_RD, SHUT_WR, or SHUT_RDWR) Raises: Socket_Failed on error Thread-safe: No (callers must synchronize concurrent access to the socket) </p>

</div>
</div>
<a id="a590cc74ce83a3ed92afa6f50bb6de788" name="a590cc74ce83a3ed92afa6f50bb6de788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590cc74ce83a3ed92afa6f50bb6de788">&#9670;&#160;</a></span>Socket_timeouts_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_timeouts_get - Retrieve per-socket timeout configuration @socket: Socket instance @timeouts: Output timeout structure Returns: Nothing. </p>

</div>
</div>
<a id="acfcc79428e54b0284cc7cad257d56adf" name="acfcc79428e54b0284cc7cad257d56adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc79428e54b0284cc7cad257d56adf">&#9670;&#160;</a></span>Socket_timeouts_getdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_getdefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_timeouts_getdefaults - Get global default timeouts @timeouts: Output timeout structure containing current defaults Returns: Nothing. </p>

</div>
</div>
<a id="a617c15d23eeff4b6b91aca2d1993a407" name="a617c15d23eeff4b6b91aca2d1993a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617c15d23eeff4b6b91aca2d1993a407">&#9670;&#160;</a></span>Socket_timeouts_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structT.html">T</a>&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_timeouts_set - Set per-socket timeout configuration @socket: Socket instance @timeouts: Timeout configuration (NULL to reset to defaults) Returns: Nothing. </p>

</div>
</div>
<a id="a0385e87c51740c37c9d90ff5bba1eced" name="a0385e87c51740c37c9d90ff5bba1eced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385e87c51740c37c9d90ff5bba1eced">&#9670;&#160;</a></span>Socket_timeouts_setdefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Socket_timeouts_setdefaults </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Socket_8h.html#a3debcc5506f258fc65706fa6455f1a05">SocketTimeouts_T</a> *&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket_timeouts_setdefaults - Set global default timeouts @timeouts: New default timeout configuration Returns: Nothing. </p>

</div>
</div>
<a id="a98ea06a38e059da3259baf352f74bf15" name="a98ea06a38e059da3259baf352f74bf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ea06a38e059da3259baf352f74bf15">&#9670;&#160;</a></span>SocketPair_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPair_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>socket1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structT.html">T</a> *&#160;</td>
          <td class="paramname"><em>socket2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SocketPair_new - Create a pair of connected Unix domain sockets @type: Socket type (SOCK_STREAM or SOCK_DGRAM) @socket1: Output - first socket of the pair @socket2: Output - second socket of the pair Raises: Socket_Failed on error Thread-safe: Yes (creates new sockets) Note: Creates two connected Unix domain sockets for IPC. </p>
<p>Both sockets are ready to use - no bind/connect needed. Typically used for parent-child or thread communication. Only supports AF_UNIX (Unix domain sockets). </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae149a16c5ec76f277f565783bc39469e" name="ae149a16c5ec76f277f565783bc39469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae149a16c5ec76f277f565783bc39469e">&#9670;&#160;</a></span>Socket_Closed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Except_T Socket_Closed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connection closed by peer. </p>

</div>
</div>
<a id="a84516221c8fd2d4bdfde8d05eaf42cc6" name="a84516221c8fd2d4bdfde8d05eaf42cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84516221c8fd2d4bdfde8d05eaf42cc6">&#9670;&#160;</a></span>Socket_Failed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Except_T Socket_Failed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General socket operation failure. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_472464c21f3697a4351aeeea96351180.html">socket</a></li><li class="navelem"><a class="el" href="Socket_8h.html">Socket.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
