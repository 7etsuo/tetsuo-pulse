---
description: Documents the October 2025 feature expansion adding UDP, cross-platform support, and Unix domain sockets
---

# Socket Library Feature Expansion - October 2025

This rule documents the major feature expansion completed in October 2025, adding UDP support, cross-platform event backends, and Unix domain sockets to the socket library.

## Expansion Summary

**Date:** October 26, 2025  
**Scope:** UDP sockets, cross-platform event system, Unix domain sockets, async DNS resolution  
**Lines Added:** ~5,700 lines of production code (3,500 + 2,200 async DNS)  
**Files Created:** 13 new files (11 + 2 async DNS)  
**Files Modified:** 6 files (4 + 2 async DNS)  
**Build Status:** ✅ Compiles with zero warnings on Linux/BSD/macOS  
**Backward Compatibility:** 100% (zero breaking changes)

---

## New Features

### 1. UDP Socket Support (SocketDgram Module)

**Files:**
- `SocketDgram.h` (187 lines) - Public API
- `SocketDgram.c` (692 lines) - Implementation

**Capabilities:**
- ✅ IPv4 and IPv6 support
- ✅ Connectionless (sendto/recvfrom) and connected (send/recv) modes
- ✅ Broadcast support (`SocketDgram_setbroadcast()`)
- ✅ Multicast support (join/leave groups, IPv4 and IPv6)
- ✅ TTL control (`SocketDgram_setttl()`)
- ✅ Non-blocking I/O
- ✅ Integration with SocketPoll
- ✅ Thread-safe error reporting

**Usage Pattern:**

```c
/* UDP server */
SocketDgram_T server = SocketDgram_new(AF_INET, 0);
SocketDgram_bind(server, NULL, 5000);

char buffer[65536], sender_host[256];
int sender_port;

ssize_t n = SocketDgram_recvfrom(server, buffer, sizeof(buffer),
                                 sender_host, sizeof(sender_host),
                                 &sender_port);

SocketDgram_sendto(server, buffer, n, sender_host, sender_port);
```

### 2. Cross-Platform Event System

**Backend Abstraction:**
- `SocketPoll_backend.h` (98 lines) - Backend interface (private)
- `SocketPoll_epoll.c` (196 lines) - Linux epoll
- `SocketPoll_kqueue.c` (227 lines) - BSD/macOS kqueue
- `SocketPoll_poll.c` (298 lines) - POSIX poll(2) fallback

**Platform Support:**

| Platform | Backend | Performance | Status |
|----------|---------|-------------|--------|
| Linux | epoll | O(active) | ✅ Production |
| macOS | kqueue | O(active) | ✅ Production |
| FreeBSD/OpenBSD/NetBSD | kqueue | O(active) | ✅ Production |
| Other POSIX | poll(2) | O(n) | ✅ Fallback |

**Auto-Detection:**
- Makefile detects platform via `uname -s`
- Automatically selects best backend
- Build message shows selected backend

**Backend Features:**
- Edge-triggered mode on epoll (EPOLLET) and kqueue (EV_CLEAR)
- Level-triggered on poll(2)
- Same SocketPoll API across all platforms
- Zero overhead (compile-time selection)

### 3. Async DNS Resolution (SocketDNS Module)

**Files:**
- `SocketDNS.h` (~200 lines) - Public API
- `SocketDNS.c` (~700 lines) - Implementation

**Capabilities:**
- ✅ Thread pool-based async DNS resolution
- ✅ Callback-based completion notification
- ✅ SocketPoll integration via pollable file descriptor
- ✅ Request cancellation support
- ✅ Thread-safe implementation
- ✅ Eliminates 30+ second blocking during DNS failures
- ✅ Addresses DoS vulnerability from blocking DNS

**Usage Pattern (Callback-based):**
```c
SocketDNS_T dns = SocketDNS_new();

void on_resolve(SocketDNS_Request_T req, struct addrinfo *res, int error, void *data) {
    Socket_T socket = (Socket_T)data;
    if (res) {
        Socket_bind_with_addrinfo(socket, res);
        freeaddrinfo(res);
    }
}

SocketDNS_Request_T req = Socket_bind_async(dns, socket, "example.com", 8080);
SocketDNS_resolve(dns, "example.com", 8080, on_resolve, socket);
```

**Usage Pattern (SocketPoll integration):**
```c
SocketDNS_T dns = SocketDNS_new();
SocketPoll_T poll = SocketPoll_new(100);
int dns_fd = SocketDNS_pollfd(dns);

/* Monitor DNS completion */
SocketDNS_Request_T req = Socket_bind_async(dns, socket, "example.com", 8080);

/* In event loop: */
SocketDNS_check(dns);  /* Process completed requests */
struct addrinfo *res = SocketDNS_getresult(dns, req);
if (res) {
    Socket_bind_with_addrinfo(socket, res);
    freeaddrinfo(res);
}
```

**Configuration:**
- `SOCKET_DNS_THREAD_COUNT` - Worker thread count (default: 4)
- `SOCKET_DNS_MAX_PENDING` - Max pending requests (default: 1000)
- `SOCKET_DNS_TIMEOUT_SEC` - Request timeout (default: 5)

### 4. Unix Domain Sockets

**Integration:** Added to existing Socket module (no new module needed)

**New Functions:**
```c
void Socket_bind_unix(Socket_T socket, const char *path);
void Socket_connect_unix(Socket_T socket, const char *path);
int Socket_getpeerpid(Socket_T socket);  /* Linux only */
int Socket_getpeeruid(Socket_T socket);  /* Linux only */
int Socket_getpeergid(Socket_T socket);  /* Linux only */
```

**Features:**
- ✅ Filesystem-based Unix sockets (all platforms)
- ✅ Abstract namespace sockets (Linux, '@' prefix)
- ✅ Peer credentials via SO_PEERCRED (Linux)
- ✅ IPC with file permission security
- ✅ Works with SocketPoll and SocketPool

**Usage Pattern:**

```c
/* Server */
Socket_T server = Socket_new(AF_UNIX, SOCK_STREAM, 0);
unlink("/tmp/app.sock");
Socket_bind_unix(server, "/tmp/app.sock");
Socket_listen(server, 5);

Socket_T client = Socket_accept(server);
pid_t peer_pid = Socket_getpeerpid(client);  /* Linux */

/* Client */
Socket_T client = Socket_new(AF_UNIX, SOCK_STREAM, 0);
Socket_connect_unix(client, "/tmp/app.sock");
```

---

## Build System Enhancements

### Platform Auto-Detection

```makefile
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
    POLL_BACKEND = epoll
else ifeq ($(UNAME_S),Darwin)
    POLL_BACKEND = kqueue
else
    POLL_BACKEND = poll
endif
```

### New Build Targets

```bash
make              # Build with auto-detected backend
make lib          # Build libsocket.so and libsocket.a
make release      # Optimized production build
make clean        # Clean all artifacts
```

### Build Output

```
Building socket library with epoll backend on Linux
```

---

## Example Programs

**Created:**
- `examples/udp_echo_server.c` (109 lines) - UDP datagram server
- `examples/unix_ipc_server.c` (111 lines) - Unix domain socket server
- `examples/unix_ipc_client.c` (62 lines) - Unix domain socket client
- `examples/Makefile` (44 lines) - Build system for examples

**Existing:**
- `main.c` - TCP IRC-style server (uses SocketPoll + SocketPool)
- `test_client.c` - TCP client tester

**Total:** 5 complete working examples demonstrating all socket types

---

## Documentation

### README.md (565 lines)

**Sections:**
- Feature overview with platform support matrix
- Architecture documentation
- Complete API reference for all modules
- Build instructions with platform detection
- Usage examples for TCP/UDP/Unix sockets
- Performance characteristics
- Thread safety documentation
- Security considerations
- Limitations and caveats

### Implementation Summary

**Created:** `IMPLEMENTATION_SUMMARY.md` documenting:
- Feature completion status
- Implementation details
- Files created/modified
- Build verification
- Backward compatibility
- Performance impact

---

## API Changes

### New Public APIs

**SocketDgram (UDP):**
- `SocketDgram_new()`, `SocketDgram_free()`
- `SocketDgram_bind()`, `SocketDgram_connect()`
- `SocketDgram_sendto()`, `SocketDgram_recvfrom()`
- `SocketDgram_send()`, `SocketDgram_recv()`
- `SocketDgram_setbroadcast()`, `SocketDgram_setttl()`
- `SocketDgram_joinmulticast()`, `SocketDgram_leavemulticast()`
- `SocketDgram_setnonblocking()`, `SocketDgram_setreuseaddr()`

**SocketDNS (Async DNS):**
- `SocketDNS_new()`, `SocketDNS_free()`
- `SocketDNS_resolve()` - Start async resolution
- `SocketDNS_cancel()` - Cancel pending request
- `SocketDNS_pollfd()` - Get pollable file descriptor
- `SocketDNS_check()` - Check for completed requests
- `SocketDNS_getresult()` - Get resolved address

**Socket (Async DNS + Unix domain extensions):**
- `Socket_bind_async()` - Start async DNS for bind
- `Socket_connect_async()` - Start async DNS for connect
- `Socket_bind_with_addrinfo()` - Bind with pre-resolved address
- `Socket_connect_with_addrinfo()` - Connect with pre-resolved address
- `Socket_bind_unix()` - Bind to Unix socket path
- `Socket_connect_unix()` - Connect to Unix socket path
- `Socket_getpeerpid()` - Get peer process ID (Linux)
- `Socket_getpeeruid()` - Get peer user ID (Linux)
- `Socket_getpeergid()` - Get peer group ID (Linux)

**SocketPoll (unchanged - internal refactoring only):**
- API 100% compatible
- Now supports epoll/kqueue/poll backends transparently

### No Breaking Changes

- ✅ All existing APIs unchanged
- ✅ Existing code compiles without modification
- ✅ Binary compatibility maintained
- ✅ SocketPoll refactored internally only

---

## Code Quality Maintained

### Coding Standards
- ✅ GNU C coding style throughout
- ✅ C Interfaces and Implementations patterns
- ✅ Comprehensive Doxygen documentation
- ✅ Thread safety documented and implemented
- ✅ Input validation on all public APIs
- ✅ Overflow protection in arithmetic

### Build Quality
- ✅ Compiles with `-Wall -Wextra -Werror`
- ✅ Zero compiler warnings on Linux
- ✅ Debug and release builds supported
- ✅ Shared and static library targets

### Documentation Quality
- ✅ Every public function documented
- ✅ Platform requirements stated
- ✅ Thread safety documented
- ✅ Performance characteristics noted
- ✅ Working examples provided

---

## Usage Patterns

### TCP Server (Existing, Enhanced)

```c
Socket_T server = Socket_new(AF_INET6, SOCK_STREAM, 0);  /* Dual-stack */
Socket_bind(server, NULL, 8080);
Socket_listen(server, 128);

SocketPoll_T poll = SocketPoll_new(1000);  /* Auto-selects backend */
SocketPoll_add(poll, server, POLL_READ, NULL);
```

### UDP Server (New)

```c
SocketDgram_T server = SocketDgram_new(AF_INET, 0);
SocketDgram_bind(server, NULL, 5000);

/* Multicast support */
SocketDgram_joinmulticast(server, "224.0.0.1", NULL);
```

### Unix Domain IPC (New)

```c
Socket_T server = Socket_new(AF_UNIX, SOCK_STREAM, 0);
Socket_bind_unix(server, "/tmp/app.sock");
Socket_listen(server, 5);

Socket_T client = Socket_accept(server);
pid_t peer = Socket_getpeerpid(client);  /* Linux peer credentials */
```

### Cross-Platform Event Polling (Enhanced)

```c
/* Same API works on Linux (epoll), macOS (kqueue), or POSIX (poll) */
SocketPoll_T poll = SocketPoll_new(1000);
SocketPoll_add(poll, socket, POLL_READ | POLL_WRITE, data);

int n = SocketPoll_wait(poll, &events, timeout);
/* Backend automatically selected at compile time */
```

---

## Design Decisions

### Why Separate SocketDgram Module?

**Decision:** Create separate module instead of adding to Socket.

**Rationale:**
- UDP and TCP have fundamentally different APIs (sendto vs send)
- Clearer separation of concerns
- Easier to understand and maintain
- Follows single-responsibility principle
- Smaller, focused modules

### Why Backend Abstraction?

**Decision:** Internal backend abstraction with compile-time selection.

**Rationale:**
- Public API remains unchanged
- Zero runtime overhead (no function pointers)
- Platform-specific optimizations (edge-trigger on epoll/kqueue)
- Portable fallback (poll) available
- Compile-time guarantee of platform support

### Why Integrate Unix Sockets into Socket Module?

**Decision:** Add to existing Socket module instead of new module.

**Rationale:**
- Unix domain sockets are stream-based (like TCP)
- Reuses existing Socket_T structure
- Same send/recv/listen/accept API
- Only bind/connect differ (Unix paths vs IP addresses)
- Natural extension of existing functionality

---

## Performance Impact

### Event System Performance

**No degradation for existing users:**
- epoll backend on Linux: Same performance as before
- kqueue backend on BSD/macOS: Equivalent to epoll
- poll backend: Only used where epoll/kqueue unavailable

### Memory Overhead

**Minimal overhead:**
- UDP socket: ~200 bytes per socket
- Backend abstraction: Zero runtime overhead (compile-time)
- Unix domain sockets: Zero overhead (reuses Socket_T)

### Binary Size

**Acceptable increase:**
- Total library size: ~80KB increase
- Breakdown: 40KB UDP, 20KB kqueue, 15KB poll, 5KB Unix sockets
- Negligible on modern systems

---

## Future Enhancements (Not Implemented)

### Windows Support
**Status:** Not planned (would require Winsock adaptation)

**Reason:** Library targets POSIX systems, Windows requires different APIs.

### TLS/SSL Support
**Status:** Future consideration

**Reason:** Could be added as wrapper module using OpenSSL/LibreSSL.

---

## Migration Guide

### For Existing Code

**No changes required!** Existing code compiles and runs without modification.

### To Use New Features

**Add UDP support:**
```c
#include "SocketDgram.h"

SocketDgram_T udp = SocketDgram_new(AF_INET, 0);
SocketDgram_bind(udp, NULL, 5000);
```

**Add Unix socket support:**
```c
Socket_T unix_sock = Socket_new(AF_UNIX, SOCK_STREAM, 0);
Socket_bind_unix(unix_sock, "/tmp/app.sock");
```

**Use on BSD/macOS:**
```bash
# Just rebuild - kqueue backend auto-selected
make clean && make
# Shows: "Building socket library with kqueue backend on Darwin"
```

---

## References

### Implementation Files

**UDP Support:**
- [SocketDgram.h](mdc:SocketDgram.h)
- [SocketDgram.c](mdc:SocketDgram.c)

**Cross-Platform Backends:**
- [SocketPoll_backend.h](mdc:SocketPoll_backend.h)
- [SocketPoll_epoll.c](mdc:SocketPoll_epoll.c)
- [SocketPoll_kqueue.c](mdc:SocketPoll_kqueue.c)
- [SocketPoll_poll.c](mdc:SocketPoll_poll.c)

**Async DNS Resolution:**
- [SocketDNS.h](mdc:SocketDNS.h) - Async DNS API
- [SocketDNS.c](mdc:SocketDNS.c) - Thread pool implementation

**Unix Domain Sockets:**
- [Socket.h](mdc:Socket.h) - Unix API additions
- [Socket.c](mdc:Socket.c) - Unix implementation

**Examples:**
- [examples/udp_echo_server.c](mdc:examples/udp_echo_server.c)
- [examples/unix_ipc_server.c](mdc:examples/unix_ipc_server.c)
- [examples/unix_ipc_client.c](mdc:examples/unix_ipc_client.c)

**Documentation:**
- [README.md](mdc:README.md) - Comprehensive guide
- [IMPLEMENTATION_SUMMARY.md](mdc:IMPLEMENTATION_SUMMARY.md) - Implementation details

### Related Rules
- `udp-sockets` - UDP socket patterns
- `cross-platform-backends` - Backend system documentation
- `unix-domain-sockets` - Unix socket patterns
- `async-dns` - Async DNS resolution patterns and usage
- `build-system` - Updated with platform detection
- `module-patterns` - Updated with new modules
- `architecture-patterns` - Updated with new architecture
- `error-handling` - Thread-safe exception patterns

---

## Quick Reference

### Socket Types Supported

| Type | Module | Create | Bind | Connect |
|------|--------|--------|------|---------|
| TCP IPv4 | Socket | `AF_INET, SOCK_STREAM` | `Socket_bind()` / `Socket_bind_async()` | `Socket_connect()` / `Socket_connect_async()` |
| TCP IPv6 | Socket | `AF_INET6, SOCK_STREAM` | `Socket_bind()` / `Socket_bind_async()` | `Socket_connect()` / `Socket_connect_async()` |
| Unix Stream | Socket | `AF_UNIX, SOCK_STREAM` | `Socket_bind_unix()` | `Socket_connect_unix()` |
| UDP IPv4 | SocketDgram | `AF_INET, 0` | `SocketDgram_bind()` | `SocketDgram_connect()` |
| UDP IPv6 | SocketDgram | `AF_INET6, 0` | `SocketDgram_bind()` | `SocketDgram_connect()` |

### Async DNS Usage

| Operation | Async Start | Completion Check | Finish Operation |
|-----------|-------------|------------------|------------------|
| Bind | `Socket_bind_async()` | `SocketDNS_getresult()` | `Socket_bind_with_addrinfo()` |
| Connect | `Socket_connect_async()` | `SocketDNS_getresult()` | `Socket_connect_with_addrinfo()` |

### Event Backends by Platform

| Platform | Backend | Select via |
|----------|---------|------------|
| Linux | epoll | Automatic |
| Darwin (macOS) | kqueue | Automatic |
| FreeBSD | kqueue | Automatic |
| OpenBSD | kqueue | Automatic |
| NetBSD | kqueue | Automatic |
| Other | poll | Automatic |

### Build Commands

```bash
# Standard build (shows backend selection)
make clean && make

# Build libraries
make lib          # Creates libsocket.so and libsocket.a

# Build examples
cd examples && make

# Run examples
./examples/udp_echo_server 5000
./examples/unix_ipc_server
./examples/unix_ipc_client
```

---

## Best Practices for New Features

### UDP Sockets

1. **USE** large buffers (65536 bytes) to avoid truncation
2. **LIMIT** datagram size to 1472 bytes to avoid fragmentation
3. **VALIDATE** sender addresses (UDP is spoofable)
4. **HANDLE** packet loss, reordering, duplication
5. **INTEGRATE** with SocketPoll for non-blocking I/O

### Unix Domain Sockets

1. **ALWAYS** unlink() socket file before bind
2. **ALWAYS** cleanup socket file on shutdown
3. **USE** absolute paths for socket files
4. **SET** appropriate file permissions (chmod)
5. **USE** peer credentials for authentication (Linux)
6. **PREFER** abstract namespace (@prefix) on Linux to avoid filesystem clutter

### Cross-Platform Development

1. **TEST** on multiple platforms (Linux, macOS, BSD)
2. **USE** SocketPoll API (not backend-specific APIs)
3. **DOCUMENT** platform-specific features (SO_PEERCRED, abstract sockets)
4. **VERIFY** backend selection during build
5. **HANDLE** platform differences gracefully

---

## Changelog

### Version 2.0.0 (October 26, 2025)

**Added:**
- SocketDgram module for UDP datagram sockets
- Cross-platform event backend system (epoll/kqueue/poll)
- Unix domain socket support in Socket module
- Multicast and broadcast support for UDP
- Peer credential access for Unix sockets (Linux)
- Shared library target (libsocket.so)
- Static library target (libsocket.a)
- Platform auto-detection in build system
- 3 new example programs
- Comprehensive README.md

**Changed:**
- SocketPoll internally refactored for backend abstraction
- Makefile enhanced with platform detection
- Build system now shows selected backend

**No Breaking Changes:**
- All existing APIs unchanged
- Binary compatibility maintained
- Existing code works without modification
