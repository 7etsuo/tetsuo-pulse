---
description: Enforces the build system patterns and project structure used in the socket library
---

# Build System and Project Structure

This rule enforces the build system patterns and project structure conventions used throughout the socket library project.

## Project Structure

### Directory Layout
**ALWAYS** organize projects with this structure:

```
project/
├── src/                    # Source code (optional)
├── include/               # Public headers (optional)
├── .cursor/rules/         # Cursor rules and documentation
├── Makefile              # Build system
├── README.md             # Project documentation
├── *.c                   # Source files
├── *.h                   # Header files
└── tags                  # Tag file for navigation
```

### File Organization
**ALWAYS** group related files together:

```c
Arena.c Arena.h             # Memory management
Except.c Except.h           # Exception handling
Socket.c Socket.h           # TCP and Unix domain sockets
SocketDgram.c SocketDgram.h # UDP datagram sockets
SocketBuf.c SocketBuf.h     # Socket buffering
SocketPoll.c SocketPoll.h   # Event polling (frontend)
SocketPoll_backend.h        # Backend interface (private)
SocketPoll_epoll.c          # Linux epoll backend
SocketPoll_kqueue.c         # BSD/macOS kqueue backend
SocketPoll_poll.c           # POSIX poll fallback
SocketPool.c SocketPool.h   # Connection management
SocketConfig.h              # Configuration constants
SocketError.c SocketError.h # Error handling utilities
main.c                      # Main program/demo
Makefile                    # Build configuration
examples/                   # Example programs
```

## Makefile Structure

### Platform Detection and Backend Selection
**ALWAYS** auto-detect platform for cross-platform builds:

```makefile
CC = gcc

# Auto-detect platform for backend selection
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Linux)
    POLL_BACKEND = epoll
    POLL_BACKEND_SRC = SocketPoll_epoll.c
else ifeq ($(UNAME_S),Darwin)
    POLL_BACKEND = kqueue
    POLL_BACKEND_SRC = SocketPoll_kqueue.c
else ifeq ($(UNAME_S),FreeBSD)
    POLL_BACKEND = kqueue
    POLL_BACKEND_SRC = SocketPoll_kqueue.c
else ifeq ($(UNAME_S),OpenBSD)
    POLL_BACKEND = kqueue
    POLL_BACKEND_SRC = SocketPoll_kqueue.c
else ifeq ($(UNAME_S),NetBSD)
    POLL_BACKEND = kqueue
    POLL_BACKEND_SRC = SocketPoll_kqueue.c
else
    POLL_BACKEND = poll
    POLL_BACKEND_SRC = SocketPoll_poll.c
endif
```

### Standard Makefile Pattern with Debug/Release
**ALWAYS** use the standard Makefile structure with separate debug/release builds:

```makefile
# Debug build (default) - includes symbols, optimizes for debugging
CFLAGS_DEBUG = -Wall -Wextra -Werror -g -Og -D_GNU_SOURCE -pthread -std=gnu99

# Release build - full optimization, no debug symbols
CFLAGS_RELEASE = -Wall -Wextra -Werror -O3 -DNDEBUG -D_GNU_SOURCE -pthread -std=gnu99

# Default to debug build
CFLAGS = $(CFLAGS_DEBUG)

LDFLAGS = -pthread
TARGET = program_name

# Object files (include backend-specific source)
SOURCES = Arena.c Except.c Socket.c SocketDgram.c SocketBuf.c \
          SocketPoll.c $(POLL_BACKEND_SRC) SocketPool.c SocketError.c main.c
OBJECTS = $(SOURCES:.c=.o)
DEPS = $(SOURCES:.c=.d)

# Library object files (exclude main.c)
LIB_SOURCES = Arena.c Except.c Socket.c SocketDgram.c SocketBuf.c \
              SocketPoll.c $(POLL_BACKEND_SRC) SocketPool.c SocketError.c
LIB_OBJECTS = $(LIB_SOURCES:.c=.o)

# Default target with info message
all: info $(TARGET)

info:
	@echo "Building socket library with $(POLL_BACKEND) backend on $(UNAME_S)"

# Link target
# NOTE: $(LDFLAGS) must come after object files for proper linking
$(TARGET): $(OBJECTS)
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# Shared library target
libsocket.so: $(LIB_OBJECTS)
	$(CC) -shared -o $@ $^ $(LDFLAGS)

# Static library target
libsocket.a: $(LIB_OBJECTS)
	$(AR) rcs $@ $^

# Compilation rule with dependency tracking
%.o: %.c
	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@

# Auto-generated dependencies
-include $(DEPS)

# Cleanup (remove all backend object files)
clean:
	rm -f $(OBJECTS) $(TARGET) $(DEPS)
	rm -f libsocket.so libsocket.a
	rm -f SocketPoll_epoll.o SocketPoll_kqueue.o SocketPoll_poll.o
	rm -f SocketPoll_epoll.d SocketPoll_kqueue.d SocketPoll_poll.d

# Release build target - optimized for production
release: CFLAGS = $(CFLAGS_RELEASE)
release: clean all

# Library build target
lib: libsocket.so libsocket.a

# Phony targets
.PHONY: all clean release lib info
```

### Dependency Tracking
**ALWAYS** specify proper file dependencies:

```makefile
# Proper dependency declarations
Arena.o: Arena.c Arena.h SocketConfig.h
Except.o: Except.c Except.h
Socket.o: Socket.c Socket.h Arena.h Except.h SocketConfig.h SocketError.h
SocketBuf.o: SocketBuf.c SocketBuf.h Arena.h
SocketPoll.o: SocketPoll.c SocketPoll.h Socket.h Except.h Arena.h SocketConfig.h SocketError.h
SocketPool.o: SocketPool.c SocketPool.h Socket.h SocketBuf.h Arena.h SocketConfig.h
SocketError.o: SocketError.c SocketError.h
main.o: main.c Arena.h Except.h Socket.h SocketBuf.h SocketPoll.h SocketPool.h
```

### Compilation Flags
**ALWAYS** use appropriate compilation flags:

```makefile
# Enable all warnings
CFLAGS = -Wall -Wextra -Werror

# Debugging information
CFLAGS += -g

# Optimization level
CFLAGS += -O2

# Thread support (required for thread safety)
CFLAGS += -pthread           # Compiler flags for pthread
LDFLAGS += -pthread          # Linker flags for pthread (CRITICAL!)
CFLAGS += -D_GNU_SOURCE      # GNU extensions

# Standards compliance
CFLAGS += -std=c99

# Platform-specific flags
ifeq ($(OS), Windows_NT)
    CFLAGS += -D_WIN32
else
    CFLAGS += -D_POSIX_C_SOURCE=200809L
endif
```

## Header File Organization

### Include Guards
**ALWAYS** use consistent include guards:

```c
#ifndef FILENAME_INCLUDED
#define FILENAME_INCLUDED

// Header content

#endif /* FILENAME_INCLUDED */
```

### Header File Order
**ALWAYS** include headers in this order:

```c
#include <system_header1.h>    // System headers first
#include <system_header2.h>
#include <system_header3.h>

#include "local_header1.h"     // Local headers second
#include "local_header2.h"
#include "local_header3.h"
```

### Forward Declarations
**PREFER** forward declarations over unnecessary includes:

```c
/* Forward declaration instead of including header */
typedef struct Arena_T Arena_T;

/* Only include when implementation is needed */
#ifdef IMPLEMENTATION
#include "Arena.h"
#endif
```

## Source File Organization

### File Headers
**ALWAYS** include a standard file header:

```c
/**
 * filename.c - Brief description of the module
 *
 * Part of the Socket Library
 * Following C Interfaces and Implementations patterns
 */
```

### Function Order
**PREFER** organize functions in logical order:

```c
/**
 * filename.c - Brief description
 *
 * Part of the Socket Library
 * Following C Interfaces and Implementations patterns
 */

/* System headers */
#include <system_header.h>

/* Local headers */
#include "ModuleName.h"

/* 1. Type definitions */
#define T ModuleName_T
struct T
{
    // Structure members
};
typedef struct T *T;

/* 2. Static helper functions */
static Type helper_function(Type param)
{
    // Implementation
}

/* 3. Public API functions */
Type ModuleName_function(Type param)
{
    // Implementation
}

/* 4. Cleanup */
#undef T
```

### Static Functions
**ALWAYS** declare static functions before use:

```c
static Type helper_function1(Type param);
static Type helper_function2(Type param);

Type public_function(Type param)
{
    result1 = helper_function1(param);
    result2 = helper_function2(result1);
    return result2;
}

static Type helper_function1(Type param)
{
    // Implementation
}

static Type helper_function2(Type param)
{
    // Implementation
}
```

## Configuration Management

### Configuration Headers
**ALWAYS** use configuration headers with override protection:

```c
#ifndef MODULE_CONFIG_H
#define MODULE_CONFIG_H

/* Default values with compile-time override */
#ifndef MODULE_MAX_SIZE
#define MODULE_MAX_SIZE 1000
#endif

#ifndef MODULE_TIMEOUT
#define MODULE_TIMEOUT 30
#endif

#ifndef MODULE_BUFFER_SIZE
#define MODULE_BUFFER_SIZE (1024 * 1024)
#endif

/* Runtime validation */
#define MODULE_VALID_SIZE(s) ((size_t)(s) > 0 && (size_t)(s) <= MODULE_MAX_SIZE)
#define MODULE_VALID_TIMEOUT(t) ((int)(t) > 0 && (int)(t) <= 3600)

#endif /* MODULE_CONFIG_H */
```

### Build Configuration
**ALWAYS** support build-time configuration:

```makefile
# Build configuration
DEBUG ?= 0
PROFILE ?= 0

# Conditional compilation
ifeq ($(DEBUG), 1)
    CFLAGS += -DDEBUG -O0
else
    CFLAGS += -DNDEBUG -O2
endif

ifeq ($(PROFILE), 1)
    CFLAGS += -pg
    LDFLAGS += -pg
endif

# Feature flags
WITH_CUDA ?= 0
ifeq ($(WITH_CUDA), 1)
    CFLAGS += -DWITH_CUDA
    LDFLAGS += -lcuda
endif
```

## Documentation

### Module Documentation
**ALWAYS** include comprehensive module documentation:

```c
/**
 * Module Name
 *
 * Detailed description of the module's purpose, functionality, and behavior.
 * Explain the design decisions and trade-offs made.
 *
 * Features:
 * - Feature 1: Description of what it does
 * - Feature 2: Description of what it does
 * - Feature 3: Description of what it does
 *
 * Thread Safety:
 * - Function1: Thread-safe, explanation
 * - Function2: Not thread-safe, explanation
 *
 * Performance:
 * - Time complexity: O(n) average case
 * - Space complexity: O(m) memory usage
 * - Limitations: Description of limits
 *
 * Usage Example:
 *   // Example code showing typical usage
 *   Module_T module = Module_new();
 *   result = Module_process(module, input);
 *   Module_free(&module);
 */
```

### Function Documentation
**ALWAYS** document all public functions:

```c
/**
 * FunctionName - Brief description of what the function does
 * @param1: Description of the first parameter
 * @param2: Description of the second parameter
 * @param3: Description of the third parameter
 *
 * Returns: Description of what the function returns
 * Raises: Description of exceptions that may be raised
 * Thread-safe: Yes/No with explanation if No
 * Performance: O(?) complexity information
 *
 * Detailed description of behavior, side effects, and important notes.
 * Include information about error conditions and edge cases.
 */
```

## Testing Structure

### Test Organization
**ALWAYS** organize tests with this structure:

```c
tests/
├── unit/                 # Unit tests
│   ├── test_arena.c
│   ├── test_socket.c
│   ├── test_buffer.c
│   └── test_poll.c
├── integration/          # Integration tests
│   ├── test_server.c
│   └── test_client.c
├── performance/          # Performance tests
│   └── benchmark.c
└── Makefile             # Test build configuration
```

### Test Makefile
**ALWAYS** provide a test build system:

```makefile
# Test configuration
TEST_CFLAGS = -Wall -Wextra -g -O0 -DTESTING
TEST_LDFLAGS = -lcheck -lm -pthread

# Test targets
test: unit_tests integration_tests
	./unit_tests
	./integration_tests

unit_tests: tests/unit/test_*.c src/*.c
	$(CC) $(TEST_CFLAGS) -o $@ $^ $(TEST_LDFLAGS)

integration_tests: tests/integration/test_*.c src/*.c
	$(CC) $(TEST_CFLAGS) -o $@ $^ $(TEST_LDFLAGS)

performance_tests: tests/performance/benchmark.c src/*.c
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS) -lbenchmark

# Test data
test_data:
	mkdir -p tests/data
	# Generate test data

# Coverage
coverage: CFLAGS += -fprofile-arcs -ftest-coverage
coverage: test
	gcov src/*.c
	lcov --capture --directory . --output-file coverage.info
	genhtml coverage.info --output-directory coverage_report

.PHONY: test unit_tests integration_tests performance_tests test_data coverage
```

## Version Control

### Git Structure
**ALWAYS** use proper git structure:

```bash
# Repository structure
.git/
.gitignore
README.md
LICENSE
CONTRIBUTING.md
CHANGELOG.md
docs/
src/
include/
tests/
tools/
scripts/
examples/
```

### Gitignore Pattern
**ALWAYS** ignore build artifacts:

```gitignore
# Build artifacts
*.o
*.so
*.dylib
*.dll
*.exe
*.out
program_name
tags

# Test artifacts
*.gcno
*.gcda
coverage.info
coverage_report/

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
```

## Installation and Distribution

### Installation Structure
**ALWAYS** support standard installation:

```makefile
# Installation paths
PREFIX ?= /usr/local
BINDIR = $(PREFIX)/bin
LIBDIR = $(PREFIX)/lib
INCDIR = $(PREFIX)/include
MANDIR = $(PREFIX)/share/man

# Installation targets
install: $(TARGET)
	install -d $(BINDIR)
	install -m 755 $(TARGET) $(BINDIR)
	install -d $(INCDIR)
	install -m 644 *.h $(INCDIR)
	install -d $(LIBDIR)
	install -m 644 *.so $(LIBDIR) 2>/dev/null || true

uninstall:
	rm -f $(BINDIR)/$(TARGET)
	rm -f $(INCDIR)/*.h
	rm -f $(LIBDIR)/*.so 2>/dev/null || true

.PHONY: install uninstall
```

### Package Configuration
**ALWAYS** provide package configuration:

```makefile
# Package information
PACKAGE_NAME = socket-library
PACKAGE_VERSION = 1.0.0
PACKAGE_DESCRIPTION = "High-performance socket library"

# Package target
package: clean
	tar -czf $(PACKAGE_NAME)-$(PACKAGE_VERSION).tar.gz \
		--exclude='.git' \
		--exclude='*.tar.gz' \
		--exclude='tests' \
		--transform='s,^,$(PACKAGE_NAME)-$(PACKAGE_VERSION)/,' \
		*

.PHONY: package
```

## Development Workflow

### Development Makefile
**ALWAYS** provide development-friendly targets:

```makefile
# Development targets
dev: CFLAGS += -DDEBUG -O0 -g
dev: $(TARGET)

# Static analysis
analyze: clean
	scan-build make

# Format code
format:
	clang-format -i *.c *.h

# Check style
style:
	clang-format --dry-run --Werror *.c *.h

# Run tests with coverage
test-coverage: clean
	$(MAKE) coverage

# Full development cycle
check: style analyze test test-coverage

.PHONY: dev analyze format style test-coverage check
```

## Continuous Integration

### CI Configuration
**ALWAYS** provide CI configuration:

```yaml
# Basic CI pipeline
language: c
compiler:
  - gcc
  - clang

before_script:
  - sudo apt-get update -qq
  - sudo apt-get install -qq check libsubunit-dev

script:
  - make clean
  - make
  - make test

after_success:
  - make test-coverage
  - bash <(curl -s https://codecov.io/bash)
```

## Documentation Generation

### Doxygen Configuration
**ALWAYS** provide Doxygen configuration:

```makefile
# Documentation
docs: Doxyfile
	doxygen Doxyfile

Doxyfile: docs/Doxyfile.in
	sed 's/@VERSION@/$(PACKAGE_VERSION)/g' $< > $@

.PHONY: docs
```

### Documentation Structure
**ALWAYS** organize documentation:

```c
docs/
├── Doxyfile.in           # Doxygen template
├── api/                  # API documentation
├── examples/             # Usage examples
├── design/               # Design documents
└── README.md            # Documentation overview
```

## Release Management

### Version Information
**ALWAYS** maintain version information:

```makefile
# Version information
MAJOR_VERSION = 1
MINOR_VERSION = 0
PATCH_VERSION = 0
VERSION = $(MAJOR_VERSION).$(MINOR_VERSION).$(PATCH_VERSION)

# Version targets
version:
	@echo $(VERSION)

# Release preparation
release: clean test docs package
	@echo "Release $(VERSION) ready"
	@echo "Files:"
	@ls -la *.tar.gz

.PHONY: version release
```

## Quality Assurance

### Code Quality Checks
**ALWAYS** implement quality checks:

```makefile
# Quality assurance
quality: format style analyze test test-coverage

# Comprehensive check
check-all: clean
	$(MAKE) quality
	@echo "All checks passed"

.PHONY: quality check-all
```

### Metrics Collection
**ALWAYS** collect project metrics:

```makefile
# Project metrics
metrics:
	@echo "Lines of code:"
	@find . -name "*.c" -o -name "*.h" | xargs wc -l
	@echo "Function count:"
	@grep -r "^[a-zA-Z_][a-zA-Z0-9_]*(" *.c | wc -l
	@echo "Test coverage:"
	@gcovr -r . --html --html-details -o coverage.html

.PHONY: metrics
```