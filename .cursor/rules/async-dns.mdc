---
description: Async DNS resolution patterns and usage guidelines for the SocketDNS module
---

# Async DNS Resolution Patterns

This rule documents the async DNS resolution patterns and best practices for using the SocketDNS module.

## Overview

The SocketDNS module provides asynchronous DNS resolution using a thread pool to eliminate blocking `getaddrinfo()` calls that can take 30+ seconds during DNS failures. This addresses DoS vulnerabilities and enables truly non-blocking socket operations.

## Architecture

### Thread Pool Design

- **Worker Threads**: Configurable count (default: 4 via `SOCKET_DNS_THREAD_COUNT`)
- **Request Queue**: Thread-safe queue with mutex + condition variable
- **Result Storage**: Hash table for O(1) request lookup
- **Completion Signaling**: Pipe for SocketPoll integration

### Request Lifecycle

1. **PENDING**: Request in queue, waiting for worker thread
2. **PROCESSING**: Worker thread performing DNS resolution
3. **COMPLETE**: Result available for retrieval
4. **CANCELLED**: Request cancelled before completion

## Usage Patterns

### Pattern 1: Callback-Based Async Resolution

**Use Case**: Simple async operations where callback is sufficient

```c
SocketDNS_T dns = SocketDNS_new();

void on_resolve(SocketDNS_Request_T req, struct addrinfo *res, int error, void *data) {
    Socket_T socket = (Socket_T)data;
    
    if (error == 0 && res) {
        TRY
            Socket_bind_with_addrinfo(socket, res);
            printf("Bound successfully\n");
        EXCEPT(Socket_Failed)
            fprintf(stderr, "Bind failed: %s\n", Socket_Failed.reason);
        END_TRY;
        
        freeaddrinfo(res);
    } else {
        fprintf(stderr, "DNS resolution failed: %s\n", gai_strerror(error));
    }
}

Socket_T socket = Socket_new(AF_INET, SOCK_STREAM, 0);
SocketDNS_resolve(dns, "example.com", 8080, on_resolve, socket);
```

### Pattern 2: SocketPoll Integration

**Use Case**: Event-driven applications already using SocketPoll

```c
SocketDNS_T dns = SocketDNS_new();
SocketPoll_T poll = SocketPoll_new(100);
Socket_T socket = Socket_new(AF_INET, SOCK_STREAM, 0);

/* Start async DNS resolution */
SocketDNS_Request_T req = Socket_bind_async(dns, socket, "example.com", 8080);

/* Get pollable file descriptor */
int dns_fd = SocketDNS_pollfd(dns);

/* Monitor DNS completion (manual polling - pipe FD) */
struct pollfd pfd = {.fd = dns_fd, .events = POLLIN};
while (poll(&pfd, 1, 1000) > 0) {
    if (pfd.revents & POLLIN) {
        SocketDNS_check(dns);  /* Process completed requests */
        
        struct addrinfo *res = SocketDNS_getresult(dns, req);
        if (res) {
            Socket_bind_with_addrinfo(socket, res);
            freeaddrinfo(res);
            break;
        }
    }
}
```

### Pattern 3: Async Connect with Multiple Addresses

**Use Case**: Connecting to a hostname that resolves to multiple addresses

```c
SocketDNS_T dns = SocketDNS_new();
Socket_T socket = Socket_new(AF_INET6, SOCK_STREAM, 0);
Socket_setnonblocking(socket);

SocketDNS_Request_T req = Socket_connect_async(dns, socket, "example.com", 80);

/* Wait for DNS completion */
struct addrinfo *res = NULL;
while (!res) {
    SocketDNS_check(dns);
    res = SocketDNS_getresult(dns, req);
    if (!res) {
        usleep(10000);  /* Small delay before retry */
    }
}

if (res) {
    TRY
        Socket_connect_with_addrinfo(socket, res);
        printf("Connected successfully\n");
    EXCEPT(Socket_Failed)
        fprintf(stderr, "Connect failed: %s\n", Socket_Failed.reason);
    END_TRY;
    
    freeaddrinfo(res);
}
```

## Configuration

### Thread Pool Sizing

**Default**: 4 worker threads (`SOCKET_DNS_THREAD_COUNT`)

**Guidelines**:
- **Low concurrency** (< 10 concurrent requests): 2-4 threads
- **Medium concurrency** (10-100 requests): 4-8 threads
- **High concurrency** (> 100 requests): 8-16 threads

**Note**: More threads than CPU cores provides little benefit due to I/O wait times.

### Queue Limits

**Default**: 1000 pending requests (`SOCKET_DNS_MAX_PENDING`)

**Guidelines**:
- **Small applications**: 100-500 requests
- **Medium applications**: 500-2000 requests
- **Large applications**: 2000-10000 requests

**Warning**: Queue full will raise `SocketDNS_Failed` exception.

### Timeout Configuration

**Default**: 5 seconds (`SOCKET_DNS_TIMEOUT_SEC`)

**Note**: Currently informational - actual timeout handled by system `getaddrinfo()` (typically 30+ seconds).

## Error Handling

### DNS Resolution Errors

```c
struct addrinfo *res = SocketDNS_getresult(dns, req);
if (!res) {
    /* Check if request was cancelled or still pending */
    /* Error code available in callback mode */
    fprintf(stderr, "DNS resolution failed or cancelled\n");
} else {
    /* Use result */
    Socket_bind_with_addrinfo(socket, res);
    freeaddrinfo(res);
}
```

### Exception Handling

```c
TRY
    SocketDNS_Request_T req = Socket_bind_async(dns, socket, "example.com", 8080);
EXCEPT(SocketDNS_Failed)
    fprintf(stderr, "DNS resolver error: %s\n", SocketDNS_Failed.reason);
    /* Handle error - request queue full, invalid parameters, etc. */
END_TRY;
```

## Thread Safety

### Resolver Instance

- **Thread-safe**: Multiple threads can share same `SocketDNS_T` instance
- **Request handles**: Valid across threads but single-threaded use recommended
- **Result retrieval**: Thread-safe but avoid concurrent access to same request handle

### Best Practices

1. **One resolver per application**: Create single resolver instance, share across threads
2. **Request handle isolation**: Each thread manages its own request handles
3. **Result ownership**: Caller owns `addrinfo` result, must call `freeaddrinfo()`

## Performance Considerations

### Request Latency

- **DNS cache hits**: < 1ms (from system cache)
- **Local DNS server**: 1-10ms
- **Remote DNS server**: 10-100ms
- **DNS failures**: 30+ seconds (blocking without async DNS)

### Throughput

- **With 4 threads**: ~400-1000 requests/second (depending on DNS server latency)
- **Memory per request**: ~200 bytes (hostname + request structure)
- **Hash table lookup**: O(1) average case

### Resource Usage

- **Thread stack**: ~8MB per thread (default stack size)
- **Total memory**: ~32MB for 4 worker threads + request storage
- **File descriptors**: 2 (pipe for completion signaling)

## Security Considerations

### DoS Protection

**Queue Limits**: Prevents unbounded memory growth from malicious hosts

```c
/* Configure reasonable limits */
#ifndef SOCKET_DNS_MAX_PENDING
#define SOCKET_DNS_MAX_PENDING 1000
#endif
```

**Input Validation**: Hostname length validated (max 255 characters)

**Timeout Protection**: Requests timeout after configured duration (prevents indefinite blocking)

### Best Practices

1. **Validate hostnames**: Check hostname format before submitting requests
2. **Limit concurrent requests**: Use queue limits to prevent resource exhaustion
3. **Handle failures gracefully**: Always check DNS result before use
4. **Cleanup resources**: Always call `freeaddrinfo()` on successful resolution

## Integration with Existing Code

### Migrating from Blocking DNS

**Before (blocking)**:
```c
Socket_bind(socket, "example.com", 8080);  /* Blocks 30+ seconds on failure */
```

**After (async)**:
```c
SocketDNS_T dns = SocketDNS_new();
SocketDNS_Request_T req = Socket_bind_async(dns, socket, "example.com", 8080);

/* Check completion */
struct addrinfo *res = SocketDNS_getresult(dns, req);
if (res) {
    Socket_bind_with_addrinfo(socket, res);
    freeaddrinfo(res);
}
```

### Backward Compatibility

- **Existing blocking functions**: Still work unchanged (`Socket_bind()`, `Socket_connect()`)
- **No breaking changes**: All new functionality is additive
- **Optional usage**: Async DNS is opt-in, not required

## Common Patterns

### Pattern: Non-Blocking Server Setup

```c
SocketDNS_T dns = SocketDNS_new();
Socket_T server = Socket_new(AF_INET6, SOCK_STREAM, 0);
Socket_setnonblocking(server);

/* Start async DNS for bind */
SocketDNS_Request_T bind_req = Socket_bind_async(dns, server, NULL, 8080);

/* In event loop */
while (running) {
    SocketDNS_check(dns);
    
    struct addrinfo *res = SocketDNS_getresult(dns, bind_req);
    if (res) {
        Socket_bind_with_addrinfo(server, res);
        freeaddrinfo(res);
        Socket_listen(server, 128);
        break;  /* DNS complete, continue with server setup */
    }
    
    /* Handle other events */
    usleep(10000);
}
```

### Pattern: Cancellation

```c
SocketDNS_Request_T req = Socket_bind_async(dns, socket, "slow-dns.example.com", 8080);

/* ... later, need to cancel ... */
SocketDNS_cancel(dns, req);

/* Request handle now invalid - do not use */
```

## Troubleshooting

### Issue: Requests Never Complete

**Symptoms**: `SocketDNS_getresult()` always returns NULL

**Causes**:
- Request still pending (not enough worker threads)
- Request cancelled
- DNS resolution failed (check callback error code)

**Solution**: Ensure `SocketDNS_check()` called regularly, verify thread count

### Issue: Queue Full Errors

**Symptoms**: `SocketDNS_Failed` exception when submitting requests

**Causes**: Too many pending requests exceed `SOCKET_DNS_MAX_PENDING`

**Solution**: Increase queue limit or check completion more frequently

### Issue: Memory Leaks

**Symptoms**: Memory usage grows over time

**Causes**: Not calling `freeaddrinfo()` on resolved addresses

**Solution**: Always free addrinfo results:
```c
struct addrinfo *res = SocketDNS_getresult(dns, req);
if (res) {
    /* Use result */
    Socket_bind_with_addrinfo(socket, res);
    freeaddrinfo(res);  /* REQUIRED */
}
```

## References

### Implementation Files
- [SocketDNS.h](mdc:SocketDNS.h) - Public API
- [SocketDNS.c](mdc:SocketDNS.c) - Thread pool implementation

### Related Modules
- [Socket.h](mdc:Socket.h) - Async bind/connect functions
- [SocketPoll.h](mdc:SocketPoll.h) - Event polling integration

### Related Rules
- `error-handling` - Thread-safe exception patterns
- `module-patterns` - Module design patterns
- `architecture-patterns` - Event-driven architecture
