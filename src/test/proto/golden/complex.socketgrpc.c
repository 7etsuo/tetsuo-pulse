/* Auto-generated by tools/protoc-gen-socketgrpc. DO NOT EDIT. */

#include "complex.socketgrpc.h"

#include "grpc/SocketProto.h"

#include <stdlib.h>
#include <string.h>

#define SOCKETGRPC_GEN_EMBEDDED_LIMIT 65536U

#define SOCKETGRPC_GEN_ALLOC(arena, nbytes) ((arena) ? ALLOC ((arena), (nbytes)) : malloc ((nbytes)))
#define SOCKETGRPC_GEN_CALLOC(arena, count, nbytes) ((arena) ? CALLOC ((arena), (count), (nbytes)) : calloc ((count), (nbytes)))

void test_complex_Envelope_Meta_init (test_complex_Envelope_Meta *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
}

void test_complex_Envelope_Meta_free (test_complex_Envelope_Meta *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int test_complex_Envelope_Meta_encode (const test_complex_Envelope_Meta *message, uint8_t *out, size_t out_len, size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->timestamp != (uint64_t)0)
    {
      rc = SocketProto_Message_append_varint (wire, 1, (uint64_t)message->timestamp);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  if (message->source != NULL)
    {
      rc = SocketProto_Message_append_bytes (wire, 2, (const uint8_t *)message->source, strlen (message->source));
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int test_complex_Envelope_Meta_decode (test_complex_Envelope_Meta *message, const uint8_t *data, size_t len, Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_complex_Envelope_Meta_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              message->timestamp = (uint64_t)value;
          }
          break;
        case 2:
          {
            char *copy = (char *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len + 1U);
            if (copy != NULL)
              {
                memcpy (copy, field->value, field->value_len);
                copy[field->value_len] = '\0';
                message->source = copy;
              }
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

static int test_complex_Envelope_append_tags (test_complex_Envelope *message, char *value, Arena_T arena)
{
  size_t new_count = message->tags_count + 1U;
  char **items = (char **)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (char *));
  if (items == NULL)
    return -1;
  if (message->tags != NULL && message->tags_count > 0)
    memcpy (items, message->tags, message->tags_count * sizeof (char *));
  items[message->tags_count] = value;
  message->tags = items;
  message->tags_count = new_count;
  return 0;
}

static int test_complex_Envelope_append_scores (test_complex_Envelope *message, uint32_t value, Arena_T arena)
{
  size_t new_count = message->scores_count + 1U;
  uint32_t *items = (uint32_t *)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (uint32_t));
  if (items == NULL)
    return -1;
  if (message->scores != NULL && message->scores_count > 0)
    memcpy (items, message->scores, message->scores_count * sizeof (uint32_t));
  items[message->scores_count] = value;
  message->scores = items;
  message->scores_count = new_count;
  return 0;
}

static int test_complex_Envelope_append_attachments (test_complex_Envelope *message, uint8_t *value, size_t value_len, Arena_T arena)
{
  size_t new_count = message->attachments_count + 1U;
  uint8_t **items = (uint8_t **)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (uint8_t *));
  size_t *lens = (size_t *)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (size_t));
  if (items == NULL || lens == NULL)
    return -1;
  if (message->attachments != NULL && message->attachments_count > 0)
    memcpy (items, message->attachments, message->attachments_count * sizeof (uint8_t *));
  if (message->attachments_len != NULL && message->attachments_count > 0)
    memcpy (lens, message->attachments_len, message->attachments_count * sizeof (size_t));
  items[message->attachments_count] = value;
  lens[message->attachments_count] = value_len;
  message->attachments = items;
  message->attachments_len = lens;
  message->attachments_count = new_count;
  return 0;
}

void test_complex_Envelope_init (test_complex_Envelope *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
  test_complex_Envelope_Meta_init (&message->meta);
  message->payload_case = TEST_COMPLEX_ENVELOPE_PAYLOADCASE_NOT_SET;
}

void test_complex_Envelope_free (test_complex_Envelope *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int test_complex_Envelope_encode (const test_complex_Envelope *message, uint8_t *out, size_t out_len, size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->has_meta)
    {
      uint8_t *nested_buf = (uint8_t *)malloc (SOCKETGRPC_GEN_EMBEDDED_LIMIT);
      size_t nested_len = 0;
      if (nested_buf == NULL)
        { SocketProto_Message_free (&wire); return -1; }
      if (test_complex_Envelope_Meta_encode (&message->meta, nested_buf, SOCKETGRPC_GEN_EMBEDDED_LIMIT, &nested_len) != 0)
        { free (nested_buf); SocketProto_Message_free (&wire); return -1; }
      rc = SocketProto_Message_append_embedded (wire, 1, nested_buf, nested_len);
      free (nested_buf);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  for (size_t i = 0; i < message->tags_count; i++)
    {
      if (message->tags[i] == NULL)
        continue;
      rc = SocketProto_Message_append_bytes (wire, 2, (const uint8_t *)message->tags[i], strlen (message->tags[i]));
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  for (size_t i = 0; i < message->scores_count; i++)
    {
      rc = SocketProto_Message_append_varint (wire, 3, (uint64_t)message->scores[i]);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  for (size_t i = 0; i < message->attachments_count; i++)
    {
      rc = SocketProto_Message_append_bytes (wire, 4, (const uint8_t *)message->attachments[i], message->attachments_len[i]);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  switch (message->payload_case)
    {
    case TEST_COMPLEX_ENVELOPE_PAYLOADCASE_TEXT:
      if (message->payload.text == NULL)
        break;
      rc = SocketProto_Message_append_bytes (wire, 5, (const uint8_t *)message->payload.text, strlen (message->payload.text));
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
      break;
    case TEST_COMPLEX_ENVELOPE_PAYLOADCASE_BLOB:
      rc = SocketProto_Message_append_bytes (wire, 6, (const uint8_t *)message->payload.blob.data, message->payload.blob.len);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
      break;
    case TEST_COMPLEX_ENVELOPE_PAYLOADCASE_REF_ID:
      rc = SocketProto_Message_append_varint (wire, 7, (uint64_t)message->payload.ref_id);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
      break;
    default:
      break;
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int test_complex_Envelope_decode (test_complex_Envelope *message, const uint8_t *data, size_t len, Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_complex_Envelope_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          if (test_complex_Envelope_Meta_decode (&message->meta, field->value, field->value_len, arena) == 0)
            message->has_meta = 1;
          break;
        case 2:
          {
            char *copy = (char *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len + 1U);
            if (copy != NULL)
              {
                memcpy (copy, field->value, field->value_len);
                copy[field->value_len] = '\0';
                (void)test_complex_Envelope_append_tags (message, copy, arena);
              }
          }
          break;
        case 3:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              (void)test_complex_Envelope_append_scores (message, (uint32_t)value, arena);
          }
          break;
        case 4:
          {
            uint8_t *copy = NULL;
            if (field->value_len > 0)
              {
                copy = (uint8_t *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len);
                if (copy != NULL)
                  memcpy (copy, field->value, field->value_len);
              }
            (void)test_complex_Envelope_append_attachments (message, copy, field->value_len, arena);
          }
          break;
        case 5:
          {
            char *copy = (char *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len + 1U);
            if (copy != NULL)
              {
                memcpy (copy, field->value, field->value_len);
                copy[field->value_len] = '\0';
                message->payload_case = TEST_COMPLEX_ENVELOPE_PAYLOADCASE_TEXT;
                message->payload.text = copy;
              }
          }
          break;
        case 6:
          {
            uint8_t *copy = NULL;
            if (field->value_len > 0)
              {
                copy = (uint8_t *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len);
                if (copy != NULL)
                  memcpy (copy, field->value, field->value_len);
              }
            message->payload_case = TEST_COMPLEX_ENVELOPE_PAYLOADCASE_BLOB;
            message->payload.blob.data = copy;
            message->payload.blob.len = field->value_len;
          }
          break;
        case 7:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              {
                message->payload_case = TEST_COMPLEX_ENVELOPE_PAYLOADCASE_REF_ID;
                message->payload.ref_id = (uint64_t)value;
              }
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

static int test_complex_ComplexRequest_append_notes (test_complex_ComplexRequest *message, char *value, Arena_T arena)
{
  size_t new_count = message->notes_count + 1U;
  char **items = (char **)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (char *));
  if (items == NULL)
    return -1;
  if (message->notes != NULL && message->notes_count > 0)
    memcpy (items, message->notes, message->notes_count * sizeof (char *));
  items[message->notes_count] = value;
  message->notes = items;
  message->notes_count = new_count;
  return 0;
}

static int test_complex_ComplexRequest_append_codes (test_complex_ComplexRequest *message, uint32_t value, Arena_T arena)
{
  size_t new_count = message->codes_count + 1U;
  uint32_t *items = (uint32_t *)SOCKETGRPC_GEN_ALLOC (arena, new_count * sizeof (uint32_t));
  if (items == NULL)
    return -1;
  if (message->codes != NULL && message->codes_count > 0)
    memcpy (items, message->codes, message->codes_count * sizeof (uint32_t));
  items[message->codes_count] = value;
  message->codes = items;
  message->codes_count = new_count;
  return 0;
}

void test_complex_ComplexRequest_init (test_complex_ComplexRequest *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
  test_complex_Envelope_init (&message->envelope);
}

void test_complex_ComplexRequest_free (test_complex_ComplexRequest *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int test_complex_ComplexRequest_encode (const test_complex_ComplexRequest *message, uint8_t *out, size_t out_len, size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->has_envelope)
    {
      uint8_t *nested_buf = (uint8_t *)malloc (SOCKETGRPC_GEN_EMBEDDED_LIMIT);
      size_t nested_len = 0;
      if (nested_buf == NULL)
        { SocketProto_Message_free (&wire); return -1; }
      if (test_complex_Envelope_encode (&message->envelope, nested_buf, SOCKETGRPC_GEN_EMBEDDED_LIMIT, &nested_len) != 0)
        { free (nested_buf); SocketProto_Message_free (&wire); return -1; }
      rc = SocketProto_Message_append_embedded (wire, 1, nested_buf, nested_len);
      free (nested_buf);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  for (size_t i = 0; i < message->notes_count; i++)
    {
      if (message->notes[i] == NULL)
        continue;
      rc = SocketProto_Message_append_bytes (wire, 2, (const uint8_t *)message->notes[i], strlen (message->notes[i]));
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  for (size_t i = 0; i < message->codes_count; i++)
    {
      rc = SocketProto_Message_append_varint (wire, 3, (uint64_t)message->codes[i]);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int test_complex_ComplexRequest_decode (test_complex_ComplexRequest *message, const uint8_t *data, size_t len, Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_complex_ComplexRequest_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          if (test_complex_Envelope_decode (&message->envelope, field->value, field->value_len, arena) == 0)
            message->has_envelope = 1;
          break;
        case 2:
          {
            char *copy = (char *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len + 1U);
            if (copy != NULL)
              {
                memcpy (copy, field->value, field->value_len);
                copy[field->value_len] = '\0';
                (void)test_complex_ComplexRequest_append_notes (message, copy, arena);
              }
          }
          break;
        case 3:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              (void)test_complex_ComplexRequest_append_codes (message, (uint32_t)value, arena);
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

void test_complex_ComplexResponse_init (test_complex_ComplexResponse *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
}

void test_complex_ComplexResponse_free (test_complex_ComplexResponse *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int test_complex_ComplexResponse_encode (const test_complex_ComplexResponse *message, uint8_t *out, size_t out_len, size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->accepted != (int)0)
    {
      rc = SocketProto_Message_append_varint (wire, 1, (uint64_t)message->accepted);
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  if (message->reason != NULL)
    {
      rc = SocketProto_Message_append_bytes (wire, 2, (const uint8_t *)message->reason, strlen (message->reason));
      if (rc != SOCKET_PROTO_OK)
        { SocketProto_Message_free (&wire); return -1; }
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int test_complex_ComplexResponse_decode (test_complex_ComplexResponse *message, const uint8_t *data, size_t len, Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_complex_ComplexResponse_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              message->accepted = (int)value;
          }
          break;
        case 2:
          {
            char *copy = (char *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len + 1U);
            if (copy != NULL)
              {
                memcpy (copy, field->value, field->value_len);
                copy[field->value_len] = '\0';
                message->reason = copy;
              }
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

void test_complex_ComplexService_Client_init (test_complex_ComplexService_Client *client, SocketGRPC_Channel_T channel)
{
  if (client == NULL)
    return;
  client->channel = channel;
  client->local_handlers = NULL;
}

void test_complex_ComplexService_Client_bind_local (test_complex_ComplexService_Client *client, const test_complex_ComplexService_ServerHandlers *handlers)
{
  if (client == NULL)
    return;
  client->local_handlers = handlers;
}

int test_complex_ComplexService_Client_Process (test_complex_ComplexService_Client *client, const test_complex_ComplexRequest *request, test_complex_ComplexResponse *response, Arena_T arena)
{
  if (client == NULL || request == NULL || response == NULL || arena == NULL)
    return -1;
  if (client->local_handlers == NULL || client->local_handlers->Process == NULL)
    return SOCKET_GRPC_STATUS_UNIMPLEMENTED;
  return client->local_handlers->Process (request, response, client->local_handlers->userdata, arena);
}
