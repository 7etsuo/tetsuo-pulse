/* Auto-generated by tools/protoc-gen-socketgrpc. DO NOT EDIT. */

#include "streaming.socketgrpc.h"

#include "grpc/SocketProto.h"

#include <stdlib.h>
#include <string.h>

#define SOCKETGRPC_GEN_EMBEDDED_LIMIT 65536U

#define SOCKETGRPC_GEN_ALLOC(arena, nbytes) \
  ((arena) ? ALLOC ((arena), (nbytes)) : malloc ((nbytes)))
#define SOCKETGRPC_GEN_CALLOC(arena, count, nbytes) \
  ((arena) ? CALLOC ((arena), (count), (nbytes)) : calloc ((count), (nbytes)))

void
test_streaming_Chunk_init (test_streaming_Chunk *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
}

void
test_streaming_Chunk_free (test_streaming_Chunk *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int
test_streaming_Chunk_encode (const test_streaming_Chunk *message,
                             uint8_t *out,
                             size_t out_len,
                             size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->data != NULL && message->data_len > 0)
    {
      rc = SocketProto_Message_append_bytes (
          wire, 1, (const uint8_t *)message->data, message->data_len);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  if (message->sequence != (uint32_t)0)
    {
      rc = SocketProto_Message_append_varint (
          wire, 2, (uint64_t)message->sequence);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int
test_streaming_Chunk_decode (test_streaming_Chunk *message,
                             const uint8_t *data,
                             size_t len,
                             Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_streaming_Chunk_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          {
            uint8_t *copy = NULL;
            if (field->value_len > 0)
              {
                copy
                    = (uint8_t *)SOCKETGRPC_GEN_ALLOC (arena, field->value_len);
                if (copy != NULL)
                  memcpy (copy, field->value, field->value_len);
              }
            message->data = copy;
            message->data_len = field->value_len;
          }
          break;
        case 2:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              message->sequence = (uint32_t)value;
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

void
test_streaming_Ack_init (test_streaming_Ack *message)
{
  if (message == NULL)
    return;
  memset (message, 0, sizeof (*message));
}

void
test_streaming_Ack_free (test_streaming_Ack *message)
{
  if (message == NULL)
    return;
  /* Arena-backed decoded pointers are not individually freed. */
  memset (message, 0, sizeof (*message));
}

int
test_streaming_Ack_encode (const test_streaming_Ack *message,
                           uint8_t *out,
                           size_t out_len,
                           size_t *written)
{
  SocketProto_Message_T wire;
  SocketProto_Result rc;
  if (message == NULL || out == NULL || written == NULL)
    return -1;
  wire = SocketProto_Message_new (NULL, NULL, NULL);
  if (wire == NULL)
    return -1;
  if (message->received != (uint32_t)0)
    {
      rc = SocketProto_Message_append_varint (
          wire, 1, (uint64_t)message->received);
      if (rc != SOCKET_PROTO_OK)
        {
          SocketProto_Message_free (&wire);
          return -1;
        }
    }
  rc = SocketProto_Message_encode (wire, out, out_len, written);
  SocketProto_Message_free (&wire);
  return (rc == SOCKET_PROTO_OK) ? 0 : -1;
}

int
test_streaming_Ack_decode (test_streaming_Ack *message,
                           const uint8_t *data,
                           size_t len,
                           Arena_T arena)
{
  SocketProto_Message_T parsed;
  if (message == NULL || (data == NULL && len != 0) || arena == NULL)
    return -1;
  test_streaming_Ack_init (message);
  parsed = SocketProto_Message_new (arena, NULL, NULL);
  if (parsed == NULL)
    return -1;
  if (SocketProto_Message_parse (parsed, data, len) != SOCKET_PROTO_OK)
    {
      SocketProto_Message_free (&parsed);
      return -1;
    }
  for (size_t i = 0; i < SocketProto_Message_field_count (parsed); i++)
    {
      const SocketProto_Field *field = SocketProto_Message_field_at (parsed, i);
      if (field == NULL)
        continue;
      switch (field->field_number)
        {
        case 1:
          {
            uint64_t value = 0;
            if (SocketProto_Field_decode_u64 (field, &value) == SOCKET_PROTO_OK)
              message->received = (uint32_t)value;
          }
          break;
        default:
          break;
        }
    }
  SocketProto_Message_free (&parsed);
  return 0;
}

void
test_streaming_Streamer_Client_init (test_streaming_Streamer_Client *client,
                                     SocketGRPC_Channel_T channel)
{
  if (client == NULL)
    return;
  client->channel = channel;
  client->local_handlers = NULL;
}

void
test_streaming_Streamer_Client_bind_local (
    test_streaming_Streamer_Client *client,
    const test_streaming_Streamer_ServerHandlers *handlers)
{
  if (client == NULL)
    return;
  client->local_handlers = handlers;
}

int
test_streaming_Streamer_Client_Upload_stream (
    test_streaming_Streamer_Client *client, void *stream_ctx, Arena_T arena)
{
  (void)arena;
  if (client == NULL)
    return -1;
  if (client->local_handlers == NULL
      || client->local_handlers->Upload_stream == NULL)
    return SOCKET_GRPC_STATUS_UNIMPLEMENTED;
  return client->local_handlers->Upload_stream (
      stream_ctx, client->local_handlers->userdata, arena);
}

int
test_streaming_Streamer_Client_Subscribe_stream (
    test_streaming_Streamer_Client *client, void *stream_ctx, Arena_T arena)
{
  (void)arena;
  if (client == NULL)
    return -1;
  if (client->local_handlers == NULL
      || client->local_handlers->Subscribe_stream == NULL)
    return SOCKET_GRPC_STATUS_UNIMPLEMENTED;
  return client->local_handlers->Subscribe_stream (
      stream_ctx, client->local_handlers->userdata, arena);
}

int
test_streaming_Streamer_Client_Chat_stream (
    test_streaming_Streamer_Client *client, void *stream_ctx, Arena_T arena)
{
  (void)arena;
  if (client == NULL)
    return -1;
  if (client->local_handlers == NULL
      || client->local_handlers->Chat_stream == NULL)
    return SOCKET_GRPC_STATUS_UNIMPLEMENTED;
  return client->local_handlers->Chat_stream (
      stream_ctx, client->local_handlers->userdata, arena);
}
