/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) 2025 Tetsuo AI
 * https://x.com/tetsuoai
 */

/**
 * @file SocketHTTP3Server.c
 * @brief HTTP/3 server implementation (RFC 9114).
 *
 * Wraps SocketQUICServer_T and per-connection SocketHTTP3_Conn_T into a
 * user-facing HTTP/3 server API. Each QUIC connection gets its own H3
 * connection with server role. The output queue model bridges H3 framing
 * with QUIC transport: H3 generates wire data -> flush sends via QUIC
 * server -> QUIC stream callback delivers received data back to H3.
 */

#ifdef SOCKET_HAS_TLS

#include "http/SocketHTTP3-server.h"

#include <string.h>

#include "core/Arena.h"
#include "http/SocketHTTP3-private.h"
#include "quic/SocketQUICServer.h"

#define H3_SERVER_MAX_CONNS 256

typedef struct H3ServerConn
{
  QUICServerConn_T quic_conn;
  SocketHTTP3_Conn_T h3_conn;
  Arena_T arena;
  struct H3ServerConn *next;
} H3ServerConn;

struct SocketHTTP3_Server
{
  Arena_T arena;
  SocketHTTP3_ServerConfig config;

  /* QUIC server transport */
  SocketQUICServer_T quic_server;

  /* Per-connection H3 state (linked list) */
  H3ServerConn *conns;
  size_t conn_count;

  /* Request handler */
  SocketHTTP3_RequestHandler handler;
  void *handler_userdata;

  /* State */
  int started;
  int closed;
};

static H3ServerConn *
find_h3_conn (SocketHTTP3_Server_T server, QUICServerConn_T quic_conn)
{
  for (H3ServerConn *c = server->conns; c; c = c->next)
    {
      if (c->quic_conn == quic_conn)
        return c;
    }
  return NULL;
}

static int
flush_h3_output (H3ServerConn *hc)
{
  size_t count = SocketHTTP3_Conn_output_count (hc->h3_conn);
  for (size_t i = 0; i < count; i++)
    {
      const SocketHTTP3_Output *entry
          = SocketHTTP3_Conn_get_output (hc->h3_conn, i);
      if (!entry)
        continue;
      if (SocketQUICServer_send_stream (
              hc->quic_conn, entry->stream_id, entry->data, entry->len, 0)
          < 0)
        {
          SocketHTTP3_Conn_drain_output (hc->h3_conn);
          return -1;
        }
    }
  SocketHTTP3_Conn_drain_output (hc->h3_conn);
  return 0;
}

static void
h3_request_ready (SocketHTTP3_Conn_T conn,
                  struct SocketHTTP3_Request *req,
                  void *userdata)
{
  SocketHTTP3_Server_T server = userdata;
  if (!server || !server->handler || !req)
    return;

  SocketHTTP_Headers_T headers = NULL;
  int status_code = 0;
  SocketHTTP3_Request_recv_headers (
      (SocketHTTP3_Request_T)req, &headers, &status_code);

  server->handler (
      (SocketHTTP3_Request_T)req, headers, server->handler_userdata);

  /* Flush any response output generated by the handler */
  for (H3ServerConn *c = server->conns; c; c = c->next)
    {
      if (c->h3_conn == conn)
        {
          flush_h3_output (c);
          break;
        }
    }
}

static void
quic_conn_callback (QUICServerConn_T quic_conn, void *userdata)
{
  SocketHTTP3_Server_T server = userdata;
  if (!server)
    return;

  /* Create per-connection arena and H3 state */
  Arena_T conn_arena = Arena_new ();

  H3ServerConn *hc = Arena_alloc (conn_arena, sizeof (*hc), __FILE__, __LINE__);
  memset (hc, 0, sizeof (*hc));
  hc->quic_conn = quic_conn;
  hc->arena = conn_arena;

  /* Create H3 connection (server role) */
  SocketHTTP3_ConnConfig h3_config;
  SocketHTTP3_ConnConfig_defaults (&h3_config, H3_ROLE_SERVER);
  h3_config.local_settings = server->config.h3_settings;

  hc->h3_conn = SocketHTTP3_Conn_new (conn_arena, quic_conn, &h3_config);
  if (!hc->h3_conn)
    {
      Arena_dispose (&conn_arena);
      return;
    }

  /* Register request-ready callback on this H3 connection */
  SocketHTTP3_Conn_set_request_callback (hc->h3_conn, h3_request_ready, server);

  /* Initialize H3 (opens critical streams, sends SETTINGS) */
  if (SocketHTTP3_Conn_init (hc->h3_conn) < 0)
    {
      Arena_dispose (&conn_arena);
      return;
    }

  /* Flush SETTINGS output through QUIC transport */
  flush_h3_output (hc);

  /* Add to linked list */
  hc->next = server->conns;
  server->conns = hc;
  server->conn_count++;
}

static void
quic_stream_callback (QUICServerConn_T quic_conn,
                      uint64_t stream_id,
                      const uint8_t *data,
                      size_t len,
                      int fin,
                      void *userdata)
{
  SocketHTTP3_Server_T server = userdata;
  if (!server)
    return;

  H3ServerConn *hc = find_h3_conn (server, quic_conn);
  if (!hc)
    return;

  /* Feed data to H3 connection (auto-creates requests for bidi streams) */
  SocketHTTP3_Conn_feed_stream (hc->h3_conn, stream_id, data, len, fin);

  /* Flush any output generated by feed_stream */
  flush_h3_output (hc);
}

void
SocketHTTP3_ServerConfig_defaults (SocketHTTP3_ServerConfig *config)
{
  if (!config)
    return;
  memset (config, 0, sizeof (*config));
  config->bind_addr = "0.0.0.0";
  config->port = 443;
  config->idle_timeout_ms = 30000;
  config->initial_max_streams_bidi = 100;
  config->max_stream_data = 262144;
  SocketHTTP3_Settings_init (&config->h3_settings);
  config->cert_file = NULL;
  config->key_file = NULL;
  config->max_connections = 256;
  config->max_header_size = 65536;
}

SocketHTTP3_Server_T
SocketHTTP3_Server_new (Arena_T arena, const SocketHTTP3_ServerConfig *config)
{
  if (!arena || !config)
    return NULL;

  SocketHTTP3_Server_T server
      = Arena_alloc (arena, sizeof (*server), __FILE__, __LINE__);
  memset (server, 0, sizeof (*server));
  server->arena = arena;
  server->config = *config;

  /* Create QUIC server transport */
  SocketQUICServerConfig quic_config;
  SocketQUICServerConfig_defaults (&quic_config);
  quic_config.bind_addr = config->bind_addr;
  quic_config.port = config->port;
  quic_config.idle_timeout_ms = config->idle_timeout_ms;
  quic_config.max_stream_data = config->max_stream_data;
  quic_config.initial_max_streams_bidi = config->initial_max_streams_bidi;
  quic_config.cert_file = config->cert_file;
  quic_config.key_file = config->key_file;
  quic_config.max_connections = config->max_connections;

  server->quic_server = SocketQUICServer_new (arena, &quic_config);
  if (!server->quic_server)
    return NULL;

  /* Register QUIC callbacks */
  SocketQUICServer_set_callbacks (
      server->quic_server, quic_conn_callback, quic_stream_callback, server);

  return server;
}

void
SocketHTTP3_Server_on_request (SocketHTTP3_Server_T server,
                               SocketHTTP3_RequestHandler handler,
                               void *userdata)
{
  if (!server)
    return;
  server->handler = handler;
  server->handler_userdata = userdata;
}

int
SocketHTTP3_Server_start (SocketHTTP3_Server_T server)
{
  if (!server || server->started || server->closed)
    return -1;

  if (SocketQUICServer_listen (server->quic_server) < 0)
    return -1;

  server->started = 1;
  return 0;
}

int
SocketHTTP3_Server_poll (SocketHTTP3_Server_T server, int timeout_ms)
{
  if (!server || !server->started || server->closed)
    return -1;

  return SocketQUICServer_poll (server->quic_server, timeout_ms);
}

int
SocketHTTP3_Server_shutdown (SocketHTTP3_Server_T server)
{
  if (!server)
    return -1;

  /* Send GOAWAY on all H3 connections */
  for (H3ServerConn *hc = server->conns; hc; hc = hc->next)
    {
      if (hc->h3_conn
          && SocketHTTP3_Conn_state (hc->h3_conn) == H3_CONN_STATE_OPEN)
        {
          SocketHTTP3_Conn_shutdown (hc->h3_conn, UINT64_MAX);
          flush_h3_output (hc);
        }
    }

  return 0;
}

void
SocketHTTP3_Server_close (SocketHTTP3_Server_T server)
{
  if (!server || server->closed)
    return;

  /* Close all H3 connections */
  H3ServerConn *hc = server->conns;
  while (hc)
    {
      H3ServerConn *next = hc->next;
      if (hc->h3_conn)
        SocketHTTP3_Conn_close (hc->h3_conn, 0);
      /* Per-connection arenas are managed by QUIC server close */
      hc = next;
    }
  server->conns = NULL;
  server->conn_count = 0;

  /* Close QUIC server */
  if (server->quic_server)
    SocketQUICServer_close (server->quic_server);

  server->started = 0;
  server->closed = 1;
}

size_t
SocketHTTP3_Server_active_connections (SocketHTTP3_Server_T server)
{
  if (!server || !server->quic_server)
    return 0;
  return SocketQUICServer_active_connections (server->quic_server);
}

#endif /* SOCKET_HAS_TLS */
