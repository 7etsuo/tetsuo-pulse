Phase 2: Quick wins (builds confidence, enables docs)

2.2 Address resolution helpers (#8)
Why fifth: Independent, useful immediately.
Implementation:
Add SocketCommon_reverse_lookup() (getnameinfo wrapper)
Add SocketCommon_parse_ip() for IP validation
Add SocketCommon_cidr_match() for CIDR checks
Dependencies: #1.1 (error handling)

Phase 3: Advanced I/O (builds on foundation)

3.1 Partial I/O helpers (#10)
Why sixth: Prepares for scatter/gather.
Implementation:
Add Socket_sendall() (handles partial sends)
Add Socket_recvall() (handles partial receives)
Add SocketDgram_sendall(), SocketDgram_recvall()
Dependencies: #1.1, #1.3 (state checks)

3.2 Scatter/gather I/O (#2)
Why seventh: Uses partial I/O patterns.
Implementation:
Add Socket_sendv() / Socket_recvv() (readv/writev wrappers)
Add SocketDgram_sendv() / SocketDgram_recvv()
Handle partial I/O automatically
Dependencies: #3.1 (partial I/O helpers)

3.3 Zero-copy I/O (#1)
Why eighth: Most complex; benefits from prior work.
Implementation:
Add Socket_sendfile() (file-to-socket)
Add Socket_sendmsg() / Socket_recvmsg() wrappers
Platform detection for splice(), sendfile(), splice()
Dependencies: #1.1, #3.1, #3.2

Phase 4: Advanced options (polish)

4.1 Advanced socket options (#7)
Why ninth: Builds on option infrastructure.
Implementation:
Add TCP congestion control (Socket_setcongestion())
Add TCP fast open (Socket_setfastopen())
Add TCP user timeout (Socket_setusertimeout())
Add buffer size setters/getters
Dependencies: #1.2 (option infrastructure)

Phase 5: Documentation (throughout)
5.1 Examples and documentation (#6)
When: Incrementally after each phase.
Implementation:
Add examples/ directory
Basic TCP echo server/client
UDP echo server/client
Event-driven server with SocketPoll
Connection pool example
API reference (Doxygen or similar)
Update README with usage patterns
Dependencies: All previous phases