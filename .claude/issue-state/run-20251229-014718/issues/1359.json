{
  "number": 1359,
  "title": "refactor(socket-iov): simplify socket_send_with_timeout function complexity",
  "body": "## Summary\nThe `socket_send_with_timeout()` function is 58 lines long with complex timeout handling logic that could be simplified by extracting helper functions.\n\n## Location\nFile: `/home/tetsuo/git/tetsuo-socket/src/socket/Socket-iov.c`\nLines: 612-669\n\n## Current Complexity\n- **Lines**: 58\n- **Cyclomatic Complexity**: High (multiple nested conditionals)\n- **Responsibilities**: Timeout calculation, poll waiting, send loop, exception handling\n\n## Category\n- **Type**: Refactoring\n- **Severity**: MEDIUM\n- **Pattern**: LONG_FUNCTION_socket_send_with_timeout\n\n## Issues\n1. Mixes low-level timeout logic with high-level send loop\n2. Duplicates timeout handling with `socket_recv_with_timeout()`\n3. Hard to test timeout logic in isolation\n4. Makes code harder to understand and maintain\n\n## Recommendation\n\n### Step 1: Extract timeout wait helper (shared with recv)\n```c\nstatic int\nsocket_wait_for_io_with_timeout(int fd, short events, int timeout_ms,\n                                int64_t deadline_ms, const char *operation)\n{\n    if (timeout_ms > 0) {\n        int64_t remaining = SocketTimeout_remaining_ms(deadline_ms);\n        if (remaining <= 0)\n            return 0; /* Timeout */\n        \n        if (SocketCommon_wait_for_fd(fd, events, (int)remaining) <= 0)\n            return 0; /* Timeout or error */\n    }\n    else if (timeout_ms == -1) {\n        if (SocketCommon_wait_for_fd(fd, events, -1) < 0) {\n            SOCKET_ERROR_FMT(\"poll() failed during %s\", operation);\n            RAISE_MODULE_ERROR(Socket_Failed);\n        }\n    }\n    return 1; /* Ready */\n}\n```\n\n### Step 2: Simplify main function\n```c\nstatic ssize_t\nsocket_send_with_timeout(T socket, const void *buf, size_t len, int timeout_ms)\n{\n    volatile size_t total_sent = 0;\n    const char *ptr = (const char *)buf;\n    int fd = SocketBase_fd(socket->base);\n    volatile int64_t deadline_ms = SocketTimeout_deadline_ms(timeout_ms);\n    \n    assert(socket);\n    assert(buf || len == 0);\n    if (len == 0)\n        return 0;\n    \n    TRY {\n        while (total_sent < len) {\n            if (!socket_wait_for_io_with_timeout(fd, POLLOUT, timeout_ms, \n                                                 deadline_ms, \"send\"))\n                break; /* Timeout */\n            \n            ssize_t result = Socket_send(socket, ptr + total_sent, \n                                        len - total_sent);\n            if (result > 0)\n                total_sent += (size_t)result;\n            else if (result == 0)\n                break; /* Would block */\n        }\n    }\n    EXCEPT(Socket_Closed)\n        RERAISE;\n    EXCEPT(Socket_Failed)\n        RERAISE;\n    END_TRY;\n    \n    return (ssize_t)total_sent;\n}\n```\n\n### Step 3: Apply same pattern to socket_recv_with_timeout\n\n## Benefits\n1. **Reduced complexity**: From 58 to ~30 lines per function\n2. **Eliminates duplication**: Shared timeout wait logic\n3. **Improved testability**: Can test timeout logic separately\n4. **Better readability**: Clear separation of concerns\n\n## Impact\n- Reduces total code by ~40 lines (after deduplication)\n- Makes timeout logic consistent and easier to maintain\n- Improves code clarity and testability\n\n## Related\n- See also: \"Extract duplicated timeout calculation logic\" issue\n- Both issues can be addressed together for maximum benefit\n\n## Labels\n`refactor`, `code-quality`, `medium-priority`, `complexity`",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}