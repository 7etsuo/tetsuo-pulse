{
  "number": 1627,
  "title": "refactor(quic): flatten nested if statements in SocketQUICMigration_check_timeouts",
  "body": "## Summary\n\nThe `SocketQUICMigration_check_timeouts` function contains 4-level deep nested if statements that reduce readability and should be flattened using guard clauses and early continues.\n\n**Category**: Refactoring\n**Severity**: HIGH\n**Pattern**: `NESTED_IF_DEPTH_4`\n**Files Affected**: 1\n\n## Affected Locations\n\n| File | Lines | Context |\n|------|-------|---------|\n| `src/quic/SocketQUICMigration.c` | 302-329 | Nested conditions in path timeout validation |\n\n## Problem\n\nThe timeout checking logic uses deeply nested if statements that make the code harder to follow:\n\n```c\nif (elapsed >= QUIC_PATH_VALIDATION_TIMEOUT_MS)\n  {\n    if (path->challenge_count < QUIC_PATH_MAX_CHALLENGES)\n      {\n        /* Retry challenge */\n        path->challenge_count++;\n        path->challenge_sent_time = current_time_ms;\n\n        /* Regenerate challenge data */\n        if (SocketCrypto_random_bytes (path->challenge,\n                                      QUIC_PATH_CHALLENGE_SIZE)\n            != 0)\n          {\n            /* RNG failure - mark path as permanently failed */\n            path->state = QUIC_PATH_FAILED;\n            timeout_count++;\n            continue;\n          }\n\n        /* Caller must resend PATH_CHALLENGE frame */\n      }\n    else\n      {\n        /* Max retries exceeded, mark as failed */\n        path->state = QUIC_PATH_FAILED;\n        timeout_count++;\n      }\n  }\n```\n\nThis nesting pattern:\n1. Makes error handling logic harder to trace\n2. Increases cognitive load for readers\n3. Makes future modifications more error-prone\n4. Violates the \"early return/continue\" principle\n\n## Recommended Fix\n\nFlatten the nested structure using guard clauses and early continues:\n\n```c\n// Timeout not reached yet - skip this path\nif (elapsed < QUIC_PATH_VALIDATION_TIMEOUT_MS)\n  continue;\n\n// Max retries exceeded - mark as failed\nif (path->challenge_count >= QUIC_PATH_MAX_CHALLENGES)\n  {\n    path->state = QUIC_PATH_FAILED;\n    timeout_count++;\n    continue;\n  }\n\n// Retry challenge - regenerate data\npath->challenge_count++;\npath->challenge_sent_time = current_time_ms;\n\nif (SocketCrypto_random_bytes (path->challenge, QUIC_PATH_CHALLENGE_SIZE) != 0)\n  {\n    /* RNG failure - mark path as permanently failed */\n    path->state = QUIC_PATH_FAILED;\n    timeout_count++;\n    continue;\n  }\n\n/* Caller must resend PATH_CHALLENGE frame */\n```\n\n**Benefits:**\n- Reduces nesting from 4 levels to 2 levels\n- Makes control flow linear and easier to follow\n- Separates failure cases from success path\n- Improves maintainability\n\n## Checklist\n\n- [ ] Refactor nested if statements in `src/quic/SocketQUICMigration.c` (lines 302-329)\n- [ ] Verify logic equivalence with existing implementation\n- [ ] Run tests: `cd build && ctest -j$(nproc) -R test_quic --output-on-failure`\n- [ ] Run with sanitizers: `cd build && ASAN_OPTIONS=detect_leaks=1:abort_on_error=1 ctest -j$(nproc) --output-on-failure`\n- [ ] Verify no behavioral changes or regressions\n\n## References\n\n- RFC 9000 Section 8.2: Path validation timeout handling\n- Codebase style: Early return/continue pattern used throughout `src/socket/` modules\n- Related: Similar pattern in `SocketQUICMigration_initiate` (lines 341-393) uses guard clauses effectively\n\n---\n*Generated by /pipeline code analysis*",
  "labels": [
    "enhancement",
    "quic"
  ],
  "state": "OPEN",
  "dependencies": []
}