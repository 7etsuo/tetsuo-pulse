{
  "number": 1640,
  "title": "fix(metrics): potential race condition in SocketMetrics_shutdown",
  "body": "## Summary\n\nThe `SocketMetrics_shutdown()` function has a potential race condition where it destroys histogram mutexes that may still be in use by other threads. This can lead to undefined behavior, crashes, or deadlocks.\n\n## Location\n\n- **File**: `/home/tetsuo/git/tetsuo-socket/src/core/SocketMetrics.c`\n- **Lines**: 514-532\n- **Functions**: `SocketMetrics_shutdown()`, `histogram_destroy()`\n\n## Issue Details\n\n**Category**: Security  \n**Severity**: HIGH  \n**Pattern**: RACE_CONDITION_SHUTDOWN\n\n### Current Code\n\n```c\nvoid\nSocketMetrics_shutdown (void)\n{\n  int expected;\n  int i;\n\n  expected = 1;\n  if (!atomic_compare_exchange_strong (&metrics_initialized, &expected, 0))\n    return;\n\n  pthread_mutex_lock (&metrics_global_mutex);\n\n  for (i = 0; i < SOCKET_HISTOGRAM_METRIC_COUNT; i++)\n    histogram_destroy (&histogram_values[i]);\n\n  pthread_mutex_unlock (&metrics_global_mutex);\n\n  METRICS_LOG_DEBUG (\"Metrics subsystem shutdown\");\n}\n```\n\n```c\nstatic void\nhistogram_destroy (Histogram *h)\n{\n  if (h->initialized)\n    {\n      int rc = pthread_mutex_destroy (&h->mutex);\n      assert (rc == 0 && \"pthread_mutex_destroy failed - mutex may be locked\");\n      h->initialized = 0;\n    }\n}\n```\n\n### Problem\n\nThe race condition occurs in this sequence:\n\n1. **Thread A**: Calls `SocketMetrics_shutdown()`\n   - Sets `metrics_initialized = 0`\n   - Acquires `metrics_global_mutex`\n   - Begins destroying histogram mutexes\n\n2. **Thread B**: Calls `SocketMetrics_histogram_observe()`\n   - Checks `histogram_is_valid()` which only checks `h->initialized`\n   - Acquires `h->mutex` via `pthread_mutex_lock()` in `histogram_observe()`\n   - Thread B is now inside the critical section\n\n3. **Thread A**: Calls `pthread_mutex_destroy(&h->mutex)`\n   - **UNDEFINED BEHAVIOR**: Destroying a locked mutex\n   - The assert catches this in debug builds but fails silently in release builds\n\n### Why This Happens\n\nThe `histogram_is_valid()` check only looks at `h->initialized`:\n\n```c\nstatic inline int\nhistogram_is_valid (SocketHistogramMetric metric)\n{\n  if (!HISTOGRAM_VALID (metric))\n    return 0;\n  return histogram_values[metric].initialized;\n}\n```\n\nBut shutdown sets `metrics_initialized = 0` first, then destroys mutexes. There's a window where:\n- `metrics_initialized == 0` (shutdown started)\n- `h->initialized == 1` (histogram still marked valid)\n- Thread can still enter histogram functions and acquire locks\n\n### Potential Consequences\n\n1. **Crash**: `pthread_mutex_destroy()` on a locked mutex can crash\n2. **Deadlock**: Thread B waiting on a destroyed mutex\n3. **Memory Corruption**: Undefined behavior from destroyed mutexes\n4. **Silent Failure**: Assert compiled out in release builds (see issue #1632)\n\n## Recommendation\n\n### Option 1: Wait for quiescence (preferred)\n\n```c\nvoid\nSocketMetrics_shutdown (void)\n{\n  int expected;\n  int i;\n\n  expected = 1;\n  if (!atomic_compare_exchange_strong (&metrics_initialized, &expected, 0))\n    return;\n\n  /* Mark all histograms as shutting down BEFORE acquiring locks */\n  pthread_mutex_lock (&metrics_global_mutex);\n  \n  for (i = 0; i < SOCKET_HISTOGRAM_METRIC_COUNT; i++)\n    histogram_values[i].initialized = 0;\n  \n  pthread_mutex_unlock (&metrics_global_mutex);\n\n  /* Small delay to let in-flight operations complete */\n  usleep(10000);  /* 10ms should be enough for histogram operations */\n\n  /* Now safe to destroy mutexes */\n  pthread_mutex_lock (&metrics_global_mutex);\n  \n  for (i = 0; i < SOCKET_HISTOGRAM_METRIC_COUNT; i++)\n    {\n      int rc = pthread_mutex_destroy (&histogram_values[i].mutex);\n      if (rc != 0)\n        {\n          SocketLog_emitf (SOCKET_LOG_ERROR, \"metrics\",\n                          \"pthread_mutex_destroy failed: %d\", rc);\n        }\n    }\n\n  pthread_mutex_unlock (&metrics_global_mutex);\n\n  METRICS_LOG_DEBUG (\"Metrics subsystem shutdown\");\n}\n```\n\n### Option 2: Use trylock with timeout\n\n```c\nstatic void\nhistogram_destroy_safe (Histogram *h)\n{\n  if (!h->initialized)\n    return;\n\n  /* Try to acquire lock with timeout */\n  struct timespec timeout;\n  clock_gettime(CLOCK_REALTIME, &timeout);\n  timeout.tv_sec += 1;  /* 1 second timeout */\n  \n  int rc = pthread_mutex_timedlock(&h->mutex, &timeout);\n  if (rc == 0)\n    {\n      /* We got the lock, unlock and destroy */\n      pthread_mutex_unlock(&h->mutex);\n      pthread_mutex_destroy(&h->mutex);\n      h->initialized = 0;\n    }\n  else\n    {\n      /* Timeout or error - log and continue */\n      SocketLog_emitf (SOCKET_LOG_WARNING, \"metrics\",\n                      \"Could not acquire histogram mutex for destroy: %d\", rc);\n    }\n}\n```\n\n### Option 3: Add reference counting\n\nTrack active operations per histogram and wait for them to drain before destroying.\n\n## Testing\n\nTo reproduce the race condition:\n\n```c\n/* Thread 1: Hammer metrics */\nvoid* hammer_metrics(void* arg)\n{\n  while (keep_running)\n    {\n      SocketMetrics_histogram_observe(SOCKET_HIST_DNS_QUERY_TIME_MS, 123.45);\n      usleep(100);\n    }\n  return NULL;\n}\n\n/* Thread 2: Shutdown */\nvoid* shutdown_thread(void* arg)\n{\n  sleep(1);\n  SocketMetrics_shutdown();\n  return NULL;\n}\n```\n\nRun under ThreadSanitizer (TSan):\n```bash\ncmake -B build -DENABLE_TSAN=ON\ncmake --build build\n./test_metrics\n```\n\n## Related Issues\n\n- Issue #1632: Assert error handling in `pthread_mutex_init`\n- Both issues involve improper mutex lifecycle management",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}