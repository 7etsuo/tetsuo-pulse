{
  "number": 1635,
  "title": "refactor(quic): inline single-use helper functions in SocketQUICAck.c",
  "body": "## Summary\n\nThree small static helper functions in `SocketQUICAck.c` are used only once and add unnecessary indirection. Inlining them into their single call sites will improve code locality and readability without sacrificing clarity.\n\n**Category**: Refactoring\n**Severity**: LOW\n**Pattern**: `SINGLE_USE_FUNCTION`\n**Files Affected**: 1\n\n## Affected Locations\n\n| Function | Lines | Size | Called From | Usage Count |\n|----------|-------|------|-------------|-------------|\n| `calculate_ack_delay` | 362-368 | 9 lines | `SocketQUICAck_encode:579` | 1\u00d7 |\n| `should_include_ecn` | 377-384 | 8 lines | `SocketQUICAck_encode:580` | 1\u00d7 |\n| `encode_first_range` | 443-459 | 12 lines | `SocketQUICAck_encode:590` | 1\u00d7 |\n\n## Problem\n\nThese three functions are simple, single-purpose helpers that are only called once in the entire codebase. While they have clear names and documentation, they add an extra layer of indirection that makes the code flow harder to follow:\n\n1. **`calculate_ack_delay`** - Simple bit shift operation with a bounds check\n2. **`should_include_ecn`** - Simple boolean expression combining 4 conditions\n3. **`encode_first_range`** - Sequential encoding step, part of the larger encoding flow\n\n### Current Code Structure\n\nThe main encoding function has this flow:\n```c\nSocketQUICAck_Result\nSocketQUICAck_encode(SocketQUICAckState_T state, uint64_t current_time,\n                      uint8_t *out, size_t out_size, size_t *out_len)\n{\n  // ... setup ...\n  \n  ack_delay = calculate_ack_delay(current_time, state->largest_recv_time);\n  has_ecn = should_include_ecn(state);\n  \n  // ... header encoding ...\n  \n  res = encode_first_range(&p, &remaining, &state->ranges[0]);\n  \n  // ... additional ranges ...\n}\n```\n\nThe reader must jump to three different locations to understand what should be a linear encoding flow.\n\n## Recommended Fix\n\nInline these functions directly into `SocketQUICAck_encode` at their call sites with comments preserving the semantic meaning:\n\n### 1. Inline `calculate_ack_delay` (line 579)\n\n```c\n// Before\nack_delay = calculate_ack_delay(current_time, state->largest_recv_time);\n\n// After\n/* Calculate ACK delay in units of ack_delay_exponent microseconds (RFC 9000).\n * Default exponent is 3, so divide by 8 (2^3).\n */\nack_delay = (current_time > state->largest_recv_time)\n            ? (current_time - state->largest_recv_time) >> QUIC_ACK_DELAY_EXPONENT_DEFAULT\n            : 0;\n```\n\n### 2. Inline `should_include_ecn` (line 580)\n\n```c\n// Before\nhas_ecn = should_include_ecn(state);\n\n// After\n/* Include ECN counts if validated and any counters are non-zero */\nhas_ecn = state->ecn_validated\n          && (state->ecn_counts.ect0_count > 0\n              || state->ecn_counts.ect1_count > 0\n              || state->ecn_counts.ce_count > 0);\n```\n\n### 3. Inline `encode_first_range` (line 590)\n\n```c\n// Before\nres = encode_first_range(&p, &remaining, &state->ranges[0]);\nif (res != QUIC_ACK_OK)\n  return res;\n\n// After\n/* Encode first ACK range (end - start) */\n{\n  uint64_t first_ack_range = state->ranges[0].end - state->ranges[0].start;\n  size_t n = SocketQUICVarInt_encode(first_ack_range, p, remaining);\n  if (n == 0)\n    return QUIC_ACK_ERROR_BUFFER;\n  p += n;\n  remaining -= n;\n}\n```\n\n## Benefits\n\n1. **Improved Code Locality** - All encoding logic in one place, easier to understand the flow\n2. **Reduced Indirection** - No function call overhead or mental context switching\n3. **Clearer Intent** - Comments explain \"why\" at the point of use, not in separate function docs\n4. **Consistency** - Matches the pattern used by other encoding helpers like `encode_ack_header` and `encode_additional_ranges` (which are multi-use)\n\n## Checklist\n\n- [ ] Inline `calculate_ack_delay` at line 579\n- [ ] Inline `should_include_ecn` at line 580\n- [ ] Inline `encode_first_range` at line 590\n- [ ] Remove function definitions (lines 362-368, 377-384, 443-459)\n- [ ] Remove function declarations if in header\n- [ ] Verify encoding logic still correct\n- [ ] Run tests: `cmake --build build -j$(nproc) && cd build && ctest -R quic -j$(nproc) --output-on-failure`\n\n## References\n\n- File: `/home/tetsuo/git/tetsuo-socket/src/quic/SocketQUICAck.c`\n- Multi-use helpers for comparison: `encode_ack_header` (lines 398-432), `encode_additional_ranges` (lines 471-514)\n- Related: This follows the same refactoring pattern as extracting helpers - but in reverse when functions have only one caller\n\n---\n*Generated by /pipeline code analysis*",
  "labels": [
    "enhancement",
    "good first issue",
    "quic"
  ],
  "state": "OPEN",
  "dependencies": []
}