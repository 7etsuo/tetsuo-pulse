{
  "number": 1632,
  "title": "fix(metrics): replace assert with error handling in pthread_mutex_init",
  "body": "## Summary\n\nThe `histogram_init()` function uses `assert()` to handle `pthread_mutex_init()` failures. In release builds with `NDEBUG` defined, asserts are compiled out, leaving the error unchecked and potentially causing undefined behavior if mutex initialization fails.\n\n## Location\n\n- **File**: `/home/tetsuo/git/tetsuo-socket/src/core/SocketMetrics.c`\n- **Lines**: 299-301\n- **Function**: `histogram_init()`\n\n## Issue Details\n\n**Category**: Security  \n**Severity**: MEDIUM  \n**Pattern**: ASSERT_ERROR_HANDLING\n\n### Current Code (Lines 297-309)\n\n```c\nstatic void\nhistogram_init (Histogram *h)\n{\n  int rc;\n\n  rc = pthread_mutex_init (&h->mutex, NULL);\n  assert (rc == 0 && \"pthread_mutex_init failed\");\n  (void)rc; /* Suppress unused warning when NDEBUG is defined */\n  memset (h->values, 0, sizeof (h->values));\n  // ... rest of initialization\n}\n```\n\n### Problem\n\n1. **Release Build Risk**: When compiled with `-DNDEBUG` (standard for release builds), the assert is removed by the preprocessor, leaving no error checking\n2. **Silent Failure**: If `pthread_mutex_init()` fails in production, the mutex will be in an undefined state, leading to:\n   - Deadlocks when trying to lock an uninitialized mutex\n   - Crashes from undefined behavior\n   - Data corruption from unsynchronized access\n3. **Acknowledged Issue**: The `(void)rc` comment explicitly acknowledges this is a problem\n\n### Potential Causes of Mutex Init Failure\n\n- Out of memory\n- Resource limits (EAGAIN)\n- Invalid attributes (EINVAL)\n- Permission issues (EPERM)\n\n## Recommendation\n\nReplace assert-based error handling with proper error propagation:\n\n### Option 1: Return error code\n\n```c\nstatic int\nhistogram_init (Histogram *h)\n{\n  int rc;\n\n  rc = pthread_mutex_init (&h->mutex, NULL);\n  if (rc != 0)\n    {\n      return -1;\n    }\n  \n  memset (h->values, 0, sizeof (h->values));\n  h->write_index = 0;\n  atomic_store (&h->count, 0);\n  h->sum = 0.0;\n  h->min = HUGE_VAL;\n  h->max = -HUGE_VAL;\n  h->initialized = 1;\n  \n  return 0;\n}\n```\n\nThen update `SocketMetrics_init()` to check return values:\n\n```c\nfor (i = 0; i < SOCKET_HISTOGRAM_METRIC_COUNT; i++)\n  {\n    if (histogram_init (&histogram_values[i]) != 0)\n      {\n        // Cleanup already-initialized histograms\n        for (int j = 0; j < i; j++)\n          histogram_destroy (&histogram_values[j]);\n        return -1;\n      }\n  }\n```\n\n### Option 2: Log and abort gracefully\n\n```c\nrc = pthread_mutex_init (&h->mutex, NULL);\nif (rc != 0)\n  {\n    SocketLog_emitf (SOCKET_LOG_ERROR, \"metrics\", \n                     \"pthread_mutex_init failed: %d\", rc);\n    abort();  // Or handle gracefully\n  }\n```\n\n## Impact\n\n- **Current**: Silent failure in release builds \u2192 undefined behavior\n- **After Fix**: Explicit error handling \u2192 predictable failure mode\n\n## Testing\n\nVerify the fix by:\n1. Building with `-DNDEBUG` (release mode)\n2. Running under resource constraints (ulimit)\n3. Using ThreadSanitizer to detect mutex issues\n\n## Related\n\nSimilar pattern at line 317 in `histogram_destroy()` where `pthread_mutex_destroy()` return value is asserted.",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}