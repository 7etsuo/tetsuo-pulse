{
  "number": 1628,
  "title": "fix(syn-protect): correct crypto random bytes error check logic",
  "body": "## Issue\n**File**: `src/core/SocketSYNProtect.c`\n**Line**: 820-822\n**Category**: Security\n**Severity**: MEDIUM\n**Pattern**: CRYPTO_ERROR_LOGIC\n\n## Description\nThe error checking logic for `SocketCrypto_random_bytes()` is inverted. The function returns 0 on success and -1 on error (per `SocketCrypto.h`), but the code checks `!= 0` which means it falls back to weaker entropy even when the crypto RNG succeeds.\n\n## Current Code\n```c\nif (SocketCrypto_random_bytes(&protect->hash_seed, sizeof(protect->hash_seed)) != 0)\n{\n    protect->hash_seed = synprotect_get_fallback_seed();\n}\n```\n\n## Problem\n- Currently falls back to `synprotect_get_fallback_seed()` when crypto RNG succeeds\n- This defeats the purpose of using cryptographically secure random bytes\n- The EXCEPT block at line 827-830 already handles failures via exception\n\n## Impact\n- Hash table collisions become more predictable\n- Reduced security against DoS attacks targeting hash collisions\n- Unnecessary use of fallback entropy source\n\n## Recommendation\nOption 1: Remove the explicit check and rely on exception handling:\n```c\nTRY\n{\n    SocketCrypto_random_bytes(&protect->hash_seed, sizeof(protect->hash_seed));\n}\nEXCEPT (SocketCrypto_Failed)\n{\n    protect->hash_seed = synprotect_get_fallback_seed();\n}\nEND_TRY;\n```\n\nOption 2: Fix the condition:\n```c\nif (SocketCrypto_random_bytes(&protect->hash_seed, sizeof(protect->hash_seed)) == 0)\n{\n    // Success - use the crypto random seed\n}\nelse\n{\n    protect->hash_seed = synprotect_get_fallback_seed();\n}\n```\n\nRecommendation: **Option 1** - the exception handler already exists and provides cleaner error flow.\n\n## References\n- `SocketCrypto_random_bytes()` documentation in `include/core/SocketCrypto.h` line 233\n- Fallback seed function at line 44",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}