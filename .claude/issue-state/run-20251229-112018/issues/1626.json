{
  "number": 1626,
  "title": "refactor(quic): flatten nested if statements in SocketQUICLoss.c",
  "body": "## Summary\n\nDeeply nested if statements (4 levels) in `SocketQUICLoss_on_ack_received` function reduce code readability and should be flattened using early continue/return patterns.\n\n**Category**: Refactoring\n**Severity**: MEDIUM\n**Pattern**: `NESTED_IF_DEPTH_4`\n**Files Affected**: 1\n\n## Affected Locations\n\n| File | Lines | Function | Context |\n|------|-------|----------|---------|\n| `src/quic/SocketQUICLoss.c` | 537-555 | `SocketQUICLoss_on_ack_received` | Nested if statements for packet acknowledgment processing |\n\n## Problem\n\nThe current code has 4 levels of nested if statements when processing the largest acknowledged packet. This creates a \"pyramid of doom\" that makes the code harder to read, understand, and maintain.\n\n**Current Code** (lines 537-555):\n```c\nif (largest_pkt != NULL)\n  {\n    if (largest_pkt->in_flight)\n      {\n        /* Defensive check: prevent underflow */\n        if (largest_pkt->sent_bytes > state->bytes_in_flight)\n          {\n            SOCKET_LOG_ERROR_MSG (\n                \"bytes_in_flight underflow: sent_bytes=%zu, in_flight=%zu\",\n                largest_pkt->sent_bytes, state->bytes_in_flight);\n            state->bytes_in_flight = 0;\n          }\n        else\n          {\n            state->bytes_in_flight -= largest_pkt->sent_bytes;\n          }\n      }\n    remove_sent_packet (state, largest_acked);\n  }\n```\n\nThe nesting depth of 4 makes it difficult to:\n- Quickly understand the control flow\n- Identify the main logic path\n- Add new conditions without increasing complexity\n- Follow the \"happy path\" through the code\n\n## Recommended Fix\n\nFlatten the nested conditions using guard clauses and early returns/continues:\n\n```c\n/* Early return if no packet found */\nif (largest_pkt == NULL)\n  {\n    goto detect_lost;\n  }\n\n/* Handle in-flight bytes adjustment */\nif (largest_pkt->in_flight)\n  {\n    /* Defensive check: prevent underflow */\n    if (largest_pkt->sent_bytes > state->bytes_in_flight)\n      {\n        SOCKET_LOG_ERROR_MSG (\n            \"bytes_in_flight underflow: sent_bytes=%zu, in_flight=%zu\",\n            largest_pkt->sent_bytes, state->bytes_in_flight);\n        state->bytes_in_flight = 0;\n      }\n    else\n      {\n        state->bytes_in_flight -= largest_pkt->sent_bytes;\n      }\n  }\n\nremove_sent_packet (state, largest_acked);\n\ndetect_lost:\n  /* Detect lost packets */\n  detect_lost_packets (state, rtt, recv_time_us, lost_callback, context,\n                       lost_count);\n```\n\n**Alternative approach** - Extract to helper function:\n```c\nstatic void\nhandle_acked_packet (SocketQUICLossState_T state,\n                     SocketQUICLossSentPacket_T *packet)\n{\n  if (!packet->in_flight)\n    return;\n\n  /* Defensive check: prevent underflow */\n  if (packet->sent_bytes > state->bytes_in_flight)\n    {\n      SOCKET_LOG_ERROR_MSG (\n          \"bytes_in_flight underflow: sent_bytes=%zu, in_flight=%zu\",\n          packet->sent_bytes, state->bytes_in_flight);\n      state->bytes_in_flight = 0;\n      return;\n    }\n\n  state->bytes_in_flight -= packet->sent_bytes;\n}\n```\n\nThen use it in the main function:\n```c\nif (largest_pkt != NULL)\n  {\n    handle_acked_packet (state, largest_pkt);\n    remove_sent_packet (state, largest_acked);\n  }\n```\n\n## Benefits\n\n- **Improved readability**: Flatter structure is easier to scan and understand\n- **Reduced cognitive load**: Fewer levels of indentation to track\n- **Better maintainability**: Easier to add new conditions without increasing complexity\n- **Consistent style**: Matches the pattern used elsewhere in the codebase (see `detect_lost_packets` at lines 448-487 which uses early continues)\n\n## Checklist\n\n- [ ] Review both refactoring approaches (guard clause vs. helper function)\n- [ ] Choose the approach that best fits the codebase style\n- [ ] Implement the refactoring in `src/quic/SocketQUICLoss.c:537-555`\n- [ ] Run tests with sanitizers: `cmake -B build -DENABLE_SANITIZERS=ON && cmake --build build -j$(nproc) && cd build && ctest -j$(nproc) --output-on-failure`\n- [ ] Verify no functional changes in behavior\n- [ ] Verify no regressions in QUIC loss detection tests\n\n## References\n\n- **Similar pattern in codebase**: `detect_lost_packets()` (lines 416-492) uses early continues effectively\n- **RFC 9002**: QUIC Loss Detection and Congestion Control\n- **Code style**: Matches the existing pattern of using early returns/continues for guard clauses\n\n---\n*Generated by /pipeline code analysis - refactor mode*",
  "labels": [
    "enhancement",
    "good first issue",
    "quic"
  ],
  "state": "OPEN",
  "dependencies": []
}