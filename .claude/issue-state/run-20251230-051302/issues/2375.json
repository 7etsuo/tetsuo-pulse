{
  "number": 2375,
  "title": "refactor(quic): optimize frame parser dispatch with direct array lookup",
  "body": "## File\n`src/quic/SocketQUICFrame.c`\n\n## Line\n802\n\n## Category\nRefactor / Performance Optimization\n\n## Severity\nLOW\n\n## Pattern\nLINEAR_TABLE_SEARCH\n\n## Description\n\nThe `dispatch_frame_parser` function uses a linear search through `frame_parser_table` with 21 frame parsers. Since QUIC frame types are relatively dense (0x00-0x1e for most frames, plus 0x30-0x31 for DATAGRAM frames), a direct lookup array would provide O(1) performance instead of O(n).\n\n### Current Implementation (Line 802-809)\n\n```c\nstatic SocketQUICFrame_Result\ndispatch_frame_parser (uint64_t type, const uint8_t *data, size_t len,\n                       size_t *pos, SocketQUICFrame_T *frame)\n{\n  for (size_t i = 0; frame_parser_table[i].parser != NULL; i++)\n    {\n      if (type >= frame_parser_table[i].type_min\n          && type <= frame_parser_table[i].type_max)\n        return frame_parser_table[i].parser (data, len, pos, frame);\n    }\n  return QUIC_FRAME_ERROR_TYPE;\n}\n```\n\n### Impact\n\n- **Average case**: ~10-11 comparisons for random frame types\n- **Worst case**: 21 iterations for unknown frame types\n- **Hot path**: This function is called for every QUIC frame parsed\n\n### Recommended Fix\n\nReplace the linear search with a direct array lookup:\n\n1. Create a static 50-element array (covering frame types 0x00-0x31)\n2. Initialize all elements to NULL\n3. Populate with parser function pointers at appropriate indices\n4. Use bounds check + NULL check for lookup\n\n**Example Implementation:**\n\n```c\nstatic frame_parser_fn parser_dispatch_array[0x32] = { NULL };\n\nstatic void __attribute__((constructor))\ninit_parser_dispatch_array(void)\n{\n  parser_dispatch_array[QUIC_FRAME_PADDING] = parse_padding;\n  parser_dispatch_array[QUIC_FRAME_PING] = parse_ping;\n  parser_dispatch_array[QUIC_FRAME_ACK] = parse_ack;\n  // ... populate all frame types\n  \n  // STREAM frames (0x08-0x0f)\n  for (int i = QUIC_FRAME_STREAM; i <= QUIC_FRAME_STREAM_MAX; i++)\n    parser_dispatch_array[i] = parse_stream;\n}\n\nstatic SocketQUICFrame_Result\ndispatch_frame_parser (uint64_t type, const uint8_t *data, size_t len,\n                       size_t *pos, SocketQUICFrame_T *frame)\n{\n  if (type >= sizeof(parser_dispatch_array)/sizeof(parser_dispatch_array[0]))\n    return QUIC_FRAME_ERROR_TYPE;\n    \n  frame_parser_fn parser = parser_dispatch_array[type];\n  if (parser == NULL)\n    return QUIC_FRAME_ERROR_TYPE;\n    \n  return parser(data, len, pos, frame);\n}\n```\n\n### Performance Benefit\n\n- **Average case**: 2 comparisons + 1 array access (O(1))\n- **Worst case**: 2 comparisons (O(1))\n- **Memory cost**: 400 bytes (50 \u00d7 8-byte pointers) - negligible\n\n### RFC Reference\n\nQUIC frame types are defined in RFC 9000 Section 12.4, Table 3. The frame type space is intentionally kept compact to enable efficient parsing.\n\n---\n\n**Automated finding from pipeline analysis**\nPattern ID: `LINEAR_TABLE_SEARCH`\nVerification: VERIFIED",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}