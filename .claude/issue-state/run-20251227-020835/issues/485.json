{
  "number": 485,
  "title": "fix(proxy): add exception handling for Socket_setnonblocking call",
  "body": "## Problem\n\nIn `SocketProxy_Conn_new()`, the call to `Socket_setnonblocking()` at line 995 is not wrapped in a TRY/EXCEPT block, but according to the header documentation (`Socket.h:1962`), this function can throw `Socket_Failed` on error.\n\n## Location\n\n`src/socket/SocketProxy.c:995`\n\n```c\n  /* Allocate and initialize context */\n  conn = Arena_alloc (arena, sizeof (*conn), __FILE__, __LINE__);\n  proxy_init_context (conn, arena, proxy, target_host, target_port);\n\n  if (proxy_connect_to_server_sync (conn) < 0)\n    return conn;\n\n  Socket_setnonblocking (conn->socket);  // <-- Can raise Socket_Failed\n\n  conn->state = PROXY_STATE_HANDSHAKE_SEND;\n```\n\n## Analysis\n\nIf `Socket_setnonblocking()` raises `Socket_Failed`:\n1. The arena allocated at line 981 is leaked (never disposed)\n2. The connection context is in a partially initialized state\n3. The exception propagates to the caller without proper cleanup\n\nThe function is not designed to be called within an exception-aware context - it allocates resources and expects to clean them up if errors occur.\n\n## Fix\n\nWrap the `Socket_setnonblocking()` call in TRY/EXCEPT and handle the exception by cleaning up resources:\n\n```c\n  TRY\n  {\n    Socket_setnonblocking (conn->socket);\n  }\n  EXCEPT (Socket_Failed)\n  {\n    conn->state = PROXY_STATE_FAILED;\n    conn->error_code = PROXY_ERR_SOCKET;\n    PROXY_ERROR_MSG (\"Failed to set socket non-blocking\");\n    return conn;\n  }\n  END_TRY;\n```\n\nOr alternatively, ensure proper cleanup in the exception path:\n\n```c\n  TRY\n  {\n    Socket_setnonblocking (conn->socket);\n  }\n  EXCEPT (Socket_Failed)\n  {\n    Arena_dispose (&arena);\n    RERAISE;\n  }\n  END_TRY;\n```\n\n## Category\n\nError Handling",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}