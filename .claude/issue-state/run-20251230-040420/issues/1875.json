{
  "number": 1875,
  "title": "security: validate chunk_size range before casting to size_t (lines 388-389)",
  "body": "## Summary\n\nIn `handle_chunk_size_state`, `chunk_size` (int64_t) is cast to size_t at lines 388-389 **before** any range validation. On 32-bit systems, this causes silent truncation of large values.\n\n## Location\n\n**File**: `/home/tetsuo/git/tetsuo-socket/src/http/SocketHTTP1-chunked.c`  \n**Lines**: 388-389  \n**Function**: `handle_chunk_size_state`\n\n## Current Code\n\n```c\n(*p) += line_len;\nparser->chunk_size = (size_t)chunk_size;          // Line 388 - UNSAFE CAST\nparser->chunk_remaining = (size_t)chunk_size;     // Line 389 - UNSAFE CAST\n\nif (chunk_size == 0)\n  {\n    /* Last chunk - expect trailers or final CRLF */\n    ...\n  }\nelse\n  {\n    /* Check chunk size limit */                  // Line 412 - validation AFTER cast\n    if ((size_t)chunk_size > parser->config.max_chunk_size)\n      return HTTP1_ERROR_CHUNK_TOO_LARGE;\n    ...\n  }\n```\n\n## Issue\n\nThe range validation at line 412 happens **after** the casts at lines 388-389. This creates a race condition:\n\n1. `chunk_size` arrives as int64_t (e.g., 0x100000001 on 32-bit)\n2. Lines 388-389 cast to size_t, truncating to 0x1\n3. Line 412 validates the **already-truncated** value\n4. Parser state corrupted with wrong chunk_size\n\nAdditionally, `parse_chunk_size` validates against INT64_MAX (line 365) but not SIZE_MAX.\n\n## Example Attack Scenario\n\n32-bit system with `max_chunk_size = 1GB`:\n\n1. Attacker sends chunk size `0x100000001` (4GB + 1)\n2. `parse_chunk_size` validates against INT64_MAX \u2713\n3. Returns chunk_size = 0x100000001 as int64_t\n4. Line 388: `parser->chunk_size = (size_t)0x100000001` \u2192 truncates to **1**\n5. Line 389: `parser->chunk_remaining = (size_t)0x100000001` \u2192 truncates to **1**\n6. Line 412: `if (1 > 1073741824)` \u2192 **false**, validation passes\n7. Parser expects 1-byte chunk but attacker sends 4GB+ data\n8. Buffer overflow or memory corruption\n\n## Recommendation\n\nMove the SIZE_MAX validation **before** the casts:\n\n```c\n(*p) += line_len;\n\nif (chunk_size == 0)\n  {\n    /* Last chunk - expect trailers or final CRLF */\n    parser->chunk_size = 0;\n    parser->chunk_remaining = 0;\n    ...\n  }\nelse\n  {\n    /* Validate chunk_size fits in size_t (32-bit safety) */\n    if (chunk_size > (int64_t)SIZE_MAX)\n      return HTTP1_ERROR_CHUNK_TOO_LARGE;\n    \n    /* Check chunk size limit */\n    if ((size_t)chunk_size > parser->config.max_chunk_size)\n      return HTTP1_ERROR_CHUNK_TOO_LARGE;\n    \n    /* Safe to cast after validation */\n    parser->chunk_size = (size_t)chunk_size;\n    parser->chunk_remaining = (size_t)chunk_size;\n    \n    parser->internal_state = HTTP1_PS_CHUNK_DATA;\n    parser->state = HTTP1_STATE_CHUNK_DATA;\n  }\n```\n\n## Severity\n\n**MEDIUM** - Exploitable on 32-bit systems, could lead to buffer overflow or memory corruption. Higher severity than finding #3 because the cast happens before ALL validation.\n\n## Related Issues\n\n- Duplicate/related to UNSAFE_CAST_INT64_TO_SIZE_T at line 412\n\n## Labels\n\nsecurity, bug, http, 32-bit, memory-safety\n\n## Pattern ID\n\nDOUBLE_CAST_VULNERABILITY",
  "labels": [
    "wip:claude-1767076235-1089877"
  ],
  "state": "OPEN",
  "dependencies": []
}