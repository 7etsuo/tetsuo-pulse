{
  "number": 2361,
  "title": "refactor(tls): simplify deep nesting in SocketTLS_shutdown",
  "body": "## Summary\n\nThe `SocketTLS_shutdown()` function has complex nested control flow in its shutdown loop (lines 1028-1048) that makes it hard to follow and test.\n\n## Location\n\n**File**: `src/tls/SocketTLS.c`\n**Lines**: 1012-1051\n**Function**: `SocketTLS_shutdown()`\n\n## Issue\n\nThe shutdown loop has 3+ nesting levels:\n- while loop\n- SSL_shutdown result handling (if/else if/else)\n- Error checking within each branch\n- Poll and retry logic\n\nThis \"arrow code\" pattern violates clean code principles.\n\n## Recommendation\n\nExtract shutdown state handling:\n\n```c\n// Helper returns: 0=complete, 1=retry, -1=timeout/error\nstatic int handle_shutdown_attempt(SSL *ssl, Socket_T socket, int64_t deadline) {\n    int result = SSL_shutdown(ssl);\n    int cont = shutdown_handle_result(socket, ssl, result);\n    if (cont == 0) return 0;  // Complete\n    \n    if (!shutdown_wait_for_io(socket, deadline))\n        return -1;  // Timeout\n    \n    return 1;  // Retry\n}\n\n// Main loop becomes clearer\nvoid SocketTLS_shutdown(Socket_T socket) {\n    // ... validation ...\n    \n    while (!SocketTimeout_expired(deadline)) {\n        SSL *ssl = tls_socket_get_ssl(socket);\n        if (!ssl) { /* error handling */ }\n        \n        int status = handle_shutdown_attempt(ssl, socket, deadline);\n        if (status <= 0) {\n            if (status == 0) return;  // Success\n            break;  // Timeout\n        }\n    }\n    \n    shutdown_finalize(socket, timeout_ms);\n}\n```\n\n## Impact\n\n- **Severity**: MEDIUM\n- **Category**: Refactoring\n- **Pattern**: DEEP_NESTING_3\n\n## Labels\n\n- `refactoring`\n- `code-quality`\n- `medium-priority`",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}