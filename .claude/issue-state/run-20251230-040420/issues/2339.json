{
  "number": 2339,
  "title": "refactor(tls): replace manual hash implementation with socket_util_hash_djb2_len()",
  "body": "## Summary\n\nThe `select_shard()` function manually implements a DJB2-style hash algorithm, duplicating functionality that already exists in `SocketUtil.h` as `socket_util_hash_djb2_len()`.\n\n## Location\n\n**File:** `src/tls/SocketTLS-performance.c`  \n**Lines:** 643-648  \n**Function:** `select_shard()`\n\n## Current Code\n\n```c\nstatic size_t\nselect_shard (TLSSessionCacheSharded_T *cache, const unsigned char *session_id,\n              size_t id_len)\n{\n  unsigned hash = 0;\n  for (size_t i = 0; i < id_len && i < 16; i++)\n    {\n      hash = hash * 31 + session_id[i];\n    }\n  return (size_t)((hash * HASH_GOLDEN_RATIO) & cache->shard_mask);\n}\n```\n\n## Issue\n\nThis code re-implements hash logic that already exists in the codebase:\n\n**From `include/core/SocketUtil.h` (lines 456-464):**\n```c\nstatic inline unsigned\nsocket_util_hash_djb2_len (const char *str, size_t len, unsigned table_size)\n{\n  unsigned hash = SOCKET_UTIL_DJB2_SEED;\n  size_t i;\n\n  for (i = 0; i < len; i++)\n    hash = ((hash << 5) + hash) + (unsigned char)str[i];\n\n  return hash % table_size;\n}\n```\n\nCode duplication:\n- Increases maintenance burden\n- Can lead to inconsistent behavior if one implementation is updated\n- Violates DRY principle\n- This file already includes `SocketUtil.h` (line 33)\n\n## Recommendation\n\nReplace the manual hash with the existing utility:\n\n```c\nstatic size_t\nselect_shard (TLSSessionCacheSharded_T *cache, const unsigned char *session_id,\n              size_t id_len)\n{\n  /* Limit to first 16 bytes for performance */\n  size_t hash_len = (id_len < 16) ? id_len : 16;\n  \n  /* Use standard DJB2 hash from SocketUtil.h */\n  unsigned hash = socket_util_hash_djb2_len((const char *)session_id, \n                                             hash_len, \n                                             UINT_MAX);\n  \n  return (size_t)((hash * HASH_GOLDEN_RATIO) & cache->shard_mask);\n}\n```\n\n**Alternative:** Use the golden ratio hash directly since it's already being applied:\n```c\nstatic size_t\nselect_shard (TLSSessionCacheSharded_T *cache, const unsigned char *session_id,\n              size_t id_len)\n{\n  /* Extract first 4 bytes as uint32_t for golden ratio hash */\n  uint32_t key = 0;\n  size_t n = (id_len < 4) ? id_len : 4;\n  for (size_t i = 0; i < n; i++)\n    key = (key << 8) | session_id[i];\n    \n  return (size_t)((key * HASH_GOLDEN_RATIO) & cache->shard_mask);\n}\n```\n\n## Impact\n\n- **Category:** Redundancy\n- **Severity:** High (code duplication)\n- **Pattern ID:** REDUNDANT_DJB2_HASH\n- **Effort:** Low (use existing function)\n- **Benefits:** Reduces code duplication, improves maintainability\n\n## Related\n\n- See CLAUDE.md \"C Anti-Patterns and Fixes\" section\n- Related to issue about documenting the `31` multiplier",
  "labels": [
    "enhancement"
  ],
  "state": "OPEN",
  "dependencies": []
}