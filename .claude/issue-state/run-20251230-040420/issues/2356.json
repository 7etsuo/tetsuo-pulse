{
  "number": 2356,
  "title": "refactor: Break down 147-line Socket_simple_proxy_parse_url function (SocketSimple-proxy.c:204)",
  "body": "## Refactoring: God Function Exceeds 100-Line Guideline\n\n**File:** `/home/tetsuo/git/tetsuo-socket/src/simple/SocketSimple-proxy.c`  \n**Lines:** 204-351 (147 lines)  \n**Severity:** HIGH  \n**Category:** Refactoring  \n**Pattern ID:** LONG_FUNCTION_147\n\n### Issue Description\n\nThe `Socket_simple_proxy_parse_url()` function is 147 lines long, exceeding the 100-line guideline in CLAUDE.md. It handles multiple responsibilities:\n1. URL scheme parsing\n2. Userinfo (user:pass) extraction\n3. IPv6 bracket notation handling\n4. Hostname parsing\n5. Port parsing\n6. Default port assignment\n7. Input validation\n\nThis violates the \"God Functions\" anti-pattern from CLAUDE.md.\n\n### Current Structure\n\n```c\nint Socket_simple_proxy_parse_url(const char *url, SocketSimple_ProxyConfig *config)\n{\n  // Lines 208-224: Initial validation & scheme parsing\n  const char *rest = NULL;\n  if (parse_scheme(url, &config->type, &rest) != 0) { ... }\n  \n  // Lines 227-254: Userinfo extraction (user:pass@)\n  const char *at = strchr(rest, '@');\n  if (at && ...) {\n    // url_decode username and password\n  }\n  \n  // Lines 256-307: Host and port parsing (IPv6 aware)\n  if (*host_start == '[') {\n    // IPv6 handling\n  } else {\n    // IPv4/hostname handling\n  }\n  \n  // Lines 309-320: Port parsing\n  if (port_start) {\n    long port = strtol(...);\n  }\n  \n  // Lines 322-340: Default port assignment\n  switch (config->type) { ... }\n  \n  // Lines 342-351: Final validation\n}\n```\n\n### Recommended Decomposition\n\nBreak into focused helper functions per CLAUDE.md guidance:\n\n```c\n/**\n * @brief Parse and decode userinfo from proxy URL.\n * @return 0 on success, -1 on error (credentials too long).\n */\nstatic int\nparse_userinfo(const char *userinfo_start, const char *userinfo_end,\n               SocketSimple_ProxyConfig *config)\n{\n  const char *colon = memchr(userinfo_start, ':', userinfo_end - userinfo_start);\n  \n  if (colon) {\n    // Decode username and password with truncation checks\n    size_t user_len = url_decode(userinfo_start, colon - userinfo_start,\n                                   config->username, sizeof(config->username));\n    if (user_len >= sizeof(config->username) - 1) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Username too long\");\n      return -1;\n    }\n    \n    size_t pass_len = url_decode(colon + 1, userinfo_end - colon - 1,\n                                   config->password, sizeof(config->password));\n    if (pass_len >= sizeof(config->password) - 1) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Password too long\");\n      return -1;\n    }\n  } else {\n    // Username only\n    size_t user_len = url_decode(userinfo_start, userinfo_end - userinfo_start,\n                                   config->username, sizeof(config->username));\n    if (user_len >= sizeof(config->username) - 1) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Username too long\");\n      return -1;\n    }\n  }\n  \n  return 0;\n}\n\n/**\n * @brief Parse host and port from URL remainder.\n * @return Pointer to port section (or NULL if no port), or (const char*)-1 on error.\n */\nstatic const char *\nparse_host_port(const char *host_start, SocketSimple_ProxyConfig *config)\n{\n  const char *host_end = host_start;\n  const char *port_start = NULL;\n  \n  // Handle IPv6 [address] notation\n  if (*host_start == '[') {\n    const char *bracket = strchr(host_start, ']');\n    if (!bracket) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Invalid IPv6 address\");\n      return (const char *)-1;\n    }\n    \n    size_t addr_len = bracket - host_start - 1;\n    if (addr_len >= sizeof(config->host)) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Hostname too long\");\n      return (const char *)-1;\n    }\n    \n    memcpy(config->host, host_start + 1, addr_len);\n    config->host[addr_len] = '\\0';\n    host_end = bracket + 1;\n    \n    if (*host_end == ':')\n      port_start = host_end + 1;\n  } else {\n    // Regular hostname or IPv4\n    while (*host_end && *host_end != ':' && *host_end != '/')\n      host_end++;\n      \n    size_t host_len = host_end - host_start;\n    if (host_len >= sizeof(config->host)) {\n      simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Hostname too long\");\n      return (const char *)-1;\n    }\n    \n    memcpy(config->host, host_start, host_len);\n    config->host[host_len] = '\\0';\n    \n    if (*host_end == ':')\n      port_start = host_end + 1;\n  }\n  \n  return port_start;\n}\n\n/**\n * @brief Parse port number from string.\n * @return Parsed port on success, -1 on error.\n */\nstatic int\nparse_port_number(const char *port_str)\n{\n  char *endptr;\n  errno = 0;\n  long port = strtol(port_str, &endptr, 10);\n  \n  // Check for parse failure (see issue #2301)\n  if (endptr == port_str) {\n    simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Invalid port: not a number\");\n    return -1;\n  }\n  \n  // Check for overflow\n  if (errno == ERANGE || port < 0 || port > 65535) {\n    simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Invalid port: out of range\");\n    return -1;\n  }\n  \n  return (int)port;\n}\n\n/**\n * @brief Main parsing function - now under 50 lines.\n */\nint\nSocket_simple_proxy_parse_url(const char *url, SocketSimple_ProxyConfig *config)\n{\n  Socket_simple_clear_error();\n  \n  if (!url || !config) {\n    simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"NULL url or config\");\n    return -1;\n  }\n  \n  Socket_simple_proxy_config_init(config);\n  \n  // Parse scheme\n  const char *rest = NULL;\n  if (parse_scheme(url, &config->type, &rest) != 0) {\n    simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Unknown proxy URL scheme\");\n    return -1;\n  }\n  \n  // Parse optional userinfo\n  const char *at = strchr(rest, '@');\n  const char *slash = strchr(rest, '/');\n  const char *host_start = rest;\n  \n  if (at && (!slash || at < slash)) {\n    if (parse_userinfo(rest, at, config) != 0)\n      return -1;\n    host_start = at + 1;\n  }\n  \n  // Parse host and port\n  const char *port_start = parse_host_port(host_start, config);\n  if (port_start == (const char *)-1)\n    return -1;\n    \n  // Parse explicit port or use default\n  if (port_start) {\n    int port = parse_port_number(port_start);\n    if (port < 0)\n      return -1;\n    config->port = port;\n  } else {\n    config->port = get_default_proxy_port(config->type);  // See issue #2338\n  }\n  \n  // Validate hostname\n  if (config->host[0] == '\\0') {\n    simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Missing hostname\");\n    return -1;\n  }\n  \n  return 0;\n}\n```\n\n### Benefits\n\n1. **Readability**: Each function has a single, clear purpose\n2. **Testability**: Helper functions can be unit tested independently\n3. **Maintainability**: Easier to understand and modify\n4. **Reusability**: parse_port_number could be used elsewhere\n5. **Error Handling**: Clearer separation of validation logic\n\n### Metrics\n\n| Metric | Before | After |\n|--------|--------|-------|\n| Function length | 147 lines | ~45 lines |\n| Cyclomatic complexity | High | Low per function |\n| Responsibilities | 7 | 1 per function |\n\n### Related Issues\n- #2301: Fix port parsing overflow (affects `parse_port_number`)\n- #2320: Check url_decode returns (affects `parse_userinfo`)\n- #2338: Use dispatch table for default ports\n\n### References\n- CLAUDE.md: God Functions anti-pattern\n- CLAUDE.md: Code Style (functions > 100 lines)",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}