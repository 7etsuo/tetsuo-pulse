{
  "number": 2296,
  "title": "fix(quic): unchecked integer addition at line 114 bypasses overflow protection",
  "body": "## Summary\n**File:** `src/quic/SocketQUICHandshake.c`  \n**Line:** 114  \n**Severity:** HIGH  \n**Category:** Security - Unchecked Integer Arithmetic\n\n## Issue\nLine 114 performs unchecked integer addition that executes **even when the overflow check on line 106 would fail**:\n\n```c\n103:  if (offset == stream->recv_offset) {\n104:    if (stream->recv_buffer) {\n105:      uint64_t total_offset;\n106:      if (!socket_util_safe_add_u64(stream->recv_offset, length, &total_offset)) {\n107:        return QUIC_HANDSHAKE_ERROR_BUFFER;  /* Overflow would occur */\n108:      }\n109:      if (total_offset > stream->recv_buffer_size) {\n110:        return QUIC_HANDSHAKE_ERROR_BUFFER;\n111:      }\n112:      memcpy(stream->recv_buffer + stream->recv_offset, data, length);\n113:    }\n114:    stream->recv_offset += length;  // <-- UNCHECKED!\n115:    return QUIC_HANDSHAKE_OK;\n116:  }\n```\n\n## Problem\n**Line 114 is OUTSIDE the `if (stream->recv_buffer)` block**, so it executes even when:\n1. `stream->recv_buffer` is NULL (no overflow check performed)\n2. The overflow check on line 106 would have failed\n\nThis creates two vulnerable code paths:\n\n### Path 1: recv_buffer is NULL\n```c\nif (offset == stream->recv_offset) {\n    if (stream->recv_buffer) {  // FALSE - buffer is NULL\n        // overflow check SKIPPED\n    }\n    stream->recv_offset += length;  // UNCHECKED ADDITION\n}\n```\n\n### Path 2: After overflow check returns\nIf the check existed and passed, we'd still do the addition again.\n\n## Verification\n- Line 114 is at column 2 (outside the `if` block at line 104)\n- Line 113 ends the `if (stream->recv_buffer)` block\n- Code structure allows unchecked addition regardless of buffer state\n\n## Impact\n- **Integer Overflow:** `recv_offset` can wrap around on overflow\n- **State Corruption:** Invalid offset breaks stream reassembly\n- **DoS:** Malicious peer could send crafted CRYPTO frames to trigger overflow\n\n## Recommendation\n\n**Option 1: Move inside the buffer check**\n```c\nif (stream->recv_buffer) {\n    uint64_t total_offset;\n    if (stream->recv_offset > UINT64_MAX - length) {\n        return QUIC_HANDSHAKE_ERROR_BUFFER;\n    }\n    total_offset = stream->recv_offset + length;\n    if (total_offset > stream->recv_buffer_size) {\n        return QUIC_HANDSHAKE_ERROR_BUFFER;\n    }\n    memcpy(stream->recv_buffer + stream->recv_offset, data, (size_t)length);\n    stream->recv_offset += length;  // Now inside safe block\n} else {\n    // No buffer case - still need overflow check\n    if (stream->recv_offset > UINT64_MAX - length) {\n        return QUIC_HANDSHAKE_ERROR_BUFFER;\n    }\n    stream->recv_offset += length;\n}\n```\n\n**Option 2: Add overflow check before line 114**\n```c\n    }\n    // Check overflow before unconditional addition\n    if (stream->recv_offset > UINT64_MAX - length) {\n        return QUIC_HANDSHAKE_ERROR_BUFFER;\n    }\n    stream->recv_offset += length;\n    return QUIC_HANDSHAKE_OK;\n```\n\n## Pattern ID\n`UNCHECKED_INTEGER_ADDITION`\n\n## Related Issues\n- Issue #2276: Missing `socket_util_safe_add_u64()` function\n- Issue #2285: Implicit size_t cast in memcpy",
  "labels": [
    "bug",
    "quic"
  ],
  "state": "OPEN",
  "dependencies": []
}