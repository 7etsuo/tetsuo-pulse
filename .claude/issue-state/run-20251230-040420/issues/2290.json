{
  "number": 2290,
  "title": "[REFACTOR] Duplicate IPv4/IPv6 lookup functions",
  "body": "## Summary\nFunctions `Socket_simple_dns_lookup4` and `Socket_simple_dns_lookup6` are nearly identical, differing only in the address family constant.\n\n## Location\n- File: `src/simple/SocketSimple-dns.c`\n- Lines: 208-275 (lookup4), 278-345 (lookup6)\n\n## Issue\nBoth functions contain 95% identical code. The only difference is:\n- Line 231: `hints.ai_family = AF_INET;`\n- Line 301: `hints.ai_family = AF_INET6;`\n\n## Risk\n- **Severity**: MEDIUM\n- **Pattern**: DUPLICATE_EXCEPTION_PATTERN\n- **Impact**: Code maintenance burden, potential for bugs if one is updated but not the other\n\n## Current Code Structure\n```c\nint Socket_simple_dns_lookup4(const char *hostname, char *buf, size_t len)\n{\n    // ... 10 lines of setup\n    hints.ai_family = AF_INET;  // Only difference\n    // ... 40 lines of TRY/EXCEPT/FINALLY and result handling\n}\n\nint Socket_simple_dns_lookup6(const char *hostname, char *buf, size_t len)\n{\n    // ... 10 lines of setup (identical)\n    hints.ai_family = AF_INET6;  // Only difference\n    // ... 40 lines of TRY/EXCEPT/FINALLY and result handling (identical)\n}\n```\n\n## Recommendation\nCreate a helper function that takes address family as a parameter:\n\n```c\nstatic int\ndns_lookup_family(const char *hostname, char *buf, size_t len, int family)\n{\n    SocketDNS_T dns = SocketCommon_get_dns_resolver();\n    volatile struct addrinfo *res = NULL;\n    struct addrinfo hints;\n    volatile int exception_occurred = 0;\n    int ret = -1;\n\n    Socket_simple_clear_error();\n\n    if (!hostname || !buf) {\n        simple_set_error(SOCKET_SIMPLE_ERR_INVALID_ARG, \"Invalid argument\");\n        return -1;\n    }\n\n    if (!dns) {\n        simple_set_error(SOCKET_SIMPLE_ERR_DNS, \"DNS resolver not available\");\n        return -1;\n    }\n\n    SocketCommon_setup_hints(&hints, SOCK_STREAM, 0);\n    hints.ai_family = family;\n\n    TRY {\n        res = SocketDNS_resolve_sync(dns, hostname, 0, &hints,\n                                    SOCKET_SIMPLE_DNS_DEFAULT_TIMEOUT_MS);\n    }\n    EXCEPT(SocketDNS_Failed) {\n        simple_set_error(SOCKET_SIMPLE_ERR_DNS, \"DNS resolution failed\");\n        exception_occurred = 1;\n    }\n    FINALLY {\n        if (exception_occurred && res) {\n            SocketCommon_free_addrinfo((struct addrinfo *)res);\n            res = NULL;\n        }\n    }\n    END_TRY;\n\n    if (exception_occurred)\n        return -1;\n\n    if (!res) {\n        simple_set_error(SOCKET_SIMPLE_ERR_DNS,\n                        family == AF_INET ? \"No IPv4 address found\"\n                                         : \"No IPv6 address found\");\n        return -1;\n    }\n\n    char host[NI_MAXHOST];\n    if (SocketCommon_reverse_lookup(((struct addrinfo *)res)->ai_addr,\n                                   ((struct addrinfo *)res)->ai_addrlen,\n                                   host, sizeof(host), NULL, 0,\n                                   NI_NUMERICHOST, SocketCommon_Failed) == 0) {\n        snprintf(buf, len, \"%s\", host);\n        ret = 0;\n    } else {\n        simple_set_error(SOCKET_SIMPLE_ERR_DNS, \"Failed to get address string\");\n    }\n\n    SocketCommon_free_addrinfo((struct addrinfo *)res);\n    return ret;\n}\n\nint\nSocket_simple_dns_lookup4(const char *hostname, char *buf, size_t len)\n{\n    return dns_lookup_family(hostname, buf, len, AF_INET);\n}\n\nint\nSocket_simple_dns_lookup6(const char *hostname, char *buf, size_t len)\n{\n    return dns_lookup_family(hostname, buf, len, AF_INET6);\n}\n```\n\n## Benefits\n- Eliminates ~60 lines of duplicate code\n- Single source of truth for lookup logic\n- Easier to maintain and test\n- Follows DRY (Don't Repeat Yourself) principle",
  "labels": [
    "enhancement"
  ],
  "state": "OPEN",
  "dependencies": []
}