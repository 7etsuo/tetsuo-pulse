{
  "number": 390,
  "title": "feat(quic): implement CRYPTO frame (RFC 9000 \u00a719.6)",
  "body": "## RFC 9000 Section 19.6: CRYPTO Frame\n\n### Overview\nImplement CRYPTO frame for TLS handshake message transport.\n\n### Complexity: MEDIUM (~250 lines)\nOffset-based reassembly similar to STREAM frames.\n\n### Key Requirements\n- Frame Type: 0x06\n- Offset (varint) - byte offset in crypto stream\n- Length (varint) - length of crypto data\n- Crypto Data - TLS handshake messages\n\nCRYPTO frames:\n- Cannot be sent on 0-RTT packets\n- Have separate offset space per encryption level\n- Must be reassembled in order before TLS processing\n\n### Implementation\n**Files:**\n- `include/quic/SocketQUICFrame.h`\n- `src/quic/SocketQUICFrame-crypto.c`\n\n**Functions:**\n```c\nsize_t SocketQUICFrame_encode_crypto(uint64_t offset, const uint8_t *data,\n                                      size_t len, uint8_t *out);\nint SocketQUICFrame_decode_crypto(const uint8_t *data, size_t len,\n                                   SocketQUICCryptoFrame_T *frame);\n```\n\n### Dependencies\n- #384 (Section 12 - Frame infrastructure)\n- #377 (Section 16 - VarInt)\n\n### Test Cases\n- Encode/decode roundtrip\n- Out-of-order reassembly\n- Multiple crypto streams per encryption level",
  "labels": [
    "enhancement",
    "quic",
    "rfc-9000"
  ],
  "state": "OPEN",
  "dependencies": []
}