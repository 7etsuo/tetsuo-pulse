{
  "number": 2348,
  "title": "Critical: Flawed realloc rollback in SNI certificate array expansion",
  "body": "## Issue Summary\n\n**File**: \\`src/tls/SocketTLSContext-certs.c\\`  \n**Lines**: 180-204  \n**Function**: \\`expand_sni_capacity()\\`  \n**Severity**: CRITICAL  \n**Category**: Security / Memory Management\n\n## Description\n\nThe SNI certificate array expansion logic contains a fundamental memory management flaw in its rollback mechanism. The code attempts to atomically expand 5 parallel arrays using \\`realloc()\\`, but the rollback logic when any allocation fails is incorrect and leaves the context in an inconsistent state.\n\n## Vulnerable Code\n\n\\`\\`\\`c\nvoid *new_hostnames = realloc (ctx->sni_certs.hostnames, alloc_size);\nvoid *new_cert_files = realloc (ctx->sni_certs.cert_files, alloc_size);\nvoid *new_key_files = realloc (ctx->sni_certs.key_files, alloc_size);\nvoid *new_chains = realloc (ctx->sni_certs.chains, alloc_size);\nvoid *new_pkeys = realloc (ctx->sni_certs.pkeys, alloc_size);\n\nif (!new_hostnames || !new_cert_files || !new_key_files || !new_chains || !new_pkeys)\n  {\n    /* Rollback: only free if pointer changed */\n    if (new_hostnames && new_hostnames != ctx->sni_certs.hostnames)\n      free (new_hostnames);\n    if (new_cert_files && new_cert_files != ctx->sni_certs.cert_files)\n      free (new_cert_files);\n    // ... etc\n\\`\\`\\`\n\n## The Problem\n\nThe \\`realloc()\\` behavior is:\n- **On success with new pointer**: Old pointer is freed, returns new pointer\n- **On success with same pointer**: Returns same pointer (in-place resize)\n- **On failure**: Returns NULL, old pointer remains valid\n\nThe current rollback logic:\n1. Performs 5 reallocs sequentially\n2. If ANY fail, attempts to \"rollback\" by freeing successful reallocs\n3. **CRITICAL FLAW**: After freeing successful reallocs, the old pointers stored in \\`ctx->sni_certs\\` are now dangling pointers to freed memory\n4. The context structure is left in an inconsistent state with some arrays valid, others dangling\n\n## Attack Scenario\n\n1. Attacker causes memory pressure to trigger realloc failure on 4th or 5th array\n2. First 3 reallocs succeed and free old arrays\n3. Rollback code frees the new arrays\n4. Context now has dangling pointers to freed memory\n5. Next SNI operation uses dangling pointers \u2192 use-after-free vulnerability\n\n## Impact\n\n- **Use-after-free vulnerability** in subsequent SNI operations\n- **Double-free** if cleanup is attempted\n- **Memory corruption** leading to arbitrary code execution\n- Affects TLS server contexts using SNI certificate selection\n\n## Recommended Fix\n\nUse a two-phase approach:\n\n\\`\\`\\`c\nstatic void\nexpand_sni_capacity (T ctx)\n{\n  size_t new_cap = ctx->sni_certs.capacity == 0\n                       ? SOCKET_TLS_SNI_INITIAL_CAPACITY\n                       : ctx->sni_certs.capacity * 2;\n\n  size_t alloc_size;\n  if (!SocketSecurity_check_multiply (new_cap, sizeof (void *), &alloc_size)\n      || !SocketSecurity_check_size (alloc_size))\n    ctx_raise_openssl_error (\"SNI capacity overflow\");\n\n  /* Phase 1: Allocate new arrays independently (don't modify originals) */\n  void *new_hostnames = malloc (alloc_size);\n  void *new_cert_files = malloc (alloc_size);\n  void *new_key_files = malloc (alloc_size);\n  void *new_chains = malloc (alloc_size);\n  void *new_pkeys = malloc (alloc_size);\n\n  /* Verify all allocations succeeded */\n  if (!new_hostnames || !new_cert_files || !new_key_files || !new_chains || !new_pkeys)\n    {\n      /* Simple cleanup - all are independent mallocs */\n      free (new_hostnames);\n      free (new_cert_files);\n      free (new_key_files);\n      free (new_chains);\n      free (new_pkeys);\n      ctx_raise_openssl_error (\"Failed to allocate SNI certificate arrays\");\n    }\n\n  /* Phase 2: Copy old data to new arrays */\n  if (ctx->sni_certs.capacity > 0)\n    {\n      size_t old_size = ctx->sni_certs.capacity * sizeof(void *);\n      memcpy (new_hostnames, ctx->sni_certs.hostnames, old_size);\n      memcpy (new_cert_files, ctx->sni_certs.cert_files, old_size);\n      memcpy (new_key_files, ctx->sni_certs.key_files, old_size);\n      memcpy (new_chains, ctx->sni_certs.chains, old_size);\n      memcpy (new_pkeys, ctx->sni_certs.pkeys, old_size);\n    }\n\n  /* Phase 3: Free old arrays and commit new state atomically */\n  free (ctx->sni_certs.hostnames);\n  free (ctx->sni_certs.cert_files);\n  free (ctx->sni_certs.key_files);\n  free (ctx->sni_certs.chains);\n  free (ctx->sni_certs.pkeys);\n\n  ctx->sni_certs.hostnames = new_hostnames;\n  ctx->sni_certs.cert_files = new_cert_files;\n  ctx->sni_certs.key_files = new_key_files;\n  ctx->sni_certs.chains = new_chains;\n  ctx->sni_certs.pkeys = new_pkeys;\n  ctx->sni_certs.capacity = new_cap;\n}\n\\`\\`\\`\n\n## References\n\n- CWE-416: Use After Free\n- CWE-415: Double Free\n- OWASP: Memory Management\n\n## Testing\n\nAdd test case that:\n1. Configures multiple SNI certificates to trigger expansion\n2. Uses memory limiting or fault injection to trigger allocation failure\n3. Verifies context remains valid after failed expansion\n4. Verifies no use-after-free in subsequent operations",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}