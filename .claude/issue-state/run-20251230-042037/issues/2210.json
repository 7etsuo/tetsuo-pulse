{
  "number": 2210,
  "title": "refactor(dns-tls): Break down receive_data() into smaller functions",
  "body": "## Summary\n\nThe `receive_data()` function in `src/dns/SocketDNSoverTLS.c` (lines 582-672) is 90 lines long and handles multiple concerns: reading from TLS socket, length prefix parsing, buffer allocation, and message assembly. This violates the Single Responsibility Principle and makes the code hard to test and maintain.\n\n## Location\n\n- **File**: `src/dns/SocketDNSoverTLS.c`\n- **Function**: `receive_data()`\n- **Lines**: 582-672 (90 lines)\n- **Severity**: HIGH\n- **Category**: Refactoring\n- **Pattern**: LONG_FUNCTION_90\n\n## Current Issues\n\n1. **Multiple responsibilities**: Socket I/O, state machine, buffer management\n2. **Complex nested logic**: Deep nesting makes control flow hard to follow\n3. **Hard to test**: Can't unit test individual parsing steps\n4. **Hard to debug**: 90 lines with multiple state variables\n\n## Recommendation\n\nBreak into smaller, focused functions:\n\n```c\n/* Read raw data from TLS socket */\nstatic int\nread_tls_data(T transport, unsigned char *buf, size_t bufsize, ssize_t *bytes_read);\n\n/* Parse 2-byte length prefix from receive buffer */\nstatic int\nparse_length_prefix(struct Connection *conn, const unsigned char *buf, \n                   size_t buf_len, size_t *processed);\n\n/* Allocate receive buffer for incoming message */\nstatic int\nallocate_recv_buffer(T transport, struct Connection *conn);\n\n/* Copy data into receive buffer */\nstatic void\nappend_to_recv_buffer(struct Connection *conn, const unsigned char *buf,\n                     size_t len);\n\n/* Main receive orchestrator */\nstatic int\nreceive_data(T transport)\n{\n    struct Connection *conn = &transport->conn;\n    unsigned char buf[DOT_RECV_BUFFER_SIZE];\n    ssize_t n;\n    size_t processed = 0;\n\n    if (conn->state != CONN_STATE_CONNECTED)\n        return 0;\n\n    /* Read from socket */\n    if (read_tls_data(transport, buf, sizeof(buf), &n) < 0)\n        return -1;\n    \n    if (n == 0)\n        return 0;  /* Would block */\n\n    /* Process data in chunks */\n    while (processed < (size_t)n) {\n        /* Parse length prefix */\n        if (parse_length_prefix(conn, buf + processed, n - processed, &processed) < 0)\n            return -1;\n        \n        if (conn->len_received < 2)\n            break;  /* Need more data */\n\n        /* Allocate buffer if needed */\n        if (conn->recv_buf == NULL) {\n            if (allocate_recv_buffer(transport, conn) < 0)\n                return -1;\n        }\n\n        /* Copy message body */\n        size_t need = conn->msg_len - conn->recv_len;\n        size_t avail = n - processed;\n        size_t copy = (need < avail) ? need : avail;\n        \n        append_to_recv_buffer(conn, buf + processed, copy);\n        processed += copy;\n\n        /* Check if complete */\n        if (conn->recv_len == conn->msg_len)\n            return 1;  /* Complete message */\n    }\n\n    return 0;\n}\n```\n\n## Benefits\n\n- **Testability**: Each helper can be unit tested independently\n- **Readability**: Clear separation of concerns\n- **Maintainability**: Easier to modify parsing logic\n- **Debugging**: Simpler to isolate issues\n\n## References\n\n- Clean Code by Robert C. Martin (Single Responsibility Principle)\n- Function length guidelines: prefer functions under 50 lines",
  "labels": [
    "enhancement",
    "wip:claude-1767092676-3930812"
  ],
  "state": "OPEN",
  "dependencies": []
}