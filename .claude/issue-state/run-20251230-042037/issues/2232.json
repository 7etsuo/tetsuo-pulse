{
  "number": 2232,
  "title": "refactor(dns-tls): Simplify start_connection() by extracting address setup logic",
  "body": "## Summary\n\nThe `start_connection()` function in `src/dns/SocketDNSoverTLS.c` (lines 293-372) is 79 lines long and handles multiple responsibilities: TLS context creation, socket creation, address structure setup for IPv4/IPv6, connection initiation, and error handling. The address setup logic (lines 330-350) should be extracted to improve readability.\n\n## Location\n\n- **File**: `src/dns/SocketDNSoverTLS.c`\n- **Function**: `start_connection()`\n- **Lines**: 293-372 (79 lines)\n- **Severity**: MEDIUM\n- **Category**: Refactoring\n- **Pattern**: LONG_FUNCTION_79\n\n## Current Issues\n\n1. **Multiple responsibilities**: Context creation, socket setup, address parsing, connection\n2. **Duplicate address logic**: IPv4 and IPv6 setup are nearly identical\n3. **Deep nesting**: TRY/EXCEPT blocks with conditionals inside\n4. **Hard to test**: Can't unit test address setup independently\n\n## Problematic Code Section\n\n```c\n/* Lines 330-350: Address setup duplicated for IPv4/IPv6 */\nstruct sockaddr_storage addr;\nsocklen_t addrlen;\n\nif (server->family == AF_INET)\n  {\n    struct sockaddr_in *addr4 = (struct sockaddr_in *)&addr;\n    memset (addr4, 0, sizeof (*addr4));\n    addr4->sin_family = AF_INET;\n    addr4->sin_port = htons (server->port);\n    inet_pton (AF_INET, server->address, &addr4->sin_addr);\n    addrlen = sizeof (*addr4);\n  }\nelse\n  {\n    struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&addr;\n    memset (addr6, 0, sizeof (*addr6));\n    addr6->sin6_family = AF_INET6;\n    addr6->sin6_port = htons (server->port);\n    inet_pton (AF_INET6, server->address, &addr6->sin6_addr);\n    addrlen = sizeof (*addr6);\n  }\n```\n\n## Recommendation\n\nExtract address setup into helper function:\n\n```c\n/* Setup sockaddr structure for server connection */\nstatic int\nsetup_server_address(const struct ServerConfig *server, \n                    struct sockaddr_storage *addr, \n                    socklen_t *addrlen)\n{\n    memset(addr, 0, sizeof(*addr));\n    \n    if (server->family == AF_INET) {\n        struct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n        addr4->sin_family = AF_INET;\n        addr4->sin_port = htons(server->port);\n        if (inet_pton(AF_INET, server->address, &addr4->sin_addr) != 1)\n            return -1;\n        *addrlen = sizeof(*addr4);\n    } else if (server->family == AF_INET6) {\n        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n        addr6->sin6_family = AF_INET6;\n        addr6->sin6_port = htons(server->port);\n        if (inet_pton(AF_INET6, server->address, &addr6->sin6_addr) != 1)\n            return -1;\n        *addrlen = sizeof(*addr6);\n    } else {\n        return -1;  /* Unknown family */\n    }\n    \n    return 0;\n}\n\n/* Simplified start_connection */\nstatic int\nstart_connection(T transport, int server_index)\n{\n    struct ServerConfig *server;\n    struct Connection *conn;\n    struct sockaddr_storage addr;\n    socklen_t addrlen;\n    int fd;\n\n    if (server_index < 0 || server_index >= transport->server_count)\n        return -1;\n\n    server = &transport->servers[server_index];\n    conn = &transport->conn;\n\n    /* Close existing connection */\n    if (conn->state != CONN_STATE_DISCONNECTED)\n        close_connection(transport, conn);\n\n    /* Create TLS context */\n    conn->tls_ctx = create_tls_context(transport, server);\n    if (!conn->tls_ctx) {\n        transport->stats.handshake_failures++;\n        return -1;\n    }\n\n    TRY {\n        /* Create socket */\n        conn->socket = Socket_new(server->family, SOCK_STREAM, 0);\n        Socket_setnonblocking(conn->socket);\n        fd = Socket_fd(conn->socket);\n\n        /* Setup server address */\n        if (setup_server_address(server, &addr, &addrlen) < 0)\n            RAISE(Socket_Failed);\n\n        /* Connect */\n        int ret = connect(fd, (struct sockaddr *)&addr, addrlen);\n        if (ret < 0 && errno != EINPROGRESS)\n            RAISE(Socket_Failed);\n\n        conn->state = CONN_STATE_CONNECTING;\n        conn->connect_start_ms = get_monotonic_ms();\n        conn->server_index = server_index;\n        transport->stats.connections_opened++;\n    }\n    EXCEPT(Socket_Failed) {\n        close_connection(transport, conn);\n        transport->stats.handshake_failures++;\n        return -1;\n    }\n    END_TRY;\n\n    return 0;\n}\n```\n\n## Benefits\n\n- **Testability**: Address setup can be unit tested\n- **Readability**: Main function is more linear\n- **Error handling**: Can validate inet_pton() results\n- **Reusability**: Address setup helper could be used elsewhere\n\n## Additional Improvements\n\nWhile refactoring, also consider:\n- Checking `inet_pton()` return values (currently ignored)\n- Validating port range (see issue #2205)\n- Adding error messages for debugging\n\n## References\n\n- Clean Code by Robert C. Martin (Extract Method)\n- Function length best practices: aim for under 50 lines",
  "labels": [
    "enhancement",
    "wip:claude-1767092676-3930812"
  ],
  "state": "OPEN",
  "dependencies": []
}