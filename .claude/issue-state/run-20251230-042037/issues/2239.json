{
  "number": 2239,
  "title": "refactor(dns-tls): Simplify process_socket_io() state machine logic",
  "body": "## Summary\n\nThe `process_socket_io()` function in `src/dns/SocketDNSoverTLS.c` (lines 898-977) is 79 lines long and handles complex state machine logic with polling, connection continuation, sending, and receiving. The function mixes I/O setup, event handling, and state transitions, making it difficult to understand and test.\n\n## Location\n\n- **File**: `src/dns/SocketDNSoverTLS.c`\n- **Function**: `process_socket_io()`\n- **Lines**: 898-977 (79 lines)\n- **Severity**: MEDIUM\n- **Category**: Refactoring\n- **Pattern**: COMPLEX_STATE_MACHINE\n\n## Current Issues\n\n1. **Multiple responsibilities**: Poll setup, event detection, state transitions, I/O operations\n2. **Complex conditionals**: State checks mixed with I/O logic\n3. **Duplicated logic**: Connection continuation logic appears twice (lines 943-957)\n4. **Hard to test**: Can't test event handling separately from I/O\n\n## Current Code Structure\n\n```c\nstatic int\nprocess_socket_io(T transport, int timeout_ms)\n{\n    /* Lines 912-916: Get socket FD */\n    fd = Socket_fd(conn->socket);\n    \n    /* Lines 917-923: Determine poll events */\n    events = POLLIN;\n    if (conn->state == CONN_STATE_CONNECTING \n        || conn->state == CONN_STATE_HANDSHAKING \n        || conn->send_len > 0)\n        events |= POLLOUT;\n    \n    /* Lines 929-932: Poll socket */\n    ret = poll(&pfd, 1, timeout_ms);\n    \n    /* Lines 934-940: Check for errors */\n    if (pfd.revents & (POLLERR | POLLHUP))\n        /* ... */\n    \n    /* Lines 942-957: Continue handshake (duplicate logic) */\n    if (conn->state == CONN_STATE_CONNECTING \n        || conn->state == CONN_STATE_HANDSHAKING)\n        /* ... */\n    \n    /* Lines 959-963: Send data */\n    if (conn->state == CONN_STATE_CONNECTED && (pfd.revents & POLLOUT))\n        /* ... */\n    \n    /* Lines 965-974: Receive data */\n    if (conn->state == CONN_STATE_CONNECTED && (pfd.revents & POLLIN))\n        /* ... */\n}\n```\n\n## Recommendation\n\nExtract state-specific handlers:\n\n```c\n/* Determine poll events based on connection state */\nstatic int\nget_poll_events(struct Connection *conn)\n{\n    int events = POLLIN;\n    \n    if (conn->state == CONN_STATE_CONNECTING \n        || conn->state == CONN_STATE_HANDSHAKING \n        || conn->send_len > 0) {\n        events |= POLLOUT;\n    }\n    \n    return events;\n}\n\n/* Handle connection state machine progression */\nstatic int\nhandle_connection_progress(T transport, struct Connection *conn)\n{\n    if (conn->state != CONN_STATE_CONNECTING \n        && conn->state != CONN_STATE_HANDSHAKING) {\n        return 0;\n    }\n    \n    int ret = continue_connection(transport);\n    if (ret < 0) {\n        cancel_all_queries(transport, DOT_ERROR_TLS_HANDSHAKE);\n        return -1;\n    }\n    \n    if (ret > 0) {\n        /* Just connected, queue pending queries */\n        queue_pending_queries(transport);\n    }\n    \n    return ret;\n}\n\n/* Handle socket events for connected state */\nstatic int\nhandle_connected_io(T transport, struct Connection *conn, short revents)\n{\n    int completed = 0;\n    \n    /* Send pending data */\n    if (revents & POLLOUT) {\n        send_pending(transport);\n    }\n    \n    /* Receive data */\n    if (revents & POLLIN) {\n        int ret = receive_data(transport);\n        if (ret > 0) {\n            process_response(transport);\n            completed++;\n        }\n    }\n    \n    return completed;\n}\n\n/* Simplified main function */\nstatic int\nprocess_socket_io(T transport, int timeout_ms)\n{\n    struct Connection *conn = &transport->conn;\n    struct pollfd pfd;\n    int fd;\n    int ret;\n\n    /* Get socket file descriptor */\n    fd = Socket_fd(conn->socket);\n    if (fd < 0)\n        return 0;\n\n    /* Setup poll */\n    pfd.fd = fd;\n    pfd.events = get_poll_events(conn);\n    pfd.revents = 0;\n\n    /* Poll socket */\n    ret = poll(&pfd, 1, timeout_ms);\n    if (ret <= 0)\n        return 0;\n\n    /* Check for errors */\n    if (pfd.revents & (POLLERR | POLLHUP)) {\n        close_connection(transport, conn);\n        cancel_all_queries(transport, DOT_ERROR_NETWORK);\n        return 0;\n    }\n\n    /* Handle connection progress */\n    if (handle_connection_progress(transport, conn) < 0)\n        return 0;\n\n    /* Handle I/O for connected state */\n    if (conn->state == CONN_STATE_CONNECTED)\n        return handle_connected_io(transport, conn, pfd.revents);\n\n    return 0;\n}\n```\n\n## Benefits\n\n- **Clarity**: Each function has single clear purpose\n- **Testability**: Can mock poll events and test handlers\n- **Maintainability**: Easier to modify state transitions\n- **No duplication**: Connection progress logic appears once\n\n## References\n\n- State Machine Design Patterns\n- Clean Code by Robert C. Martin (Extract Method)\n- Cyclomatic complexity reduction techniques",
  "labels": [
    "enhancement",
    "wip:claude-1767092676-3930812"
  ],
  "state": "OPEN",
  "dependencies": []
}