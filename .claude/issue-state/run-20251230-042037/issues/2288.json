{
  "number": 2288,
  "title": "refactor(quic): extract key selection helper from SocketQUICInitial_protect",
  "body": "## Summary\n\nThe function `SocketQUICInitial_protect` in `src/quic/SocketQUICPacket-initial.c` is 85 lines long (lines 741-825) and combines multiple distinct responsibilities: parameter validation, key selection based on is_client flag, packet number extraction, nonce construction, AEAD encryption, and header protection. Extracting the key selection logic would improve testability and readability.\n\n## Location\n\n- **File**: `/home/tetsuo/git/tetsuo-socket/src/quic/SocketQUICPacket-initial.c`\n- **Function**: `SocketQUICInitial_protect` (lines 741-825)\n- **Severity**: MEDIUM\n- **Category**: Refactoring\n- **Pattern**: LONG_FUNCTION_50\n\n## Issue Details\n\nThe function currently handles:\n1. Parameter validation (lines 759-763)\n2. Key selection based on is_client (lines 765-777)\n3. Packet number extraction from header (lines 779-783)\n4. Payload setup (lines 785-787)\n5. Nonce construction (line 790)\n6. AEAD payload encryption (lines 792-799)\n7. Packet length update (line 802)\n8. Header protection sample extraction (line 805)\n9. Header protection application (lines 807-812)\n\nThe key selection logic (lines 765-777) is a natural candidate for extraction, as it's a distinct concern that could be reused by the unprotect function.\n\n## Recommendation\n\nExtract key selection into a helper function:\n\n```c\n/**\n * @brief Select appropriate keys based on packet direction.\n *\n * @param keys Key material for both client and server\n * @param is_client 1 if protecting client->server packet, 0 for server->client\n * @param out_key Output: selected encryption key\n * @param out_iv Output: selected IV\n * @param out_hp_key Output: selected header protection key\n */\nstatic void\nselect_protection_keys(const SocketQUICInitialKeys_T *keys,\n                       int is_client,\n                       const uint8_t **out_key,\n                       const uint8_t **out_iv,\n                       const uint8_t **out_hp_key)\n{\n  if (is_client)\n    {\n      *out_key = keys->client_key;\n      *out_iv = keys->client_iv;\n      *out_hp_key = keys->client_hp_key;\n    }\n  else\n    {\n      *out_key = keys->server_key;\n      *out_iv = keys->server_iv;\n      *out_hp_key = keys->server_hp_key;\n    }\n}\n```\n\nThen `SocketQUICInitial_protect` would use:\n```c\nconst uint8_t *key, *iv, *hp_key;\nselect_protection_keys(keys, is_client, &key, &iv, &hp_key);\n```\n\nSimilarly, `SocketQUICInitial_unprotect` (lines 827-908) has identical key selection logic (lines 852-866) that could use the same helper, but with inverted logic (receiver uses opposite keys).\n\n## Benefits\n\n1. **Code reuse**: Both protect/unprotect use the same key selection logic\n2. **Improved testability**: Key selection can be tested independently\n3. **Clearer intent**: Function name documents the purpose\n4. **Reduced duplication**: Single source of truth for key selection\n\n## Alternative Approach\n\nIf extracting a 13-line function seems excessive, consider at minimum:\n1. Add inline comments to document the key selection logic\n2. Ensure both protect/unprotect have symmetric structure for easier review\n\n## Testing\n\n- Verify all existing QUIC encryption/decryption tests pass\n- Ensure both client and server perspectives work correctly\n- Confirm no functional changes in behavior\n\n## References\n\n- RFC 9001 Section 5.4 (Packet Protection)\n- CLAUDE.md guidance on function length and focused responsibilities",
  "labels": [
    "wip:claude-1767092676-3930812"
  ],
  "state": "OPEN",
  "dependencies": []
}