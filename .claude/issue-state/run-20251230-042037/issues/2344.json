{
  "number": 2344,
  "title": "refactor(proxy-socks5): extract address encoding helpers from encode_socks5_destination_address",
  "body": "## Summary\n\nBreak down 55-line `encode_socks5_destination_address()` function into three focused helper functions for IPv4, IPv6, and domain encoding.\n\n## Location\n\n- **File**: `src/socket/SocketProxy-socks5.c`\n- **Function**: `encode_socks5_destination_address()`\n- **Lines**: 479-534\n\n## Current Code\n\n\\`\\`\\`c\nstatic int\nencode_socks5_destination_address (unsigned char *buf, size_t *len_inout,\n                                   const char *target_host,\n                                   struct SocketProxy_Conn_T *conn)\n{\n  size_t len = *len_inout;\n  struct in_addr ipv4;\n  struct in6_addr ipv6;\n  size_t host_len;\n\n  /* Determine address type */\n  if (inet_pton (AF_INET, target_host, &ipv4) == 1)\n    {\n      /* IPv4 address - 6 lines */\n    }\n  else if (inet_pton (AF_INET6, target_host, &ipv6) == 1)\n    {\n      /* IPv6 address - 6 lines */\n    }\n  else\n    {\n      /* Domain name - 25 lines with validation */\n    }\n\n  *len_inout = len;\n  return 0;\n}\n\\`\\`\\`\n\n## Issue\n\nPer CLAUDE.md \\\"God Functions\\\" anti-pattern: function handles three distinct concerns (IPv4, IPv6, domain encoding) with different validation requirements. This violates Single Responsibility Principle and reduces testability.\n\nSpecific problems:\n1. **Mixed abstraction levels**: Low-level binary encoding mixed with high-level validation\n2. **Testing difficulty**: Cannot unit test individual address type encoders\n3. **Readability**: Domain branch has 25 lines of validation logic inline\n4. **Maintainability**: Adding new address types (future SOCKS extensions) requires modifying large function\n\n## Recommendation\n\nExtract three focused helpers:\n\n\\`\\`\\`c\nstatic int\nencode_ipv4_address(unsigned char *buf, size_t *len_inout, \n                    const struct in_addr *ipv4)\n{\n  size_t len = *len_inout;\n  buf[len++] = SOCKS5_ATYP_IPV4;\n  memcpy(buf + len, ipv4, SOCKS5_IPV4_ADDR_SIZE);\n  len += SOCKS5_IPV4_ADDR_SIZE;\n  *len_inout = len;\n  return 0;\n}\n\nstatic int\nencode_ipv6_address(unsigned char *buf, size_t *len_inout,\n                    const struct in6_addr *ipv6)\n{\n  size_t len = *len_inout;\n  buf[len++] = SOCKS5_ATYP_IPV6;\n  memcpy(buf + len, ipv6, SOCKS5_IPV6_ADDR_SIZE);\n  len += SOCKS5_IPV6_ADDR_SIZE;\n  *len_inout = len;\n  return 0;\n}\n\nstatic int\nencode_domain_address(unsigned char *buf, size_t *len_inout,\n                      const char *domain, \n                      struct SocketProxy_Conn_T *conn)\n{\n  size_t len = *len_inout;\n  size_t host_len = strlen(domain);\n  \n  /* Validate length and content */\n  if (host_len == 0 || host_len > SOCKET_PROXY_MAX_HOSTNAME_LEN) {\n    socketproxy_set_error(conn, PROXY_ERROR,\n      \\\"Hostname invalid length: %zu bytes (must be 1-%d)\\\",\n      host_len, SOCKET_PROXY_MAX_HOSTNAME_LEN);\n    return -1;\n  }\n  if (strpbrk(domain, \\\"\\\\r\\\\n\\\") != NULL) {\n    socketproxy_set_error(conn, PROXY_ERROR,\n      \\\"Hostname contains forbidden characters (CR or LF)\\\");\n    return -1;\n  }\n  \n  buf[len++] = SOCKS5_ATYP_DOMAIN;\n  buf[len++] = (unsigned char)host_len;\n  memcpy(buf + len, domain, host_len);\n  len += host_len;\n  *len_inout = len;\n  return 0;\n}\n\nstatic int\nencode_socks5_destination_address(unsigned char *buf, size_t *len_inout,\n                                   const char *target_host,\n                                   struct SocketProxy_Conn_T *conn)\n{\n  struct in_addr ipv4;\n  struct in6_addr ipv6;\n  \n  if (inet_pton(AF_INET, target_host, &ipv4) == 1) {\n    return encode_ipv4_address(buf, len_inout, &ipv4);\n  }\n  if (inet_pton(AF_INET6, target_host, &ipv6) == 1) {\n    return encode_ipv6_address(buf, len_inout, &ipv6);\n  }\n  return encode_domain_address(buf, len_inout, target_host, conn);\n}\n\\`\\`\\`\n\n## Benefits\n\n1. **Testability**: Each encoder can be unit tested independently\n2. **Clarity**: Main function becomes pure dispatch logic\n3. **Maintainability**: Adding new address types is isolated\n4. **Debugging**: Stack traces clearly show which encoder failed\n5. **Code reuse**: Helpers could be reused for bind/UDP associate commands\n\n## Severity\n\n**MEDIUM** - Affects maintainability and testability, not urgent but valuable refactor.\n\n## Category\n\nRefactoring - God Functions\n\n## Pattern ID\n\n`LONG_FUNCTION_ADDRESS_ENCODING`\n\n---\n\n**Automated Analysis**: Per-file pipeline analysis by Claude Agent SDK",
  "labels": [],
  "state": "OPEN",
  "dependencies": []
}