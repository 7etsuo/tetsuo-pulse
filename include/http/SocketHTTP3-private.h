/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) 2025 Tetsuo AI
 * https://x.com/tetsuoai
 */

/**
 * @file SocketHTTP3-private.h
 * @brief HTTP/3 connection internal structures.
 *
 * Private header defining the connection struct layout. Only included
 * by the connection implementation and tests that need direct struct access.
 */

#ifndef SOCKETHTTP3_PRIVATE_INCLUDED
#define SOCKETHTTP3_PRIVATE_INCLUDED

#include "http/SocketHTTP3.h"
#include "http/SocketHTTP3-stream.h"
#include "http/SocketHTTP.h"
#include "core/SocketSecurity.h"
#ifdef SOCKET_HAS_H3_PUSH
#include "http/SocketHTTP3-push.h"
#endif

#include <string.h>

/* ============================================================================
 * Push State (RFC 9114 §4.6)
 * ============================================================================
 */

#ifdef SOCKET_HAS_H3_PUSH

/** Maximum number of concurrent push promises tracked per connection. */
#define H3_MAX_PUSH_STREAMS 64

/** Push stream lifecycle states. */
typedef enum
{
  H3_PUSH_IDLE,
  H3_PUSH_PROMISED,
  H3_PUSH_STREAM_OPENED,
  H3_PUSH_COMPLETE,
  H3_PUSH_CANCELLED
} SocketHTTP3_PushState;

/** Per-push tracking entry. */
typedef struct
{
  uint64_t push_id;
  uint64_t request_stream_id;
  uint64_t push_stream_id;
  SocketHTTP3_PushState state;
  SocketHTTP_Headers_T promised_headers;
  struct SocketHTTP3_Request *request;
} H3_PushEntry;

#endif /* SOCKET_HAS_H3_PUSH */

/** Per-stream output buffer: accumulates bytes for one QUIC stream. */
typedef struct
{
  uint64_t stream_id;
  uint8_t *data;
  size_t len;
  size_t capacity;
} H3_StreamBuf;

/** Maximum number of output entries queued between drain calls. */
#define H3_MAX_OUTPUT_ENTRIES 64

/** Output queue: collects (stream_id, data, len) entries for caller to send. */
typedef struct
{
  SocketHTTP3_Output entries[H3_MAX_OUTPUT_ENTRIES];
  size_t count;
} H3_OutputQueue;

/** Maximum number of unidirectional streams awaiting type byte. */
#define H3_MAX_PENDING_UNIDI 8

/** State for unidirectional streams whose type byte hasn't been read yet. */
typedef struct
{
  uint64_t stream_ids[H3_MAX_PENDING_UNIDI];
  size_t count;
} H3_PendingUnidi;

/** Control stream receive buffer size. */
#define H3_CTRL_RECV_BUF_SIZE 256

/** Maximum concurrent requests tracked per connection. */
#ifndef H3_MAX_CONCURRENT_REQUESTS
#define H3_MAX_CONCURRENT_REQUESTS 128
#endif

/** Initial capacity for per-stream output buffers. */
#define H3_STREAM_BUF_INIT_CAP 128

/* Forward declaration for request struct */
struct SocketHTTP3_Request;

struct SocketHTTP3_Conn
{
  Arena_T arena;
  SocketHTTP3_Role role;
  SocketHTTP3_ConnState state;
  void *quic; /**< Stored but not called — tests can pass NULL */

  /* Stream map */
  SocketHTTP3_StreamMap_T stream_map;
  uint64_t local_control_id;
  uint64_t local_encoder_id;
  uint64_t local_decoder_id;

  /* Settings */
  SocketHTTP3_Settings local_settings;
  SocketHTTP3_Settings peer_settings;
  int peer_settings_received;

  /* Control stream receive buffer (partial frame headers + payloads) */
  uint8_t ctrl_recv_buf[H3_CTRL_RECV_BUF_SIZE];
  size_t ctrl_recv_len;
  int control_first_frame_seen;

  /* GOAWAY state */
  uint64_t local_goaway_id;
  uint64_t peer_goaway_id;
  int goaway_sent;
  int goaway_received;

  /* Push ID tracking */
  uint64_t max_push_id;
  int max_push_id_received;

  /* Unidi streams waiting for type byte */
  H3_PendingUnidi pending_unidi;

  /* Output queue for frames generated by this connection */
  H3_OutputQueue output;

  /* Per-local-stream output buffers */
  H3_StreamBuf control_out;
  H3_StreamBuf encoder_out;
  H3_StreamBuf decoder_out;

  /* Request tracking */
  struct SocketHTTP3_Request *requests[H3_MAX_CONCURRENT_REQUESTS];
  size_t request_count;
  uint64_t next_bidi_stream_id;

  /* Request-ready callback (server: notified when headers decoded) */
  SocketHTTP3_RequestReadyCB request_cb;
  void *request_cb_userdata;

#ifdef SOCKET_HAS_H3_PUSH
  /* Push state (RFC 9114 §4.6) */
  uint64_t next_push_id;
  uint64_t next_server_unidi_id;
  H3_PushEntry pushes[H3_MAX_PUSH_STREAMS];
  size_t push_count;
  SocketHTTP3_PushCallback push_cb;
  void *push_cb_userdata;
  uint64_t local_max_push_id;
  int local_max_push_id_sent;
#endif
};

/* ============================================================================
 * Shared Inline Helpers
 *
 * Used by both SocketHTTP3-connection.c and SocketHTTP3-request.c.
 * ============================================================================
 */

static inline int
h3_output_queue_push (H3_OutputQueue *queue,
                      uint64_t stream_id,
                      const uint8_t *data,
                      size_t len)
{
  if (queue->count >= H3_MAX_OUTPUT_ENTRIES)
    return -1;

  queue->entries[queue->count].stream_id = stream_id;
  queue->entries[queue->count].data = data;
  queue->entries[queue->count].len = len;
  queue->count++;
  return 0;
}

static inline void
stream_buf_init (H3_StreamBuf *buf, Arena_T arena, uint64_t stream_id)
{
  buf->stream_id = stream_id;
  buf->data = ALLOC (arena, H3_STREAM_BUF_INIT_CAP);
  buf->len = 0;
  buf->capacity = H3_STREAM_BUF_INIT_CAP;
}

static inline int
stream_buf_append (H3_StreamBuf *buf,
                   Arena_T arena,
                   const uint8_t *data,
                   size_t len)
{
  /* Guard against addition overflow */
  size_t required;
  if (__builtin_add_overflow (buf->len, len, &required))
    return -1;

  if (required > buf->capacity)
    {
      size_t new_cap = buf->capacity ? buf->capacity : H3_STREAM_BUF_INIT_CAP;
      while (new_cap < required)
        {
          size_t doubled;
          if (__builtin_mul_overflow (new_cap, (size_t)2, &doubled)
              || doubled > SOCKET_SECURITY_MAX_ALLOCATION)
            return -1;
          new_cap = doubled;
        }

      uint8_t *new_data = ALLOC (arena, new_cap);
      memcpy (new_data, buf->data, buf->len);
      buf->data = new_data;
      buf->capacity = new_cap;
    }

  memcpy (buf->data + buf->len, data, len);
  buf->len += len;
  return 0;
}

static inline void
stream_buf_reset (H3_StreamBuf *buf)
{
  buf->len = 0;
}

/**
 * @brief Generic grow-buffer append: doubles capacity until data fits.
 *
 * Works for any (uint8_t *buf, size_t len, size_t cap) triple.
 * The old arena allocation is abandoned (arena reclaims on dispose).
 */
static inline int
h3_growbuf_append (Arena_T arena,
                   uint8_t **buf,
                   size_t *buf_len,
                   size_t *buf_cap,
                   const uint8_t *data,
                   size_t len)
{
  /* Guard against addition overflow */
  size_t required;
  if (__builtin_add_overflow (*buf_len, len, &required))
    return -1;

  if (required > *buf_cap)
    {
      size_t new_cap = *buf_cap ? *buf_cap : 64;
      while (new_cap < required)
        {
          size_t doubled;
          if (__builtin_mul_overflow (new_cap, (size_t)2, &doubled)
              || doubled > SOCKET_SECURITY_MAX_ALLOCATION)
            return -1;
          new_cap = doubled;
        }
      uint8_t *new_buf = ALLOC (arena, new_cap);
      memcpy (new_buf, *buf, *buf_len);
      *buf = new_buf;
      *buf_cap = new_cap;
    }
  memcpy (*buf + *buf_len, data, len);
  *buf_len += len;
  return 0;
}

/**
 * @brief Consume bytes from the front of a buffer, shifting remainder left.
 */
#define H3_BUF_CONSUME(buf, buf_len, consumed)     \
  do                                               \
    {                                              \
      size_t _rem = (buf_len) - (consumed);        \
      if (_rem > 0)                                \
        memmove ((buf), (buf) + (consumed), _rem); \
      (buf_len) = _rem;                            \
    }                                              \
  while (0)

/* ============================================================================
 * QPACK Static Table Lookup Helpers
 *
 * Shared between SocketHTTP3-request.c (encoding) and tests (response
 * building).  Depend on SocketQPACK_static_table_get() from SocketQPACK.h.
 * ============================================================================
 */

#include "http/qpack/SocketQPACK.h"

/**
 * @brief Find an exact (name+value) match in the QPACK static table.
 * @return Static table index (0-98), or -1 if no match.
 */
static inline int
h3_find_static_exact (const char *name,
                      size_t name_len,
                      const char *value,
                      size_t value_len)
{
  for (uint64_t i = 0; i < SOCKETQPACK_STATIC_TABLE_SIZE; i++)
    {
      const char *sn;
      size_t snl;
      const char *sv;
      size_t svl;
      if (SocketQPACK_static_table_get (i, &sn, &snl, &sv, &svl) != QPACK_OK)
        continue;
      if (snl == name_len && svl == value_len
          && memcmp (sn, name, name_len) == 0
          && memcmp (sv, value, value_len) == 0)
        return (int)i;
    }
  return -1;
}

/**
 * @brief Find a name-only match in the QPACK static table.
 * @return Static table index (0-98), or -1 if no match.
 */
static inline int
h3_find_static_name (const char *name, size_t name_len)
{
  for (uint64_t i = 0; i < SOCKETQPACK_STATIC_TABLE_SIZE; i++)
    {
      const char *sn;
      size_t snl;
      if (SocketQPACK_static_table_get (i, &sn, &snl, NULL, NULL) != QPACK_OK)
        continue;
      if (snl == name_len && memcmp (sn, name, name_len) == 0)
        return (int)i;
    }
  return -1;
}

/* ============================================================================
 * QPACK Encode/Decode Helpers (shared between request.c and push.c)
 * ============================================================================
 */

#ifdef SOCKET_HAS_H3_PUSH
int h3_conn_recv_push_promise (SocketHTTP3_Conn_T conn,
                               uint64_t request_stream_id,
                               const uint8_t *payload,
                               size_t payload_len);

int h3_feed_push_stream (SocketHTTP3_Conn_T conn,
                         uint64_t stream_id,
                         const uint8_t *data,
                         size_t len,
                         int fin);

void h3_handle_cancel_push (SocketHTTP3_Conn_T conn, uint64_t push_id);
#endif /* SOCKET_HAS_H3_PUSH */

int h3_qpack_encode_headers (Arena_T arena,
                             const SocketHTTP_Headers_T headers,
                             uint8_t **out,
                             size_t *out_len);

int h3_qpack_decode_headers (Arena_T arena,
                             const uint8_t *data,
                             size_t len,
                             SocketHTTP_Headers_T *headers_out);

#endif /* SOCKETHTTP3_PRIVATE_INCLUDED */
