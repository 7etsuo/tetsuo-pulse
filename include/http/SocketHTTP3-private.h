/*
 * SPDX-License-Identifier: MIT
 * Copyright (c) 2025 Tetsuo AI
 * https://x.com/tetsuoai
 */

/**
 * @file SocketHTTP3-private.h
 * @brief HTTP/3 connection internal structures.
 *
 * Private header defining the connection struct layout. Only included
 * by the connection implementation and tests that need direct struct access.
 */

#ifndef SOCKETHTTP3_PRIVATE_INCLUDED
#define SOCKETHTTP3_PRIVATE_INCLUDED

#include "http/SocketHTTP3.h"
#include "http/SocketHTTP3-stream.h"

#include <string.h>

/** Per-stream output buffer: accumulates bytes for one QUIC stream. */
typedef struct
{
  uint64_t stream_id;
  uint8_t *data;
  size_t len;
  size_t capacity;
} H3_StreamBuf;

/** Maximum number of output entries queued between drain calls. */
#define H3_MAX_OUTPUT_ENTRIES 64

/** Output queue: collects (stream_id, data, len) entries for caller to send. */
typedef struct
{
  SocketHTTP3_Output entries[H3_MAX_OUTPUT_ENTRIES];
  size_t count;
} H3_OutputQueue;

/** Maximum number of unidirectional streams awaiting type byte. */
#define H3_MAX_PENDING_UNIDI 8

/** State for unidirectional streams whose type byte hasn't been read yet. */
typedef struct
{
  uint64_t stream_ids[H3_MAX_PENDING_UNIDI];
  size_t count;
} H3_PendingUnidi;

/** Control stream receive buffer size. */
#define H3_CTRL_RECV_BUF_SIZE 256

/** Maximum concurrent requests tracked per connection. */
#ifndef H3_MAX_CONCURRENT_REQUESTS
#define H3_MAX_CONCURRENT_REQUESTS 128
#endif

/** Initial capacity for per-stream output buffers. */
#define H3_STREAM_BUF_INIT_CAP 128

/* Forward declaration for request struct */
struct SocketHTTP3_Request;

struct SocketHTTP3_Conn
{
  Arena_T arena;
  SocketHTTP3_Role role;
  SocketHTTP3_ConnState state;
  void *quic; /**< Stored but not called â€” tests can pass NULL */

  /* Stream map */
  SocketHTTP3_StreamMap_T stream_map;
  uint64_t local_control_id;
  uint64_t local_encoder_id;
  uint64_t local_decoder_id;

  /* Settings */
  SocketHTTP3_Settings local_settings;
  SocketHTTP3_Settings peer_settings;
  int peer_settings_received;

  /* Control stream receive buffer (partial frame headers + payloads) */
  uint8_t ctrl_recv_buf[H3_CTRL_RECV_BUF_SIZE];
  size_t ctrl_recv_len;
  int control_first_frame_seen;

  /* GOAWAY state */
  uint64_t local_goaway_id;
  uint64_t peer_goaway_id;
  int goaway_sent;
  int goaway_received;

  /* Push ID tracking */
  uint64_t max_push_id;
  int max_push_id_received;

  /* Unidi streams waiting for type byte */
  H3_PendingUnidi pending_unidi;

  /* Output queue for frames generated by this connection */
  H3_OutputQueue output;

  /* Per-local-stream output buffers */
  H3_StreamBuf control_out;
  H3_StreamBuf encoder_out;
  H3_StreamBuf decoder_out;

  /* Request tracking */
  struct SocketHTTP3_Request *requests[H3_MAX_CONCURRENT_REQUESTS];
  size_t request_count;
  uint64_t next_bidi_stream_id;
};

/* ============================================================================
 * Shared Inline Helpers
 *
 * Used by both SocketHTTP3-connection.c and SocketHTTP3-request.c.
 * ============================================================================
 */

static inline int
h3_output_queue_push (H3_OutputQueue *queue,
                      uint64_t stream_id,
                      const uint8_t *data,
                      size_t len)
{
  if (queue->count >= H3_MAX_OUTPUT_ENTRIES)
    return -1;

  queue->entries[queue->count].stream_id = stream_id;
  queue->entries[queue->count].data = data;
  queue->entries[queue->count].len = len;
  queue->count++;
  return 0;
}

static inline void
stream_buf_init (H3_StreamBuf *buf, Arena_T arena, uint64_t stream_id)
{
  buf->stream_id = stream_id;
  buf->data = ALLOC (arena, H3_STREAM_BUF_INIT_CAP);
  buf->len = 0;
  buf->capacity = H3_STREAM_BUF_INIT_CAP;
}

static inline int
stream_buf_append (H3_StreamBuf *buf,
                   Arena_T arena,
                   const uint8_t *data,
                   size_t len)
{
  if (buf->len + len > buf->capacity)
    {
      size_t new_cap = buf->capacity;
      while (new_cap < buf->len + len)
        new_cap *= 2;

      uint8_t *new_data = ALLOC (arena, new_cap);
      memcpy (new_data, buf->data, buf->len);
      buf->data = new_data;
      buf->capacity = new_cap;
    }

  memcpy (buf->data + buf->len, data, len);
  buf->len += len;
  return 0;
}

static inline void
stream_buf_reset (H3_StreamBuf *buf)
{
  buf->len = 0;
}

#endif /* SOCKETHTTP3_PRIVATE_INCLUDED */
