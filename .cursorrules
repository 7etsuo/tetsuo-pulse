# Socket Library Cursor Rules

This .cursorrules file enforces best practices for the socket library codebase, aligned with "C Interfaces and Implementations" (CII) patterns by David R. Hanson and GNU C style standards. These rules ensure consistency, maintainability, and production-ready quality across all modules (core, socket, poll, pool, dns, tls).

**Code Quality Standards:**
- **Build Requirements:** Must compile with `-Wall -Wextra -Werror` (zero warnings)
- **Thread Safety:** All public APIs are fully thread-safe (documented explicitly)
- **Exception Safety:** All errors use exception system, never return codes
- **Memory Safety:** Arena-based allocation with comprehensive overflow protection
- **Documentation:** All APIs have comprehensive Doxygen documentation

Rules are derived from comprehensive code review (October 2025) and existing patterns in src/core/Arena.c (memory), src/socket/Socket.c (I/O), src/poll/SocketPoll.c (threading), and src/tls/SocketTLS.c (security).

## 1. Code Style: GNU C + C Interfaces and Implementations

### 1.1 Function Signatures
**ALWAYS** place return type on a separate line:
```c
ReturnType
FunctionName(parameters)
{
    // Implementation
}
```

**BAD** (one-liner style):
```c
ReturnType FunctionName(parameters) {
    // Implementation
}
```

**Rationale**: Follows CII book conventions and GNU C style for readability.

### 1.2 Indentation and Braces
**ALWAYS** use 8-space indentation, never mix tabs/spaces:
```c
if (condition)
        {
                statement1;
                statement2;
        }
```

**ALWAYS** place opening braces on the same line as control structures:
```c
for (i = 0; i < n; i++)
        {
                do_something();
        }
```

**BAD** (K&R style):
```c
if (condition) {
    statement;
}
```

### 1.3 Line Length and Whitespace
**ALWAYS** keep lines ≤ 80 characters:
```c
/* GOOD */
SOCKET_ERROR_FMT("Connection to %s:%d failed: %s",
                 hostname, port, strerror(errno));

/* BAD - line too long */
SOCKET_ERROR_FMT("Connection to %s:%d failed: %s", hostname, port, strerror(errno));
```

**ALWAYS** end files with newline, no trailing whitespace.

### 1.4 Pointer Alignment
**ALWAYS** align pointers right (`type *ptr`):
```c
int *ptr;        /* GOOD */
int* ptr;        /* BAD */
```

### 1.5 Type Definitions
**ALWAYS** use the T macro pattern for opaque types:
```c
#define T ModuleName_T
typedef struct T *T;

// In implementation (.c) file:
struct T
{
    // Members
};
#undef T
```

## 2. Documentation Standards

### 2.1 Module Documentation
**ALWAYS** include comprehensive module documentation at the top of every file:
```c
/**
 * ModuleName.c - Brief description of module purpose
 *
 * Detailed description of the module's purpose, features, and behavior.
 * Include information about thread safety, performance characteristics,
 * and any important usage notes.
 *
 * Features:
 * - Feature 1 with brief description
 * - Feature 2 with brief description
 * - Feature 3 with brief description
 *
 * Usage example:
 *   // Code example showing typical usage
 */
```

### 2.2 Function Documentation
**ALWAYS** document every function (public or static) with Doxygen-style comments:
```c
/**
 * FunctionName - Brief description of what the function does
 * @param1: Description of first parameter
 * @param2: Description of second parameter
 *
 * Returns: Description of return value
 * Raises: Description of exceptions that may be raised
 * Thread-safe: Yes/No (with explanation)
 *
 * Additional notes about behavior, side effects, or usage constraints.
 */
```

**BAD** (missing documentation):
```c
static void helper_function(int param) {
    // Undocumented function
}
```

### 2.3 Struct Member Documentation
**ALWAYS** document struct members in implementation files:
```c
struct T
{
    int fd;              /**< File descriptor for the socket */
    Arena_T arena;       /**< Arena for allocations */
    // Other members...
};
```

## 3. Error Handling: Exception-Based Patterns

### 3.1 TRY/EXCEPT/FINALLY Blocks
**ALWAYS** use exception handling for operations that can fail:
```c
TRY
    // Code that might fail
    if (error_condition)
        RAISE(Some_Exception);
EXCEPT(Some_Exception)
    // Handle specific exception
EXCEPT(Another_Exception)
    // Handle another exception type
FINALLY
    // Cleanup code (always executed)
END_TRY;
```

**BAD** (return code error handling):
```c
if (operation() != 0) {
    return -1;  // Never return error codes
}
```

### 3.2 Thread-Local Exception Macros
**ALWAYS** use thread-local exceptions for detailed error messages:
```c
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define RAISE_MODULE_ERROR(exception)                                          \
  do                                                                           \
    {                                                                          \
      Module_DetailedException = (exception);                                  \
      Module_DetailedException.reason = module_error_buf;                      \
      RAISE(Module_DetailedException);                                         \
    }                                                                          \
  while (0)
```

### 3.3 Error Message Formatting
**ALWAYS** use standardized error macros:
```c
SOCKET_ERROR_FMT("Detailed error message with %s and %d", str, num);
RAISE_SOCKET_ERROR(Socket_Failed);
```

**BAD** (direct exception raising):
```c
Socket_Failed.reason = "hardcoded error";
RAISE(Socket_Failed);  // Race condition if multiple threads
```

### 3.4 Thread-Safe Exception Handling (Critical)
**ALWAYS** use thread-local exception copies to avoid race conditions:

```c
/* CORRECT - Thread-safe pattern */
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define RAISE_MODULE_ERROR(exception)                                          \
  do                                                                           \
    {                                                                          \
      Module_DetailedException = (exception);                                  \
      Module_DetailedException.reason = module_error_buf;                      \
      RAISE(Module_DetailedException);                                         \
    }                                                                          \
  while (0)
```

**BAD** (race condition):
```c
/* NEVER DO THIS - modifies global exception directly */
Socket_Failed.reason = module_error_buf;
RAISE(Socket_Failed);  // Race condition in multithreaded code
```

**Rationale:** Directly modifying global exception `.reason` fields creates race conditions when multiple threads raise the same exception type simultaneously.

## 4. Memory Management: Arena-Based Allocation

### 4.1 Arena Allocation Macros
**ALWAYS** use arena allocation for related objects:
```c
#define ALLOC(arena, nbytes) (Arena_alloc((arena), (nbytes), __FILE__, __LINE__))
#define CALLOC(arena, count, nbytes) (Arena_calloc((arena), (count), (nbytes), __FILE__, __LINE__))

// Usage
char *buffer = ALLOC(arena, BUFFER_SIZE);
```

**BAD** (manual malloc):
```c
char *buffer = malloc(BUFFER_SIZE);  // Only for arenas themselves
```

### 4.2 Resource Cleanup
**ALWAYS** clean up resources in reverse order of creation in FINALLY blocks:
```c
FINALLY
    if (resource3)
        Resource3_free(&resource3);
    if (resource2)
        Resource2_free(&resource2);
    if (resource1)
        Resource1_free(&resource1);
END_TRY;
```

### 4.3 Arena Disposal
**ALWAYS** dispose arenas exactly once:
```c
Arena_dispose(&arena);  // Dispose entire arena at once
```

## 5. Header Organization

### 5.1 Include Guards
**ALWAYS** use FILENAME_INCLUDED pattern:
```c
#ifndef FILENAME_INCLUDED
#define FILENAME_INCLUDED

// Header content

#endif
```

**BAD** (inconsistent naming):
```c
#ifndef _FILENAME_H_
#define _FILENAME_H_
```

### 5.2 Include Order
**ALWAYS** order includes: system headers first, then project headers:
```c
#include <stdio.h>
#include <stdlib.h>

#include "core/Arena.h"
#include "socket/Socket.h"
```

### 5.3 Opaque Types
**ALWAYS** expose only opaque types in headers:
```c
/* GOOD - opaque type */
typedef struct Connection Connection_T;

/* BAD - structure definition exposed */
struct Connection {
    int fd;
};
```

### 5.4 T Macro Usage
**ALWAYS** use and undefine the T macro:
```c
#define T Socket_T
typedef struct T *T;
// ... file content ...
#undef T
```

## 6. Naming Conventions

### 6.1 Function Names
**ALWAYS** use module prefixes for public functions:
```c
Socket_T Socket_new(int domain, int type, int protocol);     /* GOOD */
void socket_helper(int param);                               /* GOOD for static */
```

**BAD** (inconsistent prefixing):
```c
Socket_T new_socket(int domain, int type, int protocol);     /* Missing prefix */
```

### 6.2 Constants and Macros
**ALWAYS** use ALL_CAPS for constants and macros:
```c
#define SOCKET_MAX_CONNECTIONS 10000
#define SOCKET_MSG_NOSIGNAL MSG_NOSIGNAL
```

**BAD** (mixed case):
```c
#define socketMaxConnections 10000
```

### 6.3 Static Functions
**ALWAYS** use descriptive names without module prefix:
```c
static unsigned hash_function(const Socket_T socket);
static int validate_connection_parameters(int domain, int type);
```

## 7. Code Organization

### 7.1 Function Size Limits
**ALWAYS** keep functions under 20 lines; extract helpers aggressively:
```c
// GOOD - short function
ssize_t Socket_send(T socket, const void *buf, size_t len)
{
    return socket_send_internal(socket, buf, len, SOCKET_MSG_NOSIGNAL);
}

// BAD - function too long
ssize_t Socket_send(T socket, const void *buf, size_t len) {
    // 50 lines of logic...
}
```

### 7.2 File Size Limits
**ALWAYS** keep files under 400 lines; split into logical modules:
- Socket.c: Core socket operations
- SocketIO.c: I/O abstraction
- SocketBuf.c: Buffer management

### 7.3 Static Helpers First
**ALWAYS** place static helper functions before public APIs:
```c
// Static helpers first
static int validate_socket_fd(int fd) { ... }
static void cleanup_socket_resources(T socket) { ... }

// Public APIs second
Socket_T Socket_new(int domain, int type, int protocol) { ... }
```

### 7.4 Parameter Handling
**ALWAYS** cast unused parameters to void:
```c
void function_with_unused_param(int used, int unused)
{
    (void)unused;  // Suppress warning
    // Use 'used' parameter
}
```

**ALWAYS** use const for read-only parameters:
```c
static unsigned hash_function(const Socket_T socket);
```

## 8. Safety Practices

### 8.1 Input Validation
**ALWAYS** validate inputs with descriptive macros:
```c
#define SOCKET_VALID_PORT(p) ((int)(p) > 0 && (int)(p) <= 65535)
#define SOCKET_VALID_DOMAIN(d) ((d) == AF_INET || (d) == AF_INET6 || (d) == AF_UNIX)
```

### 8.2 System Call Checking
**ALWAYS** check every system call return value:
```c
result = send(socket->fd, buf, len, flags);
if (result < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK)
        return 0;  // Would block
    RAISE_SOCKET_ERROR(Socket_Failed);
}
```

### 8.3 Overflow Protection
**ALWAYS** check for integer overflow before calculations:
```c
if (nbytes > SIZE_MAX - (alignment - 1))
    return NULL;

size_t sum = nbytes + alignment - 1;
size_t aligned_bytes = sum / alignment;
```

### 8.4 Assertions
**ALWAYS** use assertions for programming errors:
```c
assert(socket != NULL);
assert(buf != NULL);
assert(len > 0);
```

## 9. Thread Safety

### 9.1 Thread-Local Storage
**ALWAYS** use thread-local storage for per-thread data:
```c
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif
```

### 9.2 Mutex Protection
**ALWAYS** protect shared resources with mutexes:
```c
static pthread_mutex_t module_mutex = PTHREAD_MUTEX_INITIALIZER;

void thread_safe_function(void)
{
    pthread_mutex_lock(&module_mutex);
    // Critical section
    pthread_mutex_unlock(&module_mutex);
}
```

### 9.3 Thread Safety Documentation
**ALWAYS** document thread safety guarantees:
```c
/**
 * Socket_new - Create a new socket
 * @domain: Address family (AF_INET, AF_INET6, AF_UNIX)
 * @type: Socket type (SOCK_STREAM, SOCK_DGRAM)
 * @protocol: Protocol (0 for default)
 *
 * Returns: New socket instance
 * Raises: Socket_Failed on error
 * Thread-safe: Yes (creates independent socket)
 */
```

## 10. Module-Specific Patterns

### 10.1 Socket Module
**ALWAYS** route I/O through SocketIO abstraction:
```c
// In Socket.c functions, delegate to internals
ssize_t Socket_send(T socket, const void *buf, size_t len)
{
    return socket_send_internal(socket, buf, len, SOCKET_MSG_NOSIGNAL);
}
```

### 10.2 Pool Module
**ALWAYS** use hash functions for connection lookups:
```c
static unsigned socket_hash(const Socket_T socket)
{
    int fd;
    assert(socket);
    fd = Socket_fd(socket);
    return ((unsigned)fd * 2654435761u) % SOCKET_HASH_SIZE;
}
```

### 10.3 Poll Module
**ALWAYS** convert between epoll and socket events:
```c
static int translate_to_epoll(int events)
{
    int epoll_events = 0;
    if (events & SOCKET_POLLIN) epoll_events |= EPOLLIN;
    if (events & SOCKET_POLLOUT) epoll_events |= EPOLLOUT;
    return epoll_events;
}
```

### 10.4 TLS Context Module
**ALWAYS** use arena allocation for TLS-related data:
```c
// Allocate ALPN wire format in context arena
unsigned char *wire_buf = Arena_alloc(ctx->arena, total_len, __FILE__, __LINE__);

// Store configuration in arena for context lifetime
ctx->alpn_config = Arena_alloc(ctx->arena, sizeof(struct ALPNConfig), __FILE__, __LINE__);
```

**ALWAYS** validate OpenSSL return values and use thread-local exceptions:
```c
if (SSL_CTX_set_min_proto_version(ctx->ssl_ctx, version) != 1)
{
    raise_tls_context_error("Failed to set minimum TLS protocol version");
}
```

**ALWAYS** clean up OpenSSL contexts and arenas in reverse order:
```c
FINALLY
    if (c->ssl_ctx)
        SSL_CTX_free(c->ssl_ctx);
    if (c->arena)
        Arena_dispose(&c->arena);
END_TRY;
```

### 10.5 Zero-Copy TLS Handling (Task 3.3 Implementation)
**ALWAYS** detect TLS-enabled sockets in `Socket_sendfile()` and route to fallback:

```c
ssize_t Socket_sendfile(T socket, int file_fd, off_t *offset, size_t count)
{
    assert(socket);
    assert(file_fd >= 0);
    assert(count > 0);

#ifdef SOCKET_HAS_TLS
    /* TLS cannot use kernel sendfile() - must use fallback */
    if (socket_is_tls_enabled(socket))
    {
        return socket_sendfile_fallback(socket, file_fd, offset, count);
    }
#endif

    /* Platform-specific sendfile implementations for non-TLS */
    // ... existing code
}
```

**ALWAYS** document TLS performance implications in API documentation:

```c
/**
 * Socket_sendfile - Zero-copy file-to-socket transfer
 * @socket: Connected socket to send to
 * @file_fd: File descriptor to read from (must be a regular file)
 * @offset: File offset to start reading from (NULL for current position)
 * @count: Number of bytes to transfer (0 for entire file from offset)
 * Returns: Total bytes transferred (> 0) or 0 if would block (EAGAIN/EWOULDBLOCK)
 * Raises: Socket_Closed on EPIPE/ECONNRESET
 * Raises: Socket_Failed on other errors
 * Thread-safe: Yes (operates on single socket)
 * Note: Uses platform-specific zero-copy mechanism (sendfile/splice).
 * Falls back to read/write loop on platforms without sendfile support.
 * TLS-enabled sockets automatically use read/write fallback since kernel
 * sendfile() cannot encrypt data. Performance will be reduced compared to
 * non-TLS sockets due to user-space encryption overhead.
 * May transfer less than requested. Use Socket_sendfileall() for guaranteed
 * complete transfer.
 */
```

### 10.6 DNS Module
**ALWAYS** document blocking behavior in DNS resolution functions:
```c
/**
 * Socket_connect - Connect socket to remote endpoint
 * @socket: Socket instance
 * @hostname: Hostname or IP address (WARNING: may block on DNS)
 * @port: Port number
 *
 * WARNING: This function may block for extended periods (30+ seconds) during
 * DNS resolution if hostname is provided. For non-blocking operation, use
 * IP addresses directly or perform DNS resolution separately.
 */
```

### 10.6 Arena Module
**ALWAYS** protect arena state with per-arena mutexes for true thread safety:

```c
struct Arena_T
{
    Arena_T *prev;             /* Previous arena chunk */
    char *avail;               /* Current allocation pointer */
    char *limit;               /* End of current chunk */
    pthread_mutex_t mutex;     /* Protects avail, limit, prev */
};
```

**ALWAYS** lock/unlock arena mutex in all allocation operations:

```c
void *Arena_alloc(T arena, size_t nbytes, const char *file, int line)
{
    void *result;

    assert(arena);
    pthread_mutex_lock(&arena->mutex);

    // ... allocation logic ...

    pthread_mutex_unlock(&arena->mutex);
    return result;
}
```

**Rationale:** Per-arena mutexes ensure multiple threads can safely allocate from the same arena concurrently (verified in October 2025 code review).

## 11. Build System Integration

### 11.1 Conditional Compilation
**ALWAYS** guard TLS code with preprocessor checks:
```c
#ifdef SOCKET_HAS_TLS
// TLS-specific code
#endif
```

### 11.2 CMake Integration
**ALWAYS** use conditional compilation in CMakeLists.txt:
```cmake
# Example from CMakeLists.txt
$<$<BOOL:${SOCKET_HAS_TLS}>:src/tls/SocketTLS.c>
$<$<BOOL:${SOCKET_HAS_TLS}>:src/tls/SocketTLSContext.c>
```

### 11.3 Header Organization in CMake
**ALWAYS** separate header lists by module:
```cmake
set(CORE_HEADERS
    include/core/Arena.h
    include/core/Except.h
    # ... other core headers
)

set(TLS_HEADERS
    include/tls/SocketTLS.h
    include/tls/SocketTLSConfig.h
    include/tls/SocketTLSContext.h
)
```

## 12. TLS Integration Patterns

### 12.1 OpenSSL Context Management
**ALWAYS** create SSL contexts with proper method selection:
```c
// Server context
SSL_CTX *ssl_ctx = SSL_CTX_new(TLS_server_method());

// Client context
SSL_CTX *ssl_ctx = SSL_CTX_new(TLS_client_method());
```

**ALWAYS** set minimum TLS version immediately after context creation:
```c
if (SSL_CTX_set_min_proto_version(ssl_ctx, SOCKET_TLS_MIN_VERSION) != 1)
{
    // Handle error - OpenSSL 1.1.0+ required
}
```

### 12.2 Certificate Validation
**ALWAYS** validate certificate files before loading:
```c
// Check file existence and readability before SSL_CTX_use_certificate_file()
struct stat st;
if (stat(cert_file, &st) != 0 || !S_ISREG(st.st_mode))
{
    raise_tls_context_error("Certificate file not found or not readable");
}
```

**ALWAYS** verify certificate-key consistency:
```c
if (SSL_CTX_check_private_key(ctx->ssl_ctx) != 1)
{
    raise_tls_context_error("Private key does not match certificate");
}
```

### 12.3 OpenSSL Error Handling
**ALWAYS** use ERR_get_error() for detailed OpenSSL error messages:
```c
static void raise_tls_context_error(const char *context)
{
    unsigned long openssl_error = ERR_get_error();
    char openssl_error_buf[256];

    if (openssl_error != 0)
    {
        ERR_error_string_n(openssl_error, openssl_error_buf, sizeof(openssl_error_buf));
        snprintf(tls_context_error_buf, SOCKET_TLS_ERROR_BUFSIZE,
                "%s: OpenSSL error: %s", context, openssl_error_buf);
    }
    else
    {
        snprintf(tls_context_error_buf, SOCKET_TLS_ERROR_BUFSIZE,
                "%s: Unknown TLS error", context);
    }

    RAISE_TLS_CONTEXT_ERROR(SocketTLS_Failed);
}
```

### 12.4 ALPN Protocol Negotiation
**ALWAYS** validate ALPN protocol names and convert to wire format:
```c
// Validate protocol names
for (size_t i = 0; i < count; i++)
{
    size_t len = strlen(protos[i]);
    if (len == 0 || len > SOCKET_TLS_MAX_ALPN_LEN)
    {
        raise_tls_context_error("Invalid ALPN protocol length");
    }
}

// Convert to wire format (length-prefixed strings)
unsigned char *wire_buf = Arena_alloc(ctx->arena, total_len, __FILE__, __LINE__);
```

### 12.5 Resource Cleanup Order
**ALWAYS** clean up OpenSSL resources in correct order:
```c
// Free SSL objects first
if (ssl) SSL_free(ssl);

// Then free SSL_CTX
if (ssl_ctx) SSL_CTX_free(ssl_ctx);

// Finally dispose arena (cleans up all arena allocations)
if (arena) Arena_dispose(&arena);
```

## 13. System Integration Patterns

### 13.1 SocketPoll TLS Integration
**ALWAYS** integrate TLS operations with event polling:

```c
/**
 * SocketPoll TLS Integration Pattern
 * Handle SSL_ERROR_WANT_READ/WRITE by adjusting poll events
 */
static void socket_poll_handle_tls_events(SocketPoll_T poll, Socket_T socket)
{
    unsigned events = 0;

    /* Check if TLS wants read/write */
    if (socket_tls_want_read(socket))
        events |= POLL_READ;
    if (socket_tls_want_write(socket))
        events |= POLL_WRITE;

    if (events != 0)
    {
        void *user_data = socket_data_get(poll, socket);
        SocketPoll_mod(poll, socket, events, user_data);
    }
}
```

**ALWAYS** implement `socket_tls_want_read/write` helpers:

```c
int socket_tls_want_read(Socket_T socket)
{
    assert(socket);
#ifdef SOCKET_HAS_TLS
    if (!socket->tls_enabled || !socket->tls_ssl)
        return 0;

    /* Check if handshake is in progress and wants read */
    if (!socket->tls_handshake_done)
    {
        return (socket->tls_last_handshake_state == TLS_HANDSHAKE_WANT_READ) ? 1 : 0;
    }

    /* For established connections, SSL_pending indicates data available */
    SSL *ssl = socket_get_ssl(socket);
    if (ssl && SSL_pending(ssl) > 0)
        return 1;

    return 0;
#else
    return 0;
#endif
}
```

**ALWAYS** track TLS handshake state in socket structures:

```c
/* In Socket_T structure */
int tls_last_handshake_state; /* Last TLSHandshakeState from handshake() */

/* In SocketTLS_handshake() function */
TLSHandshakeState SocketTLS_handshake(Socket_T socket)
{
    /* ... perform handshake ... */

    if (result == 1)
    {
        socket->tls_handshake_done = 1;
        socket->tls_last_handshake_state = TLS_HANDSHAKE_COMPLETE;
        return TLS_HANDSHAKE_COMPLETE;
    }
    else
    {
        TLSHandshakeState state = socket_handle_ssl_error(socket, ssl, result);
        socket->tls_last_handshake_state = state;  /* Store state for polling */
        return state;
    }
}
```

**ALWAYS** integrate TLS polling efficiently with O(nfds) complexity:

```c
/* In SocketPoll_wait() - only check sockets that had events */
#ifdef SOCKET_HAS_TLS
/* Update poll events for TLS sockets that had events and need handshake */
/* Only check sockets that actually had events (efficient - O(nfds) not O(total sockets)) */
for (int i = 0; i < nfds; i++)
{
    Socket_T socket = poll->socketevents[i].socket;
    if (socket && socket_is_tls_enabled(socket))
    {
        /* If handshake is in progress, update events based on TLS state */
        if (!socket->tls_handshake_done)
        {
            socketpoll_update_tls_events(poll, socket);
        }
    }
}
#endif
```

**ALWAYS** use existing socket data lookup patterns with proper mutex locking:

```c
/* Use socket_data_lookup_unlocked() pattern from translate_single_event() */
static void socketpoll_update_tls_events(T poll, Socket_T socket)
{
    /* ... */

    /* Get user data to preserve it - use existing socket_data_lookup_unlocked pattern */
    /* Same pattern as translate_single_event() uses */
    hash = socket_hash(socket);
    pthread_mutex_lock(&poll->mutex);
    user_data = socket_data_lookup_unlocked(poll, socket);
    pthread_mutex_unlock(&poll->mutex);

    /* Update events - SocketPoll_mod handles socket not found gracefully */
    SocketPoll_mod(poll, socket, events, user_data);
}
```

### 13.2 SocketAsync TLS Integration
**ALWAYS** route async operations through TLS I/O layer:

```c
/* In SocketAsync.c, replace direct send/recv with TLS-aware calls */
if (type == REQ_SEND)
{
    /* Use TLS send if enabled, otherwise direct send */
    result = socket_send_internal(socket, send_buf, len, MSG_NOSIGNAL);
}
else
{
    /* Use TLS recv if enabled, otherwise direct recv */
    result = socket_recv_internal(socket, recv_buf, len, 0);
}
```

**ALWAYS** add TLS I/O abstraction layer:

```c
/* socket_send_internal() and socket_recv_internal() in SocketIO.c */
/* Automatically route through SSL_read/SSL_write when TLS enabled */
/* Handle SSL_ERROR_WANT_READ/WRITE appropriately */
```

### 13.3 Zero-Copy TLS Handling (Implemented in Task 3.3)
**ALWAYS** detect TLS sockets early and route to existing fallback implementation:

```c
/**
 * Socket_sendfile - Zero-copy file-to-socket transfer
 * @socket: Connected socket to send to
 * @file_fd: File descriptor to read from (must be a regular file)
 * @offset: File offset to start reading from (NULL for current position)
 * @count: Number of bytes to transfer (0 for entire file from offset)
 * Returns: Total bytes transferred (> 0) or 0 if would block (EAGAIN/EWOULDBLOCK)
 * Raises: Socket_Closed on EPIPE/ECONNRESET
 * Raises: Socket_Failed on other errors
 * Thread-safe: Yes (operates on single socket)
 * Note: Uses platform-specific zero-copy mechanism (sendfile/splice).
 * Falls back to read/write loop on platforms without sendfile support.
 * TLS-enabled sockets automatically use read/write fallback since kernel
 * sendfile() cannot encrypt data. Performance will be reduced compared to
 * non-TLS sockets due to user-space encryption overhead.
 * May transfer less than requested. Use Socket_sendfileall() for guaranteed
 * complete transfer.
 */
ssize_t Socket_sendfile(T socket, int file_fd, off_t *offset, size_t count)
{
    assert(socket);
    assert(file_fd >= 0);
    assert(count > 0);

#ifdef SOCKET_HAS_TLS
    /* TLS cannot use kernel sendfile() - must use fallback */
    if (socket_is_tls_enabled(socket))
    {
        return socket_sendfile_fallback(socket, file_fd, offset, count);
    }
#endif

    /* Platform-specific sendfile implementations for non-TLS */
    // ... existing code
}
```

**Rationale:** Reuse existing TLS-compatible fallback instead of reinventing sendfile logic. The fallback uses `Socket_send()` which routes through `socket_send_internal()` and automatically handles TLS encryption.

## 13. Testing and Quality Assurance

### 13.1 Test Organization
**ALWAYS** use TRY/FINALLY for resource management in tests:
```c
TRY
    Socket_T socket = Socket_new(AF_INET, SOCK_STREAM, 0);
    // Test logic
FINALLY
    Socket_free(&socket);
END_TRY;
```

### 13.2 Leak Prevention
**ALWAYS** assert no socket leaks in tests:
```c
// At end of test
assert(Socket_debug_live_count() == 0);
```

### 13.3 TLS Context Testing
**ALWAYS** test TLS context creation and cleanup:
```c
TRY
    SocketTLSContext_T ctx = SocketTLSContext_new_client(NULL);
    assert(ctx != NULL);
    // Test context configuration
FINALLY
    SocketTLSContext_free(&ctx);
    assert(ctx == NULL);
END_TRY;
```

## Rationale and References

These rules ensure:
- **Consistency**: All code follows the same patterns across modules
- **Maintainability**: Clear structure and documentation
- **Safety**: Comprehensive error handling and validation
- **Performance**: Arena allocation and efficient I/O patterns
- **Thread Safety**: Proper synchronization and thread-local storage (critical fixes applied)
- **Portability**: Cross-platform compatibility with conditional compilation
- **Security**: TLS integration with proper certificate validation and OpenSSL error handling
- **System Integration**: Seamless TLS integration with polling, async operations, and zero-copy features

## Critical Safety Requirements (October 2025 Code Review)

### Thread Safety - CRITICAL
**NEVER** directly modify global exception `.reason` fields - this creates race conditions in multithreaded code. Always use thread-local exception copies:

```c
/* CORRECT - Thread-safe pattern */
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define RAISE_MODULE_ERROR(exception)                                          \
  do                                                                           \
    {                                                                          \
      Module_DetailedException = (exception);                                  \
      Module_DetailedException.reason = module_error_buf;                      \
      RAISE(Module_DetailedException);                                         \
    }                                                                          \
  while (0)

/* WRONG - Creates race conditions */
(exception).reason = module_error_buf;  /* NEVER DO THIS */
RAISE(exception);
```

**Rationale:** Multiple threads can simultaneously raise the same exception type, corrupting shared `.reason` strings.

### DNS Blocking Awareness - CRITICAL
**ALWAYS** document blocking behavior in functions that may perform DNS resolution. Users must be warned about potential 30+ second blocking periods:

```c
/**
 * Socket_connect - Connect socket to remote endpoint
 * @socket: Socket instance
 * @hostname: Hostname or IP address (WARNING: may block on DNS)
 * @port: Port number
 *
 * WARNING: This function may block for extended periods (30+ seconds) during
 * DNS resolution if hostname is provided. For non-blocking operation, use
 * IP addresses directly or perform DNS resolution separately.
 */
```

### Mutex Handling - CRITICAL
**NEVER** copy structures containing mutex fields. Separate chunk headers from main structures to avoid fragile mutex copying patterns:

```c
/* CORRECT - Separate chunk header without mutex */
struct ChunkHeader
{
    struct ChunkHeader *prev;
    char *avail;
    char *limit;
};

/* Main arena structure with mutex */
struct T
{
    struct ChunkHeader *prev;  /* Safe to copy */
    char *avail;
    char *limit;
    pthread_mutex_t mutex;     /* Do not copy this field */
};
```

**Rationale:** Copying mutex fields creates undefined behavior and potential deadlocks.

### Per-Arena Mutex Protection - CRITICAL
**ALWAYS** protect arena state (avail, limit, prev) with per-arena mutexes for true thread safety:

```c
struct Arena_T
{
    Arena_T *prev;
    char *avail;
    char *limit;
    pthread_mutex_t mutex;  /* Protects avail, limit, prev */
};
```

**Rationale:** Multiple threads can safely allocate from the same arena concurrently.

## Implementation Notes

### Code Review Standards (October 2025 Review)
- All code must compile with `-Wall -Wextra -Werror` (zero warnings)
- Functions must be ≤ 20 lines; extract helpers aggressively
- Files must be ≤ 400 lines; split into logical modules when exceeded
- All public APIs must have comprehensive Doxygen documentation
- All static functions must have documentation (even if brief)
- All APIs must document thread safety guarantees explicitly
- All modules must follow C Interfaces and Implementations patterns

### Build System Requirements
- CMake conditional compilation for optional TLS support (`-DENABLE_TLS=ON`)
- Separate header lists by module for maintainability
- Consistent source file organization with module directories
- Cross-platform poll backend selection (epoll/kqueue/poll)
- Debug builds must include debug symbols and assertions

### Testing Requirements
- All APIs must have comprehensive unit tests
- Tests must use TRY/FINALLY for resource cleanup
- Tests must assert no memory leaks (`Socket_debug_live_count() == 0`)
- Tests must verify thread safety where applicable
- Tests must cover both TLS and non-TLS code paths

### Module Organization
- **core/**: Foundation (Arena, Except, Config, Error, Log, Metrics, Events)
- **socket/**: Socket I/O (Socket, SocketIO, SocketDgram, SocketBuf, SocketAsync, SocketCommon)
- **poll/**: Event polling (SocketPoll with backends)
- **pool/**: Connection pooling (SocketPool split across multiple files)
- **dns/**: DNS resolution (SocketDNS)
- **tls/**: TLS/SSL (SocketTLS, SocketTLSContext)

**References**:
- "C Interfaces and Implementations" by David R. Hanson
- GNU Coding Standards
- POSIX.1-2008 specification
- OpenSSL documentation and security best practices
- Existing socket library codebase patterns
- Comprehensive Code Review (October 2025) - All 41 critical issues resolved

### Quality Assurance
- **Static Analysis:** Zero warnings with `-Wall -Wextra -Werror`
- **Thread Safety:** All APIs documented and verified thread-safe
- **Memory Safety:** Arena-based allocation with overflow protection
- **Exception Safety:** Comprehensive TRY/EXCEPT/FINALLY blocks
- **TLS Security:** Proper certificate validation and error handling
- **Documentation:** Complete Doxygen coverage with thread safety notes

Violations of these rules will be flagged during code review and should be corrected immediately to maintain production-ready code quality and security.