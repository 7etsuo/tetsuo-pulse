# Socket Library - Cursor Rules

This file enforces coding standards, patterns, and best practices for the socket library codebase. These rules are based on:
- C Interfaces and Implementations (Hanson, 1996) patterns
- GNU C coding style
- Socket library architectural patterns
- Production-ready code quality standards

---

## 1. BUILD SYSTEM

### CMake is Required
**ALWAYS** use CMake for builds. Do NOT use Makefiles.

**Current Build Configuration:**
- CMake 3.10+ required
- C11 standard with GNU extensions (`CMAKE_C_EXTENSIONS ON`)
- Compiler flags: `-Wall -Wextra -Werror -D_GNU_SOURCE -pthread -fno-strict-aliasing -fPIC`
- Debug: `-g -Og`
- Release: `-O3 -DNDEBUG`

**Build Commands:**
```bash
# Configure build
cd build && cmake ..

# Build library and tests
make

# Run tests
make test
# OR
ctest

# Build specific target
make test_socketpoll
```

**Project Structure:**
```
socket/
├── CMakeLists.txt          # Main build configuration
├── include/                # Public headers
│   ├── core/              # Core modules (Arena, Except, SocketConfig, SocketError)
│   ├── socket/            # Socket modules (Socket, SocketBuf, SocketDgram, SocketCommon)
│   ├── poll/              # Poll modules (SocketPoll, SocketPoll_backend.h)
│   ├── pool/              # Pool modules (SocketPool)
│   ├── dns/               # DNS modules (SocketDNS)
│   └── test/               # Test framework (Test.h)
├── src/                    # Implementation files
│   ├── core/              # Core implementations
│   ├── socket/            # Socket implementations
│   ├── poll/              # Poll implementations (SocketPoll.c + backend files)
│   ├── pool/              # Pool implementations
│   ├── dns/               # DNS implementations
│   └── test/              # Test implementations
└── build/                 # Build directory (gitignored)
```

**Backend Selection:**
CMake automatically selects the appropriate poll backend:
- Linux: `SocketPoll_epoll.c` (epoll)
- macOS/BSD: `SocketPoll_kqueue.c` (kqueue)
- Fallback: `SocketPoll_poll.c` (POSIX poll)

**Library Targets:**
- `socket_objects` - Object library (for tests)
- `socket_static` - Static library (`libsocket.a`)
- `socket_shared` - Shared library (`libsocket.so`)
- `lib` - Builds both static and shared (default target)

**Test Targets:**
- Test executables: `test_arena`, `test_except`, `test_socket`, `test_socketbuf`, `test_socketdgram`, `test_socketpoll`, `test_socketpool`, `test_socketdns`, `test_integration`, `test_threadsafety`
- All tests automatically registered with CTest
- Tests link against `socket_objects` to preserve constructor attributes

---

## 2. CODE STYLE

### GNU C Style Guidelines

**Indentation:**
- Use 8-space indentation (NOT tabs, NOT 4 spaces)
- Maximum line length: 80 columns
- Continuation lines indented 2 spaces from opening parenthesis

**Function Signatures:**
```c
ReturnType
FunctionName(Type1 param1, Type2 param2, Type3 param3)
{
    // Function body
}
```

**Brace Placement:**
```c
// Opening brace on same line for functions, if/else, loops
void function(void)
{
    if (condition) {
        // Code
    } else {
        // Code
    }
}
```

**Pointer Style:**
- Right-aligned pointers: `Type *ptr` (NOT `Type* ptr`)
- Spaces around operators: `ptr->field`, `ptr->method()`

**Macro Style:**
```c
#define MACRO_NAME(param)                                                       \
    do                                                                           \
    {                                                                            \
        /* Multiple statements */                                                \
        statement1;                                                             \
        statement2;                                                             \
    }                                                                            \
    while (0)
```

---

## 3. HEADER FILES

### Include Guards
**ALWAYS** use include guards with `_INCLUDED` suffix:

```c
#ifndef FILENAME_INCLUDED
#define FILENAME_INCLUDED

// Header content

#endif /* FILENAME_INCLUDED */
```

### Header Documentation
**ALWAYS** include comprehensive module documentation at the top:

```c
/**
 * Module Name
 *
 * Detailed description of the module's purpose, features, and behavior.
 * Include information about thread safety, performance characteristics,
 * platform requirements, and important usage notes.
 *
 * PLATFORM REQUIREMENTS:
 * - List platform-specific requirements
 * - Portability notes
 *
 * Features:
 * - Feature 1 with brief description
 * - Feature 2 with brief description
 *
 * Thread Safety:
 * - Document thread safety guarantees per function
 *
 * Usage example:
 *   // Code example showing typical usage
 */
```

### Include Order
**ALWAYS** include headers in this order:

```c
/* System headers first */
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

/* Project headers second */
#include "core/Arena.h"
#include "core/Except.h"
#include "socket/Socket.h"
```

### Opaque Types
**ALWAYS** use opaque types in headers:

```c
#define T ModuleName_T
typedef struct T *T;

/* Exception types exported */
extern Except_T Module_Failed;
extern Except_T Module_InvalidInput;
```

---

## 4. IMPLEMENTATION FILES

### File Header
**ALWAYS** include file header:

```c
/**
 * filename.c - Brief description of the module
 *
 * Part of the Socket Library
 * Following C Interfaces and Implementations patterns
 */
```

### Type Definitions
**ALWAYS** use the T macro pattern:

```c
#define T ModuleName_T

/* Structure definition (in .c file only) */
struct T
{
    /* Members */
};

/* Undefine at end of file */
#undef T
```

### Structure Organization
**ALWAYS** organize structures logically:

```c
/* Helper structures (private) */
struct HelperStruct
{
    /* Members */
};

/* Main structure */
struct T
{
    /* Public members */
    struct HelperStruct *helper;
    
    /* Thread safety */
    pthread_mutex_t mutex;
};
```

**CRITICAL - Chunk Headers:**
When structures are used as chunk headers (e.g., in Arena), separate the chunk header from the main structure to avoid copying mutex fields:

```c
/* Chunk header - NO mutex (used in linked lists) */
struct ChunkHeader
{
    struct ChunkHeader *prev;
    char *avail;
    char *limit;
    size_t chunk_size;  /* Store actual size for proper reuse */
};

/* Main structure - INCLUDES mutex */
struct T
{
    struct ChunkHeader *prev;
    char *avail;
    char *limit;
    pthread_mutex_t mutex;  /* Not copied when chunk reused */
};
```

---

## 5. ERROR HANDLING

### Exception System Usage
**ALWAYS** use the exception system for errors:

```c
TRY
{
    // Code that might fail
    if (error_condition)
        RAISE(Some_Exception);
}
EXCEPT(Some_Exception)
{
    // Handle specific exception
}
EXCEPT(Another_Exception)
{
    // Handle another exception type
}
FINALLY
{
    // Cleanup code (always executed)
}
END_TRY;
```

### Exception Types
**ALWAYS** define module-specific exceptions:

```c
/* In header (.h): */
extern Except_T Module_Failed;
extern Except_T Module_InvalidInput;

/* In implementation (.c): */
Except_T Module_Failed = {"Module operation failed"};
Except_T Module_InvalidInput = {"Invalid input parameter"};
```

### Thread-Local Error Buffers
**ALWAYS** use thread-local error buffers:

```c
/* Error buffer size */
#define MODULE_ERROR_BUFSIZE 256

/* Thread-local error buffer */
#ifdef _WIN32
__declspec(thread) char module_error_buf[MODULE_ERROR_BUFSIZE];
#else
__thread char module_error_buf[MODULE_ERROR_BUFSIZE];
#endif
```

### Error Formatting Macros
**ALWAYS** create error formatting macros:

```c
/* Format with errno */
#define MODULE_ERROR_FMT(fmt, ...)                                               \
    snprintf(module_error_buf, MODULE_ERROR_BUFSIZE, fmt " (errno: %d - %s)",   \
             ##__VA_ARGS__, errno, strerror(errno))

/* Format without errno */
#define MODULE_ERROR_MSG(fmt, ...)                                               \
    snprintf(module_error_buf, MODULE_ERROR_BUFSIZE, fmt, ##__VA_ARGS__)
```

### Exception Raising Macros
**CRITICAL - Thread Safety:** Use thread-local exception copies:

```c
/* Thread-local exception copy (prevents race conditions) */
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

/* CORRECT - Thread-safe pattern */
#define RAISE_MODULE_ERROR(exception)                                            \
    do                                                                           \
    {                                                                            \
        Module_DetailedException = (exception);                                  \
        Module_DetailedException.reason = module_error_buf;                     \
        RAISE(Module_DetailedException);                                         \
    }                                                                            \
    while (0)
```

**WRONG Pattern (NOT thread-safe):**
```c
/* WRONG - Don't do this! Creates race conditions! */
#define RAISE_MODULE_ERROR(exception)                                            \
    do                                                                           \
    {                                                                            \
        (exception).reason = module_error_buf;  /* Modifies global! */           \
        RAISE(exception);                                                        \
    }                                                                            \
    while (0)
```

### Exception Conversion
**ALWAYS** convert lower-level exceptions to module-specific exceptions:

```c
TRY
{
    volatile_data_entry = ALLOC(poll->arena, sizeof(SocketData));
}
EXCEPT(Arena_Failed)
{
    SOCKET_ERROR_MSG(SOCKET_ENOMEM ": Cannot allocate socket data mapping");
    RAISE_POLL_ERROR(SocketPoll_Failed);
}
END_TRY;
```

### RERAISE Macro
**CRITICAL:** Use `Except_frame` (not `Except_stack`) in RERAISE:

```c
/* CORRECT - Uses current exception frame */
#define RERAISE                                                                \
    Except_raise(Except_frame.exception, Except_frame.file, Except_frame.line)

/* WRONG - Uses stale stack pointer after unwinding */
#define RERAISE                                                                \
    Except_raise(Except_stack->exception, Except_stack->file, Except_stack->line)
```

---

## 6. MEMORY MANAGEMENT

### Arena Allocation
**ALWAYS** use arena allocation for related objects:

```c
#define ALLOC(arena, nbytes) (Arena_alloc((arena), (nbytes), __FILE__, __LINE__))
#define CALLOC(arena, count, nbytes)                                            \
    (Arena_calloc((arena), (count), (nbytes), __FILE__, __LINE__))

/* Usage */
Arena_T arena = Arena_new();
void *ptr = ALLOC(arena, sizeof(struct MyStruct));
Arena_dispose(&arena);  /* Frees everything */
```

### Overflow Protection
**ALWAYS** check for overflow before calculations:

```c
/* Check addition overflow */
if (nbytes > SIZE_MAX - (alignment - 1))
    return NULL;

/* Check multiplication overflow */
size_t sum = nbytes + alignment - 1;
size_t aligned_bytes = sum / alignment;
if (alignment != 0 && aligned_bytes > SIZE_MAX / alignment)
    return NULL;
```

### Chunk Reuse
**ALWAYS** store actual chunk size for proper reuse:

```c
struct ChunkHeader
{
    struct ChunkHeader *prev;
    char *avail;
    char *limit;
    size_t chunk_size;  /* CRITICAL: Store actual malloc'd size */
};

/* When allocating new chunk */
chunk->chunk_size = size;  /* Store size */

/* When reusing chunk */
chunk->limit = (char *)chunk + chunk->chunk_size;  /* Recalculate limit */
```

### Resource Cleanup
**ALWAYS** clean up in reverse order of creation:

```c
FINALLY
{
    if (resource3)
        Resource3_free(&resource3);
    if (resource2)
        Resource2_free(&resource2);
    if (resource1)
        Resource1_free(&resource1);
}
END_TRY;
```

---

## 7. VOLATILE VARIABLES

### Variables Across setjmp/longjmp
**CRITICAL:** Variables modified across `setjmp`/`longjmp` boundaries (within TRY/EXCEPT blocks) MUST be declared `volatile`:

```c
/* CORRECT - Variables that persist across longjmp */
TRY
{
    volatile SocketData *volatile_data_entry = NULL;
    volatile FdSocketEntry *volatile_fd_entry = NULL;
    
    volatile_data_entry = ALLOC(poll->arena, sizeof(SocketData));
    /* ... more code ... */
}
EXCEPT(Arena_Failed)
{
    /* volatile_data_entry is safe to access here */
}
END_TRY;

/* Use volatile pointers directly */
volatile_data_entry->socket = socket;
volatile_data_entry->data = data;

/* Cast to non-volatile only when storing in data structures */
poll->socket_data_map[hash] = (SocketData *)volatile_data_entry;
```

**WRONG Pattern:**
```c
/* WRONG - Non-volatile variable may be clobbered by longjmp */
TRY
{
    SocketData *data_entry = NULL;  /* NOT volatile - compiler warning! */
    data_entry = ALLOC(poll->arena, sizeof(SocketData));
}
EXCEPT(Arena_Failed)
{
    /* data_entry may have corrupted value here */
}
END_TRY;
```

---

## 8. FUNCTION DOCUMENTATION

### Doxygen-Style Comments
**ALWAYS** document all public functions:

```c
/**
 * FunctionName - Brief description of what the function does
 * @param1: Description of first parameter
 * @param2: Description of second parameter
 * @param3: Description of third parameter
 *
 * Returns: Description of return value
 * Raises: Description of exceptions that may be raised
 * Thread-safe: Yes/No with explanation if No
 * Performance: O(?) complexity information
 *
 * Detailed description of behavior, side effects, and important notes.
 * Include information about error conditions, edge cases, and platform
 * requirements.
 */
```

### Static Function Documentation
**ALWAYS** document static helper functions:

```c
/**
 * helper_function - Brief description
 * @param: Description
 *
 * Returns: Description
 *
 * Detailed notes about implementation, algorithm, thread safety, etc.
 */
static ReturnType helper_function(Type param)
{
    // Implementation
}
```

---

## 9. NAMING CONVENTIONS

### Module Prefixes
**ALWAYS** use consistent module prefixes:

- `Arena_*` - Arena memory management
- `Except_*` - Exception handling
- `Socket_*` - Socket operations
- `SocketBuf_*` - Buffer operations
- `SocketPoll_*` - Event polling
- `SocketPool_*` - Connection pooling
- `SocketDNS_*` - DNS resolution
- `SocketDgram_*` - UDP datagram sockets

### Static Functions
**ALWAYS** use `static` for private helper functions (no module prefix):

```c
static unsigned hash_function(const Socket_T socket)
{
    // Implementation
}
```

### Constants
**ALWAYS** use ALL_CAPS for constants:

```c
#define MAX_CONNECTIONS 1000
#define DEFAULT_TIMEOUT 300
#define BUFFER_SIZE (1024 * 1024)
```

### Macros
**ALWAYS** use ALL_CAPS with module prefix:

```c
#define SOCKET_VALID_PORT(p) ((int)(p) >= 0 && (int)(p) <= 65535)
#define MODULE_ERROR_FMT(fmt, ...) /* ... */
```

---

## 10. VALIDATION AND SAFETY

### Input Validation
**ALWAYS** validate inputs with descriptive macros:

```c
/* Validation macros with proper parentheses */
#define MODULE_VALID_INPUT(x) ((x) != NULL && (x)->field > 0)
#define MODULE_VALID_SIZE(s) ((size_t)(s) > 0 && (size_t)(s) <= MAX_SIZE)
#define MODULE_VALID_PORT(p) ((int)(p) >= 0 && (int)(p) <= 65535)
```

**Note:** Port 0 is valid (OS-assigned ephemeral port) - use `>= 0` not `> 0`.

### Assertions
**ALWAYS** use assertions for programming errors:

```c
void function(Type param)
{
    assert(param != NULL);
    assert(MODULE_VALID_INPUT(param));
    
    // Main logic
}
```

### Safe System Calls
**ALWAYS** use safe wrappers:

```c
#define SAFE_CLOSE(fd)                                                           \
    do                                                                           \
    {                                                                            \
        if ((fd) >= 0)                                                           \
        {                                                                        \
            int _result = close(fd);                                            \
            if (_result < 0 && errno != EINTR)                                   \
            {                                                                    \
                /* Log error but don't fail - fd is closed anyway */             \
                perror("close");                                                 \
            }                                                                    \
        }                                                                        \
    }                                                                            \
    while (0)
```

**Note:** Per POSIX.1-2008, do NOT retry `close()` on EINTR. The file descriptor state is unspecified after EINTR.

---

## 11. THREAD SAFETY

### Thread-Local Storage
**ALWAYS** use thread-local storage with Windows compatibility:

```c
/* Declaration */
#ifdef _WIN32
extern __declspec(thread) Type variable;
#else
extern __thread Type variable;
#endif

/* Implementation */
#ifdef _WIN32
__declspec(thread) Type variable = {0};
#else
__thread Type variable = {0};
#endif
```

### Mutex Protection
**ALWAYS** protect shared resources with mutexes:

```c
static pthread_mutex_t module_mutex = PTHREAD_MUTEX_INITIALIZER;

void thread_safe_function(void)
{
    pthread_mutex_lock(&module_mutex);
    // Critical section
    pthread_mutex_unlock(&module_mutex);
}
```

### Per-Arena Mutexes
**ALWAYS** use per-arena mutexes for thread-safe allocation:

```c
struct T
{
    // ... members ...
    pthread_mutex_t mutex;  /* Per-arena mutex */
};

void *Arena_alloc(T arena, size_t nbytes, const char *file, int line)
{
    pthread_mutex_lock(&arena->mutex);
    // Allocation logic
    pthread_mutex_unlock(&arena->mutex);
    return result;
}
```

---

## 12. CODE ORGANIZATION

### Function Order
**PREFER** functions organized as:

1. Static helper functions (alphabetically or logically grouped)
2. Public API functions (alphabetically or by functionality)
3. Undefine T macro at end

### Function Length
**PREFER** functions under 20 lines. Extract helpers aggressively.

### File Length
**PREFER** files under 400 lines. Split if needed.

### Variable Initialization
**ALWAYS** initialize variables:

```c
Type variable = {0};  /* Zero initialization */
Type *variable = NULL;  /* Pointer initialization */
```

### Unused Parameters
**ALWAYS** cast unused parameters to void:

```c
void function_with_unused_param(int used, int unused)
{
    (void)unused;  /* Suppress unused parameter warning */
    // Use 'used' parameter
}
```

### Const Correctness
**ALWAYS** use `const` for read-only parameters:

```c
static unsigned hash_function(const Socket_T socket)
{
    // Implementation
}
```

---

## 13. PLATFORM REQUIREMENTS

### Documentation
**ALWAYS** document platform requirements in module headers:

```c
/**
 * PLATFORM REQUIREMENTS:
 * - POSIX-compliant system (Linux, BSD, macOS, etc.)
 * - IPv6 support in kernel (for dual-stack sockets)
 * - POSIX threads (pthread) for thread-safe error reporting
 * - NOT portable to Windows without Winsock adaptation layer
 * - getaddrinfo() for DNS resolution (POSIX.1-2001)
 */
```

### DNS Blocking Warnings
**ALWAYS** document blocking behavior:

```c
/**
 * Socket_connect - Connect to remote host
 * @socket: Socket to connect
 * @host: Remote IP address or hostname
 * @port: Remote port
 *
 * WARNING: May block 30+ seconds during DNS resolution if hostname provided.
 * Use IP addresses for non-blocking operation. Can be exploited for DoS attacks
 * if untrusted hostnames are accepted.
 *
 * Raises: Socket_Failed on error
 */
```

---

## 14. TESTING

### Test Structure
**ALWAYS** organize tests in `src/test/`:

```c
#include "test/Test.h"

void test_function_name(void)
{
    // Test implementation
    ASSERT_EQ(actual, expected);
    ASSERT_NE(actual, expected);
    ASSERT_TRUE(condition);
    ASSERT_FALSE(condition);
    ASSERT_NULL(pointer);
    ASSERT_NOT_NULL(pointer);
}
```

### Test Registration
**ALWAYS** register tests:

```c
int main(void)
{
    Test_run_all();
    return 0;
}
```

### Test Naming
**ALWAYS** use descriptive test names: `module_feature_test`

### Test Cleanup
**ALWAYS** clean up resources in tests:

```c
void test_with_resources(void)
{
    Arena_T arena = NULL;
    Socket_T socket = NULL;
    
    TRY
    {
        arena = Arena_new();
        socket = Socket_new(AF_INET, SOCK_STREAM, 0);
        // Test logic
    }
    FINALLY
    {
        if (socket)
            Socket_free(&socket);
        if (arena)
            Arena_dispose(&arena);
    }
    END_TRY;
}
```

---

## 15. CONFIGURATION

### Configuration Headers
**ALWAYS** use `SocketConfig.h` for configuration constants:

```c
/* SocketConfig.h */
#ifndef SOCKET_CONFIG_INCLUDED
#define SOCKET_CONFIG_INCLUDED

/* Configuration with compile-time override */
#ifndef MODULE_MAX_SIZE
#define MODULE_MAX_SIZE 1000
#endif

/* Runtime validation macros */
#define MODULE_VALID_SIZE(s) ((size_t)(s) > 0 && (size_t)(s) <= MODULE_MAX_SIZE)

#endif /* SOCKET_CONFIG_INCLUDED */
```

---

## 16. CODE QUALITY CHECKLIST

Before submitting code, verify:

- [ ] Compiles with `-Wall -Wextra -Werror` (zero warnings)
- [ ] All functions documented with Doxygen comments
- [ ] Module header includes platform requirements
- [ ] Exception handling uses thread-local copies
- [ ] Volatile variables declared for setjmp/longjmp
- [ ] Arena allocation used for related objects
- [ ] Overflow protection for all arithmetic
- [ ] Input validation with descriptive macros
- [ ] Thread safety documented and implemented
- [ ] Resource cleanup in FINALLY blocks
- [ ] Tests pass: `make test`
- [ ] No memory leaks (valgrind clean)

---

## 17. COMMON PATTERNS REFERENCE

### Module Template

**Header (include/module/Module.h):**
```c
#ifndef MODULE_INCLUDED
#define MODULE_INCLUDED

#include "core/Except.h"

/**
 * Module Name
 *
 * Description...
 */

#define T Module_T
typedef struct T *T;

extern Except_T Module_Failed;

extern T Module_new(void);
extern void Module_free(T *module);

#endif /* MODULE_INCLUDED */
```

**Implementation (src/module/Module.c):**
```c
/**
 * Module.c - Module implementation
 *
 * Part of the Socket Library
 */

#include <assert.h>
#include "module/Module.h"
#include "core/SocketConfig.h"
#include "core/SocketError.h"

#define MODULE_ERROR_BUFSIZE 256

#ifdef _WIN32
__declspec(thread) char module_error_buf[MODULE_ERROR_BUFSIZE];
#else
__thread char module_error_buf[MODULE_ERROR_BUFSIZE];
#endif

#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define MODULE_ERROR_FMT(fmt, ...)                                               \
    snprintf(module_error_buf, MODULE_ERROR_BUFSIZE, fmt " (errno: %d - %s)",   \
             ##__VA_ARGS__, errno, strerror(errno))

#define MODULE_ERROR_MSG(fmt, ...)                                               \
    snprintf(module_error_buf, MODULE_ERROR_BUFSIZE, fmt, ##__VA_ARGS__)

#define RAISE_MODULE_ERROR(exception)                                            \
    do                                                                           \
    {                                                                            \
        Module_DetailedException = (exception);                                 \
        Module_DetailedException.reason = module_error_buf;                      \
        RAISE(Module_DetailedException);                                         \
    }                                                                            \
    while (0)

#define T Module_T

struct T
{
    // Members
};

T
Module_new(void)
{
    // Implementation
}

void
Module_free(T *module)
{
    assert(module && *module);
    // Cleanup
    *module = NULL;
}

#undef T
```

---

## 18. RECENT FIXES AND LESSONS LEARNED

### Exception Frame Corruption
**Fixed:** RERAISE macro now uses `Except_frame` instead of `Except_stack` to avoid stale pointer access after stack unwinding.

### Volatile Variables
**Fixed:** Variables modified across `setjmp`/`longjmp` boundaries must be declared `volatile` to prevent compiler optimization issues.

### Arena Chunk Reuse
**Fixed:** Chunk headers now store `chunk_size` field to properly recalculate `limit` when reusing chunks, preventing memory corruption.

### Port 0 Validation
**Fixed:** Port validation now allows port 0 (OS-assigned ephemeral port) using `>= 0` instead of `> 0`.

### Exception Conversion
**Pattern:** Convert lower-level exceptions (e.g., `Arena_Failed`) to module-specific exceptions (e.g., `SocketPoll_Failed`) at module boundaries.

---

## 19. DOCUMENTATION STANDARDS

### Module Documentation Requirements
Every module header MUST include:

1. **Purpose**: What the module does
2. **Platform Requirements**: What platforms are supported
3. **Features**: Key features list
4. **Thread Safety**: Per-function thread safety guarantees
5. **Usage Example**: Code example showing typical usage
6. **Error Handling**: Which exceptions are raised
7. **Performance**: Complexity notes where relevant

### Function Documentation Requirements
Every public function MUST document:

1. **Brief description**: One-line summary
2. **@param**: Each parameter with description
3. **Returns**: Return value description
4. **Raises**: Exceptions that may be raised
5. **Thread-safe**: Yes/No with explanation
6. **Performance**: O(?) complexity if relevant
7. **Notes**: Important behavior, side effects, edge cases

---

## 20. ENFORCEMENT

These rules are enforced through:
- CMake build system with `-Werror`
- Code review process
- Test suite (213+ tests)
- Static analysis tools (when available)

**Remember:** Code that doesn't follow these patterns will fail to compile or will be rejected in code review. Consistency is critical for maintainability.

---

**Last Updated:** January 2025
**Based on:** Socket Library v1.0.0
**Build System:** CMake 3.10+
**C Standard:** C11 with GNU extensions

