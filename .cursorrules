# Socket Library Cursor Rules

This .cursorrules file enforces best practices for the socket library codebase, aligned with "C Interfaces and Implementations" (CII) patterns by Henry S. Warren and GNU C style standards. These rules ensure consistency, maintainability, and quality across all modules (core, socket, poll, pool, dns, tls). Violations will be highlighted and fixed during editing.

Rules are derived from analysis of the existing codebase (e.g., src/core/Arena.c for memory patterns, src/socket/Socket.c for exception handling, src/poll/SocketPoll.c for thread safety).

## 1. Code Style: GNU C + C Interfaces and Implementations

### 1.1 Function Signatures
**ALWAYS** place return type on a separate line:
```c
ReturnType
FunctionName(parameters)
{
    // Implementation
}
```

**BAD** (one-liner style):
```c
ReturnType FunctionName(parameters) {
    // Implementation
}
```

**Rationale**: Follows CII book conventions and GNU C style for readability.

### 1.2 Indentation and Braces
**ALWAYS** use 8-space indentation, never mix tabs/spaces:
```c
if (condition)
        {
                statement1;
                statement2;
        }
```

**ALWAYS** place opening braces on the same line as control structures:
```c
for (i = 0; i < n; i++)
        {
                do_something();
        }
```

**BAD** (K&R style):
```c
if (condition) {
    statement;
}
```

### 1.3 Line Length and Whitespace
**ALWAYS** keep lines ≤ 80 characters:
```c
/* GOOD */
SOCKET_ERROR_FMT("Connection to %s:%d failed: %s",
                 hostname, port, strerror(errno));

/* BAD - line too long */
SOCKET_ERROR_FMT("Connection to %s:%d failed: %s", hostname, port, strerror(errno));
```

**ALWAYS** end files with newline, no trailing whitespace.

### 1.4 Pointer Alignment
**ALWAYS** align pointers right (`type *ptr`):
```c
int *ptr;        /* GOOD */
int* ptr;        /* BAD */
```

### 1.5 Type Definitions
**ALWAYS** use the T macro pattern for opaque types:
```c
#define T ModuleName_T
typedef struct T *T;

// In implementation (.c) file:
struct T
{
    // Members
};
#undef T
```

## 2. Documentation Standards

### 2.1 Module Documentation
**ALWAYS** include comprehensive module documentation at the top of every file:
```c
/**
 * ModuleName.c - Brief description of module purpose
 *
 * Detailed description of the module's purpose, features, and behavior.
 * Include information about thread safety, performance characteristics,
 * and any important usage notes.
 *
 * Features:
 * - Feature 1 with brief description
 * - Feature 2 with brief description
 * - Feature 3 with brief description
 *
 * Usage example:
 *   // Code example showing typical usage
 */
```

### 2.2 Function Documentation
**ALWAYS** document every function (public or static) with Doxygen-style comments:
```c
/**
 * FunctionName - Brief description of what the function does
 * @param1: Description of first parameter
 * @param2: Description of second parameter
 *
 * Returns: Description of return value
 * Raises: Description of exceptions that may be raised
 * Thread-safe: Yes/No (with explanation)
 *
 * Additional notes about behavior, side effects, or usage constraints.
 */
```

**BAD** (missing documentation):
```c
static void helper_function(int param) {
    // Undocumented function
}
```

### 2.3 Struct Member Documentation
**ALWAYS** document struct members in implementation files:
```c
struct T
{
    int fd;              /**< File descriptor for the socket */
    Arena_T arena;       /**< Arena for allocations */
    // Other members...
};
```

## 3. Error Handling: Exception-Based Patterns

### 3.1 TRY/EXCEPT/FINALLY Blocks
**ALWAYS** use exception handling for operations that can fail:
```c
TRY
    // Code that might fail
    if (error_condition)
        RAISE(Some_Exception);
EXCEPT(Some_Exception)
    // Handle specific exception
EXCEPT(Another_Exception)
    // Handle another exception type
FINALLY
    // Cleanup code (always executed)
END_TRY;
```

**BAD** (return code error handling):
```c
if (operation() != 0) {
    return -1;  // Never return error codes
}
```

### 3.2 Thread-Local Exception Macros
**ALWAYS** use thread-local exceptions for detailed error messages:
```c
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define RAISE_MODULE_ERROR(exception)                                          \
  do                                                                           \
    {                                                                          \
      Module_DetailedException = (exception);                                  \
      Module_DetailedException.reason = module_error_buf;                      \
      RAISE(Module_DetailedException);                                         \
    }                                                                          \
  while (0)
```

### 3.3 Error Message Formatting
**ALWAYS** use standardized error macros:
```c
SOCKET_ERROR_FMT("Detailed error message with %s and %d", str, num);
RAISE_SOCKET_ERROR(Socket_Failed);
```

**BAD** (direct exception raising):
```c
Socket_Failed.reason = "hardcoded error";
RAISE(Socket_Failed);  // Race condition if multiple threads
```

### 3.4 Thread-Safe Exception Handling (Critical)
**ALWAYS** use thread-local exception copies to avoid race conditions:

```c
/* CORRECT - Thread-safe pattern */
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif

#define RAISE_MODULE_ERROR(exception)                                          \
  do                                                                           \
    {                                                                          \
      Module_DetailedException = (exception);                                  \
      Module_DetailedException.reason = module_error_buf;                      \
      RAISE(Module_DetailedException);                                         \
    }                                                                          \
  while (0)
```

**BAD** (race condition):
```c
/* NEVER DO THIS - modifies global exception directly */
Socket_Failed.reason = module_error_buf;
RAISE(Socket_Failed);  // Race condition in multithreaded code
```

**Rationale:** Directly modifying global exception `.reason` fields creates race conditions when multiple threads raise the same exception type simultaneously.

## 4. Memory Management: Arena-Based Allocation

### 4.1 Arena Allocation Macros
**ALWAYS** use arena allocation for related objects:
```c
#define ALLOC(arena, nbytes) (Arena_alloc((arena), (nbytes), __FILE__, __LINE__))
#define CALLOC(arena, count, nbytes) (Arena_calloc((arena), (count), (nbytes), __FILE__, __LINE__))

// Usage
char *buffer = ALLOC(arena, BUFFER_SIZE);
```

**BAD** (manual malloc):
```c
char *buffer = malloc(BUFFER_SIZE);  // Only for arenas themselves
```

### 4.2 Resource Cleanup
**ALWAYS** clean up resources in reverse order of creation in FINALLY blocks:
```c
FINALLY
    if (resource3)
        Resource3_free(&resource3);
    if (resource2)
        Resource2_free(&resource2);
    if (resource1)
        Resource1_free(&resource1);
END_TRY;
```

### 4.3 Arena Disposal
**ALWAYS** dispose arenas exactly once:
```c
Arena_dispose(&arena);  // Dispose entire arena at once
```

## 5. Header Organization

### 5.1 Include Guards
**ALWAYS** use FILENAME_INCLUDED pattern:
```c
#ifndef FILENAME_INCLUDED
#define FILENAME_INCLUDED

// Header content

#endif
```

**BAD** (inconsistent naming):
```c
#ifndef _FILENAME_H_
#define _FILENAME_H_
```

### 5.2 Include Order
**ALWAYS** order includes: system headers first, then project headers:
```c
#include <stdio.h>
#include <stdlib.h>

#include "core/Arena.h"
#include "socket/Socket.h"
```

### 5.3 Opaque Types
**ALWAYS** expose only opaque types in headers:
```c
/* GOOD - opaque type */
typedef struct Connection Connection_T;

/* BAD - structure definition exposed */
struct Connection {
    int fd;
};
```

### 5.4 T Macro Usage
**ALWAYS** use and undefine the T macro:
```c
#define T Socket_T
typedef struct T *T;
// ... file content ...
#undef T
```

## 6. Naming Conventions

### 6.1 Function Names
**ALWAYS** use module prefixes for public functions:
```c
Socket_T Socket_new(int domain, int type, int protocol);     /* GOOD */
void socket_helper(int param);                               /* GOOD for static */
```

**BAD** (inconsistent prefixing):
```c
Socket_T new_socket(int domain, int type, int protocol);     /* Missing prefix */
```

### 6.2 Constants and Macros
**ALWAYS** use ALL_CAPS for constants and macros:
```c
#define SOCKET_MAX_CONNECTIONS 10000
#define SOCKET_MSG_NOSIGNAL MSG_NOSIGNAL
```

**BAD** (mixed case):
```c
#define socketMaxConnections 10000
```

### 6.3 Static Functions
**ALWAYS** use descriptive names without module prefix:
```c
static unsigned hash_function(const Socket_T socket);
static int validate_connection_parameters(int domain, int type);
```

## 7. Code Organization

### 7.1 Function Size Limits
**ALWAYS** keep functions under 20 lines; extract helpers aggressively:
```c
// GOOD - short function
ssize_t Socket_send(T socket, const void *buf, size_t len)
{
    return socket_send_internal(socket, buf, len, SOCKET_MSG_NOSIGNAL);
}

// BAD - function too long
ssize_t Socket_send(T socket, const void *buf, size_t len) {
    // 50 lines of logic...
}
```

### 7.2 File Size Limits
**ALWAYS** keep files under 400 lines; split into logical modules:
- Socket.c: Core socket operations
- SocketIO.c: I/O abstraction
- SocketBuf.c: Buffer management

### 7.3 Static Helpers First
**ALWAYS** place static helper functions before public APIs:
```c
// Static helpers first
static int validate_socket_fd(int fd) { ... }
static void cleanup_socket_resources(T socket) { ... }

// Public APIs second
Socket_T Socket_new(int domain, int type, int protocol) { ... }
```

### 7.4 Parameter Handling
**ALWAYS** cast unused parameters to void:
```c
void function_with_unused_param(int used, int unused)
{
    (void)unused;  // Suppress warning
    // Use 'used' parameter
}
```

**ALWAYS** use const for read-only parameters:
```c
static unsigned hash_function(const Socket_T socket);
```

## 8. Safety Practices

### 8.1 Input Validation
**ALWAYS** validate inputs with descriptive macros:
```c
#define SOCKET_VALID_PORT(p) ((int)(p) > 0 && (int)(p) <= 65535)
#define SOCKET_VALID_DOMAIN(d) ((d) == AF_INET || (d) == AF_INET6 || (d) == AF_UNIX)
```

### 8.2 System Call Checking
**ALWAYS** check every system call return value:
```c
result = send(socket->fd, buf, len, flags);
if (result < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK)
        return 0;  // Would block
    RAISE_SOCKET_ERROR(Socket_Failed);
}
```

### 8.3 Overflow Protection
**ALWAYS** check for integer overflow before calculations:
```c
if (nbytes > SIZE_MAX - (alignment - 1))
    return NULL;

size_t sum = nbytes + alignment - 1;
size_t aligned_bytes = sum / alignment;
```

### 8.4 Assertions
**ALWAYS** use assertions for programming errors:
```c
assert(socket != NULL);
assert(buf != NULL);
assert(len > 0);
```

## 9. Thread Safety

### 9.1 Thread-Local Storage
**ALWAYS** use thread-local storage for per-thread data:
```c
#ifdef _WIN32
static __declspec(thread) Except_T Module_DetailedException;
#else
static __thread Except_T Module_DetailedException;
#endif
```

### 9.2 Mutex Protection
**ALWAYS** protect shared resources with mutexes:
```c
static pthread_mutex_t module_mutex = PTHREAD_MUTEX_INITIALIZER;

void thread_safe_function(void)
{
    pthread_mutex_lock(&module_mutex);
    // Critical section
    pthread_mutex_unlock(&module_mutex);
}
```

### 9.3 Thread Safety Documentation
**ALWAYS** document thread safety guarantees:
```c
/**
 * Socket_new - Create a new socket
 * @domain: Address family (AF_INET, AF_INET6, AF_UNIX)
 * @type: Socket type (SOCK_STREAM, SOCK_DGRAM)
 * @protocol: Protocol (0 for default)
 *
 * Returns: New socket instance
 * Raises: Socket_Failed on error
 * Thread-safe: Yes (creates independent socket)
 */
```

## 10. Module-Specific Patterns

### 10.1 Socket Module
**ALWAYS** route I/O through SocketIO abstraction:
```c
// In Socket.c functions, delegate to internals
ssize_t Socket_send(T socket, const void *buf, size_t len)
{
    return socket_send_internal(socket, buf, len, SOCKET_MSG_NOSIGNAL);
}
```

### 10.2 Pool Module
**ALWAYS** use hash functions for connection lookups:
```c
static unsigned socket_hash(const Socket_T socket)
{
    int fd;
    assert(socket);
    fd = Socket_fd(socket);
    return ((unsigned)fd * 2654435761u) % SOCKET_HASH_SIZE;
}
```

### 10.3 Poll Module
**ALWAYS** convert between epoll and socket events:
```c
static int translate_to_epoll(int events)
{
    int epoll_events = 0;
    if (events & SOCKET_POLLIN) epoll_events |= EPOLLIN;
    if (events & SOCKET_POLLOUT) epoll_events |= EPOLLOUT;
    return epoll_events;
}
```

### 10.4 TLS Context Module
**ALWAYS** use arena allocation for TLS-related data:
```c
// Allocate ALPN wire format in context arena
unsigned char *wire_buf = Arena_alloc(ctx->arena, total_len, __FILE__, __LINE__);

// Store configuration in arena for context lifetime
ctx->alpn_config = Arena_alloc(ctx->arena, sizeof(struct ALPNConfig), __FILE__, __LINE__);
```

**ALWAYS** validate OpenSSL return values and use thread-local exceptions:
```c
if (SSL_CTX_set_min_proto_version(ctx->ssl_ctx, version) != 1)
{
    raise_tls_context_error("Failed to set minimum TLS protocol version");
}
```

**ALWAYS** clean up OpenSSL contexts and arenas in reverse order:
```c
FINALLY
    if (c->ssl_ctx)
        SSL_CTX_free(c->ssl_ctx);
    if (c->arena)
        Arena_dispose(&c->arena);
END_TRY;
```

### 10.5 DNS Module
**ALWAYS** document blocking behavior in DNS resolution functions:
```c
/**
 * Socket_connect - Connect socket to remote endpoint
 * @socket: Socket instance
 * @hostname: Hostname or IP address (WARNING: may block on DNS)
 * @port: Port number
 *
 * WARNING: This function may block for extended periods (30+ seconds) during
 * DNS resolution if hostname is provided. For non-blocking operation, use
 * IP addresses directly or perform DNS resolution separately.
 */
```

### 10.6 Arena Module
**ALWAYS** separate chunk headers from main arena structure to avoid mutex copying:
```c
/* Chunk header structure - no mutex, safe to copy */
struct ChunkHeader
{
    struct ChunkHeader *prev;
    char *avail;
    char *limit;
};

/* Main arena structure - includes mutex, do not copy directly */
struct T
{
    struct ChunkHeader *prev;  /* Chunk header (safe to copy) */
    char *avail;
    char *limit;
    pthread_mutex_t mutex;     /* Do not copy this field */
};
```

## 11. Build System Integration

### 11.1 Conditional Compilation
**ALWAYS** guard TLS code with preprocessor checks:
```c
#ifdef SOCKET_HAS_TLS
// TLS-specific code
#endif
```

### 11.2 CMake Integration
**ALWAYS** use conditional compilation in CMakeLists.txt:
```cmake
# Example from CMakeLists.txt
$<$<BOOL:${SOCKET_HAS_TLS}>:src/tls/SocketTLS.c>
$<$<BOOL:${SOCKET_HAS_TLS}>:src/tls/SocketTLSContext.c>
```

### 11.3 Header Organization in CMake
**ALWAYS** separate header lists by module:
```cmake
set(CORE_HEADERS
    include/core/Arena.h
    include/core/Except.h
    # ... other core headers
)

set(TLS_HEADERS
    include/tls/SocketTLS.h
    include/tls/SocketTLSConfig.h
    include/tls/SocketTLSContext.h
)
```

## 12. TLS Integration Patterns

### 12.1 OpenSSL Context Management
**ALWAYS** create SSL contexts with proper method selection:
```c
// Server context
SSL_CTX *ssl_ctx = SSL_CTX_new(TLS_server_method());

// Client context
SSL_CTX *ssl_ctx = SSL_CTX_new(TLS_client_method());
```

**ALWAYS** set minimum TLS version immediately after context creation:
```c
if (SSL_CTX_set_min_proto_version(ssl_ctx, SOCKET_TLS_MIN_VERSION) != 1)
{
    // Handle error - OpenSSL 1.1.0+ required
}
```

### 12.2 Certificate Validation
**ALWAYS** validate certificate files before loading:
```c
// Check file existence and readability before SSL_CTX_use_certificate_file()
struct stat st;
if (stat(cert_file, &st) != 0 || !S_ISREG(st.st_mode))
{
    raise_tls_context_error("Certificate file not found or not readable");
}
```

**ALWAYS** verify certificate-key consistency:
```c
if (SSL_CTX_check_private_key(ctx->ssl_ctx) != 1)
{
    raise_tls_context_error("Private key does not match certificate");
}
```

### 12.3 OpenSSL Error Handling
**ALWAYS** use ERR_get_error() for detailed OpenSSL error messages:
```c
static void raise_tls_context_error(const char *context)
{
    unsigned long openssl_error = ERR_get_error();
    char openssl_error_buf[256];

    if (openssl_error != 0)
    {
        ERR_error_string_n(openssl_error, openssl_error_buf, sizeof(openssl_error_buf));
        snprintf(tls_context_error_buf, SOCKET_TLS_ERROR_BUFSIZE,
                "%s: OpenSSL error: %s", context, openssl_error_buf);
    }
    else
    {
        snprintf(tls_context_error_buf, SOCKET_TLS_ERROR_BUFSIZE,
                "%s: Unknown TLS error", context);
    }

    RAISE_TLS_CONTEXT_ERROR(SocketTLS_Failed);
}
```

### 12.4 ALPN Protocol Negotiation
**ALWAYS** validate ALPN protocol names and convert to wire format:
```c
// Validate protocol names
for (size_t i = 0; i < count; i++)
{
    size_t len = strlen(protos[i]);
    if (len == 0 || len > SOCKET_TLS_MAX_ALPN_LEN)
    {
        raise_tls_context_error("Invalid ALPN protocol length");
    }
}

// Convert to wire format (length-prefixed strings)
unsigned char *wire_buf = Arena_alloc(ctx->arena, total_len, __FILE__, __LINE__);
```

### 12.5 Resource Cleanup Order
**ALWAYS** clean up OpenSSL resources in correct order:
```c
// Free SSL objects first
if (ssl) SSL_free(ssl);

// Then free SSL_CTX
if (ssl_ctx) SSL_CTX_free(ssl_ctx);

// Finally dispose arena (cleans up all arena allocations)
if (arena) Arena_dispose(&arena);
```

## 13. Testing and Quality Assurance

### 13.1 Test Organization
**ALWAYS** use TRY/FINALLY for resource management in tests:
```c
TRY
    Socket_T socket = Socket_new(AF_INET, SOCK_STREAM, 0);
    // Test logic
FINALLY
    Socket_free(&socket);
END_TRY;
```

### 13.2 Leak Prevention
**ALWAYS** assert no socket leaks in tests:
```c
// At end of test
assert(Socket_debug_live_count() == 0);
```

### 13.3 TLS Context Testing
**ALWAYS** test TLS context creation and cleanup:
```c
TRY
    SocketTLSContext_T ctx = SocketTLSContext_new_client(NULL);
    assert(ctx != NULL);
    // Test context configuration
FINALLY
    SocketTLSContext_free(&ctx);
    assert(ctx == NULL);
END_TRY;
```

## Rationale and References

These rules ensure:
- **Consistency**: All code follows the same patterns across modules
- **Maintainability**: Clear structure and documentation
- **Safety**: Comprehensive error handling and validation
- **Performance**: Arena allocation and efficient I/O patterns
- **Thread Safety**: Proper synchronization and thread-local storage (critical fixes applied)
- **Portability**: Cross-platform compatibility with conditional compilation
- **Security**: TLS integration with proper certificate validation and OpenSSL error handling

## Critical Safety Requirements

### Thread Safety (October 2025 Review)
**NEVER** directly modify global exception `.reason` fields - this creates race conditions in multithreaded code. Always use thread-local exception copies as demonstrated in the error handling patterns.

### DNS Blocking Awareness (October 2025 Review)
**ALWAYS** document blocking behavior in functions that may perform DNS resolution. Users must be warned about potential 30+ second blocking periods.

### Mutex Handling (October 2025 Review)
**NEVER** copy structures containing mutex fields. Separate chunk headers from main structures to avoid fragile mutex copying patterns.

## Implementation Notes

### Code Review Standards
- All code must compile with `-Wall -Wextra -Werror` (zero warnings)
- Functions must be ≤ 20 lines; extract helpers aggressively
- Files must be ≤ 400 lines; split into logical modules when exceeded
- All public APIs must have comprehensive Doxygen documentation
- All static functions must have documentation (even if brief)

### Build System Requirements
- CMake conditional compilation for optional TLS support
- Separate header lists by module for maintainability
- Consistent source file organization

**References**:
- "C Interfaces and Implementations" by David R. Hanson
- GNU Coding Standards
- POSIX.1-2008 specification
- OpenSSL documentation and security best practices
- Existing socket library codebase patterns
- Comprehensive Code Review (October 2025) - All critical safety issues resolved

Violations of these rules will be flagged during code review and should be corrected immediately to maintain code quality and security.