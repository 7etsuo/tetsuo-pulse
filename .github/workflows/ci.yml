name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  # UBSAN_OPTIONS apply globally; ASAN_OPTIONS set per-job (detect_leaks unsupported on macOS)
  UBSAN_OPTIONS: print_stacktrace=1:halt_on_error=1

jobs:
  # Standard builds (Debug and Release)
  build:
    name: Build (${{ matrix.build_type }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        build_type: [Debug, Release]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libevent-dev doxygen

      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} -DENABLE_TLS=ON

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure --parallel $(nproc)

      - name: Run gRPC example smoke tests
        working-directory: build
        run: ctest --output-on-failure -R "grpc_example_.*_smoke"

      - name: Run gRPC core conformance matrix
        run: |
          scripts/grpc-interop/run.sh \
            --profile core \
            --build-dir build \
            --report build/grpc-interop-core-${{ matrix.build_type }}.json

      - name: Run gRPC benchmark smoke report
        run: |
          scripts/grpc-bench/run.sh \
            --build-dir build \
            --smoke \
            --report build/grpc-bench-${{ matrix.build_type }}.json

  # Sanitizer builds (Linux)
  sanitizers:
    name: Sanitizers (${{ matrix.sanitizer }})
    runs-on: ubuntu-latest
    env:
      ASAN_OPTIONS: detect_leaks=1:abort_on_error=1:halt_on_error=1
      TSAN_OPTIONS: halt_on_error=1:second_deadlock_stack=1
    strategy:
      fail-fast: false
      matrix:
        include:
          - sanitizer: asan
            cmake_flags: -DENABLE_ASAN=ON
            name: AddressSanitizer
          - sanitizer: ubsan
            cmake_flags: -DENABLE_UBSAN=ON
            name: UBSanitizer
          - sanitizer: asan+ubsan
            cmake_flags: -DENABLE_SANITIZERS=ON
            name: ASan+UBSan
          - sanitizer: tsan
            cmake_flags: -DENABLE_TSAN=ON
            name: ThreadSanitizer

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libevent-dev

      - name: Configure CMake with ${{ matrix.name }}
        run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON ${{ matrix.cmake_flags }}

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Run tests with ${{ matrix.name }}
        working-directory: build
        run: ctest --output-on-failure --parallel 1
        # Note: Parallel=1 for sanitizers to get clearer error output

  # Valgrind memcheck (Linux only)
  valgrind:
    name: Valgrind Memcheck
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libevent-dev valgrind

      - name: Configure CMake (Debug, no sanitizers)
        run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Run tests under Valgrind
        working-directory: build
        run: |
          failed=0
          for test in test_*; do
            if [ -x "$test" ] && [ -f "$test" ]; then
              echo "=== Running $test under Valgrind ==="
              # Run Valgrind and capture output
              # Note: Don't use --error-exitcode as test programs may intentionally
              # return non-zero for error-path testing
              valgrind --leak-check=full --track-fds=yes \
                --suppressions=../valgrind.supp ./$test 2>&1 | tee valgrind_output.txt
              
              # Parse ERROR SUMMARY to check for actual memory errors
              # Format: "ERROR SUMMARY: X errors from Y contexts"
              error_count=$(grep -oP "ERROR SUMMARY: \K[0-9]+" valgrind_output.txt | tail -1)
              if [ -n "$error_count" ] && [ "$error_count" -gt 0 ]; then
                echo "ERROR: Valgrind detected $error_count memory error(s) in $test"
                cat valgrind_output.txt
                failed=1
              fi
              
              # Check for definitely lost memory (real leaks, not "still reachable")
              # Match patterns like "definitely lost: 1,234 bytes" but not "definitely lost: 0 bytes"
              definitely_lost=$(grep -oP "definitely lost: \K[0-9,]+" valgrind_output.txt | tr -d ',' | tail -1)
              if [ -n "$definitely_lost" ] && [ "$definitely_lost" -gt 0 ]; then
                echo "ERROR: Memory leak detected in $test ($definitely_lost bytes definitely lost)"
                cat valgrind_output.txt
                failed=1
              fi
              
              # Check for indirectly lost memory (also real leaks)
              indirectly_lost=$(grep -oP "indirectly lost: \K[0-9,]+" valgrind_output.txt | tr -d ',' | tail -1)
              if [ -n "$indirectly_lost" ] && [ "$indirectly_lost" -gt 0 ]; then
                echo "ERROR: Memory leak detected in $test ($indirectly_lost bytes indirectly lost)"
                cat valgrind_output.txt
                failed=1
              fi
              
              echo "  -> $test: OK (errors=$error_count, definitely_lost=${definitely_lost:-0}, indirectly_lost=${indirectly_lost:-0})"
            fi
          done
          
          if [ $failed -ne 0 ]; then
            echo "One or more tests failed Valgrind memory checks"
            exit 1
          fi
          echo "All Valgrind memory checks passed successfully"

  # macOS build (kqueue backend)
  macos:
    name: macOS Build
    runs-on: macos-latest
    env:
      OPENSSL_ROOT_DIR: /opt/homebrew/opt/openssl@3
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          brew install openssl@3 libevent doxygen
          echo "OpenSSL installed at: $(brew --prefix openssl@3)"

      - name: Configure CMake
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON \
            -DOPENSSL_ROOT_DIR=$(brew --prefix openssl@3) \
            -DOPENSSL_INCLUDE_DIR=$(brew --prefix openssl@3)/include \
            -DOPENSSL_CRYPTO_LIBRARY=$(brew --prefix openssl@3)/lib/libcrypto.dylib \
            -DOPENSSL_SSL_LIBRARY=$(brew --prefix openssl@3)/lib/libssl.dylib

      - name: Build
        run: cmake --build build --parallel $(sysctl -n hw.ncpu)

      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure --parallel $(sysctl -n hw.ncpu)

  # macOS sanitizers
  macos-sanitizers:
    name: macOS Sanitizers
    runs-on: macos-latest
    env:
      # detect_leaks not supported on macOS
      ASAN_OPTIONS: abort_on_error=1:halt_on_error=1

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          brew install openssl@3 libevent
          echo "OpenSSL installed at: $(brew --prefix openssl@3)"

      - name: Configure CMake with ASan+UBSan
        run: |
          cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON -DENABLE_SANITIZERS=ON \
            -DOPENSSL_ROOT_DIR=$(brew --prefix openssl@3) \
            -DOPENSSL_INCLUDE_DIR=$(brew --prefix openssl@3)/include \
            -DOPENSSL_CRYPTO_LIBRARY=$(brew --prefix openssl@3)/lib/libcrypto.dylib \
            -DOPENSSL_SSL_LIBRARY=$(brew --prefix openssl@3)/lib/libssl.dylib

      - name: Build
        run: cmake --build build --parallel $(sysctl -n hw.ncpu)

      - name: Run tests with sanitizers
        working-directory: build
        run: ctest --output-on-failure --parallel 1

  # Code coverage
  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libevent-dev lcov

      - name: Configure CMake with coverage
        run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON -DENABLE_COVERAGE=ON

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure --parallel $(nproc)

      - name: Generate coverage report
        run: |
          lcov --capture --directory build --output-file coverage.info --ignore-errors mismatch
          lcov --remove coverage.info '/usr/*' '*/test/*' '*/benchmark*' --output-file coverage.info --ignore-errors mismatch,unused
          lcov --list coverage.info --ignore-errors mismatch

      - name: Upload to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: coverage.info
          fail_ci_if_error: false
          verbose: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  # Static analysis (cppcheck + clang-tidy)
  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libevent-dev cppcheck clang-tidy

      - name: Configure CMake
        run: cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_TLS=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=ON

      - name: Run cppcheck
        run: |
          cppcheck --enable=warning,style,performance,portability \
            --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            --suppress=unmatchedSuppression \
            --suppress=toomanyconfigs \
            --std=c11 \
            -I include \
            --inline-suppr \
            src/ include/ 2>&1 | tee cppcheck-output.txt
          echo "=== cppcheck output ==="
          cat cppcheck-output.txt

      - name: Run clang-tidy
        run: |
          # Find all source files and run clang-tidy
          # Exclude platform-specific and benchmark files not analyzable on Linux:
          # - SocketPoll_kqueue.c: BSD/macOS only (uses sys/event.h)
          # - benchmark_libevent.c: Requires libevent headers which may not be in include path
          # - benchmark_*.c: Benchmarks are not core library code
          find src -name '*.c' \
            ! -name 'SocketPoll_kqueue.c' \
            ! -name 'benchmark_*.c' \
            -print0 | xargs -0 -P $(nproc) -I {} \
            clang-tidy {} -p build --warnings-as-errors='*' 2>&1 | tee clang-tidy-output.txt
          # Check if any errors were found
          if grep -q "error:" clang-tidy-output.txt; then
            echo "clang-tidy found errors"
            exit 1
          fi
